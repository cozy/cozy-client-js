{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap cb1624ac0c0934fd6a03","webpack:///./src/fetch.js","webpack:///./src/utils.js","webpack:///./src/doctypes.js","webpack:///./node_modules/pouchdb-utils/lib/index-browser.es.js","webpack:///./src/auth_v3.js","webpack:///./node_modules/babel-runtime/regenerator/index.js","webpack:///./src/intents/helpers.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/argsarray/index.js","webpack:///./node_modules/pouchdb-collections/lib/index.es.js","webpack:///./node_modules/inherits/inherits_browser.js","webpack:///./node_modules/pouchdb-errors/lib/index.es.js","webpack:///./node_modules/pouchdb-md5/lib/index-browser.es.js","webpack:///./node_modules/pouchdb-collate/lib/index.es.js","webpack:///./src/jsonapi.js","webpack:///./src/intents/index.js","webpack:///./node_modules/immediate/lib/browser.js","webpack:///./node_modules/events/events.js","webpack:///./node_modules/spark-md5/spark-md5.js","webpack:///./node_modules/uuid/index.js","webpack:///./node_modules/uuid/lib/rng-browser.js","webpack:///./node_modules/uuid/lib/bytesToUuid.js","webpack:///./node_modules/pouchdb-binary-utils/lib/index-browser.es.js","webpack:///./node_modules/pouchdb-fetch/lib/index-browser.es.js","webpack:///./src/index.js","webpack:///./src/auth_storage.js","webpack:///./src/auth_v2.js","webpack:///./src/data.js","webpack:///./src/mango.js","webpack:///./src/files.js","webpack:///./node_modules/babel-runtime/node_modules/regenerator-runtime/runtime-module.js","webpack:///./node_modules/babel-runtime/node_modules/regenerator-runtime/runtime.js","webpack:///./src/intents/client.js","webpack:///./src/intents/service.js","webpack:///./src/jobs.js","webpack:///./src/offline.js","webpack:///./node_modules/cross-fetch/dist/browser-polyfill.js","webpack:///./node_modules/pouchdb-browser/lib/index.es.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/pouchdb-browser/node_modules/inherits/inherits_browser.js","webpack:///./node_modules/uuid/v1.js","webpack:///./node_modules/uuid/v4.js","webpack:///./node_modules/vuvuzela/index.js","webpack:///./node_modules/pouchdb-find/lib/index-browser.es.js","webpack:///./node_modules/pouchdb-selector-core/lib/index.es.js","webpack:///./node_modules/pouchdb-abstract-mapreduce/lib/index.es.js","webpack:///./node_modules/pouchdb-mapreduce-utils/lib/index.es.js","webpack:///./src/settings.js","webpack:///./src/relations.js"],"names":["cozyFetch","cozyFetchJSON","cozyFetchRawJSON","handleInvalidTokenError","cozy","path","options","fullpath","then","resp","disableAuth","fetch","manualAuthCredentials","cozyFetchWithAuth","authorize","credentials","handleResponse","res","_invalidTokenErrorHandler","headers","token","toAuthHeader","Promise","all","isV2","status","dontRetry","client","AccessToken","saveCredentials","newToken","method","body","processJSONAPI","fetchJSON","handleJSONResponse","response","undefined","JSON","stringify","invalidTokenErrorHandler","ok","data","contentType","get","indexOf","json","text","error","FetchError","err","isInvalidToken","Error","jsonapi","currentOrigin","window","location","origin","requestUrl","url","replace","redirectURL","disconnect","e","console","warn","reason","captureStackTrace","constructor","name","Object","defineProperty","value","message","isUnauthorized","isNotFound","unpromiser","isPromise","isOnline","isOffline","sleep","retry","getFuzzedDelay","getBackedoffDelay","createPath","encodeQuery","decodeQuery","FuzzFactor","fn","args","apply","l","length","cb","navigator","onLine","time","setTimeout","resolve","count","delay","doTry","catch","retryDelay","fuzzingFactor","Math","random","retryCount","pow","doctype","id","query","route","encodeURIComponent","q","qname","queryIndex","queries","fragIndex","queryStr","slice","parts","split","i","pair","decodeURIComponent","hasOwnProperty","warned","push","normalizeDoctype","DOCTYPE_FILES","KNOWN_DOCTYPES","files","folder","contact","event","track","playlist","REVERSE_KNOWN","keys","forEach","k","isQualified","known","registerClient","updateClient","unregisterClient","getClient","getAuthCodeURL","getAccessToken","refreshToken","oauthFlow","StateSize","CredsKey","StateKey","Client","opts","clientID","client_id","clientSecret","client_secret","registrationAccessToken","registration_access_token","redirect_uris","redirectURI","softwareID","software_id","softwareVersion","software_version","clientName","client_name","clientKind","client_kind","clientURI","client_uri","logoURI","logo_uri","policyURI","policy_uri","notificationPlatform","notification_platform","notificationDeviceToken","notification_device_token","tokenType","token_type","accessToken","access_token","refresh_token","scope","AppToken","clientParams","_clientParams","cli","isRegistered","reject","toRegisterJSON","resetSecret","createClient","oldClient","newClient","shouldPassRegistration","scopes","state","generateRandomState","redirect_uri","response_type","join","_url","pageURL","grantQueries","getGrantCodeFromPageURL","retrieveToken","grant_type","code","storage","onRegistered","ignoreCachedCredentials","clear","tryCount","clearAndRetry","registerNewClient","save","load","storedState","statePromise","t","delete","creds","assign","href","buffer","crypto","getRandomValues","Uint8Array","require","randomBytes","Array","floor","btoa","String","fromCharCode","pickService","errorSerializer","mapErrorProperties","from","to","result","nativeProperties","reduce","property","serialize","deserialize","first","arr","intent","filterServices","services","attributes","filteredServices","filter","indexKey","doc","type","findByRef","resources","ref","handleResource","rawResource","links","resource","_id","_type","_rev","meta","rev","relations","rels","relationships","isArray","map","handleTopLevel","included","r","create","service","baseURL","removeQueryString","buildRedirectionURL","getRedirectionURL","redirectFn","redirectionURL","redirect","createService","action","permissions","createPromise","start","element","onReadyCallback","intentId","serviceWindow","isSerializable","includes","parameterStrings","key","auth","mango","intents","jobs","offline","settings","AppTokenV3","AccessTokenV3","ClientV3","AuthNone","AuthRunning","AuthError","AuthOK","defaultClientParams","dataProto","find","findMany","findAll","update","_delete","updateAttributes","changesFeed","defineIndex","addReferencedFiles","removeReferencedFiles","listReferencedFiles","fetchReferencedFiles","destroy","authProto","filesProto","createDirectory","createDirectoryByPath","updateById","updateAttributesById","updateAttributesByPath","trashById","statById","statByPath","downloadById","downloadByPath","getDownloadLinkById","getDownloadLink","getDownloadLinkByPath","getArchiveLink","getArchiveLinkByPaths","getArchiveLinkByIds","getFilePath","getCollectionShareLink","queryFiles","listTrash","clearTrash","restoreById","destroyById","intentsProto","jobsProto","queued","offlineProto","init","getDoctypes","hasDatabase","getDatabase","createDatabase","migrateDatabase","destroyDatabase","destroyAllDatabase","hasReplication","replicateFromCozy","stopReplication","stopAllReplication","hasRepeatedReplication","startRepeatedReplication","stopRepeatedReplication","stopAllRepeatedReplication","settingsProto","diskUsage","changePassphrase","getInstance","updateInstance","getClients","deleteClientById","updateLastSync","ensureHasReconnectParam","URL","searchParams","has","append","search","toString","AppTokenV2","LocalStorage","MemoryStorage","_inited","_oauth","_token","_authstate","_authcreds","_storage","_version","version","_offline","oauth","_onRegistered","nopOnRegistered","cozyURL","onInvalidTokenError","disablePromises","addToProto","_fetch","_fetchJSON","concat","prototype","call","arguments","forceTokenRefresh","pathprefix","datasystem","protoify","context","prototyped","ctx","obj","proto","attr","module","exports","prefix","localStorage","setItem","item","getItem","parse","removeItem","hash","deleted","getAppToken","V2TOKEN_ABORT_TIMEOUT","parent","postMessage","timeout","receiver","appName","removeEventListener","clearTimeout","addEventListener","NOREV","docType","httpVerb","ids","include_docs","docs","rows","row","match","changes","tries","parseSelector","normalizeSelector","makeMapReduceQuery","fields","defineIndexV2","defineIndexV3","indexRef","queryV2","queryV3","getV3Options","wholeResponse","VALUEOPERATORS","LOGICOPERATORS","MAP_TEMPLATE","toLowerCase","emit","FIELDSPLACEHOLDER","COUCHDB_INFINITY","COUCHDB_LOWEST","indexName","capitalize","indexDefinition","makeMapFunction","index","indexResult","selector","$gt","use_index","limit","skip","since","sort","descending","f","charAt","toUpperCase","operator","acc","filters","op","field","applySelector","lower","upper","inclusiveEnd","startkey","endkey","inclusive_end","mrquery","firstFreeValueField","normalizedSelector","used","isFreeValue","ArrayBuffer","isBuffer","isFile","File","isBlob","Blob","isStream","readable","pipe","isString","contentLength","checksum","createdAt","updatedAt","executable","lastModifiedDate","ifMatch","metadata","sourceAccount","sourceAccountIdentifier","signal","contentTypeOctetStream","getFileTypeFromName","Date","finalpath","sendMetadata","metadataId","addQuerystringParam","dateString","toGMTString","doUpload","ROOT_DIR_ID","TRASH_DIR_ID","sanitizeFileName","trim","test","date","toISOString","dirID","noSanitize","getDirectoryOrCreate","parentDirectory","parsedError","errors","part","rootDirectoryPromise","parentDirectoryPromise","doUpdateAttributes","attrs","db","dir_id","children","sortFiles","addIsDir","toJsonApi","encodePageOptions","extractResponseLinkRelated","related","file","folderPath","endsWith","collectionType","verbs","values","collection","sharecode","codes","email","paths","archive","isDir","contents","clone","allFiles","folders","a","b","localeCompare","intentClass","hideIntentIframe","iframe","style","display","showIntentFrame","buildIntentIframe","document","ownerDocument","createElement","setAttribute","classList","add","injectIntentIframe","onload","appendChild","focus","connectIntentIframe","exposeIntentFrameRemoval","compose","defaultView","serviceOrigin","src","handshaken","messageHandler","eventType","source","transition","dimensions","prop","removeIntentFrame","parentNode","removeChild","listenClientData","messageEventListener","maximize","height","documentElement","terminated","sendMessage","composeEventListener","terminate","resizeClient","transitionProperty","maxHeight","clientHeight","maxWidth","clientWidth","cancel","getData","getIntent","eventName","throw","workerType","setDatabase","replicationOfflineError","pluginLoaded","doctypes","getInfo","database","oldDb","newOptions","adapter","newDb","PouchDB","replicate","plugin","pouchdbFind","createIndexes","createIndex","getReplication","replication","setReplication","getReplicationUrl","basic","toBasicAuth","getReplicationPromise","replicationPromise","setReplicationPromise","promise","live","onError","on","info","onComplete","stop","getRepeatedReplication","interval","setRepeatedReplication","timer","setInterval","clearInterval","currentPassPhrase","newPassPhrase","current_passphrase","new_passphrase","instance","updateRelations","verb","refs","makeReferencesPath","params"],"mappings":"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AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,iDAAY;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,SAAS,iDAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iDAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,yBAAyB,gEAAG;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,oBAAoB,iBAAiB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gDAAQ,UAAU,oDAAY;;AAE9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,EAAE,oDAAY;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,iDAAS;AACjB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,oDAAY;AACd;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,0BAA0B;AAC1B,GAAG;AACH;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,yBAAyB,0BAA0B;AACnD;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,WAAW,2EAAW,CAAC,mEAAW;AAClC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2EAAW,CAAC,kEAAU;AAChC,GAAG;AACH,UAAU,2EAAW,CAAC,kEAAU;AAChC,GAAG;AACH,UAAU,2EAAW,CAAC,mEAAW;AACjC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,oDAAY;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;;AAEA;AA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CA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;ACpBa;;AAEb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,C;;;;;;;AClBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;;AAEkD;;;;;;;ACjGlD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgC;;AAEhC,gDAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEkX;;;;;;;;AC7FlX;AAAA;AAAA;AAAA;AAAA;AAA+D;AACnC;;AAE5B;AACA;;AAEA;AACA,SAAS,0EAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,uFAAiB;AACnB;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAG,SAAS,iDAAG;;AAElD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,iDAAG;AACZ;;AAEgC;;;;;;;;;AC3EhC;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,yBAAyB;AACzB,aAAa;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO,yBAAyB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kDAAkD;AACvD;AACA;AACA,KAAK;AACL,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA,6CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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ACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEa;;AAEb;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,sBAAsB;AACvC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA,iCAAiC,QAAQ;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;;AAEA;AACA,QAAQ,yBAAyB;AACjC;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,GAAG;AACH;;;;;;;AC3dA;AACA,QAAQ,IAA2B;AACnC;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA,CAAC;;AAED;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;;AAEd,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc;;AAEd,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oBAAoB,QAAQ;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,aAAa;AACjC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,MAAM;AACrB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,QAAQ;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oBAAoB,aAAa;AACjC;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,eAAe,YAAY;AAC3B,eAAe,QAAQ;AACvB;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,CAAC;;;;;;;AC9uBD,SAAS,mBAAO,CAAC,EAAM;AACvB,SAAS,mBAAO,CAAC,EAAM;;AAEvB;AACA;AACA;;AAEA;;;;;;;ACPA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB,QAAQ;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,WAAW;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;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Aa5L,IAAb,CAAkBygB,aAAlB,CAAgCD,EAAE5U,UAAF,CAAa5L,IAA7C,CAAV;AAAA,KAAX,CADW;AAAA,GAAb;AAEA,SAAOsa,KAAKgG,OAAL,EAAc7K,MAAd,CAAqB6E,KAAKvW,KAAL,CAArB,CAAP;AACD;;AAED,SAASwZ,mBAAT,CAA6BvhB,IAA7B,EAAmC2S,GAAnC,EAAwCxO,KAAxC,EAA+C;AAC7C,cAAUnE,IAAV,IAAiBA,KAAKyS,QAAL,CAAc,GAAd,IAAqB,GAArB,GAA2B,GAA5C,IAAkDE,GAAlD,SAAyDxO,KAAzD;AACD,C;;;;;;AC7iBD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,cAAc;;AAEnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,iBAAiB,mBAAO,CAAC,EAAW;;AAEpC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;;AAEA;AACA;AACA,wCAAwC,WAAW;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;;AAEA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,iCAAiC,kBAAkB;AACnD;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;;AAEjB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,8CAA8C,QAAQ;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;;AAEA,WAAW;AACX;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA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AAC/C,MAAMooB,WAAW7R,YAAYvW,IAAZ,CAAjB;AACA,MAAMgqB,OAAO,SAAPA,IAAO;AAAA,WAAW5S,wBAAwBpX,IAAxB,EAA8ByG,OAA9B,CAAX;AAAA,GAAb;AACA,SAAOvF,QAAQC,GAAR,CAAYinB,SAASjX,GAAT,CAAa6Y,IAAb,CAAZ,CAAP;AACD,C;;;;;;AC1RD;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,uDAAuD;AACvD,SAAS;AACT;AACA,SAAS;AACT,8EAA8E;AAC9E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,qBAAqB;AACnD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,0BAA0B,eAAe;AACxE;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,CAAC,GAAG;AACJ,CAAC;;;;;;;;ACjhBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqC;AACJ;AACK;AACN;AACJ;AACF;AACM;;AAEhC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS,iDAAY;AACrB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,SAAS,iDAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,iDAAY;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,oBAAoB,iBAAiB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,qBAAqB,WAAW;AAChC,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gDAAQ,UAAU,oDAAY;;AAE9B;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,EAAE,oDAAY;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,QAAQ,iDAAQ;AAChB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE,oDAAY;AACd;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA,0BAA0B;AAC1B,GAAG;AACH;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA,iCAAiC;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA,yBAAyB,0BAA0B;AACnD;;AAEA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,gDAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,oDAAY;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,4BAA4B;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA,6DAA6D,WAAW;AACxE;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iDAAG,SAAS,iDAAG;;AAElD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,iDAAG;AACZ;;AAEA;AACA;AACA;AACA,WAAW,4CAAM;AACjB;;AAEA;AACA;AACA;;AAEA,WAAW,4CAAM;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,4CAA4C,SAAS;AACrD,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD,oBAAoB,4CAA4C;AAChE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,0CAA0C;AAC7D;AACA,GAAG;AACH;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,mBAAmB;AACrC;AACA,kBAAkB,8CAA8C;AAChE;AACA,0CAA0C,SAAS;AACnD,oBAAoB,iDAAiD;AACrE;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,iCAAiC;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,qBAAqB;AAC1C;AACA,sBAAsB,uCAAuC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,uDAAuD;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,sBAAsB,yBAAyB;AAC/C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD,oBAAoB,oCAAoC;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,6BAA6B;;AAE/C;AACA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,OAAO;AAC/C,oBAAoB,iDAAiD;AACrE;AACA;;AAEA;AACA;AACA;;AAEA,gDAAQ,YAAY,oDAAY;;AAEhC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA,EAAE,oDAAY;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,yBAAyB,oBAAoB;AAC7C,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;;;;AAIH;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,cAAc;AACnC;AACA;AACA,uBAAuB,SAAS,YAAY,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iDAAY;AAC9B;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,iBAAiB;AAClC;AACA;AACA,8BAA8B;AAC9B,KAAK;AACL;AACA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM,iDAAQ;AACd;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAQ,kBAAkB,oDAAY;;AAEtC;AACA,EAAE,oDAAY;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qBAAqB,YAAY;AACjC;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA,+BAA+B,WAAW;AAC1C,KAAK;AACL;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,iBAAiB,eAAe;AAChC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;;AAEA;AACA;;AAEA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,8BAA8B,+BAA+B;AAC7D;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,OAAO;AACP,KAAK;AACL,sBAAsB,SAAS;AAC/B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,4CAA4C,OAAO;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,QAAQ;AACjC;AACA,SAAS;AACT,uBAAuB,cAAc;AACrC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,kBAAkB;AACvC;AACA,0DAA0D,aAAa,EAAE;AACzE;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kDAAkD,aAAa,EAAE;AACjE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,qCAAqC,OAAO;AAC5C;AACA;AACA;;AAEA;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC,KAAK;AACL,CAAC;;AAED;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qBAAqB;AACrB,mBAAmB,8BAA8B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gDAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,SAAS,uBAAuB;;AAEnD;AACA;;AAEA;AACA;;AAEA;;AAEA,uBAAuB,oDAAY;;AAEnC;AACA,cAAc,oDAAY;AAC1B,eAAe,oDAAY;AAC3B;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC;AAClC;AACA,GAAG;AACH;AACA,GAAG;AACH,4CAA4C;AAC5C;AACA,KAAK;AACL;AACA;AACA,iDAAiD;AACjD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC;AACnC;AACA;;AAEA,EAAE,gDAAQ;;AAEV;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,gDAAgD;;AAEhD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA,+CAA+C;AAC/C;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,aAAa,SAAS,GAAG,SAAS;AAClC,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;;;AAIA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,KAAK,OAAO;AACZ,wCAAwC;AACxC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,sCAAsC;AACtC;AACA;AACA;AACA,KAAK,OAAO;AACZ,sCAAsC;AACtC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,KAAK,OAAO;AACZ,wCAAwC;AACxC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,sCAAsC;AACtC;AACA;AACA;AACA,KAAK,OAAO;AACZ,sCAAsC;AACtC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW,UAAU,MAAM;AAC1C;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,yBAAyB;AACzB,aAAa;;AAEb;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO,yBAAyB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,kDAAkD;AACvD;AACA;AACA,KAAK;AACL,sBAAsB;AACtB;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;;AAEA,6CAA6C,sBAAsB;AACnE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,sBAAsB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA,0BAA0B,YAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kDAAkD;AAClD;AACA,YAAY;AACZ;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iDAAiD,uBAAuB;AACxE;AACA;;AAEA;AACA,iCAAiC,uBAAuB,KAAK;AAC7D;;AAEA;AACA;AACA,2BAA2B;AAC3B,oBAAoB;AACpB,2BAA2B;AAC3B,mCAAmC;AACnC,wBAAwB;AACxB,SAAS;AACT,gCAAgC;AAChC,iBAAiB;AACjB,qBAAqB;AACrB,qBAAqB;AACrB,QAAQ;AACR,OAAO;AACP;;AAEA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2CAA2C,SAAS;AACpD,4BAA4B,kBAAkB;AAC9C;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kBAAkB;AAC7C,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;;AAEA,gBAAgB,aAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG,OAAO;AACV;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA,GAAG,OAAO;AACV;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,4BAA4B,QAAQ;AACpC;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,WAAW,gDAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,WAAW,gDAAQ;AACnB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,WAAW;AAC5C,KAAK,qCAAqC;AAC1C;AACA,KAAK,OAAO;AACZ;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA,KAAK,qCAAqC;AAC1C;AACA;AACA,OAAO;AACP,KAAK,OAAO;AACZ;AACA;AACA;AACA;;AAEA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,SAAS;AACnD;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA,+DAA+D;;AAE/D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC,wBAAwB;AACxB;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,2BAA2B;AAC3B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,8BAA8B;AAC9B;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gD;AACA;AACA;AACA;;AAEA,gB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4C;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,O;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,iBAAiB;AACjB,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM,iDAAQ;AACd;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC;AACvC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,oDAAoD,eAAe;AACnE,wCAAwC,oBAAoB;AAC5D,kDAAkD,aAAa;AAC/D,wCAAwC,kBAAkB;AAC1D,sCAAsC,oCAAoC;AAC1E;;AAEA;AACA,8DAA8D,eAAe;;AAE7E;AACA,uCAAuC,eAAe;;AAEtD;AACA;AACA,OAAO,oBAAoB;AAC3B;AACA,0DAA0D,aAAa;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA,8DAA8D,eAAe;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,eAAe;AACtD,kDAAkD,aAAa;AAC/D;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO,oBAAoB;AAC3B;AACA,0DAA0D,aAAa;AACvE;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA,qDAAqD;AACrD;AACA,uBAAuB,iBAAiB;AACxC;AACA,uCAAuC;AACvC;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,uCAAuC;AAC5D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA,mBAAmB;AACnB,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,4BAA4B;AAC5B;AACA;AACA,eAAe;AACf,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,eAAe;AACf,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,iDAAQ;AACnB;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA,+BAA+B;AAC/B;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA4B,iDAAY;AACxC;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,EAAE,iDAAQ;AACV;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C,OAAO;AACP;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0BAA0B;AACtD;AACA;AACA;;AAEA,qBAAqB,gBAAgB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL,GAAG;;;AAGH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA,oBAAoB,iBAAiB;AACrC,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,iDAAQ,cAAc,oCAAoC,EAAE;AACpE,OAAO;AACP;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,mCAAmC,iBAAiB;AACpD;AACA,KAAK;AACL;AACA;AACA,wBAAwB,SAAS;AACjC,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,gDAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,gDAAQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,gDAAQ;;AAER;AACA;AACA;AACA,MAAM,iDAAQ;AACd;AACA,OAAO;AACP,KAAK;AACL,MAAM,iDAAQ;AACd;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;;AAEA;AACA,SAAS,iDAAY;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,OAAO,OAAO;AACd;AACA;AACA,KAAK;AACL;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA,iDAAiD,UAAU,EAAE;AAC7D;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,gDAAgD,UAAU,EAAE,EAAE;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE,KAAK;AACL;AACA,oCAAoC,kBAAkB;AACtD,OAAO;AACP;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,kBAAkB;AAClB,SAAS,OAAO,YAAY,aAAa;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,mCAAmC;AAC3D;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA,sBAAsB,mCAAmC;AACzD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA,kDAAkD,SAAS;AAC3D;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;AACpC;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAsB,mCAAmC;AACzD;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA,iCAAiC,mCAAmC,EAAE;AACtE;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,kBAAkB;AAClB,SAAS;AACT,OAAO;AACP,KAAK,cAAc,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,iDAAQ;AACtB;AACA,eAAe;AACf;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;;AAEA;;AAEA;;AAEA,mCAAmC;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;;AAEvC;AACA,qCAAqC;AACrC,SAAS;AACT,OAAO;;AAEP;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;AACA,IAAI;AACJ,gCAAgC;AAChC,+BAA+B;AAC/B,mCAAmC;AACnC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,OAAO;AACP,0BAA0B;AAC1B,OAAO;AACP,0BAA0B;AAC1B,OAAO;AACP,0BAA0B;AAC1B;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB,4BAA4B,6BAA6B;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;;AAEP,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iDAAQ;AACZ;AACA,KAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,gDAAQ,cAAc,oDAAY;AAClC;AACA,EAAE,oDAAY;AACd;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gDAAQ,OAAO,oDAAY;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qDAAqD;AACrD,qDAAqD;;AAErD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEe,sEAAO,EAAC;;;;;;;;AC59TvB;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;ACvLtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACtBA,UAAU,mBAAO,CAAC,EAAW;AAC7B,kBAAkB,mBAAO,CAAC,EAAmB;;AAE7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,iBAAiB,OAAO;AACxB;AACA;;AAEA;AACA;;AAEA;;;;;;;AC5GA,UAAU,mBAAO,CAAC,EAAW;AAC7B,kBAAkB,mBAAO,CAAC,EAAmB;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;AC5Ba;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,WAAW;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,kBAAkB,SAAS;AAC3B,8BAA8B,QAAQ;AACtC;AACA,oBAAoB,iCAAiC;AACrD;AACA,kBAAkB,SAAS;AAC3B,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO,EAAE;AAC3B,+BAA+B,QAAQ;AACvC;AACA;AACA;AACA;AACA,oBAAoB,8BAA8B;AAClD;AACA,kBAAkB,OAAO,EAAE;AAC3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,kDAAkD;AACrD;AACA;AACA,GAAG;AACH,oBAAoB;AACpB;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA,aAAa;AACb,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAqF;AAC1B;AACnB;AAC6G;AAC1F;AACjB;AACF;;AAExC;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAK;;AAEpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB,8DAAO,EAAE,mCAAmC;AACjE;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gBAAgB,yFAAyB;AACzC;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,oBAAoB,iBAAiB;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,IAAI,uEAAQ;AACZ;AACA,KAAK;AACL,GAAG;AACH,IAAI,uEAAQ;AACZ;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,mCAAmC,SAAS;AAC5C,UAAU,qEAAM;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C,sBAAsB,iFAAU;AAChC,gBAAgB,sFAAe;AAC/B;AACA,MAAM,oFAAa;AACnB;AACA;AACA;AACA;;AAEA;AACA;;AAEA,4DAA4D,SAAS;AACrE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD,wBAAwB,iFAAU;AAClC;AACA,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iFAAU;AAC9B;AACA;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wCAAwC,SAAS;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB,mFAAiB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA,iBAAiB,6BAA6B;AAC9C,gBAAgB,6EAAM;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,SAAS;AAC7C;;AAEA;AACA;;AAEA;AACA;AACA,yBAAyB;AACzB,KAAK,OAAO;AACZ,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wEAAO;AACxB,uCAAuC;AACvC;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,oEAAK;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,+EAAQ;AACnB,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,sBAAsB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,qEAAM;AACxC;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,wBAAwB,qEAAM;AAC9B;AACA;;AAEA;AACA;AACA,yBAAyB,oEAAK;AAC9B;;AAEA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,sEAAS;AAClC;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,SAAS,qEAAM;AACf;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;AACA,aAAa,8EAAO;AACpB,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA,kBAAkB;;AAElB;;AAEA;AACA,yCAAyC,qEAAM;AAC/C,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6EAAM;;AAE3B;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,qEAAM;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,8EAAO;AAClB,GAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B,MAAM,WAAW,QAAQ,YAAY;AAClE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA,IAAI,6EAAM;;AAEV;AACA;;AAEA;;AAEA,yCAAyC,qEAAM;;AAE/C;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,2CAA2C,qEAAM;AACjD;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,6EAAM;AACpB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,yCAAyC,qEAAM;;AAE/C;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;;AAEA;;AAEA,mDAAmD;AACnD;AACA;AACA,KAAK;AACL,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,oEAAK;;AAElB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;;AAEA;AACA;AACA,0BAA0B,sFAAe;AACzC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,eAAe,qEAAM;AACrB;AACA;AACA,KAAK;;AAEL;AACA,QAAQ,wEAAO;AACf;AACA;AACA,cAAc;AACd;;AAEA;AACA;AACA,MAAM,+EAAQ;;AAEd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,2FAAoB;AACvC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA,SAAS,qEAAM;AACf;AACA,GAAG;AACH,YAAY;AACZ,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,wEAAS;;AAE9B;AACA;AACA;;AAEA,uBAAuB,uEAAQ;AAC/B;AACA;AACA,CAAC;;AAED,cAAc,wEAAS;;AAEvB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,uEAAQ;AACxB;AACA,CAAC;;AAED,iBAAiB,wEAAS;;AAE1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,gBAAgB,uEAAQ;AACxB;AACA,CAAC;;AAED,oBAAoB,wEAAS;;AAE7B,sBAAsB,uEAAQ;AAC9B;AACA,CAAC;;AAED,qBAAqB,wEAAS;;AAE9B;AACA;AACA;;AAEA,uBAAuB,uEAAQ;AAC/B;AACA;AACA,CAAC;;AAEc,qEAAM,EAAC;;;;;;;;ACv4CtB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAsC;AACI;;AAE1C;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C,WAAW;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA,+CAA+C;AAC/C;AACA,OAAO,OAAO;AACd;AACA;AACA;AACA,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA,aAAa,SAAS,GAAG,SAAS;AAClC,WAAW;AACX;;AAEA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;;AAEA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA,WAAW;AACX;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;;;AAIA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,KAAK,OAAO;AACZ,wCAAwC;AACxC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,sCAAsC;AACtC;AACA;AACA;AACA,KAAK,OAAO;AACZ,sCAAsC;AACtC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA,KAAK,OAAO;AACZ,wCAAwC;AACxC;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,sCAAsC;AACtC;AACA;AACA;AACA,KAAK,OAAO;AACZ,sCAAsC;AACtC;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG,OAAO;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,eAAe,oEAAK;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW,UAAU,MAAM;AAC1C;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;;AAEA,iBAAiB,mBAAmB;AACpC;AACA;;AAEA;AACA,iBAAiB;AACjB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,oBAAoB,wEAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA,iDAAiD,wEAAO;AACxD,GAAG;;AAEH;AACA,iDAAiD,wEAAO;AACxD,GAAG;;AAEH;AACA,iDAAiD,wEAAO;AACxD,GAAG;;AAEH;AACA,iDAAiD,wEAAO;AACxD,GAAG;;AAEH;AACA,iDAAiD,wEAAO;AACxD,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,aAAa,wEAAO;AACpB,KAAK;AACL,GAAG;AACH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iDAAiD,uBAAuB;AACxE;AACA;;AAE6L;;;;;;;;AC3iB7L;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAoF;AAC5C;AACO;AACmB;AAC+B;AACtC;AACnB;AACwH;;AAEhK;AACA;AACA;AACA;;;AAGA;AACA,iDAAiD,UAAU,EAAE;AAC7D;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA4B,sEAAS;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,WAAW,qEAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH,IAAI,6EAAc;AAClB;AACA;AACA,gDAAgD,UAAU,EAAE,EAAE;AAC9D;AACA,IAAI,6EAAc;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,KAAK;AACL;AACA,cAAc;AACd;AACA;;AAEA;AACA,qBAAqB,wEAAO;AAC5B,2CAA2C,wEAAO;AAClD;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gGAA0B;AACxD,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,gFAAe;AACnC;AACA;AACA;AACA,mBAAmB,gFAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,MAAM,wEAAO;AACb,gBAAgB,gFAAe;AAC/B,oDAAoD,kBAAkB;AACtE,KAAK;AACL;AACA,kBAAkB,gFAAe,GAAG,kBAAkB;AACtD,OAAO;AACP;AACA,kBAAkB,gFAAe;AACjC,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,kBAAkB;AAClB,SAAS,OAAO,YAAY,aAAa;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,8DAAO,EAAE,mCAAmC;AACjE;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,gBAAgB,yFAAyB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;;AAEL;AACA,mBAAmB,8DAAO,EAAE,mCAAmC;AAC/D;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,cAAc,yFAAyB;AACvC;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA,wBAAwB,gEAAG;;AAE3B,kDAAkD,SAAS;AAC3D;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uFAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,qBAAqB,6EAAI;AACzB;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sBAAsB;AAC/C;AACA,qBAAqB,uFAAc;AACnC;AACA;AACA,SAAS;AACT,8BAA8B,sEAAO;AACrC;AACA;AACA;AACA,mCAAmC,qBAAqB;AACxD,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,sFAAa;AACxB;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,kBAAkB,6EAAY;AAClD;AACA;AACA;AACA,uBAAuB,6EAAY;AACnC;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,gEAAG;AAC3C,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC,gEAAG;AAC5C;AACA,8CAA8C,SAAS;AACvD;AACA;AACA,qBAAqB,wEAAO;AAC5B,6BAA6B;AAC7B;AACA,qCAAqC,kFAAiB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,kBAAkB,wEAAO;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA,wCAAwC,SAAS;AACjD;AACA;AACA,wDAAwD,6EAAY;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,YAAY;AACZ;;AAEA;AACA,WAAW,sFAAa;AACxB;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC,qFAAoB;AACtD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,6EAAI;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,gEAAG;AACpC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,kFAAiB;AACtC,qBAAqB,kFAAiB,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,6CAA6C,8DAAO;AACpD,KAAK,OAAO;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kFAAiB,cAAc;AACzC,UAAU,kFAAiB;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,kFAAiB;AAC3C,oCAAoC;AACpC;AACA;AACA,uBAAuB,kFAAiB;AACxC,qBAAqB,kFAAiB,cAAc;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,8DAAO,EAAE,mCAAmC;AAC/D;AACA,KAAK;AACL;AACA,KAAK;AACL;;AAEA;AACA;AACA,4BAA4B,gEAAG;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAG;AACzB;AACA;AACA;AACA,OAAO;AACP;AACA,eAAe,uFAAc;AAC7B;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA,iCAAiC,mCAAmC,EAAE;AACtE;AACA,iBAAiB,sFAAa;AAC9B;AACA,WAAW;AACX,SAAS;AACT;AACA,kBAAkB;AAClB,SAAS;AACT,OAAO;AACP,KAAK,cAAc,SAAS;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ,uEAAQ;AAChB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,4EAAG;AACpB;AACA,WAAW;AACX;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;AAC7B,oBAAoB,8EAAa;AACjC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,uEAAQ;AACtB;AACA,eAAe;AACf;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;;AA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","file":"cozy-client.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"client\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"client\"] = factory();\n\telse\n\t\troot[\"cozy\"] = root[\"cozy\"] || {}, root[\"cozy\"][\"client\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 24);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap cb1624ac0c0934fd6a03","/* global fetch */\nimport { refreshToken, AccessToken } from './auth_v3'\nimport { retry, encodeQuery } from './utils'\nimport jsonapi from './jsonapi'\n\nexport function cozyFetch(cozy, path, options = {}) {\n  return cozy.fullpath(path).then(fullpath => {\n    let resp\n    if (options.disableAuth) {\n      resp = fetch(fullpath, options)\n    } else if (options.manualAuthCredentials) {\n      resp = cozyFetchWithAuth(\n        cozy,\n        fullpath,\n        options,\n        options.manualAuthCredentials\n      )\n    } else {\n      resp = cozy\n        .authorize()\n        .then(credentials =>\n          cozyFetchWithAuth(cozy, fullpath, options, credentials)\n        )\n    }\n    return resp.then(res => handleResponse(res, cozy._invalidTokenErrorHandler))\n  })\n}\n\nfunction cozyFetchWithAuth(cozy, fullpath, options, credentials) {\n  if (credentials) {\n    options.headers = options.headers || {}\n    options.headers['Authorization'] = credentials.token.toAuthHeader()\n  }\n\n  // the option credentials:include tells fetch to include the cookies in the\n  // request even for cross-origin requests\n  options.credentials = 'include'\n\n  return Promise.all([cozy.isV2(), fetch(fullpath, options)]).then(\n    ([isV2, res]) => {\n      if (\n        (res.status !== 400 && res.status !== 401) ||\n        isV2 ||\n        !credentials ||\n        options.dontRetry\n      ) {\n        return res\n      }\n      // we try to refresh the token only for OAuth, ie, the client defined\n      // and the token is an instance of AccessToken.\n      const { client, token } = credentials\n      if (!client || !(token instanceof AccessToken)) {\n        return res\n      }\n      options.dontRetry = true\n      return retry(() => refreshToken(cozy, client, token), 3)()\n        .then(newToken => cozy.saveCredentials(client, newToken))\n        .then(credentials =>\n          cozyFetchWithAuth(cozy, fullpath, options, credentials)\n        )\n    }\n  )\n}\n\nexport function cozyFetchJSON(cozy, method, path, body, options = {}) {\n  const processJSONAPI =\n    typeof options.processJSONAPI === 'undefined' || options.processJSONAPI\n  return fetchJSON(cozy, method, path, body, options).then(response =>\n    handleJSONResponse(response, processJSONAPI)\n  )\n}\n\nexport function cozyFetchRawJSON(cozy, method, path, body, options = {}) {\n  return fetchJSON(cozy, method, path, body, options).then(response =>\n    handleJSONResponse(response, false)\n  )\n}\n\nfunction fetchJSON(cozy, method, path, body, options = {}) {\n  options.method = method\n\n  const headers = (options.headers = options.headers || {})\n\n  headers['Accept'] = 'application/json'\n\n  if (method !== 'GET' && method !== 'HEAD' && body !== undefined) {\n    if (headers['Content-Type']) {\n      options.body = body\n    } else {\n      headers['Content-Type'] = 'application/json'\n      options.body = JSON.stringify(body)\n    }\n  }\n\n  return cozyFetch(cozy, path, options)\n}\n\nfunction handleResponse(res, invalidTokenErrorHandler) {\n  if (res.ok) {\n    return res\n  }\n  let data\n  const contentType = res.headers.get('content-type')\n  if (contentType && contentType.indexOf('json') >= 0) {\n    data = res.json()\n  } else {\n    data = res.text()\n  }\n  return data.then(err => {\n    const error = new FetchError(res, err)\n    if (FetchError.isInvalidToken(error) && invalidTokenErrorHandler) {\n      invalidTokenErrorHandler(error)\n    }\n    throw error\n  })\n}\n\nfunction handleJSONResponse(res, processJSONAPI = true) {\n  const contentType = res.headers.get('content-type')\n  if (!contentType || contentType.indexOf('json') < 0) {\n    return res.text(data => {\n      throw new FetchError(res, new Error('Response is not JSON: ' + data))\n    })\n  }\n\n  const json = res.json()\n  if (contentType.indexOf('application/vnd.api+json') === 0 && processJSONAPI) {\n    return json.then(jsonapi)\n  } else {\n    return json\n  }\n}\n\nexport function handleInvalidTokenError(error) {\n  try {\n    const currentOrigin = window.location.origin\n    const requestUrl = error.url\n\n    if (\n      requestUrl.indexOf(\n        currentOrigin.replace(/^(https?:\\/\\/\\w+)-\\w+\\./, '$1.')\n      ) === 0\n    ) {\n      const redirectURL = `${currentOrigin}?${encodeQuery({ disconnect: 1 })}`\n      window.location = redirectURL\n    }\n  } catch (e) {\n    console.warn('Unable to handle invalid token error', e, error)\n  }\n}\n\nexport class FetchError extends Error {\n  constructor(res, reason) {\n    super()\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n    // XXX We have to hardcode this because babel doesn't play nice when extending Error\n    this.name = 'FetchError'\n    this.response = res\n    this.url = res.url\n    this.status = res.status\n    this.reason = reason\n\n    Object.defineProperty(this, 'message', {\n      value:\n        reason.message ||\n        (typeof reason === 'string' ? reason : JSON.stringify(reason))\n    })\n  }\n}\n\nFetchError.isUnauthorized = function(err) {\n  // XXX We can't use err instanceof FetchError because of the caveats of babel\n  return err.name === 'FetchError' && err.status === 401\n}\n\nFetchError.isNotFound = function(err) {\n  // XXX We can't use err instanceof FetchError because of the caveats of babel\n  return err.name === 'FetchError' && err.status === 404\n}\n\nFetchError.isInvalidToken = function(err) {\n  // XXX We can't use err instanceof FetchError because of the caveats of babel\n  return (\n    err.name === 'FetchError' &&\n    (err.status === 400 || err.status === 401) &&\n    err.reason &&\n    (err.reason.error === 'Invalid JWT token' ||\n      err.reason.error === 'Expired token')\n  )\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/fetch.js","/* global navigator */\nconst FuzzFactor = 0.3\n\nexport function unpromiser(fn) {\n  return function(...args) {\n    const value = fn.apply(this, args)\n    if (!isPromise(value)) {\n      return value\n    }\n    const l = args.length\n    if (l === 0 || typeof args[l - 1] !== 'function') {\n      return\n    }\n    const cb = args[l - 1]\n    value.then(res => cb(null, res), err => cb(err, null))\n  }\n}\n\nexport function isPromise(value) {\n  return !!value && typeof value.then === 'function'\n}\n\nexport function isOnline() {\n  return typeof navigator !== 'undefined' ? navigator.onLine : true\n}\n\nexport function isOffline() {\n  return !isOnline()\n}\n\nexport function sleep(time, args) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time, args)\n  })\n}\n\nexport function retry(fn, count, delay = 300) {\n  return function doTry(...args) {\n    return fn(...args).catch(err => {\n      if (--count < 0) {\n        throw err\n      }\n      return sleep(getBackedoffDelay(delay, count)).then(() => doTry(...args))\n    })\n  }\n}\n\nexport function getFuzzedDelay(retryDelay) {\n  const fuzzingFactor = (Math.random() * 2 - 1) * FuzzFactor\n  return retryDelay * (1.0 + fuzzingFactor)\n}\n\nexport function getBackedoffDelay(retryDelay, retryCount = 1) {\n  return getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1))\n}\n\nexport function createPath(cozy, isV2, doctype, id = '', query = null) {\n  let route = '/data/'\n  if (!isV2) {\n    route += `${encodeURIComponent(doctype)}/`\n  }\n  if (id !== '') {\n    route += encodeURIComponent(id)\n  }\n  const q = encodeQuery(query)\n  if (q !== '') {\n    route += '?' + q\n  }\n  return route\n}\n\nexport function encodeQuery(query) {\n  if (!query) {\n    return ''\n  }\n  let q = ''\n  for (const qname in query) {\n    if (q !== '') {\n      q += '&'\n    }\n    q += `${encodeURIComponent(qname)}=${encodeURIComponent(query[qname])}`\n  }\n  return q\n}\n\nexport function decodeQuery(url) {\n  let queryIndex = url.indexOf('?')\n  if (queryIndex < 0) {\n    queryIndex = url.length\n  }\n  const queries = {}\n  let fragIndex = url.indexOf('#')\n  if (fragIndex < 0) {\n    fragIndex = url.length\n  }\n  if (fragIndex < queryIndex) {\n    return queries\n  }\n  const queryStr = url.slice(queryIndex + 1, fragIndex)\n  if (queryStr === '') {\n    return queries\n  }\n  const parts = queryStr.split('&')\n  for (let i = 0; i < parts.length; i++) {\n    let pair = parts[i].split('=')\n    if (pair.length === 0 || pair[0] === '') {\n      continue\n    }\n    const qname = decodeURIComponent(pair[0])\n    if (queries.hasOwnProperty(qname)) {\n      continue\n    }\n    if (pair.length === 1) {\n      queries[qname] = true\n    } else if (pair.length === 2) {\n      queries[qname] = decodeURIComponent(pair[1])\n    } else {\n      throw new Error('Malformed URL')\n    }\n  }\n  return queries\n}\n\nconst warned = []\nexport function warn(text) {\n  if (warned.indexOf(text) === -1) {\n    warned.push(text)\n    console.warn('cozy-client-js', text)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","import { warn } from './utils'\n\nexport const DOCTYPE_FILES = 'io.cozy.files'\n\nconst KNOWN_DOCTYPES = {\n  files: DOCTYPE_FILES,\n  folder: DOCTYPE_FILES,\n  contact: 'io.cozy.contacts',\n  event: 'io.cozy.events',\n  track: 'io.cozy.labs.music.track',\n  playlist: 'io.cozy.labs.music.playlist'\n}\n\nconst REVERSE_KNOWN = {}\nObject.keys(KNOWN_DOCTYPES).forEach(k => {\n  REVERSE_KNOWN[KNOWN_DOCTYPES[k]] = k\n})\n\nexport function normalizeDoctype(cozy, isV2, doctype) {\n  let isQualified = doctype.indexOf('.') !== -1\n  if (isV2 && isQualified) {\n    let known = REVERSE_KNOWN[doctype]\n    if (known) return known\n    return doctype.replace(/\\./g, '-')\n  }\n  if (!isV2 && !isQualified) {\n    let known = KNOWN_DOCTYPES[doctype]\n    if (known) {\n      warn(\n        'you are using a non-qualified doctype ' +\n          doctype +\n          ' assumed to be ' +\n          known\n      )\n      return known\n    }\n    throw new Error('Doctype ' + doctype + ' should be qualified.')\n  }\n  return doctype\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/doctypes.js","import getArguments from 'argsarray';\nimport { Map } from 'pouchdb-collections';\nimport immediate from 'immediate';\nimport { EventEmitter } from 'events';\nimport inherits from 'inherits';\nimport { createError, BAD_REQUEST, INVALID_ID, MISSING_ID, RESERVED_ID } from 'pouchdb-errors';\nimport uuidV4 from 'uuid';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { clone } from 'pouchdb-utils';\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone$1(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone$1(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone$1(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone$1(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new Promise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return Promise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return Promise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new Promise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new Map();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nvar hasLocal;\n\ntry {\n  localStorage.setItem('_pouch_check_localstorage', 1);\n  hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n} catch (e) {\n  hasLocal = false;\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n\ninherits(Changes, EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (hasLocalStorage()) {\n    addEventListener(\"storage\", function (e) {\n      self.emit(e.key);\n    });\n  }\n}\n\nfunction Changes() {\n  EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        immediate(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar assign$1 = assign;\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function (fun) {\n    return fun.name;\n  };\n} else {\n  res = function (fun) {\n    var match = fun.toString().match(/^\\s*function\\s*(?:(\\S+)\\s*)?\\(/);\n    if (match && match[1]) {\n      return match[1];\n    }\n    else {\n      return '';\n    }\n  };\n}\n\nvar res$1 = res;\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new Promise(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nfunction rev(doc, deterministic_revs) {\n  var clonedDoc = clone(doc);\n  if (!deterministic_revs) {\n    return uuidV4.v4().replace(/-/g, '').toLowerCase();\n  }\n\n  delete clonedDoc._rev_tree;\n  return stringMd5(JSON.stringify(clonedDoc));\n}\n\nvar uuid = uuidV4.v4;\n\nexport { adapterFun, assign$1 as assign, bulkGet as bulkGetShim, Changes as changesHandler, clone$1 as clone, defaultBackOff, explainError, filterChange, flatten, res$1 as functionName, guardedConsole, hasLocalStorage, invalidIdError, isRemote, listenerCount, immediate as nextTick, normalizeDesignDocFunctionName as normalizeDdocFunctionName, once, parseDesignDocFunctionName as parseDdocFunctionName, parseUri, pick, rev, scopeEval, toPromise, upsert, uuid };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-utils/lib/index-browser.es.js\n// module id = 3\n// module chunks = 0","/* global btoa */\nimport { encodeQuery, decodeQuery, isOffline } from './utils'\nimport { cozyFetchJSON, FetchError } from './fetch'\n\nconst StateSize = 16\n\nexport const CredsKey = 'creds'\nexport const StateKey = 'state'\n\nexport class Client {\n  constructor(opts) {\n    this.clientID = opts.clientID || opts.client_id || ''\n    this.clientSecret = opts.clientSecret || opts.client_secret || ''\n    this.registrationAccessToken =\n      opts.registrationAccessToken || opts.registration_access_token || ''\n\n    if (opts.redirect_uris) {\n      this.redirectURI = opts.redirect_uris[0] || ''\n    } else {\n      this.redirectURI = opts.redirectURI || ''\n    }\n\n    this.softwareID = opts.softwareID || opts.software_id || ''\n    this.softwareVersion = opts.softwareVersion || opts.software_version || ''\n    this.clientName = opts.clientName || opts.client_name || ''\n    this.clientKind = opts.clientKind || opts.client_kind || ''\n    this.clientURI = opts.clientURI || opts.client_uri || ''\n\n    this.logoURI = opts.logoURI || opts.logo_uri || ''\n    this.policyURI = opts.policyURI || opts.policy_uri || ''\n\n    this.notificationPlatform =\n      opts.notificationPlatform || opts.notification_platform || ''\n    this.notificationDeviceToken =\n      opts.notificationDeviceToken || opts.notification_device_token || ''\n\n    if (!this.registrationAccessToken) {\n      if (this.redirectURI === '') {\n        throw new Error('Missing redirectURI field')\n      }\n      if (this.softwareID === '') {\n        throw new Error('Missing softwareID field')\n      }\n      if (this.clientName === '') {\n        throw new Error('Missing clientName field')\n      }\n    }\n  }\n\n  isRegistered() {\n    return this.clientID !== ''\n  }\n\n  toRegisterJSON() {\n    return {\n      redirect_uris: [this.redirectURI],\n      software_id: this.softwareID,\n      software_version: this.softwareVersion,\n      client_name: this.clientName,\n      client_kind: this.clientKind,\n      client_uri: this.clientURI,\n      logo_uri: this.logoURI,\n      policy_uri: this.policyURI,\n      notification_platform: this.notificationPlatform,\n      notification_device_token: this.notificationDeviceToken\n    }\n  }\n\n  toAuthHeader() {\n    return 'Bearer ' + this.registrationAccessToken\n  }\n}\n\nexport class AccessToken {\n  constructor(opts) {\n    this.tokenType = opts.tokenType || opts.token_type\n    this.accessToken = opts.accessToken || opts.access_token\n    this.refreshToken = opts.refreshToken || opts.refresh_token\n    this.scope = opts.scope\n  }\n\n  toAuthHeader() {\n    return 'Bearer ' + this.accessToken\n  }\n\n  toBasicAuth() {\n    return `user:${this.accessToken}@`\n  }\n}\n\nexport class AppToken {\n  constructor(opts) {\n    this.token = opts.token || ''\n  }\n\n  toAuthHeader() {\n    return 'Bearer ' + this.token\n  }\n\n  toBasicAuth() {\n    return `user:${this.token}@`\n  }\n}\n\nexport function client(cozy, clientParams) {\n  if (!clientParams) {\n    clientParams = cozy._clientParams\n  }\n  if (clientParams instanceof Client) {\n    return clientParams\n  }\n  return new Client(clientParams)\n}\n\nexport function registerClient(cozy, clientParams) {\n  const cli = client(cozy, clientParams)\n  if (cli.isRegistered()) {\n    return Promise.reject(new Error('Client already registered'))\n  }\n  return cozyFetchJSON(cozy, 'POST', '/auth/register', cli.toRegisterJSON(), {\n    disableAuth: true\n  }).then(data => new Client(data))\n}\n\nexport function updateClient(cozy, clientParams, resetSecret = false) {\n  const cli = client(cozy, clientParams)\n  if (!cli.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  let data = cli.toRegisterJSON()\n  data.client_id = cli.clientID\n  if (resetSecret) data.client_secret = cli.clientSecret\n\n  return cozyFetchJSON(cozy, 'PUT', `/auth/register/${cli.clientID}`, data, {\n    manualAuthCredentials: {\n      token: cli\n    }\n  }).then(data => createClient(data, cli))\n}\n\nexport function unregisterClient(cozy, clientParams) {\n  const cli = client(cozy, clientParams)\n  if (!cli.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  return cozyFetchJSON(cozy, 'DELETE', `/auth/register/${cli.clientID}`, null, {\n    manualAuthCredentials: {\n      token: cli\n    }\n  })\n}\n\n// getClient will retrive the registered client informations from the server.\nexport function getClient(cozy, clientParams) {\n  const cli = client(cozy, clientParams)\n  if (!cli.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  if (isOffline()) {\n    return Promise.resolve(cli)\n  }\n  return cozyFetchJSON(cozy, 'GET', `/auth/register/${cli.clientID}`, null, {\n    manualAuthCredentials: {\n      token: cli\n    }\n  })\n    .then(data => createClient(data, cli))\n    .catch(err => {\n      // If we fall into an error while fetching the client (because of a\n      // bad connectivity for instance), we do not bail the whole process\n      // since the client should be able to continue with the persisted\n      // client and token.\n      //\n      // If it is an explicit Unauthorized error though, we bail, clear th\n      // cache and retry.\n      if (FetchError.isUnauthorized(err) || FetchError.isNotFound(err)) {\n        throw new Error('Client has been revoked')\n      }\n      throw err\n    })\n}\n\n// createClient returns a new Client instance given on object containing the\n// data of the client, from the API, and an old instance of the client.\nfunction createClient(data, oldClient) {\n  const newClient = new Client(data)\n  // we need to keep track of the registrationAccessToken since it is send\n  // only on registration. The GET /auth/register/:client-id endpoint does\n  // not return this token.\n  const shouldPassRegistration =\n    !!oldClient &&\n    oldClient.registrationAccessToken !== '' &&\n    newClient.registrationAccessToken === ''\n  if (shouldPassRegistration) {\n    newClient.registrationAccessToken = oldClient.registrationAccessToken\n  }\n  return newClient\n}\n\n// getAuthCodeURL returns a pair {authURL,state} given a registered client. The\n// state should be stored in order to be checked against on the user validation\n// phase.\nexport function getAuthCodeURL(cozy, client, scopes = []) {\n  if (!(client instanceof Client)) {\n    client = new Client(client)\n  }\n  if (!client.isRegistered()) {\n    throw new Error('Client not registered')\n  }\n  const state = generateRandomState()\n  const query = {\n    client_id: client.clientID,\n    redirect_uri: client.redirectURI,\n    state: state,\n    response_type: 'code',\n    scope: scopes.join(' ')\n  }\n  return {\n    url: cozy._url + `/auth/authorize?${encodeQuery(query)}`,\n    state: state\n  }\n}\n\n// getAccessToken perform a request on the access_token entrypoint with the\n// authorization_code grant type in order to generate a new access token for a\n// newly registered client.\n//\n// This method extracts the access code and state from the given URL. By\n// default it uses window.location.href. Also, it checks the given state with\n// the one specified in the URL query parameter to prevent CSRF attacks.\nexport function getAccessToken(cozy, client, state, pageURL = '') {\n  if (!state) {\n    return Promise.reject(new Error('Missing state value'))\n  }\n  const grantQueries = getGrantCodeFromPageURL(pageURL)\n  if (grantQueries === null) {\n    return Promise.reject(new Error('Missing states from current URL'))\n  }\n  if (state !== grantQueries.state) {\n    return Promise.reject(\n      new Error('Given state does not match url query state')\n    )\n  }\n  return retrieveToken(cozy, client, null, {\n    grant_type: 'authorization_code',\n    code: grantQueries.code\n  })\n}\n\n// refreshToken perform a request on the access_token entrypoint with the\n// refresh_token grant type in order to refresh the given token.\nexport function refreshToken(cozy, client, token) {\n  return retrieveToken(cozy, client, token, {\n    grant_type: 'refresh_token',\n    refresh_token: token.refreshToken\n  })\n}\n\n// oauthFlow performs the stateful registration and access granting of an OAuth\n// client.\nexport function oauthFlow(\n  cozy,\n  storage,\n  clientParams,\n  onRegistered,\n  ignoreCachedCredentials = false\n) {\n  if (ignoreCachedCredentials) {\n    return storage\n      .clear()\n      .then(() => oauthFlow(cozy, storage, clientParams, onRegistered, false))\n  }\n\n  let tryCount = 0\n\n  function clearAndRetry(err) {\n    if (tryCount++ > 0) {\n      throw err\n    }\n    return storage\n      .clear()\n      .then(() => oauthFlow(cozy, storage, clientParams, onRegistered))\n  }\n\n  function registerNewClient() {\n    return storage\n      .clear()\n      .then(() => registerClient(cozy, clientParams))\n      .then(client => {\n        const { url, state } = getAuthCodeURL(cozy, client, clientParams.scopes)\n        return storage.save(StateKey, { client, url, state })\n      })\n  }\n\n  return Promise.all([storage.load(CredsKey), storage.load(StateKey)])\n    .then(([credentials, storedState]) => {\n      // If credentials are cached we re-fetch the registered client with the\n      // said token. Fetching the client, if the token is outdated we should try\n      // the token is refreshed.\n      if (credentials) {\n        let oldClient, token\n        try {\n          oldClient = new Client(credentials.client)\n          token = new AccessToken(credentials.token)\n        } catch (err) {\n          // bad cache, we should clear and retry the process\n          return clearAndRetry(err)\n        }\n        return getClient(cozy, oldClient)\n          .then(client => ({ client, token }))\n          .catch(err => {\n            // If we fall into an error while fetching the client (because of a\n            // bad connectivity for instance), we do not bail the whole process\n            // since the client should be able to continue with the persisted\n            // client and token.\n            //\n            // If it is an explicit Unauthorized error though, we bail, clear th\n            // cache and retry.\n            if (FetchError.isUnauthorized(err) || FetchError.isNotFound(err)) {\n              throw new Error('Client has been revoked')\n            }\n            return { client: oldClient, token }\n          })\n      }\n\n      // Otherwise register a new client if necessary (ie. no client is stored)\n      // and call the onRegistered callback to wait for the user to grant the\n      // access. Finally fetches to access token on success.\n      let statePromise\n      if (!storedState) {\n        statePromise = registerNewClient()\n      } else {\n        statePromise = Promise.resolve(storedState)\n      }\n\n      let client, state, token\n      return statePromise\n        .then(data => {\n          client = data.client\n          state = data.state\n          return Promise.resolve(onRegistered(client, data.url))\n        })\n        .then(pageURL => getAccessToken(cozy, client, state, pageURL))\n        .then(t => {\n          token = t\n        })\n        .then(() => storage.delete(StateKey))\n        .then(() => ({ client, token }))\n    })\n    .then(\n      creds => storage.save(CredsKey, creds),\n      err => {\n        if (FetchError.isUnauthorized(err)) {\n          return clearAndRetry(err)\n        } else {\n          throw err\n        }\n      }\n    )\n}\n\n// retrieveToken perform a request on the access_token entrypoint in order to\n// fetch a token.\nfunction retrieveToken(cozy, client, token, query) {\n  if (!(client instanceof Client)) {\n    client = new Client(client)\n  }\n  if (!client.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  const body = encodeQuery(\n    Object.assign({}, query, {\n      client_id: client.clientID,\n      client_secret: client.clientSecret\n    })\n  )\n  return cozyFetchJSON(cozy, 'POST', '/auth/access_token', body, {\n    disableAuth: token === null,\n    dontRetry: true,\n    manualAuthCredentials: { client, token },\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n  }).then(data => {\n    data.refreshToken = data.refreshToken || query.refresh_token\n    return new AccessToken(data)\n  })\n}\n\n// getGrantCodeFromPageURL extract the state and code query parameters from the\n// given url\nfunction getGrantCodeFromPageURL(pageURL = '') {\n  if (pageURL === '' && typeof window !== 'undefined') {\n    pageURL = window.location.href\n  }\n  const queries = decodeQuery(pageURL)\n  if (!queries.hasOwnProperty('state')) {\n    return null\n  }\n  return {\n    state: queries['state'],\n    code: queries['code']\n  }\n}\n\n// generateRandomState will try to generate a 128bits random value from a secure\n// pseudo random generator. It will fallback on Math.random if it cannot find\n// such generator.\nfunction generateRandomState() {\n  let buffer\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.crypto !== 'undefined' &&\n    typeof window.crypto.getRandomValues === 'function'\n  ) {\n    buffer = new Uint8Array(StateSize)\n    window.crypto.getRandomValues(buffer)\n  } else {\n    try {\n      buffer = require('crypto').randomBytes(StateSize)\n    } catch (e) {\n      buffer = null\n    }\n  }\n  if (!buffer) {\n    buffer = new Array(StateSize)\n    for (let i = 0; i < buffer.length; i++) {\n      buffer[i] = Math.floor(Math.random() * 255)\n    }\n  }\n  return btoa(String.fromCharCode.apply(null, buffer))\n    .replace(/=+$/, '')\n    .replace(/\\//g, '_')\n    .replace(/\\+/g, '-')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/auth_v3.js","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/regenerator/index.js\n// module id = 5\n// module chunks = 0","// helper to serialize/deserialize an error for/from postMessage\nexport const errorSerializer = (() => {\n  function mapErrorProperties(from, to) {\n    const result = Object.assign(to, from)\n    const nativeProperties = ['name', 'message']\n    return nativeProperties.reduce((result, property) => {\n      if (from[property]) {\n        to[property] = from[property]\n      }\n      return result\n    }, result)\n  }\n  return {\n    serialize: error => mapErrorProperties(error, {}),\n    deserialize: data => mapErrorProperties(data, new Error(data.message))\n  }\n})()\n\nconst first = arr => arr && arr[0]\n// In a far future, the user will have to pick the desired service from a list.\n// For now it's our job, an easy job as we arbitrary pick the first service of\n// the list.\nexport function pickService(intent, filterServices) {\n  const services = intent.attributes.services\n  const filteredServices = filterServices\n    ? (services || []).filter(filterServices)\n    : services\n  return first(filteredServices)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/intents/helpers.js","var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 7\n// module chunks = 0","'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/argsarray/index.js\n// module id = 8\n// module chunks = 0","function mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\nexport { ExportedSet as Set, ExportedMap as Map };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-collections/lib/index.es.js\n// module id = 9\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/inherits/inherits_browser.js\n// module id = 10\n// module chunks = 0","import inherits from 'inherits';\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nexport { UNAUTHORIZED, MISSING_BULK_DOCS, MISSING_DOC, REV_CONFLICT, INVALID_ID, MISSING_ID, RESERVED_ID, NOT_OPEN, UNKNOWN_ERROR, BAD_ARG, INVALID_REQUEST, QUERY_PARSE_ERROR, DOC_VALIDATION, BAD_REQUEST, NOT_AN_OBJECT, DB_MISSING, WSQ_ERROR, LDB_ERROR, FORBIDDEN, INVALID_REV, FILE_EXISTS, MISSING_STUB, IDB_ERROR, INVALID_URL, createError, generateErrorFromResponse };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-errors/lib/index.es.js\n// module id = 11\n// module chunks = 0","import { btoa, readAsArrayBuffer } from 'pouchdb-binary-utils';\nimport Md5 from 'spark-md5';\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return btoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nexport { binaryMd5, stringMd5 };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-md5/lib/index-browser.es.js\n// module id = 12\n// module chunks = 0","function pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        /* eslint-disable no-control-regex */\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n        /* eslint-enable no-control-regex */\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        /* eslint-disable no-control-regex */\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        /* eslint-enable no-control-regex */\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\nexport { collate, normalizeKey, toIndexableString, parseIndexableString };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-collate/lib/index.es.js\n// module id = 13\n// module chunks = 0","function indexKey(doc) {\n  return doc.type + '/' + doc.id\n}\n\nfunction findByRef(resources, ref) {\n  return resources[indexKey(ref)]\n}\n\nfunction handleResource(rawResource, resources, links) {\n  let resource = {\n    _id: rawResource.id,\n    _type: rawResource.type,\n    _rev: rawResource.meta && rawResource.meta.rev,\n    links: Object.assign({}, rawResource.links, links),\n    attributes: rawResource.attributes,\n    relations: name => {\n      let rels = rawResource.relationships[name]\n      if (rels === undefined || rels.data === undefined) return undefined\n      if (rels.data === null) return null\n      if (!Array.isArray(rels.data)) return findByRef(resources, rels.data)\n      return rels.data.map(ref => findByRef(resources, ref))\n    }\n  }\n  if (rawResource.relationships) {\n    resource.relationships = rawResource.relationships\n  }\n\n  resources[indexKey(rawResource)] = resource\n\n  return resource\n}\n\nfunction handleTopLevel(doc, resources = {}) {\n  // build an index of included resource by Type & ID\n  const included = doc.included\n\n  if (Array.isArray(included)) {\n    included.forEach(r => handleResource(r, resources, doc.links))\n  }\n\n  if (Array.isArray(doc.data)) {\n    return doc.data.map(r => handleResource(r, resources, doc.links))\n  } else {\n    return handleResource(doc.data, resources, doc.links)\n  }\n}\n\nexport default handleTopLevel\n\n\n\n// WEBPACK FOOTER //\n// ./src/jsonapi.js","import { cozyFetchJSON } from '../fetch'\nimport { pickService } from './helpers'\nimport * as client from './client'\nimport * as service from './service'\n\nexport function create(cozy, action, type, data = {}, permissions = []) {\n  if (!action)\n    throw new Error(`Misformed intent, \"action\" property must be provided`)\n  if (!type)\n    throw new Error(`Misformed intent, \"type\" property must be provided`)\n\n  const createPromise = cozyFetchJSON(cozy, 'POST', '/intents', {\n    data: {\n      type: 'io.cozy.intents',\n      attributes: {\n        action: action,\n        type: type,\n        data: data,\n        permissions: permissions\n      }\n    }\n  })\n\n  createPromise.start = (element, onReadyCallback) => {\n    const options = {\n      filteredServices: data.filteredServices,\n      onReadyCallback: onReadyCallback\n    }\n\n    delete data.filteredServices\n\n    return createPromise.then(intent =>\n      client.start(cozy, intent, element, data, options)\n    )\n  }\n\n  return createPromise\n}\n\n// returns a service to communicate with intent client\nexport function createService(cozy, intentId, serviceWindow) {\n  return service.start(cozy, intentId, serviceWindow)\n}\n\nfunction removeQueryString(url) {\n  return url.replace(/\\?[^/#]*/, '')\n}\n\n// Redirect to an app able to handle the doctype\n// Redirections are more or less a hack of the intent API to retrieve an URL for\n// accessing a given doctype or a given document.\n// It needs to use a special action `REDIRECT`\nexport async function getRedirectionURL(cozy, type, data) {\n  if (!type && !data)\n    throw new Error(\n      `Cannot retrieve redirection, at least type or doc must be provided`\n    )\n\n  const intent = await create(cozy, 'REDIRECT', type, data)\n\n  const service = pickService(intent)\n  if (!service) throw new Error('Unable to find a service')\n\n  // Intents cannot be deleted now\n  // await deleteIntent(cozy, intent)\n\n  const baseURL = removeQueryString(service.href)\n  return data ? buildRedirectionURL(baseURL, data) : baseURL\n}\n\nfunction isSerializable(value) {\n  return !['object', 'function'].includes(typeof value)\n}\n\nfunction buildRedirectionURL(url, data) {\n  const parameterStrings = Object.keys(data)\n    .filter(key => isSerializable(data[key]))\n    .map(key => `${key}=${data[key]}`)\n\n  return parameterStrings.length ? `${url}?${parameterStrings.join('&')}` : url\n}\n\nexport async function redirect(cozy, type, doc, redirectFn) {\n  if (!window)\n    throw new Error('redirect() method can only be called in a browser')\n  const redirectionURL = await getRedirectionURL(cozy, type, doc)\n  if (redirectFn && typeof redirectFn === 'function') {\n    return redirectFn(redirectionURL)\n  }\n\n  window.location.href = redirectionURL\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/intents/index.js","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/immediate/lib/browser.js\n// module id = 16\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function eventListener() {\n      if (errorListener !== undefined) {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n    var errorListener;\n\n    // Adding an error listener is not optional because\n    // if an error is thrown on an event emitter we cannot\n    // guarantee that the actual event we are waiting will\n    // be fired. The result could be a silent way to create\n    // memory or file descriptor leaks, which is something\n    // we should avoid.\n    if (name !== 'error') {\n      errorListener = function errorListener(err) {\n        emitter.removeListener(name, eventListener);\n        reject(err);\n      };\n\n      emitter.once('error', errorListener);\n    }\n\n    emitter.once(name, eventListener);\n  });\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/events/events.js\n// module id = 17\n// module chunks = 0","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/spark-md5/spark-md5.js\n// module id = 18\n// module chunks = 0","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/uuid/index.js\n// module id = 19\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/uuid/lib/rng-browser.js\n// module id = 20\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/uuid/lib/bytesToUuid.js\n// module id = 21\n// module chunks = 0","var thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\nfunction typedBuffer() {\n}\n\nexport { thisAtob as atob, thisBtoa as btoa, b64ToBluffer as base64StringToBlobOrBuffer, binaryStringToArrayBuffer, binStringToBluffer as binaryStringToBlobOrBuffer, createBlob as blob, blobToBase64 as blobOrBufferToBase64, blobToBinaryString as blobOrBufferToBinaryString, readAsArrayBuffer, readAsBinaryString, typedBuffer };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-binary-utils/lib/index-browser.es.js\n// module id = 22\n// module chunks = 0","// AbortController was introduced quite a while after fetch and\n// isnt required for PouchDB to function so polyfill if needed\nvar a = (typeof AbortController !== 'undefined')\n    ? AbortController\n    : function () { return {abort: function () {}}; };\n\nvar f = fetch;\nvar h = Headers;\n\nexport { f as fetch, h as Headers, a as AbortController };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-fetch/lib/index-browser.es.js\n// module id = 23\n// module chunks = 0","/* global fetch URL */\nimport { unpromiser, retry, warn } from './utils'\nimport { LocalStorage, MemoryStorage } from './auth_storage'\nimport { AppToken as AppTokenV2, getAppToken as getAppTokenV2 } from './auth_v2'\nimport * as auth from './auth_v3'\nimport * as data from './data'\nimport * as cozyFetch from './fetch'\nimport * as mango from './mango'\nimport * as files from './files'\nimport * as intents from './intents/'\nimport * as jobs from './jobs'\nimport * as offline from './offline'\nimport * as settings from './settings'\nimport * as relations from './relations'\n\nconst {\n  AppToken: AppTokenV3,\n  AccessToken: AccessTokenV3,\n  Client: ClientV3\n} = auth\n\nconst AuthNone = 0\nconst AuthRunning = 1\nconst AuthError = 2\nconst AuthOK = 3\n\nconst defaultClientParams = {\n  softwareID: 'github.com/cozy/cozy-client-js'\n}\n\nconst dataProto = {\n  create: data.create,\n  find: data.find,\n  findMany: data.findMany,\n  findAll: data.findAll,\n  update: data.update,\n  delete: data._delete,\n  updateAttributes: data.updateAttributes,\n  changesFeed: data.changesFeed,\n  defineIndex: mango.defineIndex,\n  query: mango.query,\n  addReferencedFiles: relations.addReferencedFiles,\n  removeReferencedFiles: relations.removeReferencedFiles,\n  listReferencedFiles: relations.listReferencedFiles,\n  fetchReferencedFiles: relations.fetchReferencedFiles,\n  destroy: function(...args) {\n    warn('destroy is deprecated, use cozy.data.delete instead.')\n    return data._delete(...args)\n  }\n}\n\nconst authProto = {\n  client: auth.client,\n  registerClient: auth.registerClient,\n  updateClient: auth.updateClient,\n  unregisterClient: auth.unregisterClient,\n  getClient: auth.getClient,\n  getAuthCodeURL: auth.getAuthCodeURL,\n  getAccessToken: auth.getAccessToken,\n  refreshToken: auth.refreshToken\n}\n\nconst filesProto = {\n  create: files.create,\n  createDirectory: files.createDirectory,\n  createDirectoryByPath: files.createDirectoryByPath,\n  updateById: files.updateById,\n  updateAttributesById: files.updateAttributesById,\n  updateAttributesByPath: files.updateAttributesByPath,\n  trashById: files.trashById,\n  statById: files.statById,\n  statByPath: files.statByPath,\n  downloadById: files.downloadById,\n  downloadByPath: files.downloadByPath,\n  getDownloadLinkById: files.getDownloadLinkById,\n  getDownloadLink: files.getDownloadLinkByPath, // DEPRECATED, should be removed very soon\n  getDownloadLinkByPath: files.getDownloadLinkByPath,\n  getArchiveLink: function(...args) {\n    warn(\n      'getArchiveLink is deprecated, use cozy.files.getArchiveLinkByPaths instead.'\n    )\n    return files.getArchiveLinkByPaths(...args)\n  },\n  getArchiveLinkByPaths: files.getArchiveLinkByPaths,\n  getArchiveLinkByIds: files.getArchiveLinkByIds,\n  getFilePath: files.getFilePath,\n  getCollectionShareLink: files.getCollectionShareLink,\n  query: mango.queryFiles,\n  listTrash: files.listTrash,\n  clearTrash: files.clearTrash,\n  restoreById: files.restoreById,\n  destroyById: files.destroyById\n}\n\nconst intentsProto = {\n  create: intents.create,\n  createService: intents.createService,\n  getRedirectionURL: intents.getRedirectionURL,\n  redirect: intents.redirect\n}\n\nconst jobsProto = {\n  create: jobs.create,\n  count: jobs.count,\n  queued: jobs.queued\n}\n\nconst offlineProto = {\n  init: offline.init,\n  getDoctypes: offline.getDoctypes,\n  // database\n  hasDatabase: offline.hasDatabase,\n  getDatabase: offline.getDatabase,\n  createDatabase: offline.createDatabase,\n  migrateDatabase: offline.migrateDatabase,\n  destroyDatabase: offline.destroyDatabase,\n  destroyAllDatabase: offline.destroyAllDatabase,\n  // replication\n  hasReplication: offline.hasReplication,\n  replicateFromCozy: offline.replicateFromCozy,\n  stopReplication: offline.stopReplication,\n  stopAllReplication: offline.stopAllReplication,\n  // repeated replication\n  hasRepeatedReplication: offline.hasRepeatedReplication,\n  startRepeatedReplication: offline.startRepeatedReplication,\n  stopRepeatedReplication: offline.stopRepeatedReplication,\n  stopAllRepeatedReplication: offline.stopAllRepeatedReplication\n}\n\nconst settingsProto = {\n  diskUsage: settings.diskUsage,\n  changePassphrase: settings.changePassphrase,\n  getInstance: settings.getInstance,\n  updateInstance: settings.updateInstance,\n  getClients: settings.getClients,\n  deleteClientById: settings.deleteClientById,\n  updateLastSync: settings.updateLastSync\n}\n\nconst ensureHasReconnectParam = _url => {\n  const url = new URL(_url)\n  if (url.searchParams && !url.searchParams.has('reconnect')) {\n    url.searchParams.append('reconnect', 1)\n  } else if (!url.search || url.search.indexOf('reconnect') === -1) {\n    // Some old navigators do not have the searchParams API\n    // and it is not polyfilled by babel-polyfill\n    url.search = url.search + '&reconnect=1'\n  }\n  return url.toString()\n}\n\nclass Client {\n  constructor(options) {\n    this.data = {}\n    this.files = {}\n    this.intents = {}\n    this.jobs = {}\n    this.offline = {}\n    this.settings = {}\n    this.auth = {\n      Client: ClientV3,\n      AccessToken: AccessTokenV3,\n      AppToken: AppTokenV3,\n      AppTokenV2: AppTokenV2,\n      LocalStorage: LocalStorage,\n      MemoryStorage: MemoryStorage\n    }\n    this._inited = false\n    if (options) {\n      this.init(options)\n    }\n  }\n\n  init(options = {}) {\n    this._inited = true\n    this._oauth = false // is oauth activated or not\n    this._token = null // application token\n    this._authstate = AuthNone\n    this._authcreds = null\n    this._storage = null\n    this._version = options.version || null\n    this._offline = null\n\n    const token = options.token\n    const oauth = options.oauth\n    if (token && oauth) {\n      throw new Error(\n        'Cannot specify an application token with a oauth activated'\n      )\n    }\n\n    if (token) {\n      this._token = new AppTokenV3({ token })\n    } else if (oauth) {\n      this._oauth = true\n      this._storage = oauth.storage\n      this._clientParams = Object.assign(\n        {},\n        defaultClientParams,\n        oauth.clientParams\n      )\n      this._onRegistered = oauth.onRegistered || nopOnRegistered\n    }\n\n    let url = options.cozyURL || ''\n    while (url[url.length - 1] === '/') {\n      url = url.slice(0, -1)\n    }\n\n    this._url = url\n\n    this._invalidTokenErrorHandler =\n      options.onInvalidTokenError !== undefined\n        ? options.onInvalidTokenError\n        : cozyFetch.handleInvalidTokenError\n\n    const disablePromises = !!options.disablePromises\n    addToProto(this, this.data, dataProto, disablePromises)\n    addToProto(this, this.auth, authProto, disablePromises)\n    addToProto(this, this.files, filesProto, disablePromises)\n    addToProto(this, this.intents, intentsProto, disablePromises)\n    addToProto(this, this.jobs, jobsProto, disablePromises)\n    addToProto(this, this.offline, offlineProto, disablePromises)\n    addToProto(this, this.settings, settingsProto, disablePromises)\n\n    if (options.offline) {\n      this.offline.init(options.offline)\n    }\n\n    this.fetch = function _fetch(method, url, options = {}) {\n      return cozyFetch.cozyFetch(this, url, { ...options, method })\n    }\n\n    this.fetchJSON = function _fetchJSON() {\n      const args = [this].concat(Array.prototype.slice.call(arguments))\n      return cozyFetch.cozyFetchJSON.apply(this, args)\n    }\n  }\n\n  authorize(forceTokenRefresh = false) {\n    const state = this._authstate\n    if (state === AuthOK || state === AuthRunning) {\n      return this._authcreds\n    }\n\n    this._authstate = AuthRunning\n    this._authcreds = this.isV2().then(isV2 => {\n      if (isV2 && this._oauth) {\n        throw new Error('OAuth is not supported on the V2 stack')\n      }\n      if (this._oauth) {\n        if (forceTokenRefresh && this._clientParams.redirectURI) {\n          this._clientParams.redirectURI = ensureHasReconnectParam(\n            this._clientParams.redirectURI\n          )\n        }\n        return auth.oauthFlow(\n          this,\n          this._storage,\n          this._clientParams,\n          this._onRegistered,\n          forceTokenRefresh\n        )\n      }\n      // we expect to be on a client side application running in a browser\n      // with cookie-based authentication.\n      if (isV2) {\n        return getAppTokenV2()\n      } else if (this._token) {\n        return Promise.resolve({ client: null, token: this._token })\n      } else {\n        throw new Error('Missing application token')\n      }\n    })\n\n    this._authcreds.then(\n      () => {\n        this._authstate = AuthOK\n      },\n      () => {\n        this._authstate = AuthError\n      }\n    )\n\n    return this._authcreds\n  }\n\n  saveCredentials(client, token) {\n    const creds = { client, token }\n    if (!this._storage || this._authstate === AuthRunning) {\n      return Promise.resolve(creds)\n    }\n    this._storage.save(auth.CredsKey, creds)\n    this._authcreds = Promise.resolve(creds)\n    return this._authcreds\n  }\n\n  fullpath(path) {\n    return this.isV2().then(isV2 => {\n      const pathprefix = isV2 ? '/ds-api' : ''\n      return this._url + pathprefix + path\n    })\n  }\n\n  isV2() {\n    if (!this._version) {\n      return retry(() => fetch(`${this._url}/status/`), 3)()\n        .then(res => {\n          if (!res.ok) {\n            throw new Error('Could not fetch cozy status')\n          } else {\n            return res.json()\n          }\n        })\n        .then(status => {\n          this._version = status.datasystem !== undefined ? 2 : 3\n          return this.isV2()\n        })\n    }\n    return Promise.resolve(this._version === 2)\n  }\n}\n\nfunction nopOnRegistered() {\n  throw new Error('Missing onRegistered callback')\n}\n\nfunction protoify(context, fn) {\n  return function prototyped(...args) {\n    return fn(context, ...args)\n  }\n}\n\nfunction addToProto(ctx, obj, proto, disablePromises) {\n  for (const attr in proto) {\n    let fn = protoify(ctx, proto[attr])\n    if (disablePromises) {\n      fn = unpromiser(fn)\n    }\n    obj[attr] = fn\n  }\n}\n\nmodule.exports = new Client()\nObject.assign(module.exports, { Client, LocalStorage, MemoryStorage })\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","export class LocalStorage {\n  constructor(storage, prefix) {\n    if (!storage && typeof window !== 'undefined') {\n      storage = window.localStorage\n    }\n    this.storage = storage\n    this.prefix = prefix || 'cozy:oauth:'\n  }\n\n  save(key, value) {\n    return new Promise(resolve => {\n      this.storage.setItem(this.prefix + key, JSON.stringify(value))\n      resolve(value)\n    })\n  }\n\n  load(key) {\n    return new Promise(resolve => {\n      const item = this.storage.getItem(this.prefix + key)\n      if (!item) {\n        resolve()\n      } else {\n        resolve(JSON.parse(item))\n      }\n    })\n  }\n\n  delete(key) {\n    return new Promise(resolve =>\n      resolve(this.storage.removeItem(this.prefix + key))\n    )\n  }\n\n  clear() {\n    return new Promise(resolve => {\n      const storage = this.storage\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i)\n        if (key.indexOf(this.prefix) === 0) {\n          storage.removeItem(key)\n        }\n      }\n      resolve()\n    })\n  }\n}\n\nexport class MemoryStorage {\n  constructor() {\n    this.hash = Object.create(null)\n  }\n\n  save(key, value) {\n    this.hash[key] = value\n    return Promise.resolve(value)\n  }\n\n  load(key) {\n    return Promise.resolve(this.hash[key])\n  }\n\n  delete(key) {\n    const deleted = delete this.hash[key]\n    return Promise.resolve(deleted)\n  }\n\n  clear() {\n    this.hash = Object.create(null)\n    return Promise.resolve()\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/auth_storage.js","/* global btoa */\nconst V2TOKEN_ABORT_TIMEOUT = 3000\n\nexport function getAppToken() {\n  return new Promise(function(resolve, reject) {\n    if (typeof window === 'undefined') {\n      return reject(new Error('getV2Token should be used in browser'))\n    } else if (!window.parent) {\n      return reject(new Error('getV2Token should be used in iframe'))\n    } else if (!window.parent.postMessage) {\n      return reject(new Error('getV2Token should be used in modern browser'))\n    }\n    const origin = window.location.origin\n    const intent = { action: 'getToken' }\n    let timeout = null\n    const receiver = function(event) {\n      let token\n      try {\n        token = new AppToken({\n          appName: event.data.appName,\n          token: event.data.token\n        })\n      } catch (e) {\n        reject(e)\n        return\n      }\n      window.removeEventListener('message', receiver)\n      clearTimeout(timeout)\n      resolve({ client: null, token })\n    }\n    window.addEventListener('message', receiver, false)\n    window.parent.postMessage(intent, origin)\n    timeout = setTimeout(() => {\n      reject(new Error('No response from parent iframe after 3s'))\n    }, V2TOKEN_ABORT_TIMEOUT)\n  })\n}\n\nexport class AppToken {\n  constructor(opts) {\n    this.appName = opts.appName || ''\n    this.token = opts.token || ''\n  }\n\n  toAuthHeader() {\n    return 'Basic ' + btoa(`${this.appName}:${this.token}`)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/auth_v2.js","import { createPath } from './utils'\nimport { normalizeDoctype } from './doctypes'\nimport { cozyFetchJSON } from './fetch'\n\nconst NOREV = 'stack-v2-no-rev'\n\nexport function create(cozy, doctype, attributes) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    if (isV2) {\n      attributes.docType = doctype\n    }\n    const path = createPath(cozy, isV2, doctype, attributes._id)\n    const httpVerb = attributes._id ? 'PUT' : 'POST'\n    delete attributes._id\n    return cozyFetchJSON(cozy, httpVerb, path, attributes).then(resp => {\n      if (isV2) {\n        return find(cozy, doctype, resp._id)\n      } else {\n        return resp.data\n      }\n    })\n  })\n}\n\nexport function find(cozy, doctype, id) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n\n    if (!id) {\n      return Promise.reject(new Error('Missing id parameter'))\n    }\n\n    const path = createPath(cozy, isV2, doctype, id)\n    return cozyFetchJSON(cozy, 'GET', path).then(resp => {\n      if (isV2) {\n        return Object.assign(resp, { _rev: NOREV })\n      } else {\n        return resp\n      }\n    })\n  })\n}\n\nexport function findMany(cozy, doctype, ids) {\n  if (!(ids instanceof Array)) {\n    return Promise.reject(new Error('Parameter ids must be a non-empty array'))\n  }\n  if (ids.length === 0) {\n    // So users don't need to be defensive regarding the array content.\n    // This should not hide issues in user code since the result will be an\n    // empty object anyway.\n    return Promise.resolve({})\n  }\n\n  return cozy.isV2().then(isV2 => {\n    if (isV2) {\n      return Promise.reject(new Error('findMany is not available on v2'))\n    }\n\n    const path = createPath(cozy, isV2, doctype, '_all_docs', {\n      include_docs: true\n    })\n\n    return cozyFetchJSON(cozy, 'POST', path, { keys: ids })\n      .then(resp => {\n        const docs = {}\n\n        for (const row of resp.rows) {\n          const { key, doc, error } = row\n          docs[key] = error ? { error } : { doc }\n        }\n\n        return docs\n      })\n      .catch(error => {\n        if (error.status !== 404) return Promise.reject(error)\n\n        // When no doc was ever created and the database does not exist yet,\n        // the response will be a 404 error.\n        const docs = {}\n\n        for (const id of ids) {\n          docs[id] = { error }\n        }\n\n        return docs\n      })\n  })\n}\n\nexport function findAll(cozy, doctype, options = { include_docs: true }) {\n  return cozy.isV2().then(isV2 => {\n    if (isV2) {\n      return Promise.reject(new Error('findAll is not available on v2'))\n    }\n\n    const path = createPath(cozy, isV2, doctype, '_all_docs', options)\n\n    return cozyFetchJSON(cozy, 'POST', path, {})\n      .then(resp => {\n        const docs = []\n\n        for (const row of resp.rows) {\n          const { doc } = row\n          // if not couchDB indexes\n          if (!doc._id.match(/_design\\//)) docs.push(doc)\n        }\n        return docs\n      })\n      .catch(error => {\n        // the _all_docs endpoint returns a 404 error if no document with the given\n        // doctype exists.\n        if (error.status === 404) return []\n        throw error\n      })\n  })\n}\n\nexport function changesFeed(cozy, doctype, options) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    const path = createPath(cozy, isV2, doctype, '_changes', options)\n    return cozyFetchJSON(cozy, 'GET', path)\n  })\n}\n\nexport function update(cozy, doctype, doc, changes) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    const { _id, _rev } = doc\n\n    if (!_id) {\n      return Promise.reject(new Error('Missing _id field in passed document'))\n    }\n\n    if (!isV2 && !_rev) {\n      return Promise.reject(new Error('Missing _rev field in passed document'))\n    }\n\n    if (isV2) {\n      changes = Object.assign({ _id }, changes)\n    } else {\n      changes = Object.assign({ _id, _rev }, changes)\n    }\n\n    const path = createPath(cozy, isV2, doctype, _id)\n    return cozyFetchJSON(cozy, 'PUT', path, changes).then(resp => {\n      if (isV2) {\n        return find(cozy, doctype, _id)\n      } else {\n        return resp.data\n      }\n    })\n  })\n}\n\nexport function updateAttributes(cozy, doctype, _id, changes, tries = 3) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    return find(cozy, doctype, _id)\n      .then(doc => {\n        return update(cozy, doctype, doc, Object.assign({ _id }, doc, changes))\n      })\n      .catch(err => {\n        if (tries > 0) {\n          return updateAttributes(cozy, doctype, _id, changes, tries - 1)\n        } else {\n          throw err\n        }\n      })\n  })\n}\n\nexport function _delete(cozy, doctype, doc) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    const { _id, _rev } = doc\n\n    if (!_id) {\n      return Promise.reject(new Error('Missing _id field in passed document'))\n    }\n\n    if (!isV2 && !_rev) {\n      return Promise.reject(new Error('Missing _rev field in passed document'))\n    }\n\n    const query = isV2 ? null : { rev: _rev }\n    const path = createPath(cozy, isV2, doctype, _id, query)\n    return cozyFetchJSON(cozy, 'DELETE', path).then(resp => {\n      if (isV2) {\n        return { id: _id, rev: NOREV }\n      } else {\n        return resp\n      }\n    })\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/data.js","import { warn, createPath, sleep } from './utils'\nimport { normalizeDoctype } from './doctypes'\nimport { cozyFetchJSON, cozyFetchRawJSON } from './fetch'\n\nexport function defineIndex(cozy, doctype, fields) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    if (!Array.isArray(fields) || fields.length === 0) {\n      throw new Error('defineIndex fields should be a non-empty array')\n    }\n    if (isV2) {\n      return defineIndexV2(cozy, doctype, fields)\n    } else {\n      return defineIndexV3(cozy, doctype, fields)\n    }\n  })\n}\n\nexport function query(cozy, indexRef, options) {\n  return cozy.isV2().then(isV2 => {\n    if (!indexRef) {\n      throw new Error('query should be passed the indexRef')\n    }\n    if (isV2) {\n      return queryV2(cozy, indexRef, options)\n    } else {\n      return queryV3(cozy, indexRef, options)\n    }\n  })\n}\n\nexport function queryFiles(cozy, indexRef, options) {\n  const opts = getV3Options(indexRef, options)\n  return cozyFetchRawJSON(cozy, 'POST', '/files/_find', opts).then(\n    response => (options.wholeResponse ? response : response.docs)\n  )\n}\n\n// Internals\n\nconst VALUEOPERATORS = ['$eq', '$gt', '$gte', '$lt', '$lte']\nconst LOGICOPERATORS = ['$or', '$and', '$not']\n\n/* eslint-disable */\nconst MAP_TEMPLATE = function(doc) {\n  if (doc.docType.toLowerCase() === 'DOCTYPEPLACEHOLDER') {\n    emit(FIELDSPLACEHOLDER, doc)\n  }\n}\n  .toString()\n  .replace(/ /g, '')\n  .replace(/\\n/g, '')\nconst COUCHDB_INFINITY = { '\\uFFFF': '\\uFFFF' }\nconst COUCHDB_LOWEST = null\n/* eslint-enable */\n\n// defineIndexV2 is equivalent to defineIndex but only works for V2.\n// It transforms the index fields into a map reduce view.\nfunction defineIndexV2(cozy, doctype, fields) {\n  let indexName = 'by' + fields.map(capitalize).join('')\n  let indexDefinition = {\n    map: makeMapFunction(doctype, fields),\n    reduce: '_count'\n  }\n  let path = `/request/${doctype}/${indexName}/`\n  return cozyFetchJSON(cozy, 'PUT', path, indexDefinition).then(() => ({\n    doctype: doctype,\n    type: 'mapreduce',\n    name: indexName,\n    fields: fields\n  }))\n}\n\nfunction defineIndexV3(cozy, doctype, fields) {\n  let path = createPath(cozy, false, doctype, '_index')\n  let indexDefinition = { index: { fields } }\n  return cozyFetchJSON(cozy, 'POST', path, indexDefinition).then(response => {\n    const indexResult = {\n      doctype: doctype,\n      type: 'mango',\n      name: response.id,\n      fields\n    }\n\n    if (response.result === 'exists') return indexResult\n\n    // indexes might not be usable right after being created; so we delay the resolving until they are\n    const selector = {}\n    selector[fields[0]] = { $gt: null }\n\n    const opts = getV3Options(indexResult, { selector: selector })\n    let path = createPath(cozy, false, indexResult.doctype, '_find')\n    return cozyFetchJSON(cozy, 'POST', path, opts)\n      .then(() => indexResult)\n      .catch(() => {\n        // one retry\n        return sleep(1000)\n          .then(() => cozyFetchJSON(cozy, 'POST', path, opts))\n          .then(() => indexResult)\n          .catch(() => {\n            return sleep(500).then(() => indexResult)\n          })\n      })\n  })\n}\n\n// queryV2 is equivalent to query but only works for V2.\n// It transforms the query into a _views call using makeMapReduceQuery\nfunction queryV2(cozy, indexRef, options) {\n  if (indexRef.type !== 'mapreduce') {\n    throw new Error(\n      'query indexRef should be the return value of defineIndexV2'\n    )\n  }\n  if (options.fields) {\n    warn('query fields will be ignored on v2')\n  }\n\n  let path = `/request/${indexRef.doctype}/${indexRef.name}/`\n  let opts = makeMapReduceQuery(indexRef, options)\n  return cozyFetchJSON(cozy, 'POST', path, opts).then(response =>\n    response.map(r => r.value)\n  )\n}\n\n// queryV3 is equivalent to query but only works for V3\nfunction queryV3(cozy, indexRef, options) {\n  const opts = getV3Options(indexRef, options)\n\n  let path = createPath(cozy, false, indexRef.doctype, '_find')\n  return cozyFetchJSON(cozy, 'POST', path, opts).then(\n    response => (options.wholeResponse ? response : response.docs)\n  )\n}\n\nfunction getV3Options(indexRef, options) {\n  if (indexRef.type !== 'mango') {\n    throw new Error('indexRef should be the return value of defineIndexV3')\n  }\n\n  let opts = {\n    use_index: indexRef.name,\n    fields: options.fields,\n    selector: options.selector,\n    limit: options.limit,\n    skip: options.skip,\n    since: options.since,\n    sort: options.sort\n  }\n\n  if (options.descending) {\n    opts.sort = indexRef.fields.map(f => ({ [f]: 'desc' }))\n  }\n\n  return opts\n}\n\n// misc\nfunction capitalize(name) {\n  return name.charAt(0).toUpperCase() + name.slice(1)\n}\n\nfunction makeMapFunction(doctype, fields) {\n  fields = '[' + fields.map(name => 'doc.' + name).join(',') + ']'\n\n  return MAP_TEMPLATE.replace(\n    'DOCTYPEPLACEHOLDER',\n    doctype.toLowerCase()\n  ).replace('FIELDSPLACEHOLDER', fields)\n}\n\n// parseSelector takes a mango selector and returns it as an array of filter\n// a filter is [path, operator, value] array\n// a path is an array of field names\n// This function is only exported so it can be unit tested.\n// Example :\n// parseSelector({\"test\":{\"deep\": {\"$gt\": 3}}})\n// [[['test', 'deep'], '$gt', 3 ]]\nexport function parseSelector(selector, path = [], operator = '$eq') {\n  if (typeof selector !== 'object') {\n    return [[path, operator, selector]]\n  }\n\n  let keys = Object.keys(selector)\n  if (keys.length === 0) {\n    throw new Error('empty selector')\n  } else {\n    return keys.reduce(function(acc, k) {\n      if (LOGICOPERATORS.indexOf(k) !== -1) {\n        throw new Error('cozy-client-js does not support mango logic ops')\n      } else if (VALUEOPERATORS.indexOf(k) !== -1) {\n        return acc.concat(parseSelector(selector[k], path, k))\n      } else {\n        return acc.concat(parseSelector(selector[k], path.concat(k), '$eq'))\n      }\n    }, [])\n  }\n}\n\n// normalizeSelector takes a mango selector and returns it as an object\n// normalized.\n// This function is only exported so it can be unit tested.\n// Example :\n// parseSelector({\"test\":{\"deep\": {\"$gt\": 3}}})\n// {\"test.deep\": {\"$gt\": 3}}\nexport function normalizeSelector(selector) {\n  var filters = parseSelector(selector)\n  return filters.reduce(function(acc, filter) {\n    let [path, op, value] = filter\n    let field = path.join('.')\n    acc[field] = acc[field] || {}\n    acc[field][op] = value\n    return acc\n  }, {})\n}\n\n// applySelector takes the normalized selector for the current field\n// and append the proper values to opts.startkey, opts.endkey\nfunction applySelector(selector, opts) {\n  let value = selector['$eq']\n  let lower = COUCHDB_LOWEST\n  let upper = COUCHDB_INFINITY\n  let inclusiveEnd\n\n  if (value) {\n    opts.startkey.push(value)\n    opts.endkey.push(value)\n    return false\n  }\n\n  value = selector['$gt']\n  if (value) {\n    throw new Error('operator $gt (strict greater than) not supported')\n  }\n\n  value = selector['$gte']\n  if (value) {\n    lower = value\n  }\n\n  value = selector['$lte']\n  if (value) {\n    upper = value\n    inclusiveEnd = true\n  }\n\n  value = selector['$lt']\n  if (value) {\n    upper = value\n    inclusiveEnd = false\n  }\n\n  opts.startkey.push(lower)\n  opts.endkey.push(upper)\n  if (inclusiveEnd !== undefined) opts.inclusive_end = inclusiveEnd\n  return true\n}\n\n// makeMapReduceQuery takes a mango query and generate _views call parameters\n// to obtain same results depending on fields in the passed indexRef.\nexport function makeMapReduceQuery(indexRef, query) {\n  let mrquery = {\n    startkey: [],\n    endkey: [],\n    reduce: false\n  }\n  let firstFreeValueField = null\n  let normalizedSelector = normalizeSelector(query.selector)\n\n  indexRef.fields.forEach(function(field) {\n    let selector = normalizedSelector[field]\n\n    if (selector && firstFreeValueField != null) {\n      throw new Error(\n        'Selector on field ' +\n          field +\n          ', but not on ' +\n          firstFreeValueField +\n          ' which is higher in index fields.'\n      )\n    } else if (selector) {\n      selector.used = true\n      let isFreeValue = applySelector(selector, mrquery)\n      if (isFreeValue) firstFreeValueField = field\n    } else if (firstFreeValueField == null) {\n      firstFreeValueField = field\n      mrquery.endkey.push(COUCHDB_INFINITY)\n    }\n  })\n\n  Object.keys(normalizedSelector).forEach(function(field) {\n    if (!normalizedSelector[field].used) {\n      throw new Error(\n        'Cant apply selector on ' + field + ', it is not in index'\n      )\n    }\n  })\n\n  if (query.descending) {\n    mrquery = {\n      descending: true,\n      reduce: false,\n      startkey: mrquery.endkey,\n      endkey: mrquery.startkey,\n      inclusive_end: mrquery.inclusive_end\n    }\n  }\n\n  return mrquery\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/mango.js","/* global Blob, File */\nimport { cozyFetch, cozyFetchJSON } from './fetch'\nimport jsonapi from './jsonapi'\nimport { DOCTYPE_FILES } from './doctypes'\n\n// global variables\nexport const ROOT_DIR_ID = 'io.cozy.files.root-dir'\nexport const TRASH_DIR_ID = 'io.cozy.files.trash-dir'\n\nconst contentTypeOctetStream = 'application/octet-stream'\n\nfunction sanitizeFileName(name) {\n  return name && name.trim()\n}\n\nfunction getFileTypeFromName(name) {\n  if (/\\.heic$/i.test(name)) return 'image/heic'\n  else if (/\\.heif$/i.test(name)) return 'image/heif'\n  else return null\n}\n\nfunction dateString(date) {\n  return typeof date === 'object' ? date.toISOString() : date\n}\n\nasync function doUpload(cozy, data, method, path, options) {\n  if (!data) {\n    throw new Error('missing data argument')\n  }\n\n  // transform any ArrayBufferView to ArrayBuffer\n  if (data.buffer && data.buffer instanceof ArrayBuffer) {\n    data = data.buffer\n  }\n\n  const isBuffer =\n    typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer\n  const isFile = typeof File !== 'undefined' && data instanceof File\n  const isBlob = typeof Blob !== 'undefined' && data instanceof Blob\n  const isStream = data.readable === true && typeof data.pipe === 'function'\n  const isString = typeof data === 'string'\n\n  if (!isBuffer && !isFile && !isBlob && !isStream && !isString) {\n    throw new Error('invalid data type')\n  }\n\n  let {\n    contentType,\n    contentLength,\n    checksum,\n    createdAt,\n    updatedAt,\n    executable,\n    lastModifiedDate,\n    ifMatch,\n    metadata,\n    sourceAccount,\n    sourceAccountIdentifier,\n    signal // AbortController signal\n  } = options || {}\n  if (!contentType) {\n    if (isBuffer) {\n      contentType = contentTypeOctetStream\n    } else if (isFile) {\n      contentType =\n        data.type ||\n        getFileTypeFromName(data.name.toLowerCase()) ||\n        contentTypeOctetStream\n      if (!lastModifiedDate) {\n        lastModifiedDate = data.lastModifiedDate\n      }\n    } else if (isBlob) {\n      contentType = data.type || contentTypeOctetStream\n    } else if (isStream) {\n      contentType = contentTypeOctetStream\n    } else if (typeof data === 'string') {\n      contentType = 'text/plain'\n    }\n  }\n\n  if (lastModifiedDate && typeof lastModifiedDate === 'string') {\n    lastModifiedDate = new Date(lastModifiedDate)\n  }\n  if (!createdAt) {\n    createdAt = lastModifiedDate\n  }\n  if (!updatedAt) {\n    updatedAt = lastModifiedDate\n  }\n\n  if (!executable) {\n    executable = false\n  }\n\n  let finalpath = path\n  if (metadata) {\n    const metadataId = await sendMetadata(cozy, metadata)\n    if (metadataId) {\n      finalpath = addQuerystringParam(finalpath, 'MetadataID', metadataId)\n    }\n  }\n  if (sourceAccount) {\n    finalpath = addQuerystringParam(finalpath, 'SourceAccount', sourceAccount)\n  }\n  if (sourceAccountIdentifier) {\n    finalpath = addQuerystringParam(\n      finalpath,\n      'SourceAccountIdentifier',\n      sourceAccountIdentifier\n    )\n  }\n  if (createdAt) {\n    finalpath = addQuerystringParam(\n      finalpath,\n      'CreatedAt',\n      dateString(createdAt)\n    )\n  }\n  if (updatedAt) {\n    finalpath = addQuerystringParam(\n      finalpath,\n      'UpdatedAt',\n      dateString(updatedAt)\n    )\n  }\n  if (executable) {\n    finalpath = addQuerystringParam(finalpath, 'Executable', executable)\n  }\n\n  const headers = {\n    'Content-Type': contentType\n  }\n  if (contentLength) {\n    headers['Content-Length'] = String(contentLength)\n    finalpath = addQuerystringParam(finalpath, 'Size', String(contentLength))\n  }\n  if (checksum) headers['Content-MD5'] = checksum\n  if (lastModifiedDate) headers['Date'] = lastModifiedDate.toGMTString()\n  if (ifMatch) headers['If-Match'] = ifMatch\n\n  return cozyFetch(cozy, finalpath, {\n    method: method,\n    headers: headers,\n    body: data,\n    signal\n  }).then(res => {\n    const json = res.json()\n    if (!res.ok) {\n      return json.then(err => {\n        throw err\n      })\n    } else {\n      return json.then(jsonapi)\n    }\n  })\n}\n\nasync function sendMetadata(cozy, metadata) {\n  const result = await cozyFetchJSON(cozy, 'POST', '/files/upload/metadata', {\n    data: { type: 'io.cozy.files.metadata', attributes: metadata }\n  })\n  return result && result._id ? result._id : false\n}\n\nexport function create(cozy, data, options) {\n  let { name, dirID, noSanitize } = options || {}\n\n  // handle case where data is a file and contains the name\n  if (!name && typeof data.name === 'string') {\n    name = data.name\n  }\n\n  if (!noSanitize) {\n    name = sanitizeFileName(name)\n  }\n\n  if (typeof name !== 'string' || name === '') {\n    throw new Error('missing name argument')\n  }\n\n  const path = `/files/${encodeURIComponent(dirID || '')}`\n  const query = `?Name=${encodeURIComponent(name)}&Type=file`\n  return doUpload(cozy, data, 'POST', `${path}${query}`, options)\n}\n\nexport function createDirectory(cozy, options) {\n  let { name, dirID, createdAt, updatedAt, lastModifiedDate, noSanitize } =\n    options || {}\n\n  if (!noSanitize) {\n    name = sanitizeFileName(name)\n  }\n\n  if (typeof name !== 'string' || name === '') {\n    throw new Error('missing name argument')\n  }\n\n  if (lastModifiedDate && typeof lastModifiedDate === 'string') {\n    lastModifiedDate = new Date(lastModifiedDate)\n  }\n  if (!createdAt) {\n    createdAt = lastModifiedDate\n  }\n  if (!updatedAt) {\n    updatedAt = lastModifiedDate\n  }\n\n  const path = `/files/${encodeURIComponent(dirID || '')}`\n  const query = `?Name=${encodeURIComponent(name)}&Type=directory`\n\n  let finalpath = `${path}${query}`\n  if (createdAt) {\n    finalpath = addQuerystringParam(\n      finalpath,\n      'CreatedAt',\n      dateString(createdAt)\n    )\n  }\n  if (updatedAt) {\n    finalpath = addQuerystringParam(\n      finalpath,\n      'UpdatedAt',\n      dateString(updatedAt)\n    )\n  }\n\n  const headers = {}\n  if (lastModifiedDate) headers['Date'] = lastModifiedDate.toGMTString()\n\n  return cozyFetchJSON(cozy, 'POST', finalpath, undefined, {\n    headers\n  })\n}\n\nfunction getDirectoryOrCreate(cozy, name, parentDirectory, options) {\n  if (parentDirectory && !parentDirectory.attributes)\n    throw new Error('Malformed parent directory')\n\n  const { noSanitize } = options || {}\n\n  if (!noSanitize) {\n    name = sanitizeFileName(name)\n  }\n\n  const path = `${\n    parentDirectory._id === ROOT_DIR_ID ? '' : parentDirectory.attributes.path\n  }/${name}`\n\n  return cozy.files.statByPath(path || '/').catch(error => {\n    const parsedError = JSON.parse(error.message)\n    const errors = parsedError.errors\n    if (errors && errors.length && errors[0].status === '404') {\n      return cozy.files.createDirectory({\n        name: name,\n        dirID: parentDirectory && parentDirectory._id\n      })\n    }\n\n    throw errors\n  })\n}\n\nexport function createDirectoryByPath(cozy, path, offline, options) {\n  const parts = path.split('/').filter(part => part !== '')\n\n  const rootDirectoryPromise = cozy.files.statById(ROOT_DIR_ID, offline)\n\n  return parts.length\n    ? parts.reduce((parentDirectoryPromise, part) => {\n        return parentDirectoryPromise.then(parentDirectory =>\n          getDirectoryOrCreate(cozy, part, parentDirectory, options)\n        )\n      }, rootDirectoryPromise)\n    : rootDirectoryPromise\n}\n\nexport function updateById(cozy, id, data, options) {\n  return doUpload(\n    cozy,\n    data,\n    'PUT',\n    `/files/${encodeURIComponent(id)}`,\n    options\n  )\n}\n\nfunction doUpdateAttributes(cozy, attrs, path, options) {\n  if (!attrs || typeof attrs !== 'object') {\n    throw new Error('missing attrs argument')\n  }\n\n  const { ifMatch, noSanitize } = options || {}\n\n  let name = attrs.name\n  if (!noSanitize) {\n    name = sanitizeFileName(name)\n  }\n\n  const body = {\n    data: {\n      attributes: Object.assign({}, attrs, {\n        name\n      })\n    }\n  }\n  return cozyFetchJSON(cozy, 'PATCH', path, body, {\n    headers: {\n      'If-Match': ifMatch || ''\n    }\n  })\n}\n\nexport function updateAttributesById(cozy, id, attrs, options) {\n  return doUpdateAttributes(\n    cozy,\n    attrs,\n    `/files/${encodeURIComponent(id)}`,\n    options\n  )\n}\n\nexport function updateAttributesByPath(cozy, path, attrs, options) {\n  return doUpdateAttributes(\n    cozy,\n    attrs,\n    `/files/metadata?Path=${encodeURIComponent(path)}`,\n    options\n  )\n}\n\nexport function trashById(cozy, id, options) {\n  if (typeof id !== 'string' || id === '') {\n    throw new Error('missing id argument')\n  }\n  const { ifMatch } = options || {}\n  return cozyFetchJSON(\n    cozy,\n    'DELETE',\n    `/files/${encodeURIComponent(id)}`,\n    undefined,\n    {\n      headers: {\n        'If-Match': ifMatch || ''\n      }\n    }\n  )\n}\n\nexport function statById(cozy, id, offline = true, options = {}) {\n  if (offline && cozy.offline.hasDatabase(DOCTYPE_FILES)) {\n    let db = cozy.offline.getDatabase(DOCTYPE_FILES)\n    return Promise.all([\n      db.get(id),\n      db.find(Object.assign({ selector: { dir_id: id } }, options))\n    ]).then(([doc, children]) => {\n      if (id === ROOT_DIR_ID) {\n        children.docs = children.docs.filter(doc => doc._id !== TRASH_DIR_ID)\n      }\n      children = sortFiles(\n        children.docs.map(doc => addIsDir(toJsonApi(cozy, doc)))\n      )\n      return addIsDir(toJsonApi(cozy, doc, children))\n    })\n  }\n  const query =\n    Object.keys(options).length === 0 ? '' : `?${encodePageOptions(options)}`\n  return cozyFetchJSON(\n    cozy,\n    'GET',\n    `/files/${encodeURIComponent(id)}${query}`\n  ).then(addIsDir)\n}\n\nexport function statByPath(cozy, path) {\n  return cozyFetchJSON(\n    cozy,\n    'GET',\n    `/files/metadata?Path=${encodeURIComponent(path)}`\n  ).then(addIsDir)\n}\n\nexport function downloadById(cozy, id) {\n  return cozyFetch(cozy, `/files/download/${encodeURIComponent(id)}`)\n}\n\nexport function downloadByPath(cozy, path) {\n  return cozyFetch(cozy, `/files/download?Path=${encodeURIComponent(path)}`)\n}\n\nfunction extractResponseLinkRelated(res) {\n  let href = res.links && res.links.related\n  if (!href) throw new Error('No related link in server response')\n  return href\n}\n\nexport function getDownloadLinkByPath(cozy, path) {\n  return cozyFetchJSON(\n    cozy,\n    'POST',\n    `/files/downloads?Path=${encodeURIComponent(path)}`\n  ).then(extractResponseLinkRelated)\n}\n\nexport function getDownloadLinkById(cozy, id) {\n  return cozyFetchJSON(\n    cozy,\n    'POST',\n    `/files/downloads?Id=${encodeURIComponent(id)}`\n  ).then(extractResponseLinkRelated)\n}\n\nexport function getFilePath(cozy, file = {}, folder) {\n  if (!folder || !folder.attributes) {\n    throw Error('Folder should be valid with an attributes.path property')\n  }\n\n  const folderPath = folder.attributes.path.endsWith('/')\n    ? folder.attributes.path\n    : `${folder.attributes.path}/`\n\n  return `${folderPath}${file.name}`\n}\n\nexport function getCollectionShareLink(cozy, id, collectionType) {\n  if (!id) {\n    return Promise.reject(\n      Error('An id should be provided to create a share link')\n    )\n  }\n  return cozyFetchJSON(cozy, 'POST', `/permissions?codes=email`, {\n    data: {\n      type: 'io.cozy.permissions',\n      attributes: {\n        permissions: {\n          files: {\n            type: 'io.cozy.files',\n            verbs: ['GET'],\n            values: [id],\n            selector: 'referenced_by'\n          },\n          collection: {\n            type: collectionType,\n            verbs: ['GET'],\n            values: [id]\n          }\n        }\n      }\n    }\n  }).then(data => ({\n    sharecode: `sharecode=${data.attributes.codes.email}`,\n    id: `id=${id}`\n  }))\n}\n\nexport function getArchiveLinkByPaths(cozy, paths, name = 'files') {\n  const archive = {\n    type: 'io.cozy.archives',\n    attributes: {\n      name: name,\n      files: paths\n    }\n  }\n  return cozyFetchJSON(cozy, 'POST', `/files/archive`, { data: archive }).then(\n    extractResponseLinkRelated\n  )\n}\n\nexport function getArchiveLinkByIds(cozy, ids, name = 'files') {\n  const archive = {\n    type: 'io.cozy.archives',\n    attributes: {\n      name: name,\n      ids: ids\n    }\n  }\n  return cozyFetchJSON(cozy, 'POST', `/files/archive`, { data: archive }).then(\n    extractResponseLinkRelated\n  )\n}\n\nexport function listTrash(cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/files/trash`)\n}\n\nexport function clearTrash(cozy) {\n  return cozyFetchJSON(cozy, 'DELETE', `/files/trash`)\n}\n\nexport function restoreById(cozy, id) {\n  return cozyFetchJSON(cozy, 'POST', `/files/trash/${encodeURIComponent(id)}`)\n}\n\nexport function destroyById(cozy, id, options) {\n  const { ifMatch } = options || {}\n  return cozyFetchJSON(\n    cozy,\n    'DELETE',\n    `/files/trash/${encodeURIComponent(id)}`,\n    undefined,\n    {\n      headers: {\n        'If-Match': ifMatch || ''\n      }\n    }\n  )\n}\n\nfunction addIsDir(obj) {\n  obj.isDir = obj.attributes.type === 'directory'\n  return obj\n}\n\nfunction encodePageOptions(options) {\n  let opts = []\n  for (const name in options) {\n    opts.push(\n      `page[${encodeURIComponent(name)}]=${encodeURIComponent(options[name])}`\n    )\n  }\n  return opts.join('&')\n}\n\nfunction toJsonApi(cozy, doc, contents = []) {\n  let clone = JSON.parse(JSON.stringify(doc))\n  delete clone._id\n  delete clone._rev\n  return {\n    _id: doc._id,\n    _rev: doc._rev,\n    _type: DOCTYPE_FILES,\n    attributes: clone,\n    relationships: {\n      contents: {\n        data: contents,\n        meta: {\n          count: contents.length\n        }\n      }\n    },\n    relations: name => {\n      if (name === 'contents') {\n        return contents\n      }\n    }\n  }\n}\n\nfunction sortFiles(allFiles) {\n  const folders = allFiles.filter(f => f.attributes.type === 'directory')\n  const files = allFiles.filter(f => f.attributes.type !== 'directory')\n  const sort = files =>\n    files.sort((a, b) => a.attributes.name.localeCompare(b.attributes.name))\n  return sort(folders).concat(sort(files))\n}\n\nfunction addQuerystringParam(path, key, value) {\n  return `${path}${path.includes('?') ? '&' : '?'}${key}=${value}`\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/files.js","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/node_modules/regenerator-runtime/runtime-module.js\n// module id = 30\n// module chunks = 0","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/babel-runtime/node_modules/regenerator-runtime/runtime.js\n// module id = 31\n// module chunks = 0","import { errorSerializer, pickService } from './helpers'\nimport { create as createIntent } from './'\n\nconst intentClass = 'coz-intent'\n\nfunction hideIntentIframe(iframe) {\n  iframe.style.display = 'none'\n}\n\nfunction showIntentFrame(iframe) {\n  iframe.style.display = 'block'\n}\n\nfunction buildIntentIframe(intent, element, url) {\n  const document = element.ownerDocument\n  if (!document)\n    return Promise.reject(\n      new Error('Cannot retrieve document object from given element')\n    )\n\n  const iframe = document.createElement('iframe')\n  // TODO: implement 'title' attribute\n  iframe.setAttribute('id', `intent-${intent._id}`)\n  iframe.setAttribute('src', url)\n  iframe.classList.add(intentClass)\n  return iframe\n}\n\nfunction injectIntentIframe(intent, element, url, options) {\n  const { onReadyCallback } = options\n  const iframe = buildIntentIframe(\n    intent,\n    element,\n    url,\n    options.onReadyCallback\n  )\n  // if callback provided for when iframe is loaded\n  if (typeof onReadyCallback === 'function') iframe.onload = onReadyCallback\n  element.appendChild(iframe)\n  iframe.focus()\n  return iframe\n}\n\n// inject iframe for service in given element\nfunction connectIntentIframe(cozy, iframe, element, intent, data) {\n  const document = element.ownerDocument\n  if (!document)\n    return Promise.reject(\n      new Error('Cannot retrieve document object from given element')\n    )\n\n  const window = document.defaultView\n  if (!window)\n    return Promise.reject(\n      new Error('Cannot retrieve window object from document')\n    )\n\n  // Keeps only http://domain:port/\n  const serviceOrigin = iframe.src.split('/', 3).join('/')\n\n  async function compose(cozy, action, doctype, data) {\n    const intent = await createIntent(cozy, action, doctype, data)\n    hideIntentIframe(iframe)\n    const doc = await start(cozy, intent, element, {\n      ...data,\n      exposeIntentFrameRemoval: false\n    })\n    showIntentFrame(iframe)\n    return doc\n  }\n\n  return new Promise((resolve, reject) => {\n    let handshaken = false\n    const messageHandler = async event => {\n      if (event.origin !== serviceOrigin) return\n\n      const eventType = event.data.type\n      if (eventType === 'load') {\n        // Safari 9.1 (At least) send a MessageEvent when the iframe loads,\n        // making the handshake fails.\n        console.warn &&\n          console.warn(\n            'Cozy Client ignored MessageEvent having data.type `load`.'\n          )\n        return\n      }\n\n      if (eventType === `intent-${intent._id}:ready`) {\n        handshaken = true\n        return event.source.postMessage(data, event.origin)\n      }\n\n      if (handshaken && eventType === `intent-${intent._id}:resize`) {\n        ;['width', 'height', 'maxWidth', 'maxHeight'].forEach(prop => {\n          if (event.data.transition)\n            element.style.transition = event.data.transition\n          if (event.data.dimensions[prop])\n            element.style[prop] = `${event.data.dimensions[prop]}px`\n        })\n\n        return true\n      }\n\n      if (handshaken && eventType === `intent-${intent._id}:compose`) {\n        // Let start to name `type` as `doctype`, as `event.data` already have a `type` attribute.\n        const { action, doctype, data } = event.data\n        const doc = await compose(\n          cozy,\n          action,\n          doctype,\n          data\n        )\n        return event.source.postMessage(doc, event.origin)\n      }\n\n      window.removeEventListener('message', messageHandler)\n      const removeIntentFrame = () => {\n        // check if the parent node has not been already removed from the DOM\n        iframe.parentNode && iframe.parentNode.removeChild(iframe)\n      }\n\n      if (\n        handshaken &&\n        eventType === `intent-${intent._id}:exposeFrameRemoval`\n      ) {\n        return resolve({ removeIntentFrame, doc: event.data.document })\n      }\n\n      removeIntentFrame()\n\n      if (eventType === `intent-${intent._id}:error`) {\n        return reject(errorSerializer.deserialize(event.data.error))\n      }\n\n      if (handshaken && eventType === `intent-${intent._id}:cancel`) {\n        return resolve(null)\n      }\n\n      if (handshaken && eventType === `intent-${intent._id}:done`) {\n        return resolve(event.data.document)\n      }\n\n      if (!handshaken) {\n        return reject(\n          new Error('Unexpected handshake message from intent service')\n        )\n      }\n\n      // We may be in a state where the messageHandler is still attached to then\n      // window, but will not be needed anymore. For example, the service failed\n      // before adding the `unload` listener, so no `intent:cancel` message has\n      // never been sent.\n      // So we simply ignore other messages, and this listener will stay here,\n      // waiting for a message which will never come, forever (almost).\n    }\n\n    window.addEventListener('message', messageHandler)\n  })\n}\n\nexport function start(cozy, intent, element, data = {}, options = {}) {\n  const service = pickService(intent, options.filterServices)\n\n  if (!service) {\n    throw new Error('Unable to find a service')\n  }\n\n  const iframe = injectIntentIframe(intent, element, service.href, options)\n\n  return connectIntentIframe(\n    cozy,\n    iframe,\n    element,\n    intent,\n    data,\n    options.onReadyCallback\n  )\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/intents/client.js","import { cozyFetchJSON } from '../fetch'\nimport { errorSerializer } from './helpers'\n\nfunction listenClientData(intent, window) {\n  return new Promise(resolve => {\n    const messageEventListener = event => {\n      if (event.origin !== intent.attributes.client) return\n\n      window.removeEventListener('message', messageEventListener)\n      resolve(event.data)\n    }\n\n    window.addEventListener('message', messageEventListener)\n    window.parent.postMessage(\n      {\n        type: `intent-${intent._id}:ready`\n      },\n      intent.attributes.client\n    )\n  })\n}\n\n// maximize the height of an element\nfunction maximize(element) {\n  if (element && element.style) {\n    element.style.height = '100%'\n  }\n}\n\nexport function start(cozy, intentId, serviceWindow) {\n  serviceWindow = serviceWindow || (typeof window !== 'undefined' && window)\n  if (!serviceWindow || !serviceWindow.document) {\n    return Promise.reject(new Error('Intent service should be used in browser'))\n  }\n\n  // Maximize document, the whole iframe is handled by intents, clients and\n  // services\n  serviceWindow.addEventListener('load', () => {\n    const { document } = serviceWindow\n    ;[document.documentElement, document.body].forEach(maximize)\n  })\n\n  intentId = intentId || serviceWindow.location.search.split('=')[1]\n  if (!intentId)\n    return Promise.reject(new Error('Cannot retrieve intent from URL'))\n\n  return cozyFetchJSON(cozy, 'GET', `/intents/${intentId}`).then(intent => {\n    let terminated = false\n\n    const sendMessage = message => {\n      if (terminated)\n        throw new Error('Intent service has already been terminated')\n      serviceWindow.parent.postMessage(message, intent.attributes.client)\n    }\n\n    const compose = (action, doctype, data) =>\n      new Promise(resolve => {\n        const composeEventListener = event => {\n          if (event.origin !== intent.attributes.client) return\n          serviceWindow.removeEventListener('message', composeEventListener)\n          return resolve(event.data)\n        }\n\n        serviceWindow.addEventListener('message', composeEventListener)\n\n        sendMessage({\n          type: `intent-${intent._id}:compose`,\n          action,\n          doctype,\n          data\n        })\n      })\n\n    const terminate = message => {\n      sendMessage(message)\n      terminated = true\n    }\n\n    const resizeClient = (dimensions, transitionProperty) => {\n      if (terminated) throw new Error('Intent service has been terminated')\n\n      sendMessage({\n        type: `intent-${intent._id}:resize`,\n        // if a dom element is passed, calculate its size\n        dimensions: dimensions.element\n          ? Object.assign({}, dimensions, {\n              maxHeight: dimensions.element.clientHeight,\n              maxWidth: dimensions.element.clientWidth\n            })\n          : dimensions,\n        transition: transitionProperty\n      })\n    }\n\n    const cancel = () => {\n      terminate({ type: `intent-${intent._id}:cancel` })\n    }\n\n    // Prevent unfulfilled client promises when this window unloads for a\n    // reason or another.\n    serviceWindow.addEventListener('unload', () => {\n      if (!terminated) cancel()\n    })\n\n    return listenClientData(intent, serviceWindow).then(data => {\n      return {\n        compose: compose,\n        getData: () => data,\n        getIntent: () => intent,\n        terminate: doc => {\n          const eventName =\n            data && data.exposeIntentFrameRemoval\n              ? 'exposeFrameRemoval'\n              : 'done'\n          return terminate({\n            type: `intent-${intent._id}:${eventName}`,\n            document: doc\n          })\n        },\n        throw: error =>\n          terminate({\n            type: `intent-${intent._id}:error`,\n            error: errorSerializer.serialize(error)\n          }),\n        resizeClient: resizeClient,\n        cancel: cancel\n      }\n    })\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/intents/service.js","import { cozyFetchJSON } from './fetch'\n\nexport function count(cozy, workerType) {\n  return cozyFetchJSON(cozy, 'GET', `/jobs/queue/${workerType}`).then(\n    data => data.length\n  )\n}\n\nexport function queued(cozy, workerType) {\n  return cozyFetchJSON(cozy, 'GET', `/jobs/queue/${workerType}`)\n}\n\nexport function create(cozy, workerType, args, options) {\n  return cozyFetchJSON(cozy, 'POST', `/jobs/queue/${workerType}`, {\n    data: {\n      type: 'io.cozy.jobs',\n      attributes: {\n        arguments: args || {},\n        options: options || {}\n      }\n    }\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/jobs.js","// Define global `fetch` so it's made available to `pouchdb-browser`\nimport 'cross-fetch/polyfill'\n\nimport { DOCTYPE_FILES } from './doctypes'\nimport { refreshToken } from './auth_v3'\nimport { isOffline } from './utils'\nimport PouchDB from 'pouchdb-browser'\nimport pouchdbFind from 'pouchdb-find'\n\nexport const replicationOfflineError =\n  'Replication abort, your device is actually offline.'\n\nlet pluginLoaded = false\n\n/*\n  For each doctype we have some parameters:\n  cozy._offline[doctype] = {\n    database: pouchdb database\n    replication: the pouchdb replication\n    replicationPromise: promise of replication\n    interval: repeated replication interval\n  }\n*/\n\nexport function init(cozy, { options = {}, doctypes = [] }) {\n  for (let doctype of doctypes) {\n    createDatabase(cozy, doctype, options)\n  }\n}\n\n// helper\n\nfunction getInfo(cozy, doctype) {\n  cozy._offline = cozy._offline || []\n  cozy._offline[doctype] = cozy._offline[doctype] || {}\n  return cozy._offline[doctype]\n}\n\nexport function getDoctypes(cozy) {\n  cozy._offline = cozy._offline || []\n  return Object.keys(cozy._offline)\n}\n\n//\n// DATABASE\n//\n\nexport function hasDatabase(cozy, doctype) {\n  return getDatabase(cozy, doctype) !== undefined\n}\n\nexport function getDatabase(cozy, doctype) {\n  return getInfo(cozy, doctype).database\n}\n\nexport function setDatabase(cozy, doctype, database) {\n  cozy._offline[doctype].database = database\n  return getDatabase(cozy, doctype)\n}\n\nexport function migrateDatabase(cozy, doctype, options = {}) {\n  const oldDb = getDatabase(cozy, doctype)\n  const newOptions = {\n    adapter: 'idb',\n    ...options\n  }\n  const newDb = new PouchDB(doctype, newOptions)\n\n  return oldDb.replicate.to(newDb).then(() => {\n    setDatabase(cozy, doctype, newDb)\n    oldDb.destroy()\n    return newDb\n  })\n}\n\nexport function createDatabase(cozy, doctype, options = {}) {\n  if (!pluginLoaded) {\n    PouchDB.plugin(pouchdbFind)\n    pluginLoaded = true\n  }\n\n  if (hasDatabase(cozy, doctype)) {\n    return Promise.resolve(getDatabase(cozy, doctype))\n  }\n\n  setDatabase(cozy, doctype, new PouchDB(doctype, options))\n  return createIndexes(cozy, doctype).then(() => getDatabase(cozy, doctype))\n}\n\nexport function destroyDatabase(cozy, doctype) {\n  if (!hasDatabase(cozy, doctype)) {\n    return Promise.resolve(false)\n  }\n\n  return stopRepeatedReplication(cozy, doctype)\n    .then(() => stopReplication(cozy, doctype))\n    .then(() => getDatabase(cozy, doctype).destroy())\n    .then(response => {\n      setDatabase(cozy, doctype, undefined)\n      return response\n    })\n}\n\nexport function destroyAllDatabase(cozy) {\n  const doctypes = getDoctypes(cozy)\n  const destroy = doctype => destroyDatabase(cozy, doctype)\n  return Promise.all(doctypes.map(destroy))\n}\n\nfunction createIndexes(cozy, doctype) {\n  if (doctype === DOCTYPE_FILES) {\n    return getDatabase(cozy, doctype).createIndex({\n      index: { fields: ['dir_id'] }\n    })\n  }\n  return Promise.resolve()\n}\n\n//\n// REPLICATION\n//\n\nexport function hasReplication(cozy, doctype) {\n  return getReplication(cozy, doctype) !== undefined\n}\n\nfunction getReplication(cozy, doctype) {\n  return getInfo(cozy, doctype).replication\n}\n\nfunction setReplication(cozy, doctype, replication) {\n  cozy._offline[doctype].replication = replication\n  return getReplication(cozy, doctype)\n}\n\nfunction getReplicationUrl(cozy, doctype) {\n  return cozy.authorize().then(credentials => {\n    const basic = credentials.token.toBasicAuth()\n    return (cozy._url + '/data/' + doctype).replace('//', `//${basic}`)\n  })\n}\n\nfunction getReplicationPromise(cozy, doctype) {\n  return getInfo(cozy, doctype).replicationPromise\n}\n\nfunction setReplicationPromise(cozy, doctype, promise) {\n  cozy._offline[doctype].replicationPromise = promise\n  return getReplicationPromise(cozy, doctype)\n}\n\nexport function replicateFromCozy(cozy, doctype, options = {}) {\n  return setReplicationPromise(\n    cozy,\n    doctype,\n    new Promise((resolve, reject) => {\n      if (!hasDatabase(cozy, doctype)) {\n        createDatabase(cozy, doctype)\n      }\n      if (options.live === true) {\n        return reject(\n          new Error(\"You can't use `live` option with Cozy couchdb.\")\n        )\n      }\n\n      if (isOffline()) {\n        reject(replicationOfflineError)\n        options.onError && options.onError(replicationOfflineError)\n        return\n      }\n\n      getReplicationUrl(cozy, doctype).then(url =>\n        setReplication(\n          cozy,\n          doctype,\n          getDatabase(cozy, doctype)\n            .replicate.from(url, options)\n            .on('complete', info => {\n              setReplication(cozy, doctype, undefined)\n              resolve(info)\n              options.onComplete && options.onComplete(info)\n            })\n            .on('error', err => {\n              if (/Expired token/.test(err.error)) {\n                cozy.authorize().then(({ client, token }) => {\n                  refreshToken(cozy, client, token)\n                    .then(newToken => cozy.saveCredentials(client, newToken))\n                    .then(() => replicateFromCozy(cozy, doctype, options))\n                })\n              } else {\n                console.warn(`ReplicateFromCozy '${doctype}' Error:`)\n                console.warn(err)\n                setReplication(cozy, doctype, undefined)\n                reject(err)\n                options.onError && options.onError(err)\n              }\n            })\n        )\n      )\n    })\n  )\n}\n\nexport function stopReplication(cozy, doctype) {\n  if (!getDatabase(cozy, doctype) || !hasReplication(cozy, doctype)) {\n    return Promise.resolve()\n  }\n\n  return new Promise(resolve => {\n    try {\n      getReplicationPromise(cozy, doctype).then(() => {\n        resolve()\n      })\n      getReplication(cozy, doctype).cancel()\n      // replication is set to undefined by complete replication\n    } catch (e) {\n      resolve()\n    }\n  })\n}\n\nexport function stopAllReplication(cozy) {\n  const doctypes = getDoctypes(cozy)\n  const stop = doctype => stopReplication(cozy, doctype)\n  return Promise.all(doctypes.map(stop))\n}\n\n//\n// REPEATED REPLICATION\n//\n\nfunction getRepeatedReplication(cozy, doctype) {\n  return getInfo(cozy, doctype).interval\n}\n\nfunction setRepeatedReplication(cozy, doctype, interval) {\n  cozy._offline[doctype].interval = interval\n}\n\nexport function hasRepeatedReplication(cozy, doctype) {\n  return getRepeatedReplication(cozy, doctype) !== undefined\n}\n\nexport function startRepeatedReplication(cozy, doctype, timer, options = {}) {\n  // TODO: add timer limitation for not flooding Gozy\n  if (hasRepeatedReplication(cozy, doctype)) {\n    return getRepeatedReplication(cozy, doctype)\n  }\n\n  return setRepeatedReplication(\n    cozy,\n    doctype,\n    setInterval(() => {\n      if (isOffline()) {\n        // network is offline, replication cannot be launched\n        console.info(replicationOfflineError)\n        return\n      }\n      if (!hasReplication(cozy, doctype)) {\n        replicateFromCozy(cozy, doctype, options)\n        // TODO: add replicationToCozy\n      }\n    }, timer * 1000)\n  )\n}\n\nexport function stopRepeatedReplication(cozy, doctype) {\n  if (hasRepeatedReplication(cozy, doctype)) {\n    clearInterval(getRepeatedReplication(cozy, doctype))\n    setRepeatedReplication(cozy, doctype, undefined)\n  }\n  if (hasReplication(cozy, doctype)) {\n    return stopReplication(cozy, doctype)\n  }\n\n  return Promise.resolve()\n}\n\nexport function stopAllRepeatedReplication(cozy) {\n  const doctypes = getDoctypes(cozy)\n  const stop = doctype => stopRepeatedReplication(cozy, doctype)\n  return Promise.all(doctypes.map(stop))\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/offline.js","(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  return exports;\n\n}({}));\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/cross-fetch/dist/browser-polyfill.js\n// module id = 36\n// module chunks = 0","import getArguments from 'argsarray';\nimport nextTick from 'immediate';\nimport { EventEmitter } from 'events';\nimport inherits from 'inherits';\nimport Md5 from 'spark-md5';\nimport uuidV4 from 'uuid';\nimport vuvuzela from 'vuvuzela';\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new Promise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return Promise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return Promise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new Promise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nvar hasLocal;\n\ntry {\n  localStorage.setItem('_pouch_check_localstorage', 1);\n  hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n} catch (e) {\n  hasLocal = false;\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n\ninherits(Changes, EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (hasLocalStorage()) {\n    addEventListener(\"storage\", function (e) {\n      self.emit(e.key);\n    });\n  }\n}\n\nfunction Changes() {\n  EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary', 'return_docs'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        nextTick(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new Promise(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction rev$$1(doc, deterministic_revs) {\n  var clonedDoc = clone(doc);\n  if (!deterministic_revs) {\n    return uuidV4.v4().replace(/-/g, '').toLowerCase();\n  }\n\n  delete clonedDoc._rev_tree;\n  return stringMd5(JSON.stringify(clonedDoc));\n}\n\nvar uuid = uuidV4.v4;\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\ninherits(Changes$1, EventEmitter);\n\nfunction tryCatchInChangeListener(self, change, pending, lastSeq) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change, pending, lastSeq);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$1(db, opts, callback) {\n  EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change, pending, lastSeq);\n  };\n\n  var promise = new Promise(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.validateChanges(opts);\n      }\n    });\n  } else {\n    self.validateChanges(opts);\n  }\n}\nChanges$1.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$1.prototype.validateChanges = function (opts) {\n  var callback = opts.complete;\n  var self = this;\n\n  /* istanbul ignore else */\n  if (PouchDB._changesFilterPlugin) {\n    PouchDB._changesFilterPlugin.validate(opts, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      self.doChanges(opts);\n    });\n  } else {\n    self.doChanges(opts);\n  }\n};\n\nChanges$1.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (PouchDB._changesFilterPlugin) {\n    PouchDB._changesFilterPlugin.normalize(opts);\n    if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {\n      return PouchDB._changesFilterPlugin.filter(this, opts);\n    }\n  } else {\n    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n      if (key in opts) {\n        guardedConsole('warn',\n          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n          'but pouchdb-changes-filter plugin is not installed, so it ' +\n          'was ignored. Please install the plugin to enable filtering.'\n        );\n      }\n    });\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback, docId) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      err = err || results[0];\n      err.docId = docId;\n      callback(err);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysParse(opts) {\n  var keys =  ('limit' in opts) ?\n    opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  opts.keys = keys;\n  opts.skip = 0;\n  delete opts.limit;\n  if (opts.descending) {\n    keys.reverse();\n    opts.descending = false;\n  }\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, EventEmitter);\n\nfunction AbstractPouchDB() {\n  EventEmitter.call(this);\n\n  // re-bind prototyped methods\n  for (var p in AbstractPouchDB.prototype) {\n    if (typeof this[p] === 'function') {\n      this[p] = this[p].bind(this);\n    }\n  }\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  var self = this;\n  if (opts.force && doc._rev) {\n    transformForceOptionToNewEditsOption();\n    putDoc(function (err) {\n      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n      cb(err, result);\n    });\n  } else {\n    putDoc(cb);\n  }\n\n  function transformForceOptionToNewEditsOption() {\n    var parts = doc._rev.split('-');\n    var oldRevId = parts[1];\n    var oldRevNum = parseInt(parts[0], 10);\n\n    var newRevNum = oldRevNum + 1;\n    var newRevId = rev$$1();\n\n    doc._revisions = {\n      start: newRevNum,\n      ids: [newRevId, oldRevId]\n    };\n    doc._rev = newRevNum + '-' + newRevId;\n    opts.new_edits = false;\n  }\n  function putDoc(next) {\n    if (typeof self._put === 'function' && opts.new_edits !== false) {\n      self._put(doc, opts, next);\n    } else {\n      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n    }\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev) {\n      addToMissing(id, rev);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev) {\n      if (height[rev] > maxHeight) {\n        candidates.push(rev);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n        revs.push(rev);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    Promise.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    }).catch(callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments,\n        binary: opts.binary\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ok: doc});\n          }\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        /* istanbul ignore if */\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      err.docId = id;\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo       = parseInt(splittedRev[0], 10);\n      var revHash     = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n          .indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) { return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev) {\n            return rev.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev) {\n          pos--;\n          return {\n            rev: pos + '-' + rev.id,\n            status: rev.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (!isRemote(this)) {\n      allDocsKeysParse(opts);\n      if (opts.keys.length === 0) {\n        return this._allDocs({limit: 0}, callback);\n      }\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  // By default set return_docs to false if the caller has opts.live = true,\n  // this will prevent us from collecting the set of changes indefinitely\n  // resulting in growing memory\n  opts.return_docs = ('return_docs' in opts) ? opts.return_docs : !opts.live;\n\n  return new Changes$1(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n    info.adapter = self.adapter;\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && !isRemote(adapter)) {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (!isRemote(adapter)) {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (isRemote(self)) {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    Promise.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB.adapters;\n  var preferredAdapters = PouchDB.preferredAdapters;\n  var prefix = PouchDB.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  function onDestroyed(from_constructor) {\n    self.removeListener('closed', onClosed);\n    if (!from_constructor) {\n      self.constructor.emit('destroyed', self.name);\n    }\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.constructor.emit('unref', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n  self.constructor.emit('ref', self);\n}\n\ninherits(PouchDB, AbstractPouchDB);\nfunction PouchDB(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB)) {\n    return new PouchDB(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  if (opts.deterministic_revs === undefined) {\n    opts.deterministic_revs = true;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n  if (!PouchDB.adapters[opts.adapter] ||\n      !PouchDB.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue();\n\n  self.adapter = opts.adapter;\n\n  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\n// AbortController was introduced quite a while after fetch and\n// isnt required for PouchDB to function so polyfill if needed\nvar a = (typeof AbortController !== 'undefined')\n    ? AbortController\n    : function () { return {abort: function () {}}; };\n\nvar f$1 = fetch;\nvar h = Headers;\n\nPouchDB.adapters = {};\nPouchDB.preferredAdapters = [];\n\nPouchDB.prefix = '_pouch_';\n\nvar eventEmitter = new EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(EventEmitter.prototype).forEach(function (key) {\n    if (typeof EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\n  Pouch.on('ref', function onConstructorRef(db) {\n    if (!destructListeners.has(db.name)) {\n      destructListeners.set(db.name, []);\n    }\n    destructListeners.get(db.name).push(db);\n  });\n\n  Pouch.on('unref', function onConstructorUnref(db) {\n    if (!destructListeners.has(db.name)) {\n      return;\n    }\n    var dbList = destructListeners.get(db.name);\n    var pos = dbList.indexOf(db);\n    if (pos < 0) {\n      /* istanbul ignore next */\n      return;\n    }\n    dbList.splice(pos, 1);\n    if (dbList.length > 1) {\n      /* istanbul ignore next */\n      destructListeners.set(db.name, dbList);\n    } else {\n      destructListeners.delete(db.name);\n    }\n  });\n\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    var dbList = destructListeners.get(name);\n    destructListeners.delete(name);\n    dbList.forEach(function (db) {\n      db.emit('destroyed',true);\n    });\n  });\n}\n\nsetUpEventEmitter(PouchDB);\n\nPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB;\n};\n\nPouchDB.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n    PouchDB.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB);\n\n  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();\n  Object.keys(PouchDB).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\nPouchDB.fetch = function (url, opts) {\n  return f$1(url, opts);\n};\n\n// managed automatically by set-version.js\nvar version = \"7.0.0\";\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        /* eslint-disable no-control-regex */\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n        /* eslint-enable no-control-regex */\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        /* eslint-disable no-control-regex */\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        /* eslint-enable no-control-regex */\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler.db);\n}\n\nfunction filter(changesHandler, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB.plugin(applyChangesFilterPlugin);\n\nPouchDB.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev) {\n  if (!/^\\d+-./.test(rev)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev.indexOf('-');\n  var left = rev.substring(0, idx);\n  var right = rev.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits, dbOpts) {\n  if (!dbOpts) {\n    dbOpts = {\n      deterministic_revs: true\n    };\n  }\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev$$1(doc, dbOpts.deterministic_revs);\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev) && !newEdits) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return Promise.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return Promise.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new Promise(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits, dbOpts);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  if (batchSize === -1) {\n    batchSize = 1000;\n  }\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor)\n  // 3) descending – no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction allDocsKeys(keys, docStore, onBatch) {\n  // It's not guaranted to be returned in right order  \n  var valuesBatch = new Array(keys.length);\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n        valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        onBatch(keys, valuesBatch, {});\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false; \n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange ; \n  var keyRangeError;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n    keyRangeError = keyRange && keyRange.error;\n    if (keyRangeError && \n      !(keyRangeError.name === \"DataError\" && keyRangeError.code === 0)) {\n      // DataError with error code 0 indicates start is less than end, so\n      // can just do an empty query. Else need to throw\n      return callback(createError(IDB_ERROR,\n        keyRangeError.name, keyRangeError.message));\n    }\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n  var updateSeq;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  /* istanbul ignore if */\n  if (opts.update_seq) {\n    getMaxUpdateSeq(seqStore, function (e) { \n      if (e.target.result && e.target.result.length > 0) {\n        updateSeq = e.target.result[0];\n      }\n    });\n  }\n\n  function getMaxUpdateSeq(objectStore, onSuccess) {\n    function onCursor(e) {\n      var cursor = e.target.result;\n      var maxKey = undefined;\n      if (cursor && cursor.key) {\n        maxKey = cursor.key;\n      } \n      return onSuccess({\n        target: {\n          result: [maxKey]\n        }\n      });\n    }\n    objectStore.openCursor(null, 'prev').onsuccess = onCursor;\n  }\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result) || {};\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        // deleted docs are okay with \"keys\" requests\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      if (batchValue.error && keys) {\n        // key was not found with \"keys\" requests\n        results.push(batchValue);\n        continue;\n      }\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    var returnVal = {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    };\n    \n    /* istanbul ignore if */\n    if (opts.update_seq && updateSeq !== undefined) {\n      returnVal.update_seq = updateSeq;\n    }\n    callback(null, returnVal);\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, onBatch);\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new Promise(function (resolve) {\n    var blob$$1 = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    req.onerror = txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler.addListener(dbName, id, api, opts);\n    changesHandler.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return Promise.reject(filtered);\n      }\n\n      if (!filtered) {\n        return Promise.resolve();\n      }\n      numResults++;\n      if (opts.return_docs) {\n        results.push(change);\n      }\n      // process the attachment immediately\n      // for the benefit of live listeners\n      if (opts.attachments && opts.include_docs) {\n        return new Promise(function (resolve) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              resolve(change);\n            });\n          });\n        });\n      } else {\n        return Promise.resolve(change);\n      }\n    }\n\n    function onBatchDone() {\n      var promises = [];\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        promises.push(processMetadataAndWinningDoc(metadata, winningDoc));\n      }\n\n      Promise.all(promises).then(function (changes) {\n        for (var i = 0, len = changes.length; i < len; i++) {\n          if (changes[i]) {\n            opts.onChange(changes[i]);\n          }\n        }\n      }).catch(opts.complete);\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev;\n      if (!opts.rev) {\n        rev = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev = pos + '-' + revHash;\n        if (revs.indexOf(rev) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req = indexedDB.open(dbName, ADAPTER_VERSION);\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n    txn.onabort = idbError(callback);\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Following #7085 buggy idb versions (typically Safari < 10.1) are\n  // considered valid.\n\n  // On Firefox SecurityError is thrown while referencing indexedDB if cookies\n  // are not allowed. `typeof indexedDB` also triggers the error.\n  try {\n    // some outdated implementations of IDB that appear on Samsung\n    // and HTC Android devices <4.4 are missing IDBKeyRange\n    return typeof indexedDB !== 'undefined' && typeof IDBKeyRange !== 'undefined';\n  } catch (e) {\n    return false;\n  }\n};\n\nfunction IDBPouch (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new Promise(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\nvar CHANGES_TIMEOUT_BUFFER = 5000;\nvar DEFAULT_HEARTBEAT = 10000;\n\nvar supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var doc = row.doc || row.ok;\n  var atts = doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$1(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return Promise.resolve();\n  }\n\n  return Promise.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new Promise(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n  var protocol = parseUri(opts.prefix).protocol;\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    // Ensure prefix has a trailing slash\n    var prefix = opts.prefix.replace(/\\/?$/, '/');\n    name = prefix + encodeURIComponent(dbName);\n  }\n\n  var uri = parseUri(name);\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\nfunction shouldCacheBust(opts) {\n  var ua = (typeof navigator !== 'undefined' && navigator.userAgent) ?\n      navigator.userAgent.toLowerCase() : '';\n  var isIE = ua.indexOf('msie') !== -1;\n  var isTrident = ua.indexOf('trident') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n  var isGET = !('method' in opts) || opts.method === 'GET';\n  return (isIE || isTrident || isEdge) && isGET;\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n\n  var ourFetch = function (url, options) {\n\n    options = options || {};\n    options.headers = options.headers || new h();\n\n    if (opts.auth || host.auth) {\n      var nAuth = opts.auth || host.auth;\n      var str = nAuth.username + ':' + nAuth.password;\n      var token = thisBtoa(unescape(encodeURIComponent(str)));\n      options.headers.set('Authorization', 'Basic ' + token);\n    }\n\n    var headers = opts.headers || {};\n    Object.keys(headers).forEach(function (key) {\n      options.headers.append(key, headers[key]);\n    });\n\n    /* istanbul ignore if */\n    if (shouldCacheBust(options)) {\n      url += (url.indexOf('?') === -1 ? '?' : '&') + '_nonce=' + Date.now();\n    }\n\n    var fetchFun = opts.fetch || f$1;\n    return fetchFun(url, options);\n  };\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    })).bind(api);\n  }\n\n  function fetchJSON(url, options, callback) {\n\n    var result = {};\n\n    options = options || {};\n    options.headers = options.headers || new h();\n\n    if (!options.headers.get('Content-Type')) {\n      options.headers.set('Content-Type', 'application/json');\n    }\n    if (!options.headers.get('Accept')) {\n      options.headers.set('Accept', 'application/json');\n    }\n\n    return ourFetch(url, options).then(function (response) {\n      result.ok = response.ok;\n      result.status = response.status;\n      return response.json();\n    }).then(function (json) {\n      result.data = json;\n      if (!result.ok) {\n        result.data.status = result.status;\n        var err = generateErrorFromResponse(result.data);\n        if (callback) {\n          return callback(err);\n        } else {\n          throw err;\n        }\n      }\n\n      if (Array.isArray(result.data)) {\n        result.data = result.data.map(function (v) {\n          if (v.error || v.missing) {\n            return generateErrorFromResponse(v);\n          } else {\n            return v;\n          }\n        });\n      }\n\n      if (callback) {\n        callback(null, result.data);\n      } else {\n        return result;\n      }\n    });\n  }\n\n  var setupPromise;\n\n  function setup() {\n    if (opts.skip_setup) {\n      return Promise.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    setupPromise = fetchJSON(dbUrl).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return fetchJSON(dbUrl, {method: 'PUT'});\n      } else {\n        return Promise.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return Promise.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  nextTick(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ourFetch(genUrl(host, '')).then(function (response) {\n      return response.json();\n    }).then(function (result) {\n      var uuid$$1 = (result && result.uuid) ?\n          (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    }).catch(function (err) {\n      callback(err);\n    });\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    fetchJSON(genDBUrl(host, '_compact'), {method: 'POST'}).then(function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      fetchJSON(genDBUrl(host, '_bulk_get' + paramsToStr(params)), {\n        method: 'POST',\n        body: JSON.stringify({ docs: opts.docs})\n      }).then(function (result) {\n        if (opts.attachments && opts.binary) {\n          result.data.results.forEach(function (res) {\n            res.docs.forEach(readAttachmentsAsBlobOrBuffer);\n          });\n        }\n        cb(null, result.data);\n      }).catch(cb);\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      return ourFetch(genDBUrl(host, ''));\n    }).then(function (response) {\n      return response.json();\n    }).then(function (info) {\n      info.host = genDBUrl(host, '');\n      callback(null, info);\n    }).catch(callback);\n  };\n\n  api.fetch = function (path, options) {\n    return setup().then(function () {\n      return ourFetch(genDBUrl(host, path), options);\n    });\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = opts.update_seq;\n    }\n\n    id = encodeDocId(id);\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetchData(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n            '?rev=' + doc._rev;\n        return ourFetch(genDBUrl(host, path)).then(function (response) {\n          if (typeof process !== 'undefined' && !process.browser) {\n            return response.buffer();\n          } else {\n            /* istanbul ignore next */\n            return response.blob();\n          }\n        }).then(function (blob) {\n          if (opts.binary) {\n            // TODO: Can we remove this?\n            if (typeof process !== 'undefined' && !process.browser) {\n              blob.type = att.content_type;\n            }\n            return blob;\n          }\n          return new Promise(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetchData(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return Promise.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    var url = genDBUrl(host, id + paramsToStr(params));\n    fetchJSON(url).then(function (res) {\n      return Promise.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res.data);\n        }\n      }).then(function () {\n        callback(null, res.data);\n      });\n    }).catch(function (e) {\n      e.docId = id;\n      callback(e);\n    });\n  });\n\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove', function (docOrId, optsOrRev, opts, cb) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        cb = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        cb = optsOrRev;\n        opts = {};\n      } else {\n        cb = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev = (doc._rev || opts.rev);\n    var url = genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev;\n\n    fetchJSON(url, {method: 'DELETE'}, cb).catch(cb);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment = adapterFun$$1('getAttachment', function (docId, attachmentId,\n                                                            opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n        encodeAttachmentId(attachmentId) + params;\n    var contentType;\n    ourFetch(url, {method: 'GET'}).then(function (response) {\n      contentType = response.headers.get('content-type');\n      if (!response.ok) {\n        throw response;\n      } else {\n        if (typeof process !== 'undefined' && !process.browser) {\n          return response.buffer();\n        } else {\n          /* istanbul ignore next */\n          return response.blob();\n        }\n      }\n    }).then(function (blob) {\n      // TODO: also remove\n      if (typeof process !== 'undefined' && !process.browser) {\n        blob.type = contentType;\n      }\n      callback(null, blob);\n    }).catch(function (err) {\n      callback(err);\n    });\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =  adapterFun$$1('removeAttachment', function (docId,\n                                                                   attachmentId,\n                                                                   rev,\n                                                                   callback) {\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n                       encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n    fetchJSON(url, {method: 'DELETE'}, callback).catch(callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment = adapterFun$$1('putAttachment', function (docId, attachmentId,\n                                                            rev, blob,\n                                                            type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev;\n      rev = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    // Add the attachment\n    fetchJSON(url, {\n      headers: new h({'Content-Type': type}),\n      method: 'PUT',\n      body: blob\n    }, callback).catch(callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return Promise.all(req.docs.map(preprocessAttachments$1));\n    }).then(function () {\n      // Update/create the documents\n      return fetchJSON(genDBUrl(host, '_bulk_docs'), {\n        method: 'POST',\n        body: JSON.stringify(req)\n      }, callback);\n    }).catch(callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$1(doc);\n    }).then(function () {\n      return fetchJSON(genDBUrl(host, encodeDocId(doc._id)), {\n        method: 'PUT',\n        body: JSON.stringify(doc)\n      });\n    }).then(function (result) {\n      callback(null, result.data);\n    }).catch(function (err) {\n      err.docId = doc && doc._id;\n      callback(err);\n    });\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    fetchJSON(genDBUrl(host, '_all_docs' + paramStr), {\n       method: method,\n      body: JSON.stringify(body)\n    }).then(function (result) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        result.data.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, result.data);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n\n    if (opts.continuous && !('heartbeat' in opts)) {\n      opts.heartbeat = DEFAULT_HEARTBEAT;\n    }\n\n    var requestTimeout = ('timeout' in opts) ? opts.timeout : 30 * 1000;\n\n    // ensure CHANGES_TIMEOUT_BUFFER applies\n    if ('timeout' in opts && opts.timeout &&\n      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    /* istanbul ignore if */\n    if ('heartbeat' in opts && opts.heartbeat &&\n       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    var params = {};\n    if ('timeout' in opts && opts.timeout) {\n      params.timeout = opts.timeout;\n    }\n\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.seq_interval) {\n      params.seq_interval = opts.seq_interval;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n    \n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    var controller = new a();\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetchData = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Cloudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var url = genDBUrl(host, '_changes' + paramsToStr(params));\n      var fetchOpts = {\n        signal: controller.signal,\n        method: method,\n        body: JSON.stringify(body)\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        return fetchJSON(url, fetchOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        var pending = null;\n        var lastSeq = null;\n        // Attach 'pending' property if server supports it (CouchDB 2.0+)\n        /* istanbul ignore if */\n        if (typeof res.pending === 'number') {\n          pending = res.pending;\n        }\n        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {\n          lastSeq = results.last_seq;\n        }\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (opts.return_docs) {\n              results.results.push(c);\n            }\n            opts.onChange(c, pending, lastSeq);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        nextTick(function () { fetchData(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetchData(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        controller.abort();\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    fetchJSON(genDBUrl(host, '_revs_diff'), {\n      method: 'POST',\n      body: JSON.stringify(req)\n    }, callback).catch(callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    fetchJSON(genDBUrl(host, ''), {method: 'DELETE'}).then(function (json) {\n      callback(null, json);\n    }).catch(function (err) {\n      /* istanbul ignore if */\n      if (err.status === 404) {\n        callback(null, {ok: true});\n      } else {\n        callback(err);\n      }\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nfunction HttpPouch$1 (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n}\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue$1() {\n  this.promise = new Promise(function (fulfill) {fulfill(); });\n}\nTaskQueue$1.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$1.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$1();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n    var ok, status;\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {\n        headers: new h({'Content-Type': 'application/json'}),\n        method: method,\n        body: JSON.stringify(body)\n      }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n        return response.json();\n      }).then(function (result) {\n        if (!ok) {\n          result.status = status;\n          throw generateErrorFromResponse(result);\n        }\n        // fail the entire request if the result contains an error\n        result.rows.forEach(function (row) {\n          /* istanbul ignore if */\n          if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n            throw new Error(row.reason);\n          }\n        });\n        return result;\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n\n    return db.fetch('_temp_view' + params, {\n      headers: new h({'Content-Type': 'application/json'}),\n      method: 'POST',\n      body: JSON.stringify(body)\n    }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n      return response.json();\n    }).then(function (result) {\n      if (!ok) {\n        result.status = status;\n        throw generateErrorFromResponse(result);\n      }\n      return result;\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new ExportedSet();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return Promise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$1();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue$1();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        return_docs: true,\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE$1) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new ExportedMap();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new ExportedMap();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new ExportedMap();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.fetch('_view_cleanup', {\n      headers: new h({'Content-Type': 'application/json'}),\n      method: 'POST'\n    }).then(function (response) {\n      return response.json();\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new ExportedMap();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction getBuiltIn(reduceFunString) {\n  if (/^_sum/.test(reduceFunString)) {\n    return builtInReduce._sum;\n  } else if (/^_count/.test(reduceFunString)) {\n    return builtInReduce._count;\n  } else if (/^_stats/.test(reduceFunString)) {\n    return builtInReduce._stats;\n  } else if (/^_/.test(reduceFunString)) {\n    throw new Error(reduceFunString + ' is not a supported reduce function.');\n  }\n}\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  var reduceFunString = reduceFun.toString();\n  var builtIn = getBuiltIn(reduceFunString);\n  if (builtIn) {\n    return builtIn;\n  } else {\n    return evalFunctionWithEval(reduceFunString);\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev) {\n  return /^1-/.test(rev);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return Promise.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return Promise.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return Promise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return Promise.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return Promise.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n  this.opts = opts || {};\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  if (this.opts.writeTargetCheckpoint) {\n    return updateCheckpoint(this.target, this.id, checkpoint,\n      session, this.returnValue);\n  } else {\n    return Promise.resolve(true);\n  }\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  if (this.opts.writeSourceCheckpoint) {\n    var self = this;\n    return updateCheckpoint(this.src, this.id, checkpoint,\n      session, this.returnValue)\n      .catch(function (err) {\n        if (isForbiddenError(err)) {\n          self.opts.writeSourceCheckpoint = false;\n          return true;\n        }\n        throw err;\n      });\n  } else {\n    return Promise.resolve(true);\n  }\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n\n  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {\n    return self.src.get(self.id).then(function (sourceDoc) {\n      return sourceDoc.last_seq || LOWEST_SEQ;\n    }).catch(function (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        throw err;\n      }\n      return LOWEST_SEQ;\n    });\n  }\n\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {\n      return targetDoc.last_seq || LOWEST_SEQ;\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.opts.writeSourceCheckpoint = false;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  /* istanbul ignore if */\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return Promise.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new Promise(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date().toISOString(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return Promise.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n          var errorName = (error.name || '').toLowerCase();\n          if (errorName === 'unauthorized' || errorName === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      // Attach 'pending' property if server supports it (CouchDB 2.0+)\n      /* istanbul ignore if */\n      if (typeof currentBatch.pending === 'number') {\n        outResult.pending = currentBatch.pending;\n        delete currentBatch.pending;\n      }\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date().toISOString();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n      var errorName = (fatalError.name || '').toLowerCase();\n      if (errorName === 'unauthorized' || errorName === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    // Attach 'pending' property if server supports it (CouchDB 2.0+)\n    /* istanbul ignore if */\n    if (typeof pending === 'number') {\n      pendingBatch.pending = pending;\n    }\n\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq || lastSeq;\n    pendingBatch.changes.push(change);\n    nextTick(function () {\n      processPendingBatch(batches.length === 0 && changesOpts.live);\n    });\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.results[changes.results.length - 1].seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, EventEmitter);\nfunction Replication() {\n  EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new Promise(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, EventEmitter);\nfunction sync(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = Promise.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      if (typeof this.replicateMethods === 'undefined') {\n        this.replicateMethods = {\n          from: function (other, opts, callback) {\n            return self.constructor.replicate(other, self, opts, callback);\n          },\n          to: function (other, opts, callback) {\n            return self.constructor.replicate(self, other, opts, callback);\n          }\n        };\n      }\n      return this.replicateMethods;\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB.plugin(IDBPouch)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\nexport default PouchDB;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-browser/lib/index.es.js\n// module id = 37\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 38\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-browser/node_modules/inherits/inherits_browser.js\n// module id = 39\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/uuid/v1.js\n// module id = 40\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/uuid/v4.js\n// module id = 41\n// module chunks = 0","'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/vuvuzela/index.js\n// module id = 42\n// module chunks = 0","import { clone, assign, nextTick, upsert, toPromise, isRemote } from 'pouchdb-utils';\nimport { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport { getFieldFromDoc, setFieldInDoc, parseField, getKey, getValue, compare, massageSelector, filterInMemoryFields } from 'pouchdb-selector-core';\nimport abstractMapReduce from 'pouchdb-abstract-mapreduce';\nimport { collate } from 'pouchdb-collate';\nimport { stringMd5 } from 'pouchdb-md5';\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n}\n\nfunction dbFetch(db, path, opts, callback) {\n  var status, ok;\n  opts.headers = new Headers({'Content-type': 'application/json'});\n  db.fetch(path, opts).then(function (response) {\n    status = response.status;\n    ok = response.ok;\n    return response.json();\n  }).then(function (json) {\n    if (!ok) {\n      json.status = status;\n      var err = generateErrorFromResponse(json);\n      callback(err);\n    } else {\n      callback(null, json);\n    }\n  }).catch(callback);\n}\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  dbFetch(db, '_index', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  dbFetch(db, '_find', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction explain(db, requestDef, callback) {\n  dbFetch(db, '_explain', {\n    method: 'POST',\n    body: JSON.stringify(requestDef)\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  dbFetch(db, '_index', {\n    method: 'GET'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n\n\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\n  dbFetch(db, url, {method: 'DELETE'}, callback);\n}\n\nfunction getArguments(fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  });\n}\n\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\n\nvar flatten = getArguments(function (args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n});\n\nfunction mergeObjects(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = assign(res, arr[i]);\n  }\n  return res;\n}\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = parseField(arr[i]);\n    var value = getFieldFromDoc(obj, parsedField);\n    if (typeof value !== 'undefined') {\n      setFieldInDoc(res, parsedField, value);\n    }\n  }\n  return res;\n}\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nfunction oneArrayIsSubArrayOfOther(left, right) {\n\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return oneArrayIsSubArrayOfOther(left, right);\n}\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n}\n\nfunction arrayToObject(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n}\n\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n}\n\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction uniq(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n}\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (typeof value === 'undefined') {\n          return; // don't emit\n        }\n      }\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (typeof value === 'undefined') {\n        return; // do nothing\n      }\n    }\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit) {\n  return function (doc) {\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createMapper(fields, emit) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit);\n    } else { // multi\n      return createShallowMultiMapper(fields, emit);\n    }\n  } else { // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit);\n    } else { // multi\n      return createDeepMultiMapper(fields, emit);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  var fields = Object.keys(mapFunDef.fields);\n\n  return createMapper(fields, emit);\n}\n\n/* istanbul ignore next */\nfunction reducer(/*reduceFunDef*/) {\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n      ' doesn\\'t have map.fields defined. ' +\n      'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce(\n  /* localDocName */ 'indexes',\n  mapper,\n  reducer,\n  ddocValidator\n);\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else { // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n      '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort? sort.map(getKey) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\n\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n\n  validateIndex(requestDef.index);\n\n  // calculating md5 is expensive - memoize and only\n  // run if required\n  var md5;\n  function getMd5() {\n    return md5 || (md5 = stringMd5(JSON.stringify(requestDef)));\n  }\n\n  var viewName = requestDef.name || ('idx-' + getMd5());\n\n  var ddocName = requestDef.ddoc || ('idx-' + getMd5());\n  var ddocId = '_design/' + ddocName;\n\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n\n    return doc;\n  }\n\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' +\n      ddocId +\n      '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper.query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uffff',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{_id: 'asc'}]\n        }\n      }]\n    };\n\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = {\"\\uffff\": {}};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return compare(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten(\n    // in-memory fields reported as necessary by the query planner\n    coreInMemoryFields,\n    // combine with another pass that checks for any we may have missed\n    getBasicInMemoryFields(index, selector, userFields),\n    // combine with another pass that checks for $ne's\n    getInMemoryFieldsFromNe(selector)\n  );\n\n  return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  if (typeof matcher === 'undefined') {\n    /* istanbul ignore next */\n    return true;\n  }\n\n  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n    return !(isNonLogicalMatcher(matcherKey));\n  });\n\n  if (!hasLogicalOperator) {\n    return false;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 &&\n    getKey(matcher) === '$ne';\n\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n\n  return indexes.reduce(function (res, index) {\n    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n    if (indexMatches) {\n      res.push(index);\n    }\n    return res;\n  }, []);\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    }\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n\n      if (index.ddoc === useIndexDdoc) {\n        /* istanbul ignore next */\n        return true;\n      }\n\n      return false;\n    });\n\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n    return index;\n  }\n\n  return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {key: userValue};\n    case '$lte':\n      return {endkey: userValue};\n    case '$gte':\n      return {startkey: userValue};\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]);\n  //ignoring this because the test to exercise the branch is skipped at the moment\n  /* istanbul ignore next */\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n\n  var userOperators = Object.keys(matcher);\n\n  var combinedOpts;\n\n  userOperators.forEach(function (userOperator) {\n\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n      return;\n    }\n\n    var userValue = matcher[userOperator];\n\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n\n  function finish(i) {\n\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    var matcher = selector[indexField];\n\n    if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (i > 0) {\n      if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n        finish(i);\n        break;\n      }\n      var usingGtlt = (\n        '$gt' in matcher || '$gte' in matcher ||\n        '$lt' in matcher || '$lte' in matcher);\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: {startkey: null},\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n\n  var selector = request.selector;\n  var sort = request.sort;\n\n  var userFieldsRes = getUserFields(selector, sort);\n\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  return db.allDocs(opts)\n  .then(function (res) {\n    // filter out any design docs that _all_docs might return\n    res.rows = res.rows.filter(function (row) {\n      return !/^_design\\//.test(row.id);\n    });\n    return res;\n  });\n}\n\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n\n  validateFindRequest(requestDef);\n\n  return getIndexes$1(db).then(function (getIndexesRes) {\n\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n\n    var indexToUse = queryPlan.index;\n\n    validateSort(requestDef, indexToUse);\n\n    var opts = assign({\n      include_docs: true,\n      reduce: false\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts &&\n        collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      /* istanbul ignore next */\n      return {docs: []};\n    }\n\n    var isDescending = requestDef.sort &&\n      typeof requestDef.sort[0] !== 'string' &&\n      getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    if (explain) {\n      return Promise.resolve(queryPlan, opts);\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper.query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'no matching index found, create an index to optimize query time';\n      }\n\n      return resp;\n    });\n  });\n}\n\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true)\n  .then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey,\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\", //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false, //hardcoded to match CouchDB since its not supported,\n        r: [49], // hardcoded to match CouchDB since its not support\n      },\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields,\n    };\n  });\n}\n\nfunction deleteIndex$1(db, index) {\n\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {_id: docId, _deleted: true};\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper.viewCleanup.apply(db);\n  }).then(function () {\n    return {ok: true};\n  });\n}\n\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\n\nvar plugin = {};\nplugin.createIndex = toPromise(function (requestDef, callback) {\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var createIndex$$1 = isRemote(this) ?\n    createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\n\nplugin.find = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var find$$1 = isRemote(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.explain = toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n\n  var find$$1 = isRemote(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.getIndexes = toPromise(function (callback) {\n\n  var getIndexes$$1 = isRemote(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\n\nplugin.deleteIndex = toPromise(function (indexDef, callback) {\n\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var deleteIndex$$1 = isRemote(this) ?\n    deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\n\nexport default plugin;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-find/lib/index-browser.es.js\n// module id = 43\n// module chunks = 0","import { clone } from 'pouchdb-utils';\nimport { collate } from 'pouchdb-collate';\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction setFieldInDoc(doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = {};\n  }\n  doc[parsedField[len-1]] = value;\n}\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nexport { massageSelector, matchesSelector, filterInMemoryFields, createFieldSorter, rowFilter, isCombinationalField, getKey, getValue, getFieldFromDoc, setFieldInDoc, compare, parseField };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-selector-core/lib/index.es.js\n// module id = 44\n// module chunks = 0","import { upsert, flatten, guardedConsole, nextTick, isRemote } from 'pouchdb-utils';\nimport { stringMd5 } from 'pouchdb-md5';\nimport { Set, Map } from 'pouchdb-collections';\nimport { base64StringToBlobOrBuffer } from 'pouchdb-binary-utils';\nimport { collate, toIndexableString, normalizeKey, parseIndexableString } from 'pouchdb-collate';\nimport { generateErrorFromResponse } from 'pouchdb-errors';\nimport { Headers } from 'pouchdb-fetch';\nimport { callbackify, sequentialize, uniq, fin, promisedCallback, mapToKeysArray, QueryParseError, NotFoundError, BuiltInError } from 'pouchdb-mapreduce-utils';\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue() {\n  this.promise = new Promise(function (fulfill) {fulfill(); });\n}\nTaskQueue.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = base64StringToBlobOrBuffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n    var ok, status;\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.fetch('_design/' + parts[0] + '/_view/' + parts[1] + params, {\n        headers: new Headers({'Content-Type': 'application/json'}),\n        method: method,\n        body: JSON.stringify(body)\n      }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n        return response.json();\n      }).then(function (result) {\n        if (!ok) {\n          result.status = status;\n          throw generateErrorFromResponse(result);\n        }\n        // fail the entire request if the result contains an error\n        result.rows.forEach(function (row) {\n          /* istanbul ignore if */\n          if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n            throw new Error(row.reason);\n          }\n        });\n        return result;\n      }).then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n\n    return db.fetch('_temp_view' + params, {\n      headers: new Headers({'Content-Type': 'application/json'}),\n      method: 'POST',\n      body: JSON.stringify(body)\n    }).then(function (response) {\n        ok = response.ok;\n        status = response.status;\n      return response.json();\n    }).then(function (result) {\n      if (!ok) {\n        result.status = status;\n        throw generateErrorFromResponse(result);\n      }\n      return result;\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new Set();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return Promise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        return_docs: true,\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new Map();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new Map();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new Map();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.fetch('_view_cleanup', {\n      headers: new Headers({'Content-Type': 'application/json'}),\n      method: 'POST'\n    }).then(function (response) {\n      return response.json();\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new Map();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new Set();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nexport default createAbstractMapReduce;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-abstract-mapreduce/lib/index.es.js\n// module id = 45\n// module chunks = 0","import inherits from 'inherits';\nimport { Set } from 'pouchdb-collections';\nimport argsarray from 'argsarray';\nimport { nextTick } from 'pouchdb-utils';\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return argsarray(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new Set(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nexport { uniq, sequentialize, fin, callbackify, promisedCallback, mapToKeysArray, QueryParseError, NotFoundError, BuiltInError };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/pouchdb-mapreduce-utils/lib/index.es.js\n// module id = 46\n// module chunks = 0","import { cozyFetchJSON } from './fetch'\n\nexport function diskUsage(cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/settings/disk-usage`)\n}\n\nexport function changePassphrase(cozy, currentPassPhrase, newPassPhrase) {\n  return cozyFetchJSON(cozy, 'PUT', `/settings/passphrase`, {\n    current_passphrase: currentPassPhrase,\n    new_passphrase: newPassPhrase\n  })\n}\n\nexport function getInstance(cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/settings/instance`)\n}\n\nexport function updateInstance(cozy, instance) {\n  return cozyFetchJSON(cozy, 'PUT', `/settings/instance`, instance)\n}\n\nexport function getClients(cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/settings/clients`)\n}\n\nexport function deleteClientById(cozy, id) {\n  return cozyFetchJSON(cozy, 'DELETE', `/settings/clients/${id}`)\n}\n\nexport function updateLastSync(cozy) {\n  return cozyFetchJSON(cozy, 'POST', '/settings/synchronized')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/settings.js","import { cozyFetchJSON, cozyFetchRawJSON } from './fetch'\nimport { DOCTYPE_FILES } from './doctypes'\n\nfunction updateRelations(verb) {\n  return function(cozy, doc, ids) {\n    if (!doc) throw new Error('missing doc argument')\n    if (!Array.isArray(ids)) ids = [ids]\n\n    const refs = ids.map(id => ({ type: DOCTYPE_FILES, id }))\n\n    return cozyFetchJSON(cozy, verb, makeReferencesPath(doc), { data: refs })\n  }\n}\n\nexport const addReferencedFiles = updateRelations('POST')\nexport const removeReferencedFiles = updateRelations('DELETE')\n\nexport function listReferencedFiles(cozy, doc) {\n  if (!doc) throw new Error('missing doc argument')\n  return cozyFetchJSON(cozy, 'GET', makeReferencesPath(doc)).then(files =>\n    files.map(file => file._id)\n  )\n}\n\nexport function fetchReferencedFiles(cozy, doc, options, sort) {\n  if (!doc) throw new Error('missing doc argument')\n  const params = Object.keys(options)\n    .map(key => {\n      const value = encodeURIComponent(JSON.stringify(options[key]))\n      return `&page[${key}]=${value}`\n    })\n    .join('')\n  // Datetime is the default sort, but 'id' is also available\n  if (!sort) {\n    sort = 'datetime'\n  }\n  return cozyFetchRawJSON(\n    cozy,\n    'GET',\n    `${makeReferencesPath(doc)}?include=files&sort=${sort}${params}`\n  )\n}\n\nfunction makeReferencesPath(doc) {\n  const type = encodeURIComponent(doc._type)\n  const id = encodeURIComponent(doc._id)\n  return `/data/${type}/${id}/relationships/references`\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/relations.js"],"sourceRoot":""}