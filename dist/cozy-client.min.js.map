{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///cozy-client.min.js","webpack:///webpack/bootstrap f8e327ef45269f91f28d","webpack:///./src/fetch.js","webpack:///./src/utils.js","webpack:///./src/doctypes.js","webpack:///./~/core-js/modules/_global.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/pouchdb-utils/lib/index-browser.js","webpack:///./~/argsarray/index.js","webpack:///./src/auth_v3.js","webpack:///./src/intents/helpers.js","webpack:///./~/core-js/modules/_core.js","webpack:///./~/core-js/modules/_descriptors.js","webpack:///./~/core-js/modules/_fails.js","webpack:///./~/core-js/modules/_is-object.js","webpack:///./~/immediate/lib/browser.js","webpack:///./~/pouchdb-collate/lib/index.js","webpack:///./~/pouchdb-collections/lib/index.js","webpack:///./~/pouchdb-promise/lib/index.js","webpack:///./src/intents/index.js","webpack:///./src/jsonapi.js","webpack:///./~/babel-runtime/regenerator/index.js","webpack:///./~/core-js/modules/_defined.js","webpack:///./~/core-js/modules/_has.js","webpack:///./~/core-js/modules/_hide.js","webpack:///./~/core-js/modules/_iobject.js","webpack:///./~/core-js/modules/_to-integer.js","webpack:///./~/core-js/modules/_to-iobject.js","webpack:///./~/core-js/modules/_uid.js","webpack:///./~/events/events.js","webpack:///./~/lie/lib/browser.js","webpack:///./~/pouchdb-binary-utils/lib/index-browser.js","webpack:///./~/pouchdb-md5/lib/index-browser.js","webpack:///./~/process/browser.js","webpack:///./~/spark-md5/spark-md5.js","webpack:///./~/uuid/index.js","webpack:///./~/uuid/lib/bytesToUuid.js","webpack:///./~/uuid/lib/rng-browser.js","webpack:///./src/auth_storage.js","webpack:///./src/auth_v2.js","webpack:///./src/data.js","webpack:///./src/files.js","webpack:///./src/index.js","webpack:///./src/intents/client.js","webpack:///./src/intents/service.js","webpack:///./src/jobs.js","webpack:///./src/mango.js","webpack:///./src/offline.js","webpack:///./src/relations.js","webpack:///./src/settings.js","webpack:///./~/babel-runtime/~/regenerator-runtime/runtime-module.js","webpack:///./~/babel-runtime/~/regenerator-runtime/runtime.js","webpack:///./~/core-js/modules/_a-function.js","webpack:///./~/core-js/modules/_an-object.js","webpack:///./~/core-js/modules/_array-includes.js","webpack:///./~/core-js/modules/_cof.js","webpack:///./~/core-js/modules/_ctx.js","webpack:///./~/core-js/modules/_dom-create.js","webpack:///./~/core-js/modules/_enum-bug-keys.js","webpack:///./~/core-js/modules/_export.js","webpack:///./~/core-js/modules/_ie8-dom-define.js","webpack:///./~/core-js/modules/_library.js","webpack:///./~/core-js/modules/_object-assign.js","webpack:///./~/core-js/modules/_object-dp.js","webpack:///./~/core-js/modules/_object-gops.js","webpack:///./~/core-js/modules/_object-keys-internal.js","webpack:///./~/core-js/modules/_object-keys.js","webpack:///./~/core-js/modules/_object-pie.js","webpack:///./~/core-js/modules/_property-desc.js","webpack:///./~/core-js/modules/_redefine.js","webpack:///./~/core-js/modules/_shared-key.js","webpack:///./~/core-js/modules/_shared.js","webpack:///./~/core-js/modules/_to-absolute-index.js","webpack:///./~/core-js/modules/_to-length.js","webpack:///./~/core-js/modules/_to-object.js","webpack:///./~/core-js/modules/_to-primitive.js","webpack:///./~/core-js/modules/es6.object.assign.js","webpack:///./~/isomorphic-fetch/fetch-npm-browserify.js","webpack:///./~/pouchdb-abstract-mapreduce/lib/index.js","webpack:///./~/pouchdb-find/lib/index-browser.js","webpack:///./~/pouchdb-mapreduce-utils/lib/index.js","webpack:///./~/pouchdb-selector-core/lib/index.js","webpack:///./~/pouchdb-utils/~/pouchdb-errors/lib/index.js","webpack:///./~/pouchdb/lib/index-browser.js","webpack:///./~/pouchdb/~/debug/src/browser.js","webpack:///./~/pouchdb/~/debug/src/debug.js","webpack:///./~/pouchdb/~/ms/index.js","webpack:///./~/uuid/v1.js","webpack:///./~/uuid/v4.js","webpack:///./~/vuvuzela/index.js","webpack:///./~/whatwg-fetch/fetch.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","cozyFetch","cozy","path","options","arguments","length","undefined","fullpath","then","resp","disableAuth","fetch","manualAuthCredentials","cozyFetchWithAuth","authorize","credentials","res","handleResponse","_invalidTokenErrorHandler","headers","token","toAuthHeader","Promise","all","isV2","_ref","_ref2","_slicedToArray","status","dontRetry","client","AccessToken","_utils","retry","_auth_v","refreshToken","newToken","saveCredentials","cozyFetchJSON","method","body","processJSONAPI","fetchJSON","response","handleJSONResponse","cozyFetchRawJSON","JSON","stringify","invalidTokenErrorHandler","ok","data","contentType","get","indexOf","json","text","err","error","FetchError","isInvalidToken","Error","jsonapi","handleInvalidTokenError","currentOrigin","window","location","origin","requestUrl","url","replace","redirectURL","encodeQuery","disconnect","e","console","warn","defineProperty","sliceIterator","arr","i","_arr","_n","_d","_e","_s","_i","Symbol","iterator","next","done","push","Array","isArray","_jsonapi","_jsonapi2","_Error","reason","_this","getPrototypeOf","captureStackTrace","name","message","isUnauthorized","isNotFound","unpromiser","fn","_len","args","_key","apply","isPromise","l","cb","isOnline","navigator","onLine","isOffline","sleep","time","resolve","setTimeout","count","delay","doTry","_len2","_key2","catch","getBackedoffDelay","getFuzzedDelay","retryDelay","fuzzingFactor","Math","random","FuzzFactor","retryCount","pow","createPath","doctype","query","route","encodeURIComponent","q","qname","decodeQuery","queryIndex","queries","fragIndex","queryStr","slice","parts","split","pair","decodeURIComponent","hasOwnProperty","warned","normalizeDoctype","isQualified","known","REVERSE_KNOWN","KNOWN_DOCTYPES","DOCTYPE_FILES","files","folder","contact","event","track","playlist","keys","forEach","k","global","Function","__g","ctor","superCtor","super_","TempCtor","_interopDefault","ex","isBinaryObject","object","ArrayBuffer","Blob","cloneArrayBuffer","buff","target","byteLength","targetArray","Uint8Array","sourceArray","set","cloneBinaryObject","size","type","webkitSlice","isPlainObject","proto","Ctor","funcToString","objectCtorString","clone","newObject","len","Date","toISOString","once","fun","called","getArguments","toPromise","func","usedCB","pop","promise","fulfill","reject","callback","mesg","result","logApiCall","listeners","logArgs","emit","origCallback","responseArgs","concat","adapterFun","_closed","_destroyed","taskqueue","isReady","addTask","failed","pick","prop","identityFunction","x","formatResultForOpenRevsGet","bulkGet","db","opts","collapseResultsAndFinish","results","perDocResults","docs","info","checkDone","numDone","numDocs","gotResult","docIndex","nextBatch","allRequests","upTo","min","MAX_NUM_CONCURRENT_REQUESTS","batch","processBatch","offset","docId","j","docIdx","docRequests","requestsById","docOpts","open_revs","map","request","rev","filter","formatResult","param","requests","pouchdbCollections","Map","has","key","isChromeApp","chrome","storage","local","hasLocalStorage","hasLocal","attachBrowserEvents","onChanged","addListener","db_name","dbName","newValue","addEventListener","attachEvent","Changes","events","EventEmitter","_listeners","guardedConsole","randomNumber","max","maxTimeout","parseInt","ratio","range","defaultBackOff","explainError","str","tryFilter","doc","req","msg","toString","pouchdbErrors","createError","BAD_REQUEST","filterChange","hasFilter","query_params","change","filterReturn","include_docs","attachments","att","_attachments","stub","flatten","arrs","f","invalidIdError","INVALID_ID","test","RESERVED_ID","MISSING_ID","isCordova","cordova","PhoneGap","phonegap","isRemote","_remote","listenerCount","ee","parseDesignDocFunctionName","s","normalizeDesignDocFunctionName","normalized","join","parseUri","parser","exec","uri","encoded","qName","qParser","$0","$1","$2","scopeEval","source","scope","values","upsert","diffFun","docRev","_rev","newDoc","_id","tryAndPut","updated","put","uuidV4","v4","toLowerCase","immediate","inherits","localStorage","setItem","getItem","eventFunction","onError","inprogress","changesOpts","changes","on","seq","since","cancelled","onChange","removeListener","notifyLocalWindows","notify","assign","to","index","nextSource","nextKey","assign$1","hasName","match","res$1","uuid","bulkGetShim","changesHandler","functionName","nextTick","normalizeDdocFunctionName","parseDdocFunctionName","argsArray","clientParams","_clientParams","Client","registerClient","cli","isRegistered","_fetch","toRegisterJSON","updateClient","resetSecret","client_id","clientID","client_secret","clientSecret","createClient","unregisterClient","getClient","oldClient","newClient","shouldPassRegistration","registrationAccessToken","getAuthCodeURL","scopes","state","generateRandomState","redirect_uri","redirectURI","response_type","_url","getAccessToken","pageURL","grantQueries","getGrantCodeFromPageURL","retrieveToken","grant_type","code","refresh_token","oauthFlow","onRegistered","clearAndRetry","tryCount","clear","registerNewClient","_getAuthCodeURL","save","StateKey","ignoreCachedCredentials","load","CredsKey","storedState","statePromise","t","delete","creds","Content-Type","href","buffer","crypto","getRandomValues","StateSize","randomBytes","floor","btoa","String","fromCharCode","AppToken","_createClass","defineProperties","props","descriptor","protoProps","staticProps","registration_access_token","redirect_uris","softwareID","software_id","softwareVersion","software_version","clientName","client_name","clientKind","client_kind","clientURI","client_uri","logoURI","logo_uri","policyURI","policy_uri","notificationPlatform","notification_platform","notificationDeviceToken","notification_device_token","tokenType","token_type","accessToken","access_token","pickService","intent","filterServices","services","attributes","filteredServices","first","errorSerializer","mapErrorProperties","from","nativeProperties","reduce","property","serialize","deserialize","core","version","__e","a","it","draining","oldQueue","queue","task","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","observer","element","document","createTextNode","observe","characterData","setImmediate","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","appendChild","channel","port1","onmessage","port2","postMessage","pad","padWith","upToLength","padding","targetLength","padLeft","collate","b","normalizeKey","ai","collationIndex","bi","stringCollate","arrayCollate","objectCollate","Infinity","isNaN","origKey","toJSON","val","indexify","numToIndexableString","toIndexableString","objKey","zero","SEP","parseNumber","num","originalIdx","neg","numAsString","magAsString","substring","MAGNITUDE_DIGITS","magnitude","MIN_MAGNITUDE","ch","parseFloat","stack","metaStack","lastMetaElement","lastElementIndex","parseIndexableString","parsedNum","parsedStr","arrayElement","objElement","sort","ak","bk","idx","expFormat","toExponential","magForComparison","magString","factor","abs","factorStr","toFixed","mangle","unmangle","Map$1","_store","Set$1","array","add","supportsMapAndSet","Set","getOwnPropertyDescriptor","species","mangled","lie","PouchPromise","_interopRequireWildcard","newObj","_asyncToGenerator","gen","step","arg","action","permissions","createPromise","start","onReadyCallback","createService","intentId","serviceWindow","service","removeQueryString","isSerializable","includes","_typeof","buildRedirectionURL","parameterStrings","redirect","getRedirectionURL","_regenerator","_regenerator2","mark","_callee","baseURL","wrap","_context","prev","sent","_helpers","abrupt","stop","_x3","_x4","_x5","_callee2","redirectFn","redirectionURL","_context2","_x6","_x7","_x8","_x9","_client","_service","indexKey","findByRef","resources","ref","handleResource","rawResource","links","resource","_type","meta","relations","rels","relationships","handleTopLevel","included","r","dP","createDesc","cof","propertyIsEnumerable","ceil","IObject","defined","px","_events","_maxListeners","isFunction","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","n","er","handler","context","listener","newListener","trace","g","fired","list","position","splice","removeAllListeners","ret","evlistener","emitter","INTERNAL","resolver","PENDING","outcome","safelyResolveThenable","QueueItem","onFulfilled","onRejected","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","returnValue","handlers","getThen","thenable","onSuccess","tryToUnwrap","tryCatch","out","iterable","allResolver","resolveFromAll","outValue","resolved","race","REJECTED","FULFILLED","createBlob","properties","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","append","getBlob","binaryStringToArrayBuffer","bin","buf","charCodeAt","binStringToBluffer","binString","b64ToBluffer","b64","thisAtob","arrayBufferToBinaryString","binary","bytes","readAsBinaryString","blob","FileReader","FileReaderSync","readAsArrayBuffer","reader","hasBinaryString","onloadend","blobToBinaryString","blobOrBuffer","blobToBase64","base64","thisBtoa","typedBuffer","atob","base64StringToBlobOrBuffer","binaryStringToBlobOrBuffer","blobOrBufferToBase64","blobOrBufferToBinaryString","rawToBase64","raw","pouchdbBinaryUtils","sliceBlob","end","appendBlob","arrayBuffer","appendString","string","appendBinary","binaryMd5","setImmediateShim","loadNextChunk","destroy","currentChunk","chunkSize","chunks","inputIsString","MD5_CHUNK_SIZE","Md5","stringMd5","hash","defaultSetTimout","defaultClearTimeout","runTimeout","cachedSetTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","currentQueue","queueIndex","drainQueue","timeout","run","Item","noop","process","title","browser","env","argv","versions","off","prependListener","prependOnceListener","binding","cwd","chdir","dir","umask","md5cycle","d","md5blk","md5blks","md5blk_array","md51","tail","tmp","lo","hi","md51_array","subarray","rhex","hex_chr","hex","toUtf8","unescape","utf8Str2ArrayBuffer","returnUInt8Array","arrayBuffer2Utf8Str","concatenateArrayBuffers","second","hexToBinaryString","substr","SparkMD5","reset","add32","y","lsw","msw","clamp","begin","contents","_buff","_length","_hash","_finish","getState","setState","hashBinary","content","v1","bytesToUuid","bth","byteToHex","bind","msCrypto","rnds8","rnds","LocalStorage","prefix","_this2","item","parse","_this3","removeItem","_this4","MemoryStorage","deleted","getAppToken","parent","receiver","appName","removeEventListener","V2TOKEN_ABORT_TIMEOUT","_doctypes","docType","httpVerb","find","NOREV","findMany","ids","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","rows","row","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","findAll","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","changesFeed","update","updateAttributes","tries","_delete","sanitizeFileName","trim","getFileTypeFromName","doUpload","isBuffer","isFile","File","isBlob","isStream","readable","pipe","isString","contentLength","checksum","lastModifiedDate","ifMatch","contentTypeOctetStream","toGMTString","dirID","executable","createDirectory","_ref3","getDirectoryOrCreate","parentDirectory","ROOT_DIR_ID","statByPath","parsedError","errors","createDirectoryByPath","offline","part","rootDirectoryPromise","statById","parentDirectoryPromise","updateById","doUpdateAttributes","attrs","_ref4","If-Match","updateAttributesById","updateAttributesByPath","trashById","_ref5","hasDatabase","getDatabase","selector","dir_id","_ref6","_ref7","children","TRASH_DIR_ID","sortFiles","addIsDir","toJsonApi","encodePageOptions","downloadById","downloadByPath","extractResponseLinkRelated","related","getDownloadLinkByPath","getDownloadLinkById","getFilePath","file","folderPath","endsWith","getCollectionShareLink","collectionType","verbs","collection","sharecode","codes","email","getArchiveLinkByPaths","paths","archive","getArchiveLinkByIds","listTrash","clearTrash","restoreById","destroyById","_ref8","isDir","allFiles","folders","localeCompare","nopOnRegistered","protoify","addToProto","ctx","disablePromises","attr","_auth_storage","_auth_v2","auth","_data","_mango","mango","_files","_intents","intents","_jobs","jobs","_offline","_settings","settings","_relations","AppTokenV3","AccessTokenV3","ClientV3","AuthNone","AuthRunning","AuthError","AuthOK","defaultClientParams","dataProto","defineIndex","addReferencedFiles","removeReferencedFiles","listReferencedFiles","fetchReferencedFiles","authProto","filesProto","getDownloadLink","getArchiveLink","queryFiles","intentsProto","jobsProto","queued","offlineProto","init","getDoctypes","createDatabase","destroyDatabase","destroyAllDatabase","hasReplication","replicateFromCozy","stopReplication","stopAllReplication","hasRepeatedReplication","startRepeatedReplication","stopRepeatedReplication","stopAllRepeatedReplication","settingsProto","diskUsage","changePassphrase","getInstance","updateInstance","getClients","deleteClientById","updateLastSync","ensureHasReconnectParam","URL","searchParams","search","AppTokenV2","_inited","_oauth","_token","_authstate","_authcreds","_storage","_version","oauth","_onRegistered","cozyURL","onInvalidTokenError","forceTokenRefresh","pathprefix","datasystem","hideIntentIframe","iframe","style","display","showIntentFrame","buildIntentIframe","ownerDocument","setAttribute","classList","intentClass","injectIntentIframe","onload","focus","connectIntentIframe","compose","_","_extends","exposeIntentFrameRemoval","_x","_x2","defaultView","serviceOrigin","src","handshaken","messageHandler","eventType","_event$data","removeIntentFrame","transition","dimensions","listenClientData","messageEventListener","maximize","height","_serviceWindow","terminated","sendMessage","composeEventListener","terminate","resizeClient","transitionProperty","maxHeight","clientHeight","maxWidth","clientWidth","cancel","getData","getIntent","eventName","throw","workerType","_defineProperty","fields","defineIndexV2","defineIndexV3","indexRef","queryV2","queryV3","getV3Options","wholeResponse","indexName","capitalize","indexDefinition","makeMapFunction","indexResult","$gt","makeMapReduceQuery","use_index","limit","skip","descending","charAt","toUpperCase","MAP_TEMPLATE","parseSelector","operator","acc","LOGICOPERATORS","VALUEOPERATORS","normalizeSelector","filters","_filter","op","field","applySelector","lower","COUCHDB_LOWEST","upper","COUCHDB_INFINITY","inclusiveEnd","startkey","endkey","inclusive_end","mrquery","firstFreeValueField","normalizedSelector","used","isFreeValue","FIELDSPLACEHOLDER","ï¿¿","_ref$options","_ref$doctypes","doctypes","getInfo","database","setDatabase","pluginLoaded","PouchDB","plugin","pouchdbFind","pouchdbAdapterCordovaSqlite","createIndexes","createIndex","getReplication","replication","setReplication","getReplicationUrl","basic","toBasicAuth","getReplicationPromise","replicationPromise","setReplicationPromise","live","replicationOfflineError","replicate","onComplete","getRepeatedReplication","interval","setRepeatedReplication","timer","setInterval","clearInterval","_pouchdb","_pouchdb2","_pouchdbFind","_pouchdbFind2","updateRelations","verb","refs","makeReferencesPath","params","currentPassPhrase","newPassPhrase","current_passphrase","new_passphrase","hadRuntime","regeneratorRuntime","getOwnPropertyNames","oldRuntime","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","Context","_invoke","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","AsyncIterator","invoke","record","hasOwn","__await","unwrapped","enqueue","callInvokeWithMethodAndArg","previousPromise","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","_sent","dispatchException","GenStateSuspendedYield","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","iteratorMethod","iteratorSymbol","Op","$Symbol","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","toStringTag","inModule","runtime","IteratorPrototype","getProto","NativeIteratorPrototype","Gp","displayName","isGeneratorFunction","genFun","awrap","async","iter","reverse","skipTempReset","rootEntry","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","toIObject","toLength","toAbsoluteIndex","IS_INCLUDES","$this","el","fromIndex","O","aFunction","that","is","hide","redefine","PROTOTYPE","$export","own","exp","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","P","IS_BIND","B","expProto","U","W","R","getKeys","gOPS","pIE","toObject","$assign","A","K","T","aLen","getSymbols","isEnum","anObject","IE8_DOM_DEFINE","toPrimitive","Attributes","getOwnPropertySymbols","arrayIndexOf","IE_PROTO","names","$keys","enumBugKeys","bitmap","SRC","TO_STRING","$toString","TPL","inspectSource","safe","shared","uid","SHARED","store","mode","copyright","toInteger","valueOf","TaskQueue","input","createViewSignature","mapFun","reduceFun","createView","sourceDB","viewName","temporary","localDocName","cachedViews","viewSignature","_cachedViews","promiseForView","diffFunction","views","fullViewName","depDbs","depDbName","pouchdbMd5","pouchdbUtils","registerDependentDatabase","auto_compaction","view","adapter","lastSeqDoc","parseViewName","isGenOne","emitError","createAbstractMapReduce","mapper","reducer","ddocValidator","tryMap","tryReduce","rereduce","output","sortByKeyThenValue","keyCompare","pouchdbCollate","sliceResults","rowToDocId","readAttachmentsAsBlobOrBuffer","atts","filename","content_type","postprocessAttachments","addHttpParam","paramName","asJson","coerceInteger","integerCandidate","asNumber","Number","coerceOptions","group_level","checkPositiveInteger","number","pouchdbMapreduceUtils","QueryParseError","checkQueryParseError","startkeyName","endkeyName","group","optionName","httpQuery","MAX_URL_LENGTH","keysAsString","customQuery","_query","customViewCleanup","_viewCleanup","defaultsTo","getDocsToPersist","docIdsToChangesAndEmits","getMetaDoc","defaultMetaDoc","metaDocId","getKeyValueDocs","metaDoc","allDocs","processKeyValueDocs","kvDocsRes","kvDocs","oldKeys","_deleted","indexableKeysToKeyValues","keyValue","newKeys","mapToKeysArray","kvDoc","uniq","docData","saveKeyValues","seqDocId","docIds","listOfDocsToPersist","docsToPersist","bulkDocs","getQueue","persistentQueues","updateView","sequentialize","updateViewInQueue","mapResults","processChange","processNextBatch","conflicts","currentSeq","CHANGES_BATCH_SIZE","createDocIdsToChangesAndEmits","createIndexableKeysToKeyValues","lastKey","emittedKeyValue","complexKey","reduceView","shouldGroup","groups","lvl","POSITIVE_INFINITY","last","groupKey","reduceTry","BuiltInError","queryView","queryViewInQueue","fetchFromView","viewOpts","totalRows","total_rows","expectedKeys","parsedKeyAndDocId","onMapResultsReady","finalResults","shouldReduce","update_seq","allDocsRes","docIdsToDocs","fetchPromises","start_key","end_key","keyStart","keyEnd","httpViewCleanup","localViewCleanup","docsToViews","designDocName","viewsToStatus","ddocName","viewDBNames","statusIsGood","viewDBName","dbsToDelete","destroyPromises","__opts","queryPromised","tempViewQueue","createViewPromise","fin","NotFoundError","stale","abstractQuery","promisedCallback","abstractViewCleanup","callbackify","viewCleanup","promiseFactory","massageCreateIndexRequest","requestDef","explain","getIndexes","deleteIndex","indexDef","ddoc","mergeObjects","parsedField","pouchdbSelectorCore","parseField","getFieldFromDoc","setFieldInDoc","oneArrayIsSubArrayOfOther","left","right","oneArrayIsStrictSubArrayOfOther","oneSetIsSubArrayOfOther","leftIdx","arrayToObject","maxScore","score","arrayEquals","arr1","arr2","createDeepMultiMapper","toEmit","iLen","jLen","createDeepSingleMapper","createShallowSingleMapper","createShallowMultiMapper","checkShallow","createMapper","isShallow","isSingle","mapFunDef","massageSort","sorting","massageUseIndex","useIndex","cleanedUseIndex","massageIndexDef","getKeyFromDoc","def","getKey","filterInclusiveStart","targetValue","indexFields","docKey","reverseOptions","newOpts","inclusive_start","validateIndex","ascFields","getValue","validateSort","defaultUsed","noneIdSorts","sortItem","validateFindRequest","getUserFields","userFields","selectorFields","sortFields","MAX_VALUE","rightIdx","sortOrder","createIndex$1","getMd5","md5","updateDdoc","language","hasInvalidLanguage","viewExists","originalIndexDef","ddocId","signature","abstractMapper","getIndexes$1","indexes","viewNames","compare","checkFieldInIndex","indexField","userOperatorLosesPrecision","matcher","userOperator","sortFieldsByIndex","aIdx","bIdx","getBasicInMemoryFields","needToFilterInMemory","getInMemoryFieldsFromNe","getInMemoryFields","coreInMemoryFields","checkIndexFieldsMatch","sortMatches","selectorMatches","isNonLogicalMatcher","logicalMatchers","checkFieldsLogicallySound","firstField","hasLogicalOperator","some","matcherKey","isInvalidNe","checkIndexMatches","fieldsMatch","findMatchingIndexes","indexMatches","findBestMatchingIndex","scoreIndex","userFieldsMap","matchingIndexes","defaultIndex","useIndexDdoc","useIndexName","getSingleFieldQueryOptsFor","userValue","getSingleFieldCoreQueryPlan","combinedOpts","inMemoryFields","userOperators","newQueryOpts","queryOpts","getMultiFieldCoreQueryPlan","getMultiFieldQueryOpts","inclusiveStart","COLLATE_LO","COLLATE_HI","usingGtlt","previousKeys","previousWasEq","previousWasSame","gtltLostSpecificity","getDefaultQueryPlan","getCoreQueryPlan","planQuery","userFieldsRes","coreQueryPlan","indexToSignature","doAllDocs","originalOpts","find$1","massageSelector","getIndexesRes","queryPlan","indexToUse","isDescending","filterInMemoryFields","warning","explain$1","dbname","bookmark","deleteIndex$1","deltaFun","abstractMapReduce","subArr","createIndexAsCallback","findAsCallback","explainAsCallback","getIndexesAsCallback","deleteIndexAsCallback","createIndex$$1","find$$1","getIndexes$$1","deleteIndex$$1","argsarray","finalPromiseFactory","theSet","elem","fieldName","current","isCombinationalField","combinationFields","mergeAndedSelectors","selectors","$eq","fieldMatchers","mergeGtGte","mergeLtLte","mergeNe","mergeEq","$gte","$lte","$lt","$ne","wasAnded","orOrNor","subSelector","createFieldSorter","getFieldValuesAsArray","docFieldValue","aRow","bRow","aFieldValues","bFieldValues","collation","rowFilter","fieldSorter","every","matchCominationalSelector","matchSelector","orMatchers","matchers","fieldExists","fieldIsNotUndefined","modField","divisor","mod","arrayContainsValue","arrayContainsAllValues","arraySize","regexMatch","re","RegExp","typeMatch","matchesSelector","rowsMatched","$elemMatch","$allMatch","$exists","$mod","neValue","$in","$nin","$size","$all","$regex","$type","PouchError","CustomPouchError","generateErrorFromResponse","UNKNOWN_ERROR","UNAUTHORIZED","MISSING_BULK_DOCS","MISSING_DOC","REV_CONFLICT","NOT_OPEN","BAD_ARG","INVALID_REQUEST","QUERY_PARSE_ERROR","DOC_VALIDATION","NOT_AN_OBJECT","DB_MISSING","IDB_ERROR","WSQ_ERROR","LDB_ERROR","FORBIDDEN","INVALID_REV","FILE_EXISTS","MISSING_STUB","INVALID_URL","ExportedMap","winningRev","metadata","winningId","winningPos","winningDeleted","node","toVisit","rev_tree","tree","branches","pos","traverseRevTree","revs","newCtx","sortByPos","collectLeaves","leaves","isLeaf","collectConflicts","win","leaf","compactTree","revHash","rootToLeaf","history","sortByPos$1","binarySearch","comparator","mid","low","high","insertSorted","pathToTree","numStemmed","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","tree1","tree2","merged","doMerge","dontExpand","restree","branch","t1","t2","diff","candidateParents","trees","parentIdx","elements","elementsLen","stem","depth","stemmedRevs","stemmed","merge","newTree","revExists","splitRev","targetPos","targetId","getTrees","isDeleted","isLocalId","latest","historyNode","historyRev","tryCatchInChangeListener","pending","lastSeq","Changes$2","onDestroy","isCancelled","validateChanges","changeList","_conflicts","yankError","cleanDocs","compareByIdThenRev","idCompare","aStart","_revisions","bStart","computeHeight","edges","prnt","rev$$1","edge","allDocsKeysParse","doNextCompaction","_compactionQueue","last_seq","_compact","shift","attachmentNameError","AbstractPouchDB","TaskQueue$1","parseAdapter","adapters","preferredAdapters","adapterName","usePrefix","use_prefix","prepareForDestruction","onDestroyed","from_constructor","onClosed","prefixedName","backend","_adapter","valid","fail","ready","setUpEventEmitter","Pouch","eventEmitter","destructListeners","_destructionListeners","dbList","debugPouch","debug","logs","logId","compare$1","evalFilter","evalView","validate","filterName","normalize","shouldFilter","doc_ids","doChanges","filterFun","applyChangesFilterPlugin","_changesFilterPlugin","parseRevisionInfo","makeRevTreeFromRevisions","revisions","revisionIds","parseDoc","newEdits","nRevNum","newRevId","revInfo","_rev_tree","specialKey","reservedWords","dataWords","parseBase64","preprocessString","blobType","asBinary","digest","preprocessBlob","preprocessAttachment","preprocessAttachments","docInfos","docv","overallErr","docInfo","processedAttachment","recv","updateDoc","revLimit","writeDoc","previousWinningRev","previouslyDeleted","isRoot","inConflict","newRev","rev_map","newRevIsDeleted","winningRev$$1","winningRevIsDeleted","delta","rootIsMissing","processDocs","api","fetchedDocs","tx","overallCallback","insertDoc","resultsIdx","checkAllDocsDone","docsDone","docsToDo","new_edits","idsToDocs","currentDoc","docWritten","nextDoc","safeJsonParse","vuvuzela","safeJsonStringify","idbError","evt","encodeMetadata","deletedOrLocal","decodeMetadata","storedObject","decodeDoc","_doc_id_rev","lastIndexOf","readBlobData","asBlob","fetchAttachmentsIfNecessary","txn","fetchAttachment","attObj","objectStore","ATTACH_STORE","onsuccess","postProcessAttachments","attNames","$inject_Object_assign","compactRevs","deleteOrphanedAttachments","possiblyOrphanedDigests","countReq","attAndSeqStore","IDBKeyRange","bound","attStore","seqStore","BY_SEQ_STORE","ATTACH_AND_SEQ_STORE","cursor","openCursor","only","digestSeq","primaryKey","continue","openTransactionSafely","idb","stores","transaction","idbBulkDocs","dbOpts","startTransaction","DOC_STORE","LOCAL_STORE","META_STORE","txnResult","onabort","ontimeout","oncomplete","docStore","bySeqStore","attachStore","attachAndSeqStore","metaStore","updateDocCountIfReady","verifyAttachments","preconditionErrored","fetchExistingDocs","onAllDocsProcessed","allDocsProcessed","idbProcessDocs","revs_limit","docCount","docCountDelta","numFetched","readMetadata","changesHandler$$1","_meta","verifyAttachment","digests","attErr","isUpdate","hasAttachments","writeAttachments","finishDoc","afterPutDoc","revsToDelete","metadataToStore","metaDataReq","afterPutMetadata","afterPutDocError","preventDefault","stopPropagation","getKeyReq","putReq","insertAttachmentMappings","onerror","collectResults","attachmentSaved","revpos","saveAttachment","attsAdded","attsToAdd","newAtt","docInfoError","blobSupport","runBatchedCursor","keyRange","batchSize","onBatch","onGetAll","valuesBatch","keysBatch","pseudoCursor","onGetAllKeys","continuePseudoCursor","newKeyRange","upperOpen","lowerBound","getAll","getAllKeys","onCursor","useGetAll","allDocsKeys","createKeyRange","upperBound","idbAllDocs","getMaxUpdateSeq","maxKey","fetchDocAsynchronously","docIdRevIndex","allDocsInner","batchValues","batchValue","batchKeys","onResultsReady","returnVal","updateSeq","onTxnComplete","keyRangeError","checkBlobSupport","blob$$1","DETECT_BLOB_SUPPORT_STORE","matchedChrome","userAgent","matchedEdge","countDocs","tryCode","applyNext","running","enqueueTask","processMetadataAndWinningDoc","winningDoc","filtered","numResults","returnDocs","onBatchDone","winningDocs","metadatas","fetchWinningDocAndMetadata","onGetMetadata","docIdRev","docIdsToMetadata","continuous","ExportedSet","return_docs","objectStores","IdbPouch","thisCallback","createSchema","createObjectStore","keyPath","autoIncrement","unique","addDeletedOrLocalIndex","createLocalStoreSchema","migrateLocalStore","localStore","seqCursor","addAttachAndSeqStore","migrateAttsAndSeqs","digestMap","migrateMetadata","decodeMetadataCompat","fetchMetadataSeq","metadataSeq","onGetMetadataSeq","instanceId","_bulkDocs","reqOpts","_get","_getAttachment","attachId","attachment","blobData","_info","doc_count","idb_attachment_format","_allDocs","_changes","_close","close","cachedDBs","_getRevisionTree","_doCompaction","_getLocal","_putLocal","oldRev","oStore","oldDoc","_removeLocal","_destroy","openReq","openReqList","indexedDB","deleteDatabase","cached","tryStorageOption","open","ADAPTER_VERSION","onupgradeneeded","migration","migrations","oldVersion","currentTarget","completeSetup","storedMetaDoc","storeMetaDocIfReady","instanceKey","onversionchange","blobSupportPromise","IDBPouch","decodeUtf8","escape","hexToInt","charCode","parseHexUtf8","parseHexUtf16","parseHexString","encoding","quote","escapeBlob","unescapeBlob","stringifyDoc","unstringifyDoc","qMarks","select","table","joiner","where","orderBy","compactRevs$1","deleteOrphans","seqs","sql","ATTACH_AND_SEQ_STORE$1","executeSql","digestsToCheck","nonOrphanedDigests","ATTACH_STORE$1","BY_SEQ_STORE$1","websqlError","errorNameMatch","errorName","errorReason","getSize","isAndroid","websqlBulkDocs","websqlChanges","_name","cnt","sqlArgs","deletedInt","insertId","dataWritten","fetchSql","attachmentErr","revsToCompact","DOC_STORE$1","metadataStr","websqlProcessDocs","userDocs","docInfoErrors","openDatabaseWithOpts","websql","description","openDBSafely","openDB","cachedResult","cachedDatabases","fetchAttachmentsIfNecessary$1","attOpts","WebSqlPouch","dbCreated","runMigration2","DOC_STORE_WINNINGSEQ_INDEX_SQL","BY_SEQ_STORE_DELETED_INDEX_SQL","runMigration3","LOCAL_STORE$1","doNext","runMigration4","updateRows","doc_id_rev","doc_id","BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL","runMigration5","nextPage","SELECT_DOCS","DOC_STORE_AND_BY_SEQ_JOINER","pageSize","addDigestSeq","digestSeqs","digestSeqPairs","attachAndRev","ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL","ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL","runMigration6","runMigration7","checkEncoding","onGetInstanceId","idRequests","idCallback","onGetVersion","dbVersion","META_STORE$1","attach","initSeq","initSeqArgs","ADAPTER_VERSION$1","setupDone","migrated","dbid","tasks","nextMigration","setup","fetchVersion","db_version","getMaxSeq","latest$$1","websqlOpts","POUCH_VERSION","openDBResult","readTransaction","theSeq","theDocCount","websql_encoding","latestRev","missingErr","deletedErr","criteria","destinctKeys","bindingStr","fetchChanges","selectStmt","reportChange","maxSeq","escaped","putLocal","rowsAffected","removeLocal","canOpenTestDB","openDatabase","isValidWebSQL","hasLS","localStorageKey","openedTestDB","openDB$2","WebSQLPouch","_opts","WebSqlPouch$1","wrappedFetch","wrappedPromise","fetchRequest","Headers","fetchOptions","processData","fetchResponse","statusCode","abort","xhRequest","xhr","timedout","abortReq","cleanUp","timeoutReq","onprogress","upload","XMLHttpRequest","withCredentials","Accept","responseType","setRequestHeader","readyState","getResponseHeader","responseText","send","testXhr","ajax","hasXhr","defaultBody","ajaxCore","v","missing","defaultOptions","cache","ajax$1","ua","isSafari","isIE","isTrident","isEdge","shouldCacheBust","isBlobUrl","hasArgs","now","pool","promiseFactories","runNext","runNextBatch","thisErr","encodeDocId","preprocessAttachments$2","hasUrlPrefix","protocol","getHost","user","password","username","genDBUrl","genUrl","pathDel","host","port","paramsToStr","HttpPouch","userOpts","reqAjax","ajaxOpts","defaultHeaders","_ajax","ajaxPromise","adapterFun$$1","skipSetup","skip_setup","setupPromise","checkExists","dbUrl","encodeAttachmentId","attachmentId","nAuth","Authorization","uuid$$1","compact","ping","compact_running","doBulkGet","doBulkGetShim","onResult","batchNum","numBatches","MAX_SIMULTANEOUS_REVS","subOpts","supportsBulkGet","supportsBulkGetMap","fetchAttachments","filenames","fetchAllAttachments","docOrDocs","revs_info","remove","docOrId","optsOrRev","getAttachment","removeAttachment","putAttachment","_put","paramStr","batch_size","heartbeat","DEFAULT_HEARTBEAT","requestTimeout","CHANGES_TIMEOUT_BUFFER","leftToFetch","feed","seq_interval","param_name","lastFetchedSeq","aborted","xhrOpts","fetched","raw_results_length","finished","revsDiff","HttpPouch$1","createBuiltInError","sum","jNum","evalFunctionWithEval","log","TaskQueue$2","CHANGES_BATCH_SIZE$1","getBuiltIn","reduceFunString","builtInReduce","_sum","_count","_stats","origMap","builtIn","abstract","isGenOne$1","fileHasChanged","localDoc","remoteDoc","getDocAttachments","getDocAttachmentsFromTargetOrSource","doCheckForLocalAttachments","createBulkGetOpts","diffs","missingRevs","missingRev","getDocs","getAllDocs","bulkGetOpts","bulkGetResponse","bulkGetInfo","resultDocs","Boolean","hasConflicts","fetchRevisionOneDocs","getRevisionOneDocs","returnResult","updateCheckpoint","checkpoint","session","session_id","replicator","REPLICATOR","CHECKPOINT_VERSION","unshift","CHECKPOINT_HISTORY_SIZE","Checkpointer","compareReplicationLogs","srcDoc","tgtDoc","compareReplicationHistory","sourceHistory","targetHistory","sourceRest","targetRest","LOWEST_SEQ","sourceId","hasSessionId","sessionId","rest","isForbiddenError","backOff","back_off_function","backOffSet","current_back_off","STARTING_BACK_OFF","removeBackOffSetter","sortObjectPropertiesByKey","queryParams","generateReplicationId","filterViewName","queryData","md5sum","initCheckpointer","checkpointer","repId","checkpointOpts","writeSourceCheckpoint","writeTargetCheckpoint","writeDocs","changedDocs","currentBatch","bulkOpts","completeReplication","errorsById","errorsNo","doc_write_failures","docs_written","finishBatch","outResult","writingCheckpoint","writeCheckpoint","getChanges","onCheckpointError","getDiffs","getBatchDocs","got","docs_read","startNextBatch","batches","processPendingBatch","abortReplication","pendingBatch","changesCompleted","replicationCompleted","fatalError","end_time","onChangesComplete","changesPending","onChangesError","abortChanges","batches_limit","_abortChanges","startChanges","getCheckpoint","start_time","_addedListeners","Replication","toPouch","PouchConstructor","replicateWrapper","replicateRet","srcPouch","targetPouch","sync$1","Sync","pullChange","direction","pushChange","pushDenied","pullDenied","pushPaused","pullPaused","pushActive","pullActive","removeAll","isChange","isDenied","isPaused","isActive","removed","addOneListener","canceled","optsPush","optsPull","pull","success","sync","replicateMethods","other","newPromise","post","transformForceOptionToNewEditsOption","oldRevId","oldRevNum","newRevNum","putDoc","force","createAttachment","prevrevpos","was_delete","addToMissing","revId","processDoc","missingForId","missingObj","compactDocument","revTree","candidates","promises","finishOpenRevs","existing","splittedRev","revNo","currentPath","hashIndex","hashFoundAtRevPos","indexOfRev","howMany","_revs_info","incompatibleOpt","attachmentError","dependentDb","dependentDbs","depDB","destroyDb","deletedMap","trueName","execute","addToPreferredAdapters","__defaults","defaults","defaultOpts","PouchAlt","platform","hasFetch","sumsqr","_sumsqr","mapreduce","updateTarget","updateSource","comparisons","targetDoc","sourceDoc","1","cleanup","_readyCalled","useColors","WebkitAppearance","firebug","formatArgs","namespace","humanize","color","lastC","namespaces","DEBUG","localstorage","colors","formatters","enable","selectColor","createDebug","enabled","curr","ms","prevTime","coerce","format","formatter","logFn","instances","skips","disable","h","fmtShort","round","fmtLong","plural","long","_nodeId","clockseq","_clockseq","seedBytes","rng","msecs","getTime","nsecs","_lastNSecs","dt","_lastMSecs","tl","tmh","ii","arrayPrefix","objPrefix","numChar","parsedString","lastCh","numConsecutiveSlashes","normalizeName","normalizeValue","iteratorFor","items","support","header","consumed","bodyUsed","fileReaderReady","readBlobAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","chars","bufferClone","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","URLSearchParams","isDataView","_bodyArrayBuffer","isArrayBufferView","rejected","decode","normalizeMethod","upcased","methods","Request","referrer","form","parseHeaders","rawHeaders","preProcessedHeaders","line","Response","bodyInit","statusText","viewClasses","DataView","isView","oldValue","thisArg","entries","redirectStatuses","RangeError","getAllResponseHeaders","responseURL","polyfill"],"mappings":"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","file":"cozy-client.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"client\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"client\"] = factory();\n\telse\n\t\troot[\"cozy\"] = root[\"cozy\"] || {}, root[\"cozy\"][\"client\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"client\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"client\"] = factory();\n\telse\n\t\troot[\"cozy\"] = root[\"cozy\"] || {}, root[\"cozy\"][\"client\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(76);\n\tmodule.exports = __webpack_require__(41);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.FetchError = undefined;\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* global fetch */\n\t\n\t\n\texports.cozyFetch = cozyFetch;\n\texports.cozyFetchJSON = cozyFetchJSON;\n\texports.cozyFetchRawJSON = cozyFetchRawJSON;\n\texports.handleInvalidTokenError = handleInvalidTokenError;\n\t\n\tvar _auth_v = __webpack_require__(8);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _jsonapi = __webpack_require__(19);\n\t\n\tvar _jsonapi2 = _interopRequireDefault(_jsonapi);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction cozyFetch(cozy, path) {\n\t  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  return cozy.fullpath(path).then(function (fullpath) {\n\t    var resp = void 0;\n\t    if (options.disableAuth) {\n\t      resp = fetch(fullpath, options);\n\t    } else if (options.manualAuthCredentials) {\n\t      resp = cozyFetchWithAuth(cozy, fullpath, options, options.manualAuthCredentials);\n\t    } else {\n\t      resp = cozy.authorize().then(function (credentials) {\n\t        return cozyFetchWithAuth(cozy, fullpath, options, credentials);\n\t      });\n\t    }\n\t    return resp.then(function (res) {\n\t      return handleResponse(res, cozy._invalidTokenErrorHandler);\n\t    });\n\t  });\n\t}\n\t\n\tfunction cozyFetchWithAuth(cozy, fullpath, options, credentials) {\n\t  if (credentials) {\n\t    options.headers = options.headers || {};\n\t    options.headers['Authorization'] = credentials.token.toAuthHeader();\n\t  }\n\t\n\t  // the option credentials:include tells fetch to include the cookies in the\n\t  // request even for cross-origin requests\n\t  options.credentials = 'include';\n\t\n\t  return Promise.all([cozy.isV2(), fetch(fullpath, options)]).then(function (_ref) {\n\t    var _ref2 = _slicedToArray(_ref, 2),\n\t        isV2 = _ref2[0],\n\t        res = _ref2[1];\n\t\n\t    if (res.status !== 400 && res.status !== 401 || isV2 || !credentials || options.dontRetry) {\n\t      return res;\n\t    }\n\t    // we try to refresh the token only for OAuth, ie, the client defined\n\t    // and the token is an instance of AccessToken.\n\t    var client = credentials.client,\n\t        token = credentials.token;\n\t\n\t    if (!client || !(token instanceof _auth_v.AccessToken)) {\n\t      return res;\n\t    }\n\t    options.dontRetry = true;\n\t    return (0, _utils.retry)(function () {\n\t      return (0, _auth_v.refreshToken)(cozy, client, token);\n\t    }, 3)().then(function (newToken) {\n\t      return cozy.saveCredentials(client, newToken);\n\t    }).then(function (credentials) {\n\t      return cozyFetchWithAuth(cozy, fullpath, options, credentials);\n\t    });\n\t  });\n\t}\n\t\n\tfunction cozyFetchJSON(cozy, method, path, body) {\n\t  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\t\n\t  var processJSONAPI = typeof options.processJSONAPI === 'undefined' || options.processJSONAPI;\n\t  return fetchJSON(cozy, method, path, body, options).then(function (response) {\n\t    return handleJSONResponse(response, processJSONAPI);\n\t  });\n\t}\n\t\n\tfunction cozyFetchRawJSON(cozy, method, path, body) {\n\t  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\t\n\t  return fetchJSON(cozy, method, path, body, options).then(function (response) {\n\t    return handleJSONResponse(response, false);\n\t  });\n\t}\n\t\n\tfunction fetchJSON(cozy, method, path, body) {\n\t  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\t\n\t  options.method = method;\n\t\n\t  var headers = options.headers = options.headers || {};\n\t\n\t  headers['Accept'] = 'application/json';\n\t\n\t  if (method !== 'GET' && method !== 'HEAD' && body !== undefined) {\n\t    if (headers['Content-Type']) {\n\t      options.body = body;\n\t    } else {\n\t      headers['Content-Type'] = 'application/json';\n\t      options.body = JSON.stringify(body);\n\t    }\n\t  }\n\t\n\t  return cozyFetch(cozy, path, options);\n\t}\n\t\n\tfunction handleResponse(res, invalidTokenErrorHandler) {\n\t  if (res.ok) {\n\t    return res;\n\t  }\n\t  var data = void 0;\n\t  var contentType = res.headers.get('content-type');\n\t  if (contentType && contentType.indexOf('json') >= 0) {\n\t    data = res.json();\n\t  } else {\n\t    data = res.text();\n\t  }\n\t  return data.then(function (err) {\n\t    var error = new FetchError(res, err);\n\t    if (FetchError.isInvalidToken(error) && invalidTokenErrorHandler) {\n\t      invalidTokenErrorHandler(error);\n\t    }\n\t    throw error;\n\t  });\n\t}\n\t\n\tfunction handleJSONResponse(res) {\n\t  var processJSONAPI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t  var contentType = res.headers.get('content-type');\n\t  if (!contentType || contentType.indexOf('json') < 0) {\n\t    return res.text(function (data) {\n\t      throw new FetchError(res, new Error('Response is not JSON: ' + data));\n\t    });\n\t  }\n\t\n\t  var json = res.json();\n\t  if (contentType.indexOf('application/vnd.api+json') === 0 && processJSONAPI) {\n\t    return json.then(_jsonapi2.default);\n\t  } else {\n\t    return json;\n\t  }\n\t}\n\t\n\tfunction handleInvalidTokenError(error) {\n\t  try {\n\t    var currentOrigin = window.location.origin;\n\t    var requestUrl = error.url;\n\t\n\t    if (requestUrl.indexOf(currentOrigin.replace(/^(https?:\\/\\/\\w+)-\\w+\\./, '$1.')) === 0) {\n\t      var redirectURL = currentOrigin + '?' + (0, _utils.encodeQuery)({ disconnect: 1 });\n\t      window.location = redirectURL;\n\t    }\n\t  } catch (e) {\n\t    console.warn('Unable to handle invalid token error', e, error);\n\t  }\n\t}\n\t\n\tvar FetchError = exports.FetchError = function (_Error) {\n\t  _inherits(FetchError, _Error);\n\t\n\t  function FetchError(res, reason) {\n\t    _classCallCheck(this, FetchError);\n\t\n\t    var _this = _possibleConstructorReturn(this, (FetchError.__proto__ || Object.getPrototypeOf(FetchError)).call(this));\n\t\n\t    if (Error.captureStackTrace) {\n\t      Error.captureStackTrace(_this, _this.constructor);\n\t    }\n\t    // XXX We have to hardcode this because babel doesn't play nice when extending Error\n\t    _this.name = 'FetchError';\n\t    _this.response = res;\n\t    _this.url = res.url;\n\t    _this.status = res.status;\n\t    _this.reason = reason;\n\t\n\t    Object.defineProperty(_this, 'message', {\n\t      value: reason.message || (typeof reason === 'string' ? reason : JSON.stringify(reason))\n\t    });\n\t    return _this;\n\t  }\n\t\n\t  return FetchError;\n\t}(Error);\n\t\n\tFetchError.isUnauthorized = function (err) {\n\t  // XXX We can't use err instanceof FetchError because of the caveats of babel\n\t  return err.name === 'FetchError' && err.status === 401;\n\t};\n\t\n\tFetchError.isNotFound = function (err) {\n\t  // XXX We can't use err instanceof FetchError because of the caveats of babel\n\t  return err.name === 'FetchError' && err.status === 404;\n\t};\n\t\n\tFetchError.isInvalidToken = function (err) {\n\t  // XXX We can't use err instanceof FetchError because of the caveats of babel\n\t  return err.name === 'FetchError' && err.status === 400 && err.reason && (err.reason.error === 'Invalid JWT token' || err.reason.error === 'Expired token');\n\t};\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.unpromiser = unpromiser;\n\texports.isPromise = isPromise;\n\texports.isOnline = isOnline;\n\texports.isOffline = isOffline;\n\texports.sleep = sleep;\n\texports.retry = retry;\n\texports.getFuzzedDelay = getFuzzedDelay;\n\texports.getBackedoffDelay = getBackedoffDelay;\n\texports.createPath = createPath;\n\texports.encodeQuery = encodeQuery;\n\texports.decodeQuery = decodeQuery;\n\texports.warn = warn;\n\t/* global navigator */\n\tvar FuzzFactor = 0.3;\n\t\n\tfunction unpromiser(fn) {\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    var value = fn.apply(this, args);\n\t    if (!isPromise(value)) {\n\t      return value;\n\t    }\n\t    var l = args.length;\n\t    if (l === 0 || typeof args[l - 1] !== 'function') {\n\t      return;\n\t    }\n\t    var cb = args[l - 1];\n\t    value.then(function (res) {\n\t      return cb(null, res);\n\t    }, function (err) {\n\t      return cb(err, null);\n\t    });\n\t  };\n\t}\n\t\n\tfunction isPromise(value) {\n\t  return !!value && typeof value.then === 'function';\n\t}\n\t\n\tfunction isOnline() {\n\t  return typeof navigator !== 'undefined' ? navigator.onLine : true;\n\t}\n\t\n\tfunction isOffline() {\n\t  return !isOnline();\n\t}\n\t\n\tfunction sleep(time, args) {\n\t  return new Promise(function (resolve) {\n\t    setTimeout(resolve, time, args);\n\t  });\n\t}\n\t\n\tfunction retry(fn, count) {\n\t  var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;\n\t\n\t  return function doTry() {\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    return fn.apply(undefined, args).catch(function (err) {\n\t      if (--count < 0) {\n\t        throw err;\n\t      }\n\t      return sleep(getBackedoffDelay(delay, count)).then(function () {\n\t        return doTry.apply(undefined, args);\n\t      });\n\t    });\n\t  };\n\t}\n\t\n\tfunction getFuzzedDelay(retryDelay) {\n\t  var fuzzingFactor = (Math.random() * 2 - 1) * FuzzFactor;\n\t  return retryDelay * (1.0 + fuzzingFactor);\n\t}\n\t\n\tfunction getBackedoffDelay(retryDelay) {\n\t  var retryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\t\n\t  return getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1));\n\t}\n\t\n\tfunction createPath(cozy, isV2, doctype) {\n\t  var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\t  var query = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\t\n\t  var route = '/data/';\n\t  if (!isV2) {\n\t    route += encodeURIComponent(doctype) + '/';\n\t  }\n\t  if (id !== '') {\n\t    route += encodeURIComponent(id);\n\t  }\n\t  var q = encodeQuery(query);\n\t  if (q !== '') {\n\t    route += '?' + q;\n\t  }\n\t  return route;\n\t}\n\t\n\tfunction encodeQuery(query) {\n\t  if (!query) {\n\t    return '';\n\t  }\n\t  var q = '';\n\t  for (var qname in query) {\n\t    if (q !== '') {\n\t      q += '&';\n\t    }\n\t    q += encodeURIComponent(qname) + '=' + encodeURIComponent(query[qname]);\n\t  }\n\t  return q;\n\t}\n\t\n\tfunction decodeQuery(url) {\n\t  var queryIndex = url.indexOf('?');\n\t  if (queryIndex < 0) {\n\t    queryIndex = url.length;\n\t  }\n\t  var queries = {};\n\t  var fragIndex = url.indexOf('#');\n\t  if (fragIndex < 0) {\n\t    fragIndex = url.length;\n\t  }\n\t  if (fragIndex < queryIndex) {\n\t    return queries;\n\t  }\n\t  var queryStr = url.slice(queryIndex + 1, fragIndex);\n\t  if (queryStr === '') {\n\t    return queries;\n\t  }\n\t  var parts = queryStr.split('&');\n\t  for (var i = 0; i < parts.length; i++) {\n\t    var pair = parts[i].split('=');\n\t    if (pair.length === 0 || pair[0] === '') {\n\t      continue;\n\t    }\n\t    var qname = decodeURIComponent(pair[0]);\n\t    if (queries.hasOwnProperty(qname)) {\n\t      continue;\n\t    }\n\t    if (pair.length === 1) {\n\t      queries[qname] = true;\n\t    } else if (pair.length === 2) {\n\t      queries[qname] = decodeURIComponent(pair[1]);\n\t    } else {\n\t      throw new Error('Malformed URL');\n\t    }\n\t  }\n\t  return queries;\n\t}\n\t\n\tvar warned = [];\n\tfunction warn(text) {\n\t  if (warned.indexOf(text) === -1) {\n\t    warned.push(text);\n\t    console.warn('cozy-client-js', text);\n\t  }\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.DOCTYPE_FILES = undefined;\n\texports.normalizeDoctype = normalizeDoctype;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar DOCTYPE_FILES = exports.DOCTYPE_FILES = 'io.cozy.files';\n\t\n\tvar KNOWN_DOCTYPES = {\n\t  files: DOCTYPE_FILES,\n\t  folder: DOCTYPE_FILES,\n\t  contact: 'io.cozy.contacts',\n\t  event: 'io.cozy.events',\n\t  track: 'io.cozy.labs.music.track',\n\t  playlist: 'io.cozy.labs.music.playlist'\n\t};\n\t\n\tvar REVERSE_KNOWN = {};\n\tObject.keys(KNOWN_DOCTYPES).forEach(function (k) {\n\t  REVERSE_KNOWN[KNOWN_DOCTYPES[k]] = k;\n\t});\n\t\n\tfunction normalizeDoctype(cozy, isV2, doctype) {\n\t  var isQualified = doctype.indexOf('.') !== -1;\n\t  if (isV2 && isQualified) {\n\t    var known = REVERSE_KNOWN[doctype];\n\t    if (known) return known;\n\t    return doctype.replace(/\\./g, '-');\n\t  }\n\t  if (!isV2 && !isQualified) {\n\t    var _known = KNOWN_DOCTYPES[doctype];\n\t    if (_known) {\n\t      (0, _utils.warn)('you are using a non-qualified doctype ' + doctype + ' assumed to be ' + _known);\n\t      return _known;\n\t    }\n\t    throw new Error('Doctype ' + doctype + ' should be qualified.');\n\t  }\n\t  return doctype;\n\t}\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self\n\t  // eslint-disable-next-line no-new-func\n\t  : Function('return this')();\n\tif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar getArguments = _interopDefault(__webpack_require__(7));\n\tvar Promise = _interopDefault(__webpack_require__(17));\n\tvar pouchdbCollections = __webpack_require__(16);\n\tvar immediate = _interopDefault(__webpack_require__(14));\n\tvar events = __webpack_require__(28);\n\tvar inherits = _interopDefault(__webpack_require__(5));\n\tvar pouchdbErrors = __webpack_require__(81);\n\tvar uuidV4 = _interopDefault(__webpack_require__(34));\n\t\n\tfunction isBinaryObject(object) {\n\t  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n\t    (typeof Blob !== 'undefined' && object instanceof Blob);\n\t}\n\t\n\tfunction cloneArrayBuffer(buff) {\n\t  if (typeof buff.slice === 'function') {\n\t    return buff.slice(0);\n\t  }\n\t  // IE10-11 slice() polyfill\n\t  var target = new ArrayBuffer(buff.byteLength);\n\t  var targetArray = new Uint8Array(target);\n\t  var sourceArray = new Uint8Array(buff);\n\t  targetArray.set(sourceArray);\n\t  return target;\n\t}\n\t\n\tfunction cloneBinaryObject(object) {\n\t  if (object instanceof ArrayBuffer) {\n\t    return cloneArrayBuffer(object);\n\t  }\n\t  var size = object.size;\n\t  var type = object.type;\n\t  // Blob\n\t  if (typeof object.slice === 'function') {\n\t    return object.slice(0, size, type);\n\t  }\n\t  // PhantomJS slice() replacement\n\t  return object.webkitSlice(0, size, type);\n\t}\n\t\n\t// most of this is borrowed from lodash.isPlainObject:\n\t// https://github.com/fis-components/lodash.isplainobject/\n\t// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\t\n\tvar funcToString = Function.prototype.toString;\n\tvar objectCtorString = funcToString.call(Object);\n\t\n\tfunction isPlainObject(value) {\n\t  var proto = Object.getPrototypeOf(value);\n\t  /* istanbul ignore if */\n\t  if (proto === null) { // not sure when this happens, but I guess it can\n\t    return true;\n\t  }\n\t  var Ctor = proto.constructor;\n\t  return (typeof Ctor == 'function' &&\n\t    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n\t}\n\t\n\tfunction clone(object) {\n\t  var newObject;\n\t  var i;\n\t  var len;\n\t\n\t  if (!object || typeof object !== 'object') {\n\t    return object;\n\t  }\n\t\n\t  if (Array.isArray(object)) {\n\t    newObject = [];\n\t    for (i = 0, len = object.length; i < len; i++) {\n\t      newObject[i] = clone(object[i]);\n\t    }\n\t    return newObject;\n\t  }\n\t\n\t  // special case: to avoid inconsistencies between IndexedDB\n\t  // and other backends, we automatically stringify Dates\n\t  if (object instanceof Date) {\n\t    return object.toISOString();\n\t  }\n\t\n\t  if (isBinaryObject(object)) {\n\t    return cloneBinaryObject(object);\n\t  }\n\t\n\t  if (!isPlainObject(object)) {\n\t    return object; // don't clone objects like Workers\n\t  }\n\t\n\t  newObject = {};\n\t  for (i in object) {\n\t    /* istanbul ignore else */\n\t    if (Object.prototype.hasOwnProperty.call(object, i)) {\n\t      var value = clone(object[i]);\n\t      if (typeof value !== 'undefined') {\n\t        newObject[i] = value;\n\t      }\n\t    }\n\t  }\n\t  return newObject;\n\t}\n\t\n\tfunction once(fun) {\n\t  var called = false;\n\t  return getArguments(function (args) {\n\t    /* istanbul ignore if */\n\t    if (called) {\n\t      // this is a smoke test and should never actually happen\n\t      throw new Error('once called more than once');\n\t    } else {\n\t      called = true;\n\t      fun.apply(this, args);\n\t    }\n\t  });\n\t}\n\t\n\tfunction toPromise(func) {\n\t  //create the function we will be returning\n\t  return getArguments(function (args) {\n\t    // Clone arguments\n\t    args = clone(args);\n\t    var self = this;\n\t    // if the last argument is a function, assume its a callback\n\t    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n\t    var promise = new Promise(function (fulfill, reject) {\n\t      var resp;\n\t      try {\n\t        var callback = once(function (err, mesg) {\n\t          if (err) {\n\t            reject(err);\n\t          } else {\n\t            fulfill(mesg);\n\t          }\n\t        });\n\t        // create a callback for this invocation\n\t        // apply the function in the orig context\n\t        args.push(callback);\n\t        resp = func.apply(self, args);\n\t        if (resp && typeof resp.then === 'function') {\n\t          fulfill(resp);\n\t        }\n\t      } catch (e) {\n\t        reject(e);\n\t      }\n\t    });\n\t    // if there is a callback, call it back\n\t    if (usedCB) {\n\t      promise.then(function (result) {\n\t        usedCB(null, result);\n\t      }, usedCB);\n\t    }\n\t    return promise;\n\t  });\n\t}\n\t\n\tfunction logApiCall(self, name, args) {\n\t  /* istanbul ignore if */\n\t  if (self.constructor.listeners('debug').length) {\n\t    var logArgs = ['api', self.name, name];\n\t    for (var i = 0; i < args.length - 1; i++) {\n\t      logArgs.push(args[i]);\n\t    }\n\t    self.constructor.emit('debug', logArgs);\n\t\n\t    // override the callback itself to log the response\n\t    var origCallback = args[args.length - 1];\n\t    args[args.length - 1] = function (err, res) {\n\t      var responseArgs = ['api', self.name, name];\n\t      responseArgs = responseArgs.concat(\n\t        err ? ['error', err] : ['success', res]\n\t      );\n\t      self.constructor.emit('debug', responseArgs);\n\t      origCallback(err, res);\n\t    };\n\t  }\n\t}\n\t\n\tfunction adapterFun(name, callback) {\n\t  return toPromise(getArguments(function (args) {\n\t    if (this._closed) {\n\t      return Promise.reject(new Error('database is closed'));\n\t    }\n\t    if (this._destroyed) {\n\t      return Promise.reject(new Error('database is destroyed'));\n\t    }\n\t    var self = this;\n\t    logApiCall(self, name, args);\n\t    if (!this.taskqueue.isReady) {\n\t      return new Promise(function (fulfill, reject) {\n\t        self.taskqueue.addTask(function (failed) {\n\t          if (failed) {\n\t            reject(failed);\n\t          } else {\n\t            fulfill(self[name].apply(self, args));\n\t          }\n\t        });\n\t      });\n\t    }\n\t    return callback.apply(this, args);\n\t  }));\n\t}\n\t\n\t// like underscore/lodash _.pick()\n\tfunction pick(obj, arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var prop = arr[i];\n\t    if (prop in obj) {\n\t      res[prop] = obj[prop];\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t// Most browsers throttle concurrent requests at 6, so it's silly\n\t// to shim _bulk_get by trying to launch potentially hundreds of requests\n\t// and then letting the majority time out. We can handle this ourselves.\n\tvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\t\n\tfunction identityFunction(x) {\n\t  return x;\n\t}\n\t\n\tfunction formatResultForOpenRevsGet(result) {\n\t  return [{\n\t    ok: result\n\t  }];\n\t}\n\t\n\t// shim for P/CouchDB adapters that don't directly implement _bulk_get\n\tfunction bulkGet(db, opts, callback) {\n\t  var requests = opts.docs;\n\t\n\t  // consolidate into one request per doc if possible\n\t  var requestsById = new pouchdbCollections.Map();\n\t  requests.forEach(function (request) {\n\t    if (requestsById.has(request.id)) {\n\t      requestsById.get(request.id).push(request);\n\t    } else {\n\t      requestsById.set(request.id, [request]);\n\t    }\n\t  });\n\t\n\t  var numDocs = requestsById.size;\n\t  var numDone = 0;\n\t  var perDocResults = new Array(numDocs);\n\t\n\t  function collapseResultsAndFinish() {\n\t    var results = [];\n\t    perDocResults.forEach(function (res) {\n\t      res.docs.forEach(function (info) {\n\t        results.push({\n\t          id: res.id,\n\t          docs: [info]\n\t        });\n\t      });\n\t    });\n\t    callback(null, {results: results});\n\t  }\n\t\n\t  function checkDone() {\n\t    if (++numDone === numDocs) {\n\t      collapseResultsAndFinish();\n\t    }\n\t  }\n\t\n\t  function gotResult(docIndex, id, docs) {\n\t    perDocResults[docIndex] = {id: id, docs: docs};\n\t    checkDone();\n\t  }\n\t\n\t  var allRequests = [];\n\t  requestsById.forEach(function (value, key) {\n\t    allRequests.push(key);\n\t  });\n\t\n\t  var i = 0;\n\t\n\t  function nextBatch() {\n\t\n\t    if (i >= allRequests.length) {\n\t      return;\n\t    }\n\t\n\t    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n\t    var batch = allRequests.slice(i, upTo);\n\t    processBatch(batch, i);\n\t    i += batch.length;\n\t  }\n\t\n\t  function processBatch(batch, offset) {\n\t    batch.forEach(function (docId, j) {\n\t      var docIdx = offset + j;\n\t      var docRequests = requestsById.get(docId);\n\t\n\t      // just use the first request as the \"template\"\n\t      // TODO: The _bulk_get API allows for more subtle use cases than this,\n\t      // but for now it is unlikely that there will be a mix of different\n\t      // \"atts_since\" or \"attachments\" in the same request, since it's just\n\t      // replicate.js that is using this for the moment.\n\t      // Also, atts_since is aspirational, since we don't support it yet.\n\t      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n\t      docOpts.open_revs = docRequests.map(function (request) {\n\t        // rev is optional, open_revs disallowed\n\t        return request.rev;\n\t      });\n\t\n\t      // remove falsey / undefined revisions\n\t      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\t\n\t      var formatResult = identityFunction;\n\t\n\t      if (docOpts.open_revs.length === 0) {\n\t        delete docOpts.open_revs;\n\t\n\t        // when fetching only the \"winning\" leaf,\n\t        // transform the result so it looks like an open_revs\n\t        // request\n\t        formatResult = formatResultForOpenRevsGet;\n\t      }\n\t\n\t      // globally-supplied options\n\t      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n\t        if (param in opts) {\n\t          docOpts[param] = opts[param];\n\t        }\n\t      });\n\t      db.get(docId, docOpts, function (err, res) {\n\t        var result;\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          result = [{error: err}];\n\t        } else {\n\t          result = formatResult(res);\n\t        }\n\t        gotResult(docIdx, docId, result);\n\t        nextBatch();\n\t      });\n\t    });\n\t  }\n\t\n\t  nextBatch();\n\t\n\t}\n\t\n\tfunction isChromeApp() {\n\t  return (typeof chrome !== \"undefined\" &&\n\t    typeof chrome.storage !== \"undefined\" &&\n\t    typeof chrome.storage.local !== \"undefined\");\n\t}\n\t\n\tvar hasLocal;\n\t\n\tif (isChromeApp()) {\n\t  hasLocal = false;\n\t} else {\n\t  try {\n\t    localStorage.setItem('_pouch_check_localstorage', 1);\n\t    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n\t  } catch (e) {\n\t    hasLocal = false;\n\t  }\n\t}\n\t\n\tfunction hasLocalStorage() {\n\t  return hasLocal;\n\t}\n\t\n\t// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n\t// avoid using process.nextTick() directly because the polyfill is very large and we don't\n\t// need all of it (see: https://github.com/defunctzombie/node-process).\n\t// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n\t// package, so it's the one we use.\n\t// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n\t// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n\t// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n\t// (least latency) option, which is \"immediate\" due to use of microtasks.\n\t// All of our nextTicks are isolated to this one function so we can easily swap out one\n\t// implementation for another.\n\t\n\tinherits(Changes, events.EventEmitter);\n\t\n\t/* istanbul ignore next */\n\tfunction attachBrowserEvents(self) {\n\t  if (isChromeApp()) {\n\t    chrome.storage.onChanged.addListener(function (e) {\n\t      // make sure it's event addressed to us\n\t      if (e.db_name != null) {\n\t        //object only has oldValue, newValue members\n\t        self.emit(e.dbName.newValue);\n\t      }\n\t    });\n\t  } else if (hasLocalStorage()) {\n\t    if (typeof addEventListener !== 'undefined') {\n\t      addEventListener(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    } else { // old IE\n\t      window.attachEvent(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    }\n\t  }\n\t}\n\t\n\tfunction Changes() {\n\t  events.EventEmitter.call(this);\n\t  this._listeners = {};\n\t\n\t  attachBrowserEvents(this);\n\t}\n\tChanges.prototype.addListener = function (dbName, id, db, opts) {\n\t  /* istanbul ignore if */\n\t  if (this._listeners[id]) {\n\t    return;\n\t  }\n\t  var self = this;\n\t  var inprogress = false;\n\t  function eventFunction() {\n\t    /* istanbul ignore if */\n\t    if (!self._listeners[id]) {\n\t      return;\n\t    }\n\t    if (inprogress) {\n\t      inprogress = 'waiting';\n\t      return;\n\t    }\n\t    inprogress = true;\n\t    var changesOpts = pick(opts, [\n\t      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n\t      'doc_ids', 'view', 'since', 'query_params', 'binary'\n\t    ]);\n\t\n\t    /* istanbul ignore next */\n\t    function onError() {\n\t      inprogress = false;\n\t    }\n\t\n\t    db.changes(changesOpts).on('change', function (c) {\n\t      if (c.seq > opts.since && !opts.cancelled) {\n\t        opts.since = c.seq;\n\t        opts.onChange(c);\n\t      }\n\t    }).on('complete', function () {\n\t      if (inprogress === 'waiting') {\n\t        immediate(eventFunction);\n\t      }\n\t      inprogress = false;\n\t    }).on('error', onError);\n\t  }\n\t  this._listeners[id] = eventFunction;\n\t  this.on(dbName, eventFunction);\n\t};\n\t\n\tChanges.prototype.removeListener = function (dbName, id) {\n\t  /* istanbul ignore if */\n\t  if (!(id in this._listeners)) {\n\t    return;\n\t  }\n\t  events.EventEmitter.prototype.removeListener.call(this, dbName,\n\t    this._listeners[id]);\n\t  delete this._listeners[id];\n\t};\n\t\n\t\n\t/* istanbul ignore next */\n\tChanges.prototype.notifyLocalWindows = function (dbName) {\n\t  //do a useless change on a storage thing\n\t  //in order to get other windows's listeners to activate\n\t  if (isChromeApp()) {\n\t    chrome.storage.local.set({dbName: dbName});\n\t  } else if (hasLocalStorage()) {\n\t    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n\t  }\n\t};\n\t\n\tChanges.prototype.notify = function (dbName) {\n\t  this.emit(dbName);\n\t  this.notifyLocalWindows(dbName);\n\t};\n\t\n\tfunction guardedConsole(method) {\n\t  /* istanbul ignore else */\n\t  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    console[method].apply(console, args);\n\t  }\n\t}\n\t\n\tfunction randomNumber(min, max) {\n\t  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n\t  min = parseInt(min, 10) || 0;\n\t  max = parseInt(max, 10);\n\t  if (max !== max || max <= min) {\n\t    max = (min || 1) << 1; //doubling\n\t  } else {\n\t    max = max + 1;\n\t  }\n\t  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n\t  if (max > maxTimeout) {\n\t    min = maxTimeout >> 1; // divide by two\n\t    max = maxTimeout;\n\t  }\n\t  var ratio = Math.random();\n\t  var range = max - min;\n\t\n\t  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n\t}\n\t\n\tfunction defaultBackOff(min) {\n\t  var max = 0;\n\t  if (!min) {\n\t    max = 2000;\n\t  }\n\t  return randomNumber(min, max);\n\t}\n\t\n\t// designed to give info to browser users, who are disturbed\n\t// when they see http errors in the console\n\tfunction explainError(status, str) {\n\t  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n\t}\n\t\n\tvar assign;\n\t{\n\t  if (typeof Object.assign === 'function') {\n\t    assign = Object.assign;\n\t  } else {\n\t    // lite Object.assign polyfill based on\n\t    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t    assign = function (target) {\n\t      var to = Object(target);\n\t\n\t      for (var index = 1; index < arguments.length; index++) {\n\t        var nextSource = arguments[index];\n\t\n\t        if (nextSource != null) { // Skip over if undefined or null\n\t          for (var nextKey in nextSource) {\n\t            // Avoid bugs when hasOwnProperty is shadowed\n\t            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n\t              to[nextKey] = nextSource[nextKey];\n\t            }\n\t          }\n\t        }\n\t      }\n\t      return to;\n\t    };\n\t  }\n\t}\n\t\n\tvar assign$1 = assign;\n\t\n\tfunction tryFilter(filter, doc, req) {\n\t  try {\n\t    return !filter(doc, req);\n\t  } catch (err) {\n\t    var msg = 'Filter function threw: ' + err.toString();\n\t    return pouchdbErrors.createError(pouchdbErrors.BAD_REQUEST, msg);\n\t  }\n\t}\n\t\n\tfunction filterChange(opts) {\n\t  var req = {};\n\t  var hasFilter = opts.filter && typeof opts.filter === 'function';\n\t  req.query = opts.query_params;\n\t\n\t  return function filter(change) {\n\t    if (!change.doc) {\n\t      // CSG sends events on the changes feed that don't have documents,\n\t      // this hack makes a whole lot of existing code robust.\n\t      change.doc = {};\n\t    }\n\t\n\t    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\t\n\t    if (typeof filterReturn === 'object') {\n\t      return filterReturn;\n\t    }\n\t\n\t    if (filterReturn) {\n\t      return false;\n\t    }\n\t\n\t    if (!opts.include_docs) {\n\t      delete change.doc;\n\t    } else if (!opts.attachments) {\n\t      for (var att in change.doc._attachments) {\n\t        /* istanbul ignore else */\n\t        if (change.doc._attachments.hasOwnProperty(att)) {\n\t          change.doc._attachments[att].stub = true;\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  };\n\t}\n\t\n\tfunction flatten(arrs) {\n\t  var res = [];\n\t  for (var i = 0, len = arrs.length; i < len; i++) {\n\t    res = res.concat(arrs[i]);\n\t  }\n\t  return res;\n\t}\n\t\n\t// shim for Function.prototype.name,\n\t// for browsers that don't support it like IE\n\t\n\t/* istanbul ignore next */\n\tfunction f() {}\n\t\n\tvar hasName = f.name;\n\tvar res;\n\t\n\t// We dont run coverage in IE\n\t/* istanbul ignore else */\n\tif (hasName) {\n\t  res = function (fun) {\n\t    return fun.name;\n\t  };\n\t} else {\n\t  res = function (fun) {\n\t    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n\t  };\n\t}\n\t\n\tvar res$1 = res;\n\t\n\t// Determine id an ID is valid\n\t//   - invalid IDs begin with an underescore that does not begin '_design' or\n\t//     '_local'\n\t//   - any other string value is a valid id\n\t// Returns the specific error object for each case\n\tfunction invalidIdError(id) {\n\t  var err;\n\t  if (!id) {\n\t    err = pouchdbErrors.createError(pouchdbErrors.MISSING_ID);\n\t  } else if (typeof id !== 'string') {\n\t    err = pouchdbErrors.createError(pouchdbErrors.INVALID_ID);\n\t  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n\t    err = pouchdbErrors.createError(pouchdbErrors.RESERVED_ID);\n\t  }\n\t  if (err) {\n\t    throw err;\n\t  }\n\t}\n\t\n\tfunction isCordova() {\n\t  return (typeof cordova !== \"undefined\" ||\n\t  typeof PhoneGap !== \"undefined\" ||\n\t  typeof phonegap !== \"undefined\");\n\t}\n\t\n\t// Checks if a PouchDB object is \"remote\" or not. This is\n\t// designed to opt-in to certain optimizations, such as\n\t// avoiding checks for \"dependentDbs\" and other things that\n\t// we know only apply to local databases. In general, \"remote\"\n\t// should be true for the http adapter, and for third-party\n\t// adapters with similar expensive boundaries to cross for\n\t// every API call, such as socket-pouch and worker-pouch.\n\t// Previously, this was handled via db.type() === 'http'\n\t// which is now deprecated.\n\t\n\tfunction isRemote(db) {\n\t  if (typeof db._remote === 'boolean') {\n\t    return db._remote;\n\t  }\n\t  /* istanbul ignore next */\n\t  if (typeof db.type === 'function') {\n\t    guardedConsole('warn',\n\t      'db.type() is deprecated and will be removed in ' +\n\t      'a future version of PouchDB');\n\t    return db.type() === 'http';\n\t  }\n\t  /* istanbul ignore next */\n\t  return false;\n\t}\n\t\n\tfunction listenerCount(ee, type) {\n\t  return 'listenerCount' in ee ? ee.listenerCount(type) :\n\t                                 events.EventEmitter.listenerCount(ee, type);\n\t}\n\t\n\tfunction parseDesignDocFunctionName(s) {\n\t  if (!s) {\n\t    return null;\n\t  }\n\t  var parts = s.split('/');\n\t  if (parts.length === 2) {\n\t    return parts;\n\t  }\n\t  if (parts.length === 1) {\n\t    return [s, s];\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction normalizeDesignDocFunctionName(s) {\n\t  var normalized = parseDesignDocFunctionName(s);\n\t  return normalized ? normalized.join('/') : null;\n\t}\n\t\n\t// originally parseUri 1.2.2, now patched by us\n\t// (c) Steven Levithan <stevenlevithan.com>\n\t// MIT License\n\tvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n\t    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n\tvar qName =\"queryKey\";\n\tvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\t\n\t// use the \"loose\" parser\n\t/* eslint maxlen: 0, no-useless-escape: 0 */\n\tvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\t\n\tfunction parseUri(str) {\n\t  var m = parser.exec(str);\n\t  var uri = {};\n\t  var i = 14;\n\t\n\t  while (i--) {\n\t    var key = keys[i];\n\t    var value = m[i] || \"\";\n\t    var encoded = ['user', 'password'].indexOf(key) !== -1;\n\t    uri[key] = encoded ? decodeURIComponent(value) : value;\n\t  }\n\t\n\t  uri[qName] = {};\n\t  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n\t    if ($1) {\n\t      uri[qName][$1] = $2;\n\t    }\n\t  });\n\t\n\t  return uri;\n\t}\n\t\n\t// Based on https://github.com/alexdavid/scope-eval v0.0.3\n\t// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n\t// This is basically just a wrapper around new Function()\n\t\n\tfunction scopeEval(source, scope) {\n\t  var keys = [];\n\t  var values = [];\n\t  for (var key in scope) {\n\t    if (scope.hasOwnProperty(key)) {\n\t      keys.push(key);\n\t      values.push(scope[key]);\n\t    }\n\t  }\n\t  keys.push(source);\n\t  return Function.apply(null, keys).apply(null, values);\n\t}\n\t\n\t// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n\t// the diffFun tells us what delta to apply to the doc.  it either returns\n\t// the doc, or false if it doesn't need to do an update after all\n\tfunction upsert(db, docId, diffFun) {\n\t  return new Promise(function (fulfill, reject) {\n\t    db.get(docId, function (err, doc) {\n\t      if (err) {\n\t        /* istanbul ignore next */\n\t        if (err.status !== 404) {\n\t          return reject(err);\n\t        }\n\t        doc = {};\n\t      }\n\t\n\t      // the user might change the _rev, so save it for posterity\n\t      var docRev = doc._rev;\n\t      var newDoc = diffFun(doc);\n\t\n\t      if (!newDoc) {\n\t        // if the diffFun returns falsy, we short-circuit as\n\t        // an optimization\n\t        return fulfill({updated: false, rev: docRev});\n\t      }\n\t\n\t      // users aren't allowed to modify these values,\n\t      // so reset them here\n\t      newDoc._id = docId;\n\t      newDoc._rev = docRev;\n\t      fulfill(tryAndPut(db, newDoc, diffFun));\n\t    });\n\t  });\n\t}\n\t\n\tfunction tryAndPut(db, doc, diffFun) {\n\t  return db.put(doc).then(function (res) {\n\t    return {\n\t      updated: true,\n\t      rev: res.rev\n\t    };\n\t  }, function (err) {\n\t    /* istanbul ignore next */\n\t    if (err.status !== 409) {\n\t      throw err;\n\t    }\n\t    return upsert(db, doc._id, diffFun);\n\t  });\n\t}\n\t\n\tfunction rev() {\n\t  return uuidV4.v4().replace(/-/g, '').toLowerCase();\n\t}\n\t\n\tvar uuid = uuidV4.v4;\n\t\n\texports.adapterFun = adapterFun;\n\texports.assign = assign$1;\n\texports.bulkGetShim = bulkGet;\n\texports.changesHandler = Changes;\n\texports.clone = clone;\n\texports.defaultBackOff = defaultBackOff;\n\texports.explainError = explainError;\n\texports.filterChange = filterChange;\n\texports.flatten = flatten;\n\texports.functionName = res$1;\n\texports.guardedConsole = guardedConsole;\n\texports.hasLocalStorage = hasLocalStorage;\n\texports.invalidIdError = invalidIdError;\n\texports.isChromeApp = isChromeApp;\n\texports.isCordova = isCordova;\n\texports.isRemote = isRemote;\n\texports.listenerCount = listenerCount;\n\texports.nextTick = immediate;\n\texports.normalizeDdocFunctionName = normalizeDesignDocFunctionName;\n\texports.once = once;\n\texports.parseDdocFunctionName = parseDesignDocFunctionName;\n\texports.parseUri = parseUri;\n\texports.pick = pick;\n\texports.rev = rev;\n\texports.scopeEval = scopeEval;\n\texports.toPromise = toPromise;\n\texports.upsert = upsert;\n\texports.uuid = uuid;\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = argsArray;\n\t\n\tfunction argsArray(fun) {\n\t  return function () {\n\t    var len = arguments.length;\n\t    if (len) {\n\t      var args = [];\n\t      var i = -1;\n\t      while (++i < len) {\n\t        args[i] = arguments[i];\n\t      }\n\t      return fun.call(this, args);\n\t    } else {\n\t      return fun.call(this, []);\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.AppToken = exports.AccessToken = exports.Client = exports.StateKey = exports.CredsKey = undefined;\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global btoa */\n\t\n\t\n\texports.client = client;\n\texports.registerClient = registerClient;\n\texports.updateClient = updateClient;\n\texports.unregisterClient = unregisterClient;\n\texports.getClient = getClient;\n\texports.getAuthCodeURL = getAuthCodeURL;\n\texports.getAccessToken = getAccessToken;\n\texports.refreshToken = refreshToken;\n\texports.oauthFlow = oauthFlow;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _fetch = __webpack_require__(1);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar StateSize = 16;\n\t\n\tvar CredsKey = exports.CredsKey = 'creds';\n\tvar StateKey = exports.StateKey = 'state';\n\t\n\tvar Client = exports.Client = function () {\n\t  function Client(opts) {\n\t    _classCallCheck(this, Client);\n\t\n\t    this.clientID = opts.clientID || opts.client_id || '';\n\t    this.clientSecret = opts.clientSecret || opts.client_secret || '';\n\t    this.registrationAccessToken = opts.registrationAccessToken || opts.registration_access_token || '';\n\t\n\t    if (opts.redirect_uris) {\n\t      this.redirectURI = opts.redirect_uris[0] || '';\n\t    } else {\n\t      this.redirectURI = opts.redirectURI || '';\n\t    }\n\t\n\t    this.softwareID = opts.softwareID || opts.software_id || '';\n\t    this.softwareVersion = opts.softwareVersion || opts.software_version || '';\n\t    this.clientName = opts.clientName || opts.client_name || '';\n\t    this.clientKind = opts.clientKind || opts.client_kind || '';\n\t    this.clientURI = opts.clientURI || opts.client_uri || '';\n\t\n\t    this.logoURI = opts.logoURI || opts.logo_uri || '';\n\t    this.policyURI = opts.policyURI || opts.policy_uri || '';\n\t\n\t    this.notificationPlatform = opts.notificationPlatform || opts.notification_platform || '';\n\t    this.notificationDeviceToken = opts.notificationDeviceToken || opts.notification_device_token || '';\n\t\n\t    if (!this.registrationAccessToken) {\n\t      if (this.redirectURI === '') {\n\t        throw new Error('Missing redirectURI field');\n\t      }\n\t      if (this.softwareID === '') {\n\t        throw new Error('Missing softwareID field');\n\t      }\n\t      if (this.clientName === '') {\n\t        throw new Error('Missing clientName field');\n\t      }\n\t    }\n\t  }\n\t\n\t  _createClass(Client, [{\n\t    key: 'isRegistered',\n\t    value: function isRegistered() {\n\t      return this.clientID !== '';\n\t    }\n\t  }, {\n\t    key: 'toRegisterJSON',\n\t    value: function toRegisterJSON() {\n\t      return {\n\t        redirect_uris: [this.redirectURI],\n\t        software_id: this.softwareID,\n\t        software_version: this.softwareVersion,\n\t        client_name: this.clientName,\n\t        client_kind: this.clientKind,\n\t        client_uri: this.clientURI,\n\t        logo_uri: this.logoURI,\n\t        policy_uri: this.policyURI,\n\t        notification_platform: this.notificationPlatform,\n\t        notification_device_token: this.notificationDeviceToken\n\t      };\n\t    }\n\t  }, {\n\t    key: 'toAuthHeader',\n\t    value: function toAuthHeader() {\n\t      return 'Bearer ' + this.registrationAccessToken;\n\t    }\n\t  }]);\n\t\n\t  return Client;\n\t}();\n\t\n\tvar AccessToken = exports.AccessToken = function () {\n\t  function AccessToken(opts) {\n\t    _classCallCheck(this, AccessToken);\n\t\n\t    this.tokenType = opts.tokenType || opts.token_type;\n\t    this.accessToken = opts.accessToken || opts.access_token;\n\t    this.refreshToken = opts.refreshToken || opts.refresh_token;\n\t    this.scope = opts.scope;\n\t  }\n\t\n\t  _createClass(AccessToken, [{\n\t    key: 'toAuthHeader',\n\t    value: function toAuthHeader() {\n\t      return 'Bearer ' + this.accessToken;\n\t    }\n\t  }, {\n\t    key: 'toBasicAuth',\n\t    value: function toBasicAuth() {\n\t      return 'user:' + this.accessToken + '@';\n\t    }\n\t  }]);\n\t\n\t  return AccessToken;\n\t}();\n\t\n\tvar AppToken = exports.AppToken = function () {\n\t  function AppToken(opts) {\n\t    _classCallCheck(this, AppToken);\n\t\n\t    this.token = opts.token || '';\n\t  }\n\t\n\t  _createClass(AppToken, [{\n\t    key: 'toAuthHeader',\n\t    value: function toAuthHeader() {\n\t      return 'Bearer ' + this.token;\n\t    }\n\t  }, {\n\t    key: 'toBasicAuth',\n\t    value: function toBasicAuth() {\n\t      return 'user:' + this.token + '@';\n\t    }\n\t  }]);\n\t\n\t  return AppToken;\n\t}();\n\t\n\tfunction client(cozy, clientParams) {\n\t  if (!clientParams) {\n\t    clientParams = cozy._clientParams;\n\t  }\n\t  if (clientParams instanceof Client) {\n\t    return clientParams;\n\t  }\n\t  return new Client(clientParams);\n\t}\n\t\n\tfunction registerClient(cozy, clientParams) {\n\t  var cli = client(cozy, clientParams);\n\t  if (cli.isRegistered()) {\n\t    return Promise.reject(new Error('Client already registered'));\n\t  }\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/auth/register', cli.toRegisterJSON(), {\n\t    disableAuth: true\n\t  }).then(function (data) {\n\t    return new Client(data);\n\t  });\n\t}\n\t\n\tfunction updateClient(cozy, clientParams) {\n\t  var resetSecret = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t  var cli = client(cozy, clientParams);\n\t  if (!cli.isRegistered()) {\n\t    return Promise.reject(new Error('Client not registered'));\n\t  }\n\t  var data = cli.toRegisterJSON();\n\t  data.client_id = cli.clientID;\n\t  if (resetSecret) data.client_secret = cli.clientSecret;\n\t\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'PUT', '/auth/register/' + cli.clientID, data, {\n\t    manualAuthCredentials: {\n\t      token: cli\n\t    }\n\t  }).then(function (data) {\n\t    return createClient(data, cli);\n\t  });\n\t}\n\t\n\tfunction unregisterClient(cozy, clientParams) {\n\t  var cli = client(cozy, clientParams);\n\t  if (!cli.isRegistered()) {\n\t    return Promise.reject(new Error('Client not registered'));\n\t  }\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', '/auth/register/' + cli.clientID, null, {\n\t    manualAuthCredentials: {\n\t      token: cli\n\t    }\n\t  });\n\t}\n\t\n\t// getClient will retrive the registered client informations from the server.\n\tfunction getClient(cozy, clientParams) {\n\t  var cli = client(cozy, clientParams);\n\t  if (!cli.isRegistered()) {\n\t    return Promise.reject(new Error('Client not registered'));\n\t  }\n\t  if ((0, _utils.isOffline)()) {\n\t    return Promise.resolve(cli);\n\t  }\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/auth/register/' + cli.clientID, null, {\n\t    manualAuthCredentials: {\n\t      token: cli\n\t    }\n\t  }).then(function (data) {\n\t    return createClient(data, cli);\n\t  }).catch(function (err) {\n\t    // If we fall into an error while fetching the client (because of a\n\t    // bad connectivity for instance), we do not bail the whole process\n\t    // since the client should be able to continue with the persisted\n\t    // client and token.\n\t    //\n\t    // If it is an explicit Unauthorized error though, we bail, clear th\n\t    // cache and retry.\n\t    if (_fetch.FetchError.isUnauthorized(err) || _fetch.FetchError.isNotFound(err)) {\n\t      throw new Error('Client has been revoked');\n\t    }\n\t    throw err;\n\t  });\n\t}\n\t\n\t// createClient returns a new Client instance given on object containing the\n\t// data of the client, from the API, and an old instance of the client.\n\tfunction createClient(data, oldClient) {\n\t  var newClient = new Client(data);\n\t  // we need to keep track of the registrationAccessToken since it is send\n\t  // only on registration. The GET /auth/register/:client-id endpoint does\n\t  // not return this token.\n\t  var shouldPassRegistration = !!oldClient && oldClient.registrationAccessToken !== '' && newClient.registrationAccessToken === '';\n\t  if (shouldPassRegistration) {\n\t    newClient.registrationAccessToken = oldClient.registrationAccessToken;\n\t  }\n\t  return newClient;\n\t}\n\t\n\t// getAuthCodeURL returns a pair {authURL,state} given a registered client. The\n\t// state should be stored in order to be checked against on the user validation\n\t// phase.\n\tfunction getAuthCodeURL(cozy, client) {\n\t  var scopes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t\n\t  if (!(client instanceof Client)) {\n\t    client = new Client(client);\n\t  }\n\t  if (!client.isRegistered()) {\n\t    throw new Error('Client not registered');\n\t  }\n\t  var state = generateRandomState();\n\t  var query = {\n\t    client_id: client.clientID,\n\t    redirect_uri: client.redirectURI,\n\t    state: state,\n\t    response_type: 'code',\n\t    scope: scopes.join(' ')\n\t  };\n\t  return {\n\t    url: cozy._url + ('/auth/authorize?' + (0, _utils.encodeQuery)(query)),\n\t    state: state\n\t  };\n\t}\n\t\n\t// getAccessToken perform a request on the access_token entrypoint with the\n\t// authorization_code grant type in order to generate a new access token for a\n\t// newly registered client.\n\t//\n\t// This method extracts the access code and state from the given URL. By\n\t// default it uses window.location.href. Also, it checks the given state with\n\t// the one specified in the URL query parameter to prevent CSRF attacks.\n\tfunction getAccessToken(cozy, client, state) {\n\t  var pageURL = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\t\n\t  if (!state) {\n\t    return Promise.reject(new Error('Missing state value'));\n\t  }\n\t  var grantQueries = getGrantCodeFromPageURL(pageURL);\n\t  if (grantQueries === null) {\n\t    return Promise.reject(new Error('Missing states from current URL'));\n\t  }\n\t  if (state !== grantQueries.state) {\n\t    return Promise.reject(new Error('Given state does not match url query state'));\n\t  }\n\t  return retrieveToken(cozy, client, null, {\n\t    grant_type: 'authorization_code',\n\t    code: grantQueries.code\n\t  });\n\t}\n\t\n\t// refreshToken perform a request on the access_token entrypoint with the\n\t// refresh_token grant type in order to refresh the given token.\n\tfunction refreshToken(cozy, client, token) {\n\t  return retrieveToken(cozy, client, token, {\n\t    grant_type: 'refresh_token',\n\t    refresh_token: token.refreshToken\n\t  });\n\t}\n\t\n\t// oauthFlow performs the stateful registration and access granting of an OAuth\n\t// client.\n\tfunction oauthFlow(cozy, storage, clientParams, onRegistered) {\n\t  var ignoreCachedCredentials = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\t\n\t  if (ignoreCachedCredentials) {\n\t    return storage.clear().then(function () {\n\t      return oauthFlow(cozy, storage, clientParams, onRegistered, false);\n\t    });\n\t  }\n\t\n\t  var tryCount = 0;\n\t\n\t  function clearAndRetry(err) {\n\t    if (tryCount++ > 0) {\n\t      throw err;\n\t    }\n\t    return storage.clear().then(function () {\n\t      return oauthFlow(cozy, storage, clientParams, onRegistered);\n\t    });\n\t  }\n\t\n\t  function registerNewClient() {\n\t    return storage.clear().then(function () {\n\t      return registerClient(cozy, clientParams);\n\t    }).then(function (client) {\n\t      var _getAuthCodeURL = getAuthCodeURL(cozy, client, clientParams.scopes),\n\t          url = _getAuthCodeURL.url,\n\t          state = _getAuthCodeURL.state;\n\t\n\t      return storage.save(StateKey, { client: client, url: url, state: state });\n\t    });\n\t  }\n\t\n\t  return Promise.all([storage.load(CredsKey), storage.load(StateKey)]).then(function (_ref) {\n\t    var _ref2 = _slicedToArray(_ref, 2),\n\t        credentials = _ref2[0],\n\t        storedState = _ref2[1];\n\t\n\t    // If credentials are cached we re-fetch the registered client with the\n\t    // said token. Fetching the client, if the token is outdated we should try\n\t    // the token is refreshed.\n\t    if (credentials) {\n\t      var oldClient = void 0,\n\t          _token = void 0;\n\t      try {\n\t        oldClient = new Client(credentials.client);\n\t        _token = new AccessToken(credentials.token);\n\t      } catch (err) {\n\t        // bad cache, we should clear and retry the process\n\t        return clearAndRetry(err);\n\t      }\n\t      return getClient(cozy, oldClient).then(function (client) {\n\t        return { client: client, token: _token };\n\t      }).catch(function (err) {\n\t        // If we fall into an error while fetching the client (because of a\n\t        // bad connectivity for instance), we do not bail the whole process\n\t        // since the client should be able to continue with the persisted\n\t        // client and token.\n\t        //\n\t        // If it is an explicit Unauthorized error though, we bail, clear th\n\t        // cache and retry.\n\t        if (_fetch.FetchError.isUnauthorized(err) || _fetch.FetchError.isNotFound(err)) {\n\t          throw new Error('Client has been revoked');\n\t        }\n\t        return { client: oldClient, token: _token };\n\t      });\n\t    }\n\t\n\t    // Otherwise register a new client if necessary (ie. no client is stored)\n\t    // and call the onRegistered callback to wait for the user to grant the\n\t    // access. Finally fetches to access token on success.\n\t    var statePromise = void 0;\n\t    if (!storedState) {\n\t      statePromise = registerNewClient();\n\t    } else {\n\t      statePromise = Promise.resolve(storedState);\n\t    }\n\t\n\t    var client = void 0,\n\t        state = void 0,\n\t        token = void 0;\n\t    return statePromise.then(function (data) {\n\t      client = data.client;\n\t      state = data.state;\n\t      return Promise.resolve(onRegistered(client, data.url));\n\t    }).then(function (pageURL) {\n\t      return getAccessToken(cozy, client, state, pageURL);\n\t    }).then(function (t) {\n\t      token = t;\n\t    }).then(function () {\n\t      return storage.delete(StateKey);\n\t    }).then(function () {\n\t      return { client: client, token: token };\n\t    });\n\t  }).then(function (creds) {\n\t    return storage.save(CredsKey, creds);\n\t  }, function (err) {\n\t    if (_fetch.FetchError.isUnauthorized(err)) {\n\t      return clearAndRetry(err);\n\t    } else {\n\t      throw err;\n\t    }\n\t  });\n\t}\n\t\n\t// retrieveToken perform a request on the access_token entrypoint in order to\n\t// fetch a token.\n\tfunction retrieveToken(cozy, client, token, query) {\n\t  if (!(client instanceof Client)) {\n\t    client = new Client(client);\n\t  }\n\t  if (!client.isRegistered()) {\n\t    return Promise.reject(new Error('Client not registered'));\n\t  }\n\t  var body = (0, _utils.encodeQuery)(Object.assign({}, query, {\n\t    client_id: client.clientID,\n\t    client_secret: client.clientSecret\n\t  }));\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/auth/access_token', body, {\n\t    disableAuth: token === null,\n\t    dontRetry: true,\n\t    manualAuthCredentials: { client: client, token: token },\n\t    headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n\t  }).then(function (data) {\n\t    data.refreshToken = data.refreshToken || query.refresh_token;\n\t    return new AccessToken(data);\n\t  });\n\t}\n\t\n\t// getGrantCodeFromPageURL extract the state and code query parameters from the\n\t// given url\n\tfunction getGrantCodeFromPageURL() {\n\t  var pageURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t\n\t  if (pageURL === '' && typeof window !== 'undefined') {\n\t    pageURL = window.location.href;\n\t  }\n\t  var queries = (0, _utils.decodeQuery)(pageURL);\n\t  if (!queries.hasOwnProperty('state')) {\n\t    return null;\n\t  }\n\t  return {\n\t    state: queries['state'],\n\t    code: queries['code']\n\t  };\n\t}\n\t\n\t// generateRandomState will try to generate a 128bits random value from a secure\n\t// pseudo random generator. It will fallback on Math.random if it cannot find\n\t// such generator.\n\tfunction generateRandomState() {\n\t  var buffer = void 0;\n\t  if (typeof window !== 'undefined' && typeof window.crypto !== 'undefined' && typeof window.crypto.getRandomValues === 'function') {\n\t    buffer = new Uint8Array(StateSize);\n\t    window.crypto.getRandomValues(buffer);\n\t  } else {\n\t    try {\n\t      buffer = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"crypto\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())).randomBytes(StateSize);\n\t    } catch (e) {\n\t      buffer = null;\n\t    }\n\t  }\n\t  if (!buffer) {\n\t    buffer = new Array(StateSize);\n\t    for (var i = 0; i < buffer.length; i++) {\n\t      buffer[i] = Math.floor(Math.random() * 255);\n\t    }\n\t  }\n\t  return btoa(String.fromCharCode.apply(null, buffer)).replace(/=+$/, '').replace(/\\//g, '_').replace(/\\+/g, '-');\n\t}\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.pickService = pickService;\n\t// helper to serialize/deserialize an error for/from postMessage\n\tvar errorSerializer = exports.errorSerializer = function () {\n\t  function mapErrorProperties(from, to) {\n\t    var result = Object.assign(to, from);\n\t    var nativeProperties = ['name', 'message'];\n\t    return nativeProperties.reduce(function (result, property) {\n\t      if (from[property]) {\n\t        to[property] = from[property];\n\t      }\n\t      return result;\n\t    }, result);\n\t  }\n\t  return {\n\t    serialize: function serialize(error) {\n\t      return mapErrorProperties(error, {});\n\t    },\n\t    deserialize: function deserialize(data) {\n\t      return mapErrorProperties(data, new Error(data.message));\n\t    }\n\t  };\n\t}();\n\t\n\tvar first = function first(arr) {\n\t  return arr && arr[0];\n\t};\n\t// In a far future, the user will have to pick the desired service from a list.\n\t// For now it's our job, an easy job as we arbitrary pick the first service of\n\t// the list.\n\tfunction pickService(intent, filterServices) {\n\t  var services = intent.attributes.services;\n\t  var filteredServices = filterServices ? (services || []).filter(filterServices) : services;\n\t  return first(filteredServices);\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = { version: '2.5.7' };\n\tif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(12)(function () {\n\t  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n\t});\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (exec) {\n\t  try {\n\t    return !!exec();\n\t  } catch (e) {\n\t    return true;\n\t  }\n\t};\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (it) {\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\tvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\t\n\tvar scheduleDrain;\n\t\n\t{\n\t  if (Mutation) {\n\t    var called = 0;\n\t    var observer = new Mutation(nextTick);\n\t    var element = global.document.createTextNode('');\n\t    observer.observe(element, {\n\t      characterData: true\n\t    });\n\t    scheduleDrain = function () {\n\t      element.data = (called = ++called % 2);\n\t    };\n\t  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n\t    var channel = new global.MessageChannel();\n\t    channel.port1.onmessage = nextTick;\n\t    scheduleDrain = function () {\n\t      channel.port2.postMessage(0);\n\t    };\n\t  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n\t    scheduleDrain = function () {\n\t\n\t      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t      var scriptEl = global.document.createElement('script');\n\t      scriptEl.onreadystatechange = function () {\n\t        nextTick();\n\t\n\t        scriptEl.onreadystatechange = null;\n\t        scriptEl.parentNode.removeChild(scriptEl);\n\t        scriptEl = null;\n\t      };\n\t      global.document.documentElement.appendChild(scriptEl);\n\t    };\n\t  } else {\n\t    scheduleDrain = function () {\n\t      setTimeout(nextTick, 0);\n\t    };\n\t  }\n\t}\n\t\n\tvar draining;\n\tvar queue = [];\n\t//named nextTick for less confusing stack traces\n\tfunction nextTick() {\n\t  draining = true;\n\t  var i, oldQueue;\n\t  var len = queue.length;\n\t  while (len) {\n\t    oldQueue = queue;\n\t    queue = [];\n\t    i = -1;\n\t    while (++i < len) {\n\t      oldQueue[i]();\n\t    }\n\t    len = queue.length;\n\t  }\n\t  draining = false;\n\t}\n\t\n\tmodule.exports = immediate;\n\tfunction immediate(task) {\n\t  if (queue.push(task) === 1 && !draining) {\n\t    scheduleDrain();\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tfunction pad(str, padWith, upToLength) {\n\t  var padding = '';\n\t  var targetLength = upToLength - str.length;\n\t  /* istanbul ignore next */\n\t  while (padding.length < targetLength) {\n\t    padding += padWith;\n\t  }\n\t  return padding;\n\t}\n\t\n\tfunction padLeft(str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return padding + str;\n\t}\n\t\n\tvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\n\tvar MAGNITUDE_DIGITS = 3; // ditto\n\tvar SEP = ''; // set to '_' for easier debugging \n\t\n\tfunction collate(a, b) {\n\t\n\t  if (a === b) {\n\t    return 0;\n\t  }\n\t\n\t  a = normalizeKey(a);\n\t  b = normalizeKey(b);\n\t\n\t  var ai = collationIndex(a);\n\t  var bi = collationIndex(b);\n\t  if ((ai - bi) !== 0) {\n\t    return ai - bi;\n\t  }\n\t  switch (typeof a) {\n\t    case 'number':\n\t      return a - b;\n\t    case 'boolean':\n\t      return a < b ? -1 : 1;\n\t    case 'string':\n\t      return stringCollate(a, b);\n\t  }\n\t  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n\t}\n\t\n\t// couch considers null/NaN/Infinity/-Infinity === undefined,\n\t// for the purposes of mapreduce indexes. also, dates get stringified.\n\tfunction normalizeKey(key) {\n\t  switch (typeof key) {\n\t    case 'undefined':\n\t      return null;\n\t    case 'number':\n\t      if (key === Infinity || key === -Infinity || isNaN(key)) {\n\t        return null;\n\t      }\n\t      return key;\n\t    case 'object':\n\t      var origKey = key;\n\t      if (Array.isArray(key)) {\n\t        var len = key.length;\n\t        key = new Array(len);\n\t        for (var i = 0; i < len; i++) {\n\t          key[i] = normalizeKey(origKey[i]);\n\t        }\n\t      /* istanbul ignore next */\n\t      } else if (key instanceof Date) {\n\t        return key.toJSON();\n\t      } else if (key !== null) { // generic object\n\t        key = {};\n\t        for (var k in origKey) {\n\t          if (origKey.hasOwnProperty(k)) {\n\t            var val = origKey[k];\n\t            if (typeof val !== 'undefined') {\n\t              key[k] = normalizeKey(val);\n\t            }\n\t          }\n\t        }\n\t      }\n\t  }\n\t  return key;\n\t}\n\t\n\tfunction indexify(key) {\n\t  if (key !== null) {\n\t    switch (typeof key) {\n\t      case 'boolean':\n\t        return key ? 1 : 0;\n\t      case 'number':\n\t        return numToIndexableString(key);\n\t      case 'string':\n\t        // We've to be sure that key does not contain \\u0000\n\t        // Do order-preserving replacements:\n\t        // 0 -> 1, 1\n\t        // 1 -> 1, 2\n\t        // 2 -> 2, 2\n\t        return key\n\t          .replace(/\\u0002/g, '\\u0002\\u0002')\n\t          .replace(/\\u0001/g, '\\u0001\\u0002')\n\t          .replace(/\\u0000/g, '\\u0001\\u0001');\n\t      case 'object':\n\t        var isArray = Array.isArray(key);\n\t        var arr = isArray ? key : Object.keys(key);\n\t        var i = -1;\n\t        var len = arr.length;\n\t        var result = '';\n\t        if (isArray) {\n\t          while (++i < len) {\n\t            result += toIndexableString(arr[i]);\n\t          }\n\t        } else {\n\t          while (++i < len) {\n\t            var objKey = arr[i];\n\t            result += toIndexableString(objKey) +\n\t                toIndexableString(key[objKey]);\n\t          }\n\t        }\n\t        return result;\n\t    }\n\t  }\n\t  return '';\n\t}\n\t\n\t// convert the given key to a string that would be appropriate\n\t// for lexical sorting, e.g. within a database, where the\n\t// sorting is the same given by the collate() function.\n\tfunction toIndexableString(key) {\n\t  var zero = '\\u0000';\n\t  key = normalizeKey(key);\n\t  return collationIndex(key) + SEP + indexify(key) + zero;\n\t}\n\t\n\tfunction parseNumber(str, i) {\n\t  var originalIdx = i;\n\t  var num;\n\t  var zero = str[i] === '1';\n\t  if (zero) {\n\t    num = 0;\n\t    i++;\n\t  } else {\n\t    var neg = str[i] === '0';\n\t    i++;\n\t    var numAsString = '';\n\t    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n\t    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n\t    /* istanbul ignore next */\n\t    if (neg) {\n\t      magnitude = -magnitude;\n\t    }\n\t    i += MAGNITUDE_DIGITS;\n\t    while (true) {\n\t      var ch = str[i];\n\t      if (ch === '\\u0000') {\n\t        break;\n\t      } else {\n\t        numAsString += ch;\n\t      }\n\t      i++;\n\t    }\n\t    numAsString = numAsString.split('.');\n\t    if (numAsString.length === 1) {\n\t      num = parseInt(numAsString, 10);\n\t    } else {\n\t      /* istanbul ignore next */\n\t      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n\t    }\n\t    /* istanbul ignore next */\n\t    if (neg) {\n\t      num = num - 10;\n\t    }\n\t    /* istanbul ignore next */\n\t    if (magnitude !== 0) {\n\t      // parseFloat is more reliable than pow due to rounding errors\n\t      // e.g. Number.MAX_VALUE would return Infinity if we did\n\t      // num * Math.pow(10, magnitude);\n\t      num = parseFloat(num + 'e' + magnitude);\n\t    }\n\t  }\n\t  return {num: num, length : i - originalIdx};\n\t}\n\t\n\t// move up the stack while parsing\n\t// this function moved outside of parseIndexableString for performance\n\tfunction pop(stack, metaStack) {\n\t  var obj = stack.pop();\n\t\n\t  if (metaStack.length) {\n\t    var lastMetaElement = metaStack[metaStack.length - 1];\n\t    if (obj === lastMetaElement.element) {\n\t      // popping a meta-element, e.g. an object whose value is another object\n\t      metaStack.pop();\n\t      lastMetaElement = metaStack[metaStack.length - 1];\n\t    }\n\t    var element = lastMetaElement.element;\n\t    var lastElementIndex = lastMetaElement.index;\n\t    if (Array.isArray(element)) {\n\t      element.push(obj);\n\t    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t      var key = stack.pop();\n\t      element[key] = obj;\n\t    } else {\n\t      stack.push(obj); // obj with key only\n\t    }\n\t  }\n\t}\n\t\n\tfunction parseIndexableString(str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t\n\t  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\t  while (true) {\n\t    var collationIndex = str[i++];\n\t    if (collationIndex === '\\u0000') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case '1':\n\t        stack.push(null);\n\t        break;\n\t      case '2':\n\t        stack.push(str[i] === '1');\n\t        i++;\n\t        break;\n\t      case '3':\n\t        var parsedNum = parseNumber(str, i);\n\t        stack.push(parsedNum.num);\n\t        i += parsedNum.length;\n\t        break;\n\t      case '4':\n\t        var parsedStr = '';\n\t        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\t        while (true) {\n\t          var ch = str[i];\n\t          if (ch === '\\u0000') {\n\t            break;\n\t          }\n\t          parsedStr += ch;\n\t          i++;\n\t        }\n\t        // perform the reverse of the order-preserving replacement\n\t        // algorithm (see above)\n\t        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n\t          .replace(/\\u0001\\u0002/g, '\\u0001')\n\t          .replace(/\\u0002\\u0002/g, '\\u0002');\n\t        stack.push(parsedStr);\n\t        break;\n\t      case '5':\n\t        var arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '6':\n\t        var objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      /* istanbul ignore next */\n\t      default:\n\t        throw new Error(\n\t          'bad collationIndex or unexpectedly reached end of input: ' +\n\t            collationIndex);\n\t    }\n\t  }\n\t}\n\t\n\tfunction arrayCollate(a, b) {\n\t  var len = Math.min(a.length, b.length);\n\t  for (var i = 0; i < len; i++) {\n\t    var sort = collate(a[i], b[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t  }\n\t  return (a.length === b.length) ? 0 :\n\t    (a.length > b.length) ? 1 : -1;\n\t}\n\tfunction stringCollate(a, b) {\n\t  // See: https://github.com/daleharvey/pouchdb/issues/40\n\t  // This is incompatible with the CouchDB implementation, but its the\n\t  // best we can do for now\n\t  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n\t}\n\tfunction objectCollate(a, b) {\n\t  var ak = Object.keys(a), bk = Object.keys(b);\n\t  var len = Math.min(ak.length, bk.length);\n\t  for (var i = 0; i < len; i++) {\n\t    // First sort the keys\n\t    var sort = collate(ak[i], bk[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t    // if the keys are equal sort the values\n\t    sort = collate(a[ak[i]], b[bk[i]]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t\n\t  }\n\t  return (ak.length === bk.length) ? 0 :\n\t    (ak.length > bk.length) ? 1 : -1;\n\t}\n\t// The collation is defined by erlangs ordered terms\n\t// the atoms null, true, false come first, then numbers, strings,\n\t// arrays, then objects\n\t// null/undefined/NaN/Infinity/-Infinity are all considered null\n\tfunction collationIndex(x) {\n\t  var id = ['boolean', 'number', 'string', 'object'];\n\t  var idx = id.indexOf(typeof x);\n\t  //false if -1 otherwise true, but fast!!!!1\n\t  if (~idx) {\n\t    if (x === null) {\n\t      return 1;\n\t    }\n\t    if (Array.isArray(x)) {\n\t      return 5;\n\t    }\n\t    return idx < 3 ? (idx + 2) : (idx + 3);\n\t  }\n\t  /* istanbul ignore next */\n\t  if (Array.isArray(x)) {\n\t    return 5;\n\t  }\n\t}\n\t\n\t// conversion:\n\t// x yyy zz...zz\n\t// x = 0 for negative, 1 for 0, 2 for positive\n\t// y = exponent (for negative numbers negated) moved so that it's >= 0\n\t// z = mantisse\n\tfunction numToIndexableString(num) {\n\t\n\t  if (num === 0) {\n\t    return '1';\n\t  }\n\t\n\t  // convert number to exponential format for easier and\n\t  // more succinct string sorting\n\t  var expFormat = num.toExponential().split(/e\\+?/);\n\t  var magnitude = parseInt(expFormat[1], 10);\n\t\n\t  var neg = num < 0;\n\t\n\t  var result = neg ? '0' : '2';\n\t\n\t  // first sort by magnitude\n\t  // it's easier if all magnitudes are positive\n\t  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n\t  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\t\n\t  result += SEP + magString;\n\t\n\t  // then sort by the factor\n\t  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n\t  /* istanbul ignore next */\n\t  if (neg) { // for negative reverse ordering\n\t    factor = 10 - factor;\n\t  }\n\t\n\t  var factorStr = factor.toFixed(20);\n\t\n\t  // strip zeros from the end\n\t  factorStr = factorStr.replace(/\\.?0+$/, '');\n\t\n\t  result += SEP + factorStr;\n\t\n\t  return result;\n\t}\n\t\n\texports.collate = collate;\n\texports.normalizeKey = normalizeKey;\n\texports.toIndexableString = toIndexableString;\n\texports.parseIndexableString = parseIndexableString;\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tfunction mangle(key) {\n\t  return '$' + key;\n\t}\n\tfunction unmangle(key) {\n\t  return key.substring(1);\n\t}\n\tfunction Map$1() {\n\t  this._store = {};\n\t}\n\tMap$1.prototype.get = function (key) {\n\t  var mangled = mangle(key);\n\t  return this._store[mangled];\n\t};\n\tMap$1.prototype.set = function (key, value) {\n\t  var mangled = mangle(key);\n\t  this._store[mangled] = value;\n\t  return true;\n\t};\n\tMap$1.prototype.has = function (key) {\n\t  var mangled = mangle(key);\n\t  return mangled in this._store;\n\t};\n\tMap$1.prototype.delete = function (key) {\n\t  var mangled = mangle(key);\n\t  var res = mangled in this._store;\n\t  delete this._store[mangled];\n\t  return res;\n\t};\n\tMap$1.prototype.forEach = function (cb) {\n\t  var keys = Object.keys(this._store);\n\t  for (var i = 0, len = keys.length; i < len; i++) {\n\t    var key = keys[i];\n\t    var value = this._store[key];\n\t    key = unmangle(key);\n\t    cb(value, key);\n\t  }\n\t};\n\tObject.defineProperty(Map$1.prototype, 'size', {\n\t  get: function () {\n\t    return Object.keys(this._store).length;\n\t  }\n\t});\n\t\n\tfunction Set$1(array) {\n\t  this._store = new Map$1();\n\t\n\t  // init with an array\n\t  if (array && Array.isArray(array)) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      this.add(array[i]);\n\t    }\n\t  }\n\t}\n\tSet$1.prototype.add = function (key) {\n\t  return this._store.set(key, true);\n\t};\n\tSet$1.prototype.has = function (key) {\n\t  return this._store.has(key);\n\t};\n\tSet$1.prototype.forEach = function (cb) {\n\t  this._store.forEach(function (value, key) {\n\t    cb(key);\n\t  });\n\t};\n\tObject.defineProperty(Set$1.prototype, 'size', {\n\t  get: function () {\n\t    return this._store.size;\n\t  }\n\t});\n\t\n\t/* global Map,Set,Symbol */\n\t// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n\t// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n\t// Notably they fail in IE11 and iOS 8.4, which this prevents.\n\tfunction supportsMapAndSet() {\n\t  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n\t    return false;\n\t  }\n\t  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n\t  return prop && 'get' in prop && Map[Symbol.species] === Map;\n\t}\n\t\n\t// based on https://github.com/montagejs/collections\n\t/* global Map,Set */\n\t\n\t{\n\t  if (supportsMapAndSet()) { // prefer built-in Map/Set\n\t    exports.Set = Set;\n\t    exports.Map = Map;\n\t  } else { // fall back to our polyfill\n\t    exports.Set = Set$1;\n\t    exports.Map = Map$1;\n\t  }\n\t}\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar lie = _interopDefault(__webpack_require__(29));\n\t\n\t/* istanbul ignore next */\n\tvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\t\n\tmodule.exports = PouchPromise;\n\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.redirect = exports.getRedirectionURL = undefined;\n\t\n\tvar _regenerator = __webpack_require__(20);\n\t\n\tvar _regenerator2 = _interopRequireDefault(_regenerator);\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t// Redirect to an app able to handle the doctype\n\t// Redirections are more or less a hack of the intent API to retrieve an URL for\n\t// accessing a given doctype or a given document.\n\t// It needs to use a special action `REDIRECT`\n\tvar getRedirectionURL = exports.getRedirectionURL = function () {\n\t  var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(cozy, type, data) {\n\t    var intent, service, baseURL;\n\t    return _regenerator2.default.wrap(function _callee$(_context) {\n\t      while (1) {\n\t        switch (_context.prev = _context.next) {\n\t          case 0:\n\t            if (!(!type && !data)) {\n\t              _context.next = 2;\n\t              break;\n\t            }\n\t\n\t            throw new Error('Cannot retrieve redirection, at least type or doc must be provided');\n\t\n\t          case 2:\n\t            _context.next = 4;\n\t            return create(cozy, 'REDIRECT', type, data);\n\t\n\t          case 4:\n\t            intent = _context.sent;\n\t            service = (0, _helpers.pickService)(intent);\n\t\n\t            if (service) {\n\t              _context.next = 8;\n\t              break;\n\t            }\n\t\n\t            throw new Error('Unable to find a service');\n\t\n\t          case 8:\n\t\n\t            // Intents cannot be deleted now\n\t            // await deleteIntent(cozy, intent)\n\t\n\t            baseURL = removeQueryString(service.href);\n\t            return _context.abrupt('return', data ? buildRedirectionURL(baseURL, data) : baseURL);\n\t\n\t          case 10:\n\t          case 'end':\n\t            return _context.stop();\n\t        }\n\t      }\n\t    }, _callee, this);\n\t  }));\n\t\n\t  return function getRedirectionURL(_x3, _x4, _x5) {\n\t    return _ref.apply(this, arguments);\n\t  };\n\t}();\n\t\n\tvar redirect = exports.redirect = function () {\n\t  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee2(cozy, type, doc, redirectFn) {\n\t    var redirectionURL;\n\t    return _regenerator2.default.wrap(function _callee2$(_context2) {\n\t      while (1) {\n\t        switch (_context2.prev = _context2.next) {\n\t          case 0:\n\t            if (window) {\n\t              _context2.next = 2;\n\t              break;\n\t            }\n\t\n\t            throw new Error('redirect() method can only be called in a browser');\n\t\n\t          case 2:\n\t            _context2.next = 4;\n\t            return getRedirectionURL(cozy, type, doc);\n\t\n\t          case 4:\n\t            redirectionURL = _context2.sent;\n\t\n\t            if (!(redirectFn && typeof redirectFn === 'function')) {\n\t              _context2.next = 7;\n\t              break;\n\t            }\n\t\n\t            return _context2.abrupt('return', redirectFn(redirectionURL));\n\t\n\t          case 7:\n\t\n\t            window.location.href = redirectionURL;\n\t\n\t          case 8:\n\t          case 'end':\n\t            return _context2.stop();\n\t        }\n\t      }\n\t    }, _callee2, this);\n\t  }));\n\t\n\t  return function redirect(_x6, _x7, _x8, _x9) {\n\t    return _ref2.apply(this, arguments);\n\t  };\n\t}();\n\t\n\texports.create = create;\n\texports.createService = createService;\n\t\n\tvar _fetch = __webpack_require__(1);\n\t\n\tvar _helpers = __webpack_require__(9);\n\t\n\tvar _client = __webpack_require__(42);\n\t\n\tvar client = _interopRequireWildcard(_client);\n\t\n\tvar _service = __webpack_require__(43);\n\t\n\tvar service = _interopRequireWildcard(_service);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tfunction create(cozy, action, type) {\n\t  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t  var permissions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\t\n\t  if (!action) throw new Error('Misformed intent, \"action\" property must be provided');\n\t  if (!type) throw new Error('Misformed intent, \"type\" property must be provided');\n\t\n\t  var createPromise = (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/intents', {\n\t    data: {\n\t      type: 'io.cozy.intents',\n\t      attributes: {\n\t        action: action,\n\t        type: type,\n\t        data: data,\n\t        permissions: permissions\n\t      }\n\t    }\n\t  });\n\t\n\t  createPromise.start = function (element, onReadyCallback) {\n\t    var options = {\n\t      filteredServices: data.filteredServices,\n\t      onReadyCallback: onReadyCallback\n\t    };\n\t\n\t    delete data.filteredServices;\n\t\n\t    return createPromise.then(function (intent) {\n\t      return client.start(cozy, intent, element, data, options);\n\t    });\n\t  };\n\t\n\t  return createPromise;\n\t}\n\t\n\t// returns a service to communicate with intent client\n\tfunction createService(cozy, intentId, serviceWindow) {\n\t  return service.start(cozy, intentId, serviceWindow);\n\t}\n\t\n\tfunction removeQueryString(url) {\n\t  return url.replace(/\\?[^/#]*/, '');\n\t}\n\t\n\tfunction isSerializable(value) {\n\t  return !['object', 'function'].includes(typeof value === 'undefined' ? 'undefined' : _typeof(value));\n\t}\n\t\n\tfunction buildRedirectionURL(url, data) {\n\t  var parameterStrings = Object.keys(data).filter(function (key) {\n\t    return isSerializable(data[key]);\n\t  }).map(function (key) {\n\t    return key + '=' + data[key];\n\t  });\n\t\n\t  return parameterStrings.length ? url + '?' + parameterStrings.join('&') : url;\n\t}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tfunction indexKey(doc) {\n\t  return doc.type + '/' + doc.id;\n\t}\n\t\n\tfunction findByRef(resources, ref) {\n\t  return resources[indexKey(ref)];\n\t}\n\t\n\tfunction handleResource(rawResource, resources, links) {\n\t  var resource = {\n\t    _id: rawResource.id,\n\t    _type: rawResource.type,\n\t    _rev: rawResource.meta && rawResource.meta.rev,\n\t    links: Object.assign({}, rawResource.links, links),\n\t    attributes: rawResource.attributes,\n\t    relations: function relations(name) {\n\t      var rels = rawResource.relationships[name];\n\t      if (rels === undefined || rels.data === undefined) return undefined;\n\t      if (rels.data === null) return null;\n\t      if (!Array.isArray(rels.data)) return findByRef(resources, rels.data);\n\t      return rels.data.map(function (ref) {\n\t        return findByRef(resources, ref);\n\t      });\n\t    }\n\t  };\n\t  if (rawResource.relationships) {\n\t    resource.relationships = rawResource.relationships;\n\t  }\n\t\n\t  resources[indexKey(rawResource)] = resource;\n\t\n\t  return resource;\n\t}\n\t\n\tfunction handleTopLevel(doc) {\n\t  var resources = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  // build an index of included resource by Type & ID\n\t  var included = doc.included;\n\t\n\t  if (Array.isArray(included)) {\n\t    included.forEach(function (r) {\n\t      return handleResource(r, resources, doc.links);\n\t    });\n\t  }\n\t\n\t  if (Array.isArray(doc.data)) {\n\t    return doc.data.map(function (r) {\n\t      return handleResource(r, resources, doc.links);\n\t    });\n\t  } else {\n\t    return handleResource(doc.data, resources, doc.links);\n\t  }\n\t}\n\t\n\texports.default = handleTopLevel;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(49);\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function (it) {\n\t  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function (it, key) {\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP = __webpack_require__(62);\n\tvar createDesc = __webpack_require__(67);\n\tmodule.exports = __webpack_require__(11) ? function (object, key, value) {\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function (object, key, value) {\n\t  object[key] = value;\n\t  return object;\n\t};\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(54);\n\t// eslint-disable-next-line no-prototype-builtins\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil = Math.ceil;\n\tvar floor = Math.floor;\n\tmodule.exports = function (it) {\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(24);\n\tvar defined = __webpack_require__(21);\n\tmodule.exports = function (it) {\n\t  return IObject(defined(it));\n\t};\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\tvar id = 0;\n\tvar px = Math.random();\n\tmodule.exports = function (key) {\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar immediate = __webpack_require__(14);\n\t\n\t/* istanbul ignore next */\n\tfunction INTERNAL() {}\n\t\n\tvar handlers = {};\n\t\n\tvar REJECTED = ['REJECTED'];\n\tvar FULFILLED = ['FULFILLED'];\n\tvar PENDING = ['PENDING'];\n\t\n\tmodule.exports = Promise;\n\t\n\tfunction Promise(resolver) {\n\t  if (typeof resolver !== 'function') {\n\t    throw new TypeError('resolver must be a function');\n\t  }\n\t  this.state = PENDING;\n\t  this.queue = [];\n\t  this.outcome = void 0;\n\t  if (resolver !== INTERNAL) {\n\t    safelyResolveThenable(this, resolver);\n\t  }\n\t}\n\t\n\tPromise.prototype[\"catch\"] = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\tPromise.prototype.then = function (onFulfilled, onRejected) {\n\t  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n\t    typeof onRejected !== 'function' && this.state === REJECTED) {\n\t    return this;\n\t  }\n\t  var promise = new this.constructor(INTERNAL);\n\t  if (this.state !== PENDING) {\n\t    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n\t    unwrap(promise, resolver, this.outcome);\n\t  } else {\n\t    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n\t  }\n\t\n\t  return promise;\n\t};\n\tfunction QueueItem(promise, onFulfilled, onRejected) {\n\t  this.promise = promise;\n\t  if (typeof onFulfilled === 'function') {\n\t    this.onFulfilled = onFulfilled;\n\t    this.callFulfilled = this.otherCallFulfilled;\n\t  }\n\t  if (typeof onRejected === 'function') {\n\t    this.onRejected = onRejected;\n\t    this.callRejected = this.otherCallRejected;\n\t  }\n\t}\n\tQueueItem.prototype.callFulfilled = function (value) {\n\t  handlers.resolve(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallFulfilled = function (value) {\n\t  unwrap(this.promise, this.onFulfilled, value);\n\t};\n\tQueueItem.prototype.callRejected = function (value) {\n\t  handlers.reject(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallRejected = function (value) {\n\t  unwrap(this.promise, this.onRejected, value);\n\t};\n\t\n\tfunction unwrap(promise, func, value) {\n\t  immediate(function () {\n\t    var returnValue;\n\t    try {\n\t      returnValue = func(value);\n\t    } catch (e) {\n\t      return handlers.reject(promise, e);\n\t    }\n\t    if (returnValue === promise) {\n\t      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n\t    } else {\n\t      handlers.resolve(promise, returnValue);\n\t    }\n\t  });\n\t}\n\t\n\thandlers.resolve = function (self, value) {\n\t  var result = tryCatch(getThen, value);\n\t  if (result.status === 'error') {\n\t    return handlers.reject(self, result.value);\n\t  }\n\t  var thenable = result.value;\n\t\n\t  if (thenable) {\n\t    safelyResolveThenable(self, thenable);\n\t  } else {\n\t    self.state = FULFILLED;\n\t    self.outcome = value;\n\t    var i = -1;\n\t    var len = self.queue.length;\n\t    while (++i < len) {\n\t      self.queue[i].callFulfilled(value);\n\t    }\n\t  }\n\t  return self;\n\t};\n\thandlers.reject = function (self, error) {\n\t  self.state = REJECTED;\n\t  self.outcome = error;\n\t  var i = -1;\n\t  var len = self.queue.length;\n\t  while (++i < len) {\n\t    self.queue[i].callRejected(error);\n\t  }\n\t  return self;\n\t};\n\t\n\tfunction getThen(obj) {\n\t  // Make sure we only access the accessor once as required by the spec\n\t  var then = obj && obj.then;\n\t  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n\t    return function appyThen() {\n\t      then.apply(obj, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction safelyResolveThenable(self, thenable) {\n\t  // Either fulfill, reject or reject with error\n\t  var called = false;\n\t  function onError(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.reject(self, value);\n\t  }\n\t\n\t  function onSuccess(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.resolve(self, value);\n\t  }\n\t\n\t  function tryToUnwrap() {\n\t    thenable(onSuccess, onError);\n\t  }\n\t\n\t  var result = tryCatch(tryToUnwrap);\n\t  if (result.status === 'error') {\n\t    onError(result.value);\n\t  }\n\t}\n\t\n\tfunction tryCatch(func, value) {\n\t  var out = {};\n\t  try {\n\t    out.value = func(value);\n\t    out.status = 'success';\n\t  } catch (e) {\n\t    out.status = 'error';\n\t    out.value = e;\n\t  }\n\t  return out;\n\t}\n\t\n\tPromise.resolve = resolve;\n\tfunction resolve(value) {\n\t  if (value instanceof this) {\n\t    return value;\n\t  }\n\t  return handlers.resolve(new this(INTERNAL), value);\n\t}\n\t\n\tPromise.reject = reject;\n\tfunction reject(reason) {\n\t  var promise = new this(INTERNAL);\n\t  return handlers.reject(promise, reason);\n\t}\n\t\n\tPromise.all = all;\n\tfunction all(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var values = new Array(len);\n\t  var resolved = 0;\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    allResolver(iterable[i], i);\n\t  }\n\t  return promise;\n\t  function allResolver(value, i) {\n\t    self.resolve(value).then(resolveFromAll, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t    function resolveFromAll(outValue) {\n\t      values[i] = outValue;\n\t      if (++resolved === len && !called) {\n\t        called = true;\n\t        handlers.resolve(promise, values);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tPromise.race = race;\n\tfunction race(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    resolver(iterable[i]);\n\t  }\n\t  return promise;\n\t  function resolver(value) {\n\t    self.resolve(value).then(function (response) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.resolve(promise, response);\n\t      }\n\t    }, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t  }\n\t}\n\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tvar thisAtob = function (str) {\n\t  return atob(str);\n\t};\n\t\n\tvar thisBtoa = function (str) {\n\t  return btoa(str);\n\t};\n\t\n\t// Abstracts constructing a Blob object, so it also works in older\n\t// browsers that don't support the native Blob constructor (e.g.\n\t// old QtWebKit versions, Android < 4.4).\n\tfunction createBlob(parts, properties) {\n\t  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n\t  parts = parts || [];\n\t  properties = properties || {};\n\t  try {\n\t    return new Blob(parts, properties);\n\t  } catch (e) {\n\t    if (e.name !== \"TypeError\") {\n\t      throw e;\n\t    }\n\t    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n\t                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n\t                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n\t                  WebKitBlobBuilder;\n\t    var builder = new Builder();\n\t    for (var i = 0; i < parts.length; i += 1) {\n\t      builder.append(parts[i]);\n\t    }\n\t    return builder.getBlob(properties.type);\n\t  }\n\t}\n\t\n\t// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n\t// encode-decode-image-with-base64-breaks-image (2013-04-21)\n\tfunction binaryStringToArrayBuffer(bin) {\n\t  var length = bin.length;\n\t  var buf = new ArrayBuffer(length);\n\t  var arr = new Uint8Array(buf);\n\t  for (var i = 0; i < length; i++) {\n\t    arr[i] = bin.charCodeAt(i);\n\t  }\n\t  return buf;\n\t}\n\t\n\tfunction binStringToBluffer(binString, type) {\n\t  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n\t}\n\t\n\tfunction b64ToBluffer(b64, type) {\n\t  return binStringToBluffer(thisAtob(b64), type);\n\t}\n\t\n\t//Can't find original post, but this is close\n\t//http://stackoverflow.com/questions/6965107/ (continues on next line)\n\t//converting-between-strings-and-arraybuffers\n\tfunction arrayBufferToBinaryString(buffer) {\n\t  var binary = '';\n\t  var bytes = new Uint8Array(buffer);\n\t  var length = bytes.byteLength;\n\t  for (var i = 0; i < length; i++) {\n\t    binary += String.fromCharCode(bytes[i]);\n\t  }\n\t  return binary;\n\t}\n\t\n\t// shim for browsers that don't support it\n\tfunction readAsBinaryString(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(arrayBufferToBinaryString(\n\t      new FileReaderSync().readAsArrayBuffer(blob)));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || '';\n\t    if (hasBinaryString) {\n\t      return callback(result);\n\t    }\n\t    callback(arrayBufferToBinaryString(result));\n\t  };\n\t  if (hasBinaryString) {\n\t    reader.readAsBinaryString(blob);\n\t  } else {\n\t    reader.readAsArrayBuffer(blob);\n\t  }\n\t}\n\t\n\tfunction blobToBinaryString(blobOrBuffer, callback) {\n\t  readAsBinaryString(blobOrBuffer, function (bin) {\n\t    callback(bin);\n\t  });\n\t}\n\t\n\tfunction blobToBase64(blobOrBuffer, callback) {\n\t  blobToBinaryString(blobOrBuffer, function (base64) {\n\t    callback(thisBtoa(base64));\n\t  });\n\t}\n\t\n\t// simplified API. universal browser support is assumed\n\tfunction readAsArrayBuffer(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker:\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || new ArrayBuffer(0);\n\t    callback(result);\n\t  };\n\t  reader.readAsArrayBuffer(blob);\n\t}\n\t\n\t// this is not used in the browser\n\tfunction typedBuffer() {\n\t}\n\t\n\texports.atob = thisAtob;\n\texports.btoa = thisBtoa;\n\texports.base64StringToBlobOrBuffer = b64ToBluffer;\n\texports.binaryStringToArrayBuffer = binaryStringToArrayBuffer;\n\texports.binaryStringToBlobOrBuffer = binStringToBluffer;\n\texports.blob = createBlob;\n\texports.blobOrBufferToBase64 = blobToBase64;\n\texports.blobOrBufferToBinaryString = blobToBinaryString;\n\texports.readAsArrayBuffer = readAsArrayBuffer;\n\texports.readAsBinaryString = readAsBinaryString;\n\texports.typedBuffer = typedBuffer;\n\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar pouchdbBinaryUtils = __webpack_require__(30);\n\tvar Md5 = _interopDefault(__webpack_require__(33));\n\t\n\tvar setImmediateShim = global.setImmediate || global.setTimeout;\n\tvar MD5_CHUNK_SIZE = 32768;\n\t\n\tfunction rawToBase64(raw) {\n\t  return pouchdbBinaryUtils.btoa(raw);\n\t}\n\t\n\tfunction sliceBlob(blob, start, end) {\n\t  if (blob.webkitSlice) {\n\t    return blob.webkitSlice(start, end);\n\t  }\n\t  return blob.slice(start, end);\n\t}\n\t\n\tfunction appendBlob(buffer, blob, start, end, callback) {\n\t  if (start > 0 || end < blob.size) {\n\t    // only slice blob if we really need to\n\t    blob = sliceBlob(blob, start, end);\n\t  }\n\t  pouchdbBinaryUtils.readAsArrayBuffer(blob, function (arrayBuffer) {\n\t    buffer.append(arrayBuffer);\n\t    callback();\n\t  });\n\t}\n\t\n\tfunction appendString(buffer, string, start, end, callback) {\n\t  if (start > 0 || end < string.length) {\n\t    // only create a substring if we really need to\n\t    string = string.substring(start, end);\n\t  }\n\t  buffer.appendBinary(string);\n\t  callback();\n\t}\n\t\n\tfunction binaryMd5(data, callback) {\n\t  var inputIsString = typeof data === 'string';\n\t  var len = inputIsString ? data.length : data.size;\n\t  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n\t  var chunks = Math.ceil(len / chunkSize);\n\t  var currentChunk = 0;\n\t  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\t\n\t  var append = inputIsString ? appendString : appendBlob;\n\t\n\t  function next() {\n\t    setImmediateShim(loadNextChunk);\n\t  }\n\t\n\t  function done() {\n\t    var raw = buffer.end(true);\n\t    var base64 = rawToBase64(raw);\n\t    callback(base64);\n\t    buffer.destroy();\n\t  }\n\t\n\t  function loadNextChunk() {\n\t    var start = currentChunk * chunkSize;\n\t    var end = start + chunkSize;\n\t    currentChunk++;\n\t    if (currentChunk < chunks) {\n\t      append(buffer, data, start, end, next);\n\t    } else {\n\t      append(buffer, data, start, end, done);\n\t    }\n\t  }\n\t  loadNextChunk();\n\t}\n\t\n\tfunction stringMd5(string) {\n\t  return Md5.hash(string);\n\t}\n\t\n\texports.binaryMd5 = binaryMd5;\n\texports.stringMd5 = stringMd5;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 32 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\tprocess.prependListener = noop;\n\tprocess.prependOnceListener = noop;\n\t\n\tprocess.listeners = function (name) { return [] }\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (factory) {\n\t    if (true) {\n\t        // Node/CommonJS\n\t        module.exports = factory();\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        // AMD\n\t        define(factory);\n\t    } else {\n\t        // Browser globals (with support for web workers)\n\t        var glob;\n\t\n\t        try {\n\t            glob = window;\n\t        } catch (e) {\n\t            glob = self;\n\t        }\n\t\n\t        glob.SparkMD5 = factory();\n\t    }\n\t}(function (undefined) {\n\t\n\t    'use strict';\n\t\n\t    /*\n\t     * Fastest md5 implementation around (JKM md5).\n\t     * Credits: Joseph Myers\n\t     *\n\t     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n\t     * @see http://jsperf.com/md5-shootout/7\n\t     */\n\t\n\t    /* this function is much faster,\n\t      so if possible we use it. Some IEs\n\t      are the only ones I know of that\n\t      need the idiotic second function,\n\t      generated by an if clause.  */\n\t    var add32 = function (a, b) {\n\t        return (a + b) & 0xFFFFFFFF;\n\t    },\n\t        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\t\n\t\n\t    function cmn(q, a, b, x, s, t) {\n\t        a = add32(add32(a, q), add32(x, t));\n\t        return add32((a << s) | (a >>> (32 - s)), b);\n\t    }\n\t\n\t    function md5cycle(x, k) {\n\t        var a = x[0],\n\t            b = x[1],\n\t            c = x[2],\n\t            d = x[3];\n\t\n\t        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t\n\t        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t\n\t        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t\n\t        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n\t        b  = (b << 21 | b >>> 11) + c | 0;\n\t\n\t        x[0] = a + x[0] | 0;\n\t        x[1] = b + x[1] | 0;\n\t        x[2] = c + x[2] | 0;\n\t        x[3] = d + x[3] | 0;\n\t    }\n\t\n\t    function md5blk(s) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\t\n\t    function md5blk_array(a) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\t\n\t    function md51(s) {\n\t        var n = s.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk(s.substring(i - 64, i)));\n\t        }\n\t        s = s.substring(i - 64);\n\t        length = s.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t        return state;\n\t    }\n\t\n\t    function md51_array(a) {\n\t        var n = a.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n\t        }\n\t\n\t        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n\t        // containing the last element of the parent array if the sub array specified starts\n\t        // beyond the length of the parent array - weird.\n\t        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n\t        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\t\n\t        length = a.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t\n\t        return state;\n\t    }\n\t\n\t    function rhex(n) {\n\t        var s = '',\n\t            j;\n\t        for (j = 0; j < 4; j += 1) {\n\t            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n\t        }\n\t        return s;\n\t    }\n\t\n\t    function hex(x) {\n\t        var i;\n\t        for (i = 0; i < x.length; i += 1) {\n\t            x[i] = rhex(x[i]);\n\t        }\n\t        return x.join('');\n\t    }\n\t\n\t    // In some cases the fast add32 function cannot be used..\n\t    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n\t        add32 = function (x, y) {\n\t            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n\t                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t            return (msw << 16) | (lsw & 0xFFFF);\n\t        };\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * ArrayBuffer slice polyfill.\n\t     *\n\t     * @see https://github.com/ttaubert/node-arraybuffer-slice\n\t     */\n\t\n\t    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n\t        (function () {\n\t            function clamp(val, length) {\n\t                val = (val | 0) || 0;\n\t\n\t                if (val < 0) {\n\t                    return Math.max(val + length, 0);\n\t                }\n\t\n\t                return Math.min(val, length);\n\t            }\n\t\n\t            ArrayBuffer.prototype.slice = function (from, to) {\n\t                var length = this.byteLength,\n\t                    begin = clamp(from, length),\n\t                    end = length,\n\t                    num,\n\t                    target,\n\t                    targetArray,\n\t                    sourceArray;\n\t\n\t                if (to !== undefined) {\n\t                    end = clamp(to, length);\n\t                }\n\t\n\t                if (begin > end) {\n\t                    return new ArrayBuffer(0);\n\t                }\n\t\n\t                num = end - begin;\n\t                target = new ArrayBuffer(num);\n\t                targetArray = new Uint8Array(target);\n\t\n\t                sourceArray = new Uint8Array(this, begin, num);\n\t                targetArray.set(sourceArray);\n\t\n\t                return target;\n\t            };\n\t        })();\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * Helpers.\n\t     */\n\t\n\t    function toUtf8(str) {\n\t        if (/[\\u0080-\\uFFFF]/.test(str)) {\n\t            str = unescape(encodeURIComponent(str));\n\t        }\n\t\n\t        return str;\n\t    }\n\t\n\t    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n\t        var length = str.length,\n\t           buff = new ArrayBuffer(length),\n\t           arr = new Uint8Array(buff),\n\t           i;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            arr[i] = str.charCodeAt(i);\n\t        }\n\t\n\t        return returnUInt8Array ? arr : buff;\n\t    }\n\t\n\t    function arrayBuffer2Utf8Str(buff) {\n\t        return String.fromCharCode.apply(null, new Uint8Array(buff));\n\t    }\n\t\n\t    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n\t        var result = new Uint8Array(first.byteLength + second.byteLength);\n\t\n\t        result.set(new Uint8Array(first));\n\t        result.set(new Uint8Array(second), first.byteLength);\n\t\n\t        return returnUInt8Array ? result : result.buffer;\n\t    }\n\t\n\t    function hexToBinaryString(hex) {\n\t        var bytes = [],\n\t            length = hex.length,\n\t            x;\n\t\n\t        for (x = 0; x < length - 1; x += 2) {\n\t            bytes.push(parseInt(hex.substr(x, 2), 16));\n\t        }\n\t\n\t        return String.fromCharCode.apply(String, bytes);\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation.\n\t     *\n\t     * Use this class to perform an incremental md5, otherwise use the\n\t     * static methods instead.\n\t     */\n\t\n\t    function SparkMD5() {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    }\n\t\n\t    /**\n\t     * Appends a string.\n\t     * A conversion will be applied if an utf8 string is detected.\n\t     *\n\t     * @param {String} str The string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.append = function (str) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then append as binary\n\t        this.appendBinary(toUtf8(str));\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Appends a binary string.\n\t     *\n\t     * @param {String} contents The binary string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.appendBinary = function (contents) {\n\t        this._buff += contents;\n\t        this._length += contents.length;\n\t\n\t        var length = this._buff.length,\n\t            i;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n\t        }\n\t\n\t        this._buff = this._buff.substring(i - 64);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            i,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\t\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.reset = function () {\n\t        this._buff = '';\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.prototype.getState = function () {\n\t        return {\n\t            buff: this._buff,\n\t            length: this._length,\n\t            hash: this._hash\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.setState = function (state) {\n\t        this._buff = state.buff;\n\t        this._length = state.length;\n\t        this._hash = state.hash;\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Releases memory used by the incremental buffer and other additional\n\t     * resources. If you plan to use the instance again, use reset instead.\n\t     */\n\t    SparkMD5.prototype.destroy = function () {\n\t        delete this._hash;\n\t        delete this._buff;\n\t        delete this._length;\n\t    };\n\t\n\t    /**\n\t     * Finish the final calculation based on the tail.\n\t     *\n\t     * @param {Array}  tail   The tail (will be modified)\n\t     * @param {Number} length The length of the remaining buffer\n\t     */\n\t    SparkMD5.prototype._finish = function (tail, length) {\n\t        var i = length,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(this._hash, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Do the final computation based on the tail and length\n\t        // Beware that the final length may not fit in 32 bits so we take care of that\n\t        tmp = this._length * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t        md5cycle(this._hash, tail);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a string.\n\t     * A conversion will be applied if utf8 string is detected.\n\t     *\n\t     * @param {String}  str The string\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hash = function (str, raw) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then compute it using the binary function\n\t        return SparkMD5.hashBinary(toUtf8(str), raw);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a binary string.\n\t     *\n\t     * @param {String}  content The binary string\n\t     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hashBinary = function (content, raw) {\n\t        var hash = md51(content),\n\t            ret = hex(hash);\n\t\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation for array buffers.\n\t     *\n\t     * Use this class to perform an incremental md5 ONLY for array buffers.\n\t     */\n\t    SparkMD5.ArrayBuffer = function () {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    };\n\t\n\t    /**\n\t     * Appends an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array to be appended\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n\t        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n\t            length = buff.length,\n\t            i;\n\t\n\t        this._length += arr.byteLength;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n\t        }\n\t\n\t        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            i,\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\t\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.reset = function () {\n\t        this._buff = new Uint8Array(0);\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.getState = function () {\n\t        var state = SparkMD5.prototype.getState.call(this);\n\t\n\t        // Convert buffer to a string\n\t        state.buff = arrayBuffer2Utf8Str(state.buff);\n\t\n\t        return state;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n\t        // Convert string to buffer\n\t        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\t\n\t        return SparkMD5.prototype.setState.call(this, state);\n\t    };\n\t\n\t    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\t\n\t    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\t\n\t    /**\n\t     * Performs the md5 hash on an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array buffer\n\t     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n\t        var hash = md51_array(new Uint8Array(arr)),\n\t            ret = hex(hash);\n\t\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\t\n\t    return SparkMD5;\n\t}));\n\n\n/***/ },\n/* 34 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar v1 = __webpack_require__(86);\n\tvar v4 = __webpack_require__(87);\n\t\n\tvar uuid = v4;\n\tuuid.v1 = v1;\n\tuuid.v4 = v4;\n\t\n\tmodule.exports = uuid;\n\n\n/***/ },\n/* 35 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Convert array of 16 byte values to UUID string format of the form:\n\t * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n\t */\n\tvar byteToHex = [];\n\tfor (var i = 0; i < 256; ++i) {\n\t  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n\t}\n\t\n\tfunction bytesToUuid(buf, offset) {\n\t  var i = offset || 0;\n\t  var bth = byteToHex;\n\t  return bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] + '-' +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]] +\n\t          bth[buf[i++]] + bth[buf[i++]];\n\t}\n\t\n\tmodule.exports = bytesToUuid;\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports) {\n\n\t// Unique ID creation requires a high quality random # generator.  In the\n\t// browser this is a little complicated due to unknown quality of Math.random()\n\t// and inconsistent support for the `crypto` API.  We do the best we can via\n\t// feature-detection\n\t\n\t// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n\tvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n\t                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\n\tif (getRandomValues) {\n\t  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n\t  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\t\n\t  module.exports = function whatwgRNG() {\n\t    getRandomValues(rnds8);\n\t    return rnds8;\n\t  };\n\t} else {\n\t  // Math.random()-based (RNG)\n\t  //\n\t  // If all else fails, use Math.random().  It's fast, but is of unspecified\n\t  // quality.\n\t  var rnds = new Array(16);\n\t\n\t  module.exports = function mathRNG() {\n\t    for (var i = 0, r; i < 16; i++) {\n\t      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n\t      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n\t    }\n\t\n\t    return rnds;\n\t  };\n\t}\n\n\n/***/ },\n/* 37 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar LocalStorage = exports.LocalStorage = function () {\n\t  function LocalStorage(storage, prefix) {\n\t    _classCallCheck(this, LocalStorage);\n\t\n\t    if (!storage && typeof window !== 'undefined') {\n\t      storage = window.localStorage;\n\t    }\n\t    this.storage = storage;\n\t    this.prefix = prefix || 'cozy:oauth:';\n\t  }\n\t\n\t  _createClass(LocalStorage, [{\n\t    key: 'save',\n\t    value: function save(key, value) {\n\t      var _this = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this.storage.setItem(_this.prefix + key, JSON.stringify(value));\n\t        resolve(value);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'load',\n\t    value: function load(key) {\n\t      var _this2 = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        var item = _this2.storage.getItem(_this2.prefix + key);\n\t        if (!item) {\n\t          resolve();\n\t        } else {\n\t          resolve(JSON.parse(item));\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'delete',\n\t    value: function _delete(key) {\n\t      var _this3 = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        return resolve(_this3.storage.removeItem(_this3.prefix + key));\n\t      });\n\t    }\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      var _this4 = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        var storage = _this4.storage;\n\t        for (var i = 0; i < storage.length; i++) {\n\t          var key = storage.key(i);\n\t          if (key.indexOf(_this4.prefix) === 0) {\n\t            storage.removeItem(key);\n\t          }\n\t        }\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return LocalStorage;\n\t}();\n\t\n\tvar MemoryStorage = exports.MemoryStorage = function () {\n\t  function MemoryStorage() {\n\t    _classCallCheck(this, MemoryStorage);\n\t\n\t    this.hash = Object.create(null);\n\t  }\n\t\n\t  _createClass(MemoryStorage, [{\n\t    key: 'save',\n\t    value: function save(key, value) {\n\t      this.hash[key] = value;\n\t      return Promise.resolve(value);\n\t    }\n\t  }, {\n\t    key: 'load',\n\t    value: function load(key) {\n\t      return Promise.resolve(this.hash[key]);\n\t    }\n\t  }, {\n\t    key: 'delete',\n\t    value: function _delete(key) {\n\t      var deleted = delete this.hash[key];\n\t      return Promise.resolve(deleted);\n\t    }\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      this.hash = Object.create(null);\n\t      return Promise.resolve();\n\t    }\n\t  }]);\n\n\t  return MemoryStorage;\n\t}();\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.getAppToken = getAppToken;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* global btoa */\n\tvar V2TOKEN_ABORT_TIMEOUT = 3000;\n\t\n\tfunction getAppToken() {\n\t  return new Promise(function (resolve, reject) {\n\t    if (typeof window === 'undefined') {\n\t      return reject(new Error('getV2Token should be used in browser'));\n\t    } else if (!window.parent) {\n\t      return reject(new Error('getV2Token should be used in iframe'));\n\t    } else if (!window.parent.postMessage) {\n\t      return reject(new Error('getV2Token should be used in modern browser'));\n\t    }\n\t    var origin = window.location.origin;\n\t    var intent = { action: 'getToken' };\n\t    var timeout = null;\n\t    var receiver = function receiver(event) {\n\t      var token = void 0;\n\t      try {\n\t        token = new AppToken({\n\t          appName: event.data.appName,\n\t          token: event.data.token\n\t        });\n\t      } catch (e) {\n\t        reject(e);\n\t        return;\n\t      }\n\t      window.removeEventListener('message', receiver);\n\t      clearTimeout(timeout);\n\t      resolve({ client: null, token: token });\n\t    };\n\t    window.addEventListener('message', receiver, false);\n\t    window.parent.postMessage(intent, origin);\n\t    timeout = setTimeout(function () {\n\t      reject(new Error('No response from parent iframe after 3s'));\n\t    }, V2TOKEN_ABORT_TIMEOUT);\n\t  });\n\t}\n\t\n\tvar AppToken = exports.AppToken = function () {\n\t  function AppToken(opts) {\n\t    _classCallCheck(this, AppToken);\n\t\n\t    this.appName = opts.appName || '';\n\t    this.token = opts.token || '';\n\t  }\n\t\n\t  _createClass(AppToken, [{\n\t    key: 'toAuthHeader',\n\t    value: function toAuthHeader() {\n\t      return 'Basic ' + btoa(this.appName + ':' + this.token);\n\t    }\n\t  }]);\n\n\t  return AppToken;\n\t}();\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.create = create;\n\texports.find = find;\n\texports.findMany = findMany;\n\texports.findAll = findAll;\n\texports.changesFeed = changesFeed;\n\texports.update = update;\n\texports.updateAttributes = updateAttributes;\n\texports._delete = _delete;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _doctypes = __webpack_require__(3);\n\t\n\tvar _fetch = __webpack_require__(1);\n\t\n\tvar NOREV = 'stack-v2-no-rev';\n\t\n\tfunction create(cozy, doctype, attributes) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    if (isV2) {\n\t      attributes.docType = doctype;\n\t    }\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, attributes._id);\n\t    var httpVerb = attributes._id ? 'PUT' : 'POST';\n\t    delete attributes._id;\n\t    return (0, _fetch.cozyFetchJSON)(cozy, httpVerb, path, attributes).then(function (resp) {\n\t      if (isV2) {\n\t        return find(cozy, doctype, resp._id);\n\t      } else {\n\t        return resp.data;\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\tfunction find(cozy, doctype, id) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t\n\t    if (!id) {\n\t      return Promise.reject(new Error('Missing id parameter'));\n\t    }\n\t\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, id);\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'GET', path).then(function (resp) {\n\t      if (isV2) {\n\t        return Object.assign(resp, { _rev: NOREV });\n\t      } else {\n\t        return resp;\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\tfunction findMany(cozy, doctype, ids) {\n\t  if (!(ids instanceof Array)) {\n\t    return Promise.reject(new Error('Parameter ids must be a non-empty array'));\n\t  }\n\t  if (ids.length === 0) {\n\t    // So users don't need to be defensive regarding the array content.\n\t    // This should not hide issues in user code since the result will be an\n\t    // empty object anyway.\n\t    return Promise.resolve({});\n\t  }\n\t\n\t  return cozy.isV2().then(function (isV2) {\n\t    if (isV2) {\n\t      return Promise.reject(new Error('findMany is not available on v2'));\n\t    }\n\t\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, '_all_docs', {\n\t      include_docs: true\n\t    });\n\t\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, { keys: ids }).then(function (resp) {\n\t      var docs = {};\n\t\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = resp.rows[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var row = _step.value;\n\t          var key = row.key,\n\t              doc = row.doc,\n\t              error = row.error;\n\t\n\t          docs[key] = error ? { error: error } : { doc: doc };\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t\n\t      return docs;\n\t    }).catch(function (error) {\n\t      if (error.status !== 404) return Promise.reject(error);\n\t\n\t      // When no doc was ever created and the database does not exist yet,\n\t      // the response will be a 404 error.\n\t      var docs = {};\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = ids[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var id = _step2.value;\n\t\n\t          docs[id] = { error: error };\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return docs;\n\t    });\n\t  });\n\t}\n\t\n\tfunction findAll(cozy, doctype) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    if (isV2) {\n\t      return Promise.reject(new Error('findAll is not available on v2'));\n\t    }\n\t\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, '_all_docs', {\n\t      include_docs: true\n\t    });\n\t\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, {}).then(function (resp) {\n\t      var docs = [];\n\t\n\t      var _iteratorNormalCompletion3 = true;\n\t      var _didIteratorError3 = false;\n\t      var _iteratorError3 = undefined;\n\t\n\t      try {\n\t        for (var _iterator3 = resp.rows[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t          var row = _step3.value;\n\t          var doc = row.doc;\n\t          // if not couchDB indexes\n\t\n\t          if (!doc._id.match(/_design\\//)) docs.push(doc);\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t            _iterator3.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError3) {\n\t            throw _iteratorError3;\n\t          }\n\t        }\n\t      }\n\t\n\t      return docs;\n\t    }).catch(function (error) {\n\t      // the _all_docs endpoint returns a 404 error if no document with the given\n\t      // doctype exists.\n\t      if (error.status === 404) return [];\n\t      throw error;\n\t    });\n\t  });\n\t}\n\t\n\tfunction changesFeed(cozy, doctype, options) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, '_changes', options);\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'GET', path);\n\t  });\n\t}\n\t\n\tfunction update(cozy, doctype, doc, changes) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    var _id = doc._id,\n\t        _rev = doc._rev;\n\t\n\t\n\t    if (!_id) {\n\t      return Promise.reject(new Error('Missing _id field in passed document'));\n\t    }\n\t\n\t    if (!isV2 && !_rev) {\n\t      return Promise.reject(new Error('Missing _rev field in passed document'));\n\t    }\n\t\n\t    if (isV2) {\n\t      changes = Object.assign({ _id: _id }, changes);\n\t    } else {\n\t      changes = Object.assign({ _id: _id, _rev: _rev }, changes);\n\t    }\n\t\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, _id);\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'PUT', path, changes).then(function (resp) {\n\t      if (isV2) {\n\t        return find(cozy, doctype, _id);\n\t      } else {\n\t        return resp.data;\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\tfunction updateAttributes(cozy, doctype, _id, changes) {\n\t  var tries = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 3;\n\t\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    return find(cozy, doctype, _id).then(function (doc) {\n\t      return update(cozy, doctype, doc, Object.assign({ _id: _id }, doc, changes));\n\t    }).catch(function (err) {\n\t      if (tries > 0) {\n\t        return updateAttributes(cozy, doctype, _id, changes, tries - 1);\n\t      } else {\n\t        throw err;\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\tfunction _delete(cozy, doctype, doc) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    var _id = doc._id,\n\t        _rev = doc._rev;\n\t\n\t\n\t    if (!_id) {\n\t      return Promise.reject(new Error('Missing _id field in passed document'));\n\t    }\n\t\n\t    if (!isV2 && !_rev) {\n\t      return Promise.reject(new Error('Missing _rev field in passed document'));\n\t    }\n\t\n\t    var query = isV2 ? null : { rev: _rev };\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, _id, query);\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', path).then(function (resp) {\n\t      if (isV2) {\n\t        return { id: _id, rev: NOREV };\n\t      } else {\n\t        return resp;\n\t      }\n\t    });\n\t  });\n\t}\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.TRASH_DIR_ID = exports.ROOT_DIR_ID = undefined;\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /* global Blob, File */\n\t\n\t\n\texports.create = create;\n\texports.createDirectory = createDirectory;\n\texports.createDirectoryByPath = createDirectoryByPath;\n\texports.updateById = updateById;\n\texports.updateAttributesById = updateAttributesById;\n\texports.updateAttributesByPath = updateAttributesByPath;\n\texports.trashById = trashById;\n\texports.statById = statById;\n\texports.statByPath = statByPath;\n\texports.downloadById = downloadById;\n\texports.downloadByPath = downloadByPath;\n\texports.getDownloadLinkByPath = getDownloadLinkByPath;\n\texports.getDownloadLinkById = getDownloadLinkById;\n\texports.getFilePath = getFilePath;\n\texports.getCollectionShareLink = getCollectionShareLink;\n\texports.getArchiveLinkByPaths = getArchiveLinkByPaths;\n\texports.getArchiveLinkByIds = getArchiveLinkByIds;\n\texports.listTrash = listTrash;\n\texports.clearTrash = clearTrash;\n\texports.restoreById = restoreById;\n\texports.destroyById = destroyById;\n\t\n\tvar _fetch = __webpack_require__(1);\n\t\n\tvar _jsonapi = __webpack_require__(19);\n\t\n\tvar _jsonapi2 = _interopRequireDefault(_jsonapi);\n\t\n\tvar _doctypes = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// global variables\n\tvar ROOT_DIR_ID = exports.ROOT_DIR_ID = 'io.cozy.files.root-dir';\n\tvar TRASH_DIR_ID = exports.TRASH_DIR_ID = 'io.cozy.files.trash-dir';\n\t\n\tvar contentTypeOctetStream = 'application/octet-stream';\n\t\n\tfunction sanitizeFileName(name) {\n\t  return name && name.trim();\n\t}\n\t\n\tfunction getFileTypeFromName(name) {\n\t  if (/\\.heic$/i.test(name)) return 'image/heic';else if (/\\.heif$/i.test(name)) return 'image/heif';else return null;\n\t}\n\t\n\tfunction doUpload(cozy, data, method, path, options) {\n\t  if (!data) {\n\t    throw new Error('missing data argument');\n\t  }\n\t\n\t  // transform any ArrayBufferView to ArrayBuffer\n\t  if (data.buffer && data.buffer instanceof ArrayBuffer) {\n\t    data = data.buffer;\n\t  }\n\t\n\t  var isBuffer = typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer;\n\t  var isFile = typeof File !== 'undefined' && data instanceof File;\n\t  var isBlob = typeof Blob !== 'undefined' && data instanceof Blob;\n\t  var isStream = data.readable === true && typeof data.pipe === 'function';\n\t  var isString = typeof data === 'string';\n\t\n\t  if (!isBuffer && !isFile && !isBlob && !isStream && !isString) {\n\t    throw new Error('invalid data type');\n\t  }\n\t\n\t  var _ref = options || {},\n\t      contentType = _ref.contentType,\n\t      contentLength = _ref.contentLength,\n\t      checksum = _ref.checksum,\n\t      lastModifiedDate = _ref.lastModifiedDate,\n\t      ifMatch = _ref.ifMatch;\n\t\n\t  if (!contentType) {\n\t    if (isBuffer) {\n\t      contentType = contentTypeOctetStream;\n\t    } else if (isFile) {\n\t      contentType = data.type || getFileTypeFromName(data.name.toLowerCase()) || contentTypeOctetStream;\n\t      if (!lastModifiedDate) {\n\t        lastModifiedDate = data.lastModifiedDate;\n\t      }\n\t    } else if (isBlob) {\n\t      contentType = data.type || contentTypeOctetStream;\n\t    } else if (isStream) {\n\t      contentType = contentTypeOctetStream;\n\t    } else if (typeof data === 'string') {\n\t      contentType = 'text/plain';\n\t    }\n\t  }\n\t\n\t  if (lastModifiedDate && typeof lastModifiedDate === 'string') {\n\t    lastModifiedDate = new Date(lastModifiedDate);\n\t  }\n\t\n\t  var headers = {\n\t    'Content-Type': contentType\n\t  };\n\t  if (contentLength) headers['Content-Length'] = String(contentLength);\n\t  if (checksum) headers['Content-MD5'] = checksum;\n\t  if (lastModifiedDate) headers['Date'] = lastModifiedDate.toGMTString();\n\t  if (ifMatch) headers['If-Match'] = ifMatch;\n\t\n\t  return (0, _fetch.cozyFetch)(cozy, path, {\n\t    method: method,\n\t    headers: headers,\n\t    body: data\n\t  }).then(function (res) {\n\t    var json = res.json();\n\t    if (!res.ok) {\n\t      return json.then(function (err) {\n\t        throw err;\n\t      });\n\t    } else {\n\t      return json.then(_jsonapi2.default);\n\t    }\n\t  });\n\t}\n\t\n\tfunction create(cozy, data, options) {\n\t  var _ref2 = options || {},\n\t      name = _ref2.name,\n\t      dirID = _ref2.dirID,\n\t      executable = _ref2.executable;\n\t\n\t  // handle case where data is a file and contains the name\n\t\n\t\n\t  if (!name && typeof data.name === 'string') {\n\t    name = data.name;\n\t  }\n\t\n\t  name = sanitizeFileName(name);\n\t\n\t  if (typeof name !== 'string' || name === '') {\n\t    throw new Error('missing name argument');\n\t  }\n\t\n\t  if (executable === undefined) {\n\t    executable = false;\n\t  }\n\t\n\t  var path = '/files/' + encodeURIComponent(dirID || '');\n\t  var query = '?Name=' + encodeURIComponent(name) + '&Type=file&Executable=' + executable;\n\t  return doUpload(cozy, data, 'POST', '' + path + query, options);\n\t}\n\t\n\tfunction createDirectory(cozy, options) {\n\t  var _ref3 = options || {},\n\t      name = _ref3.name,\n\t      dirID = _ref3.dirID,\n\t      lastModifiedDate = _ref3.lastModifiedDate;\n\t\n\t  name = sanitizeFileName(name);\n\t\n\t  if (typeof name !== 'string' || name === '') {\n\t    throw new Error('missing name argument');\n\t  }\n\t\n\t  if (lastModifiedDate && typeof lastModifiedDate === 'string') {\n\t    lastModifiedDate = new Date(lastModifiedDate);\n\t  }\n\t\n\t  var path = '/files/' + encodeURIComponent(dirID || '');\n\t  var query = '?Name=' + encodeURIComponent(name) + '&Type=directory';\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '' + path + query, undefined, {\n\t    headers: {\n\t      Date: lastModifiedDate ? lastModifiedDate.toGMTString() : ''\n\t    }\n\t  });\n\t}\n\t\n\tfunction getDirectoryOrCreate(cozy, name, parentDirectory) {\n\t  if (parentDirectory && !parentDirectory.attributes) throw new Error('Malformed parent directory');\n\t\n\t  name = sanitizeFileName(name);\n\t\n\t  var path = (parentDirectory._id === ROOT_DIR_ID ? '' : parentDirectory.attributes.path) + '/' + name;\n\t\n\t  return cozy.files.statByPath(path || '/').catch(function (error) {\n\t    var parsedError = JSON.parse(error.message);\n\t    var errors = parsedError.errors;\n\t    if (errors && errors.length && errors[0].status === '404') {\n\t      return cozy.files.createDirectory({\n\t        name: name,\n\t        dirID: parentDirectory && parentDirectory._id\n\t      });\n\t    }\n\t\n\t    throw errors;\n\t  });\n\t}\n\t\n\tfunction createDirectoryByPath(cozy, path, offline) {\n\t  var parts = path.split('/').filter(function (part) {\n\t    return part !== '';\n\t  });\n\t\n\t  var rootDirectoryPromise = cozy.files.statById(ROOT_DIR_ID, offline);\n\t\n\t  return parts.length ? parts.reduce(function (parentDirectoryPromise, part) {\n\t    return parentDirectoryPromise.then(function (parentDirectory) {\n\t      return getDirectoryOrCreate(cozy, part, parentDirectory);\n\t    });\n\t  }, rootDirectoryPromise) : rootDirectoryPromise;\n\t}\n\t\n\tfunction updateById(cozy, id, data, options) {\n\t  return doUpload(cozy, data, 'PUT', '/files/' + encodeURIComponent(id), options);\n\t}\n\t\n\tfunction doUpdateAttributes(cozy, attrs, path, options) {\n\t  if (!attrs || (typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) !== 'object') {\n\t    throw new Error('missing attrs argument');\n\t  }\n\t\n\t  var _ref4 = options || {},\n\t      ifMatch = _ref4.ifMatch;\n\t\n\t  var body = {\n\t    data: {\n\t      attributes: Object.assign({}, attrs, {\n\t        name: sanitizeFileName(attrs.name)\n\t      })\n\t    }\n\t  };\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'PATCH', path, body, {\n\t    headers: {\n\t      'If-Match': ifMatch || ''\n\t    }\n\t  });\n\t}\n\t\n\tfunction updateAttributesById(cozy, id, attrs, options) {\n\t  return doUpdateAttributes(cozy, attrs, '/files/' + encodeURIComponent(id), options);\n\t}\n\t\n\tfunction updateAttributesByPath(cozy, path, attrs, options) {\n\t  return doUpdateAttributes(cozy, attrs, '/files/metadata?Path=' + encodeURIComponent(path), options);\n\t}\n\t\n\tfunction trashById(cozy, id, options) {\n\t  if (typeof id !== 'string' || id === '') {\n\t    throw new Error('missing id argument');\n\t  }\n\t\n\t  var _ref5 = options || {},\n\t      ifMatch = _ref5.ifMatch;\n\t\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', '/files/' + encodeURIComponent(id), undefined, {\n\t    headers: {\n\t      'If-Match': ifMatch || ''\n\t    }\n\t  });\n\t}\n\t\n\tfunction statById(cozy, id) {\n\t  var offline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\n\t  if (offline && cozy.offline.hasDatabase(_doctypes.DOCTYPE_FILES)) {\n\t    var db = cozy.offline.getDatabase(_doctypes.DOCTYPE_FILES);\n\t    return Promise.all([db.get(id), db.find(Object.assign({ selector: { dir_id: id } }, options))]).then(function (_ref6) {\n\t      var _ref7 = _slicedToArray(_ref6, 2),\n\t          doc = _ref7[0],\n\t          children = _ref7[1];\n\t\n\t      if (id === ROOT_DIR_ID) {\n\t        children.docs = children.docs.filter(function (doc) {\n\t          return doc._id !== TRASH_DIR_ID;\n\t        });\n\t      }\n\t      children = sortFiles(children.docs.map(function (doc) {\n\t        return addIsDir(toJsonApi(cozy, doc));\n\t      }));\n\t      return addIsDir(toJsonApi(cozy, doc, children));\n\t    });\n\t  }\n\t  var query = Object.keys(options).length === 0 ? '' : '?' + encodePageOptions(options);\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/files/' + encodeURIComponent(id) + query).then(addIsDir);\n\t}\n\t\n\tfunction statByPath(cozy, path) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/files/metadata?Path=' + encodeURIComponent(path)).then(addIsDir);\n\t}\n\t\n\tfunction downloadById(cozy, id) {\n\t  return (0, _fetch.cozyFetch)(cozy, '/files/download/' + encodeURIComponent(id));\n\t}\n\t\n\tfunction downloadByPath(cozy, path) {\n\t  return (0, _fetch.cozyFetch)(cozy, '/files/download?Path=' + encodeURIComponent(path));\n\t}\n\t\n\tfunction extractResponseLinkRelated(res) {\n\t  var href = res.links && res.links.related;\n\t  if (!href) throw new Error('No related link in server response');\n\t  return href;\n\t}\n\t\n\tfunction getDownloadLinkByPath(cozy, path) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/files/downloads?Path=' + encodeURIComponent(path)).then(extractResponseLinkRelated);\n\t}\n\t\n\tfunction getDownloadLinkById(cozy, id) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/files/downloads?Id=' + encodeURIComponent(id)).then(extractResponseLinkRelated);\n\t}\n\t\n\tfunction getFilePath(cozy) {\n\t  var file = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t  var folder = arguments[2];\n\t\n\t  if (!folder || !folder.attributes) {\n\t    throw Error('Folder should be valid with an attributes.path property');\n\t  }\n\t\n\t  var folderPath = folder.attributes.path.endsWith('/') ? folder.attributes.path : folder.attributes.path + '/';\n\t\n\t  return '' + folderPath + file.name;\n\t}\n\t\n\tfunction getCollectionShareLink(cozy, id, collectionType) {\n\t  if (!id) {\n\t    return Promise.reject(Error('An id should be provided to create a share link'));\n\t  }\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/permissions?codes=email', {\n\t    data: {\n\t      type: 'io.cozy.permissions',\n\t      attributes: {\n\t        permissions: {\n\t          files: {\n\t            type: 'io.cozy.files',\n\t            verbs: ['GET'],\n\t            values: [id],\n\t            selector: 'referenced_by'\n\t          },\n\t          collection: {\n\t            type: collectionType,\n\t            verbs: ['GET'],\n\t            values: [id]\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }).then(function (data) {\n\t    return {\n\t      sharecode: 'sharecode=' + data.attributes.codes.email,\n\t      id: 'id=' + id\n\t    };\n\t  });\n\t}\n\t\n\tfunction getArchiveLinkByPaths(cozy, paths) {\n\t  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'files';\n\t\n\t  var archive = {\n\t    type: 'io.cozy.archives',\n\t    attributes: {\n\t      name: name,\n\t      files: paths\n\t    }\n\t  };\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/files/archive', { data: archive }).then(extractResponseLinkRelated);\n\t}\n\t\n\tfunction getArchiveLinkByIds(cozy, ids) {\n\t  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'files';\n\t\n\t  var archive = {\n\t    type: 'io.cozy.archives',\n\t    attributes: {\n\t      name: name,\n\t      ids: ids\n\t    }\n\t  };\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/files/archive', { data: archive }).then(extractResponseLinkRelated);\n\t}\n\t\n\tfunction listTrash(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/files/trash');\n\t}\n\t\n\tfunction clearTrash(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', '/files/trash');\n\t}\n\t\n\tfunction restoreById(cozy, id) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/files/trash/' + encodeURIComponent(id));\n\t}\n\t\n\tfunction destroyById(cozy, id, options) {\n\t  var _ref8 = options || {},\n\t      ifMatch = _ref8.ifMatch;\n\t\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', '/files/trash/' + encodeURIComponent(id), undefined, {\n\t    headers: {\n\t      'If-Match': ifMatch || ''\n\t    }\n\t  });\n\t}\n\t\n\tfunction addIsDir(obj) {\n\t  obj.isDir = obj.attributes.type === 'directory';\n\t  return obj;\n\t}\n\t\n\tfunction encodePageOptions(options) {\n\t  var opts = [];\n\t  for (var name in options) {\n\t    opts.push('page[' + encodeURIComponent(name) + ']=' + encodeURIComponent(options[name]));\n\t  }\n\t  return opts.join('&');\n\t}\n\t\n\tfunction toJsonApi(cozy, doc) {\n\t  var contents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t\n\t  var clone = JSON.parse(JSON.stringify(doc));\n\t  delete clone._id;\n\t  delete clone._rev;\n\t  return {\n\t    _id: doc._id,\n\t    _rev: doc._rev,\n\t    _type: _doctypes.DOCTYPE_FILES,\n\t    attributes: clone,\n\t    relationships: {\n\t      contents: {\n\t        data: contents,\n\t        meta: {\n\t          count: contents.length\n\t        }\n\t      }\n\t    },\n\t    relations: function relations(name) {\n\t      if (name === 'contents') {\n\t        return contents;\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tfunction sortFiles(allFiles) {\n\t  var folders = allFiles.filter(function (f) {\n\t    return f.attributes.type === 'directory';\n\t  });\n\t  var files = allFiles.filter(function (f) {\n\t    return f.attributes.type !== 'directory';\n\t  });\n\t  var sort = function sort(files) {\n\t    return files.sort(function (a, b) {\n\t      return a.attributes.name.localeCompare(b.attributes.name);\n\t    });\n\t  };\n\t  return sort(folders).concat(sort(files));\n\t}\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global fetch URL */\n\t\n\t\n\t__webpack_require__(75);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _auth_storage = __webpack_require__(37);\n\t\n\tvar _auth_v = __webpack_require__(38);\n\t\n\tvar _auth_v2 = __webpack_require__(8);\n\t\n\tvar auth = _interopRequireWildcard(_auth_v2);\n\t\n\tvar _data = __webpack_require__(39);\n\t\n\tvar data = _interopRequireWildcard(_data);\n\t\n\tvar _fetch = __webpack_require__(1);\n\t\n\tvar cozyFetch = _interopRequireWildcard(_fetch);\n\t\n\tvar _mango = __webpack_require__(45);\n\t\n\tvar mango = _interopRequireWildcard(_mango);\n\t\n\tvar _files = __webpack_require__(40);\n\t\n\tvar files = _interopRequireWildcard(_files);\n\t\n\tvar _intents = __webpack_require__(18);\n\t\n\tvar intents = _interopRequireWildcard(_intents);\n\t\n\tvar _jobs = __webpack_require__(44);\n\t\n\tvar jobs = _interopRequireWildcard(_jobs);\n\t\n\tvar _offline = __webpack_require__(46);\n\t\n\tvar offline = _interopRequireWildcard(_offline);\n\t\n\tvar _settings = __webpack_require__(48);\n\t\n\tvar settings = _interopRequireWildcard(_settings);\n\t\n\tvar _relations = __webpack_require__(47);\n\t\n\tvar relations = _interopRequireWildcard(_relations);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar AppTokenV3 = auth.AppToken,\n\t    AccessTokenV3 = auth.AccessToken,\n\t    ClientV3 = auth.Client;\n\t\n\t\n\tvar AuthNone = 0;\n\tvar AuthRunning = 1;\n\tvar AuthError = 2;\n\tvar AuthOK = 3;\n\t\n\tvar defaultClientParams = {\n\t  softwareID: 'github.com/cozy/cozy-client-js'\n\t};\n\t\n\tvar dataProto = {\n\t  create: data.create,\n\t  find: data.find,\n\t  findMany: data.findMany,\n\t  findAll: data.findAll,\n\t  update: data.update,\n\t  delete: data._delete,\n\t  updateAttributes: data.updateAttributes,\n\t  changesFeed: data.changesFeed,\n\t  defineIndex: mango.defineIndex,\n\t  query: mango.query,\n\t  addReferencedFiles: relations.addReferencedFiles,\n\t  removeReferencedFiles: relations.removeReferencedFiles,\n\t  listReferencedFiles: relations.listReferencedFiles,\n\t  fetchReferencedFiles: relations.fetchReferencedFiles,\n\t  destroy: function destroy() {\n\t    (0, _utils.warn)('destroy is deprecated, use cozy.data.delete instead.');\n\t    return data._delete.apply(data, arguments);\n\t  }\n\t};\n\t\n\tvar authProto = {\n\t  client: auth.client,\n\t  registerClient: auth.registerClient,\n\t  updateClient: auth.updateClient,\n\t  unregisterClient: auth.unregisterClient,\n\t  getClient: auth.getClient,\n\t  getAuthCodeURL: auth.getAuthCodeURL,\n\t  getAccessToken: auth.getAccessToken,\n\t  refreshToken: auth.refreshToken\n\t};\n\t\n\tvar filesProto = {\n\t  create: files.create,\n\t  createDirectory: files.createDirectory,\n\t  createDirectoryByPath: files.createDirectoryByPath,\n\t  updateById: files.updateById,\n\t  updateAttributesById: files.updateAttributesById,\n\t  updateAttributesByPath: files.updateAttributesByPath,\n\t  trashById: files.trashById,\n\t  statById: files.statById,\n\t  statByPath: files.statByPath,\n\t  downloadById: files.downloadById,\n\t  downloadByPath: files.downloadByPath,\n\t  getDownloadLinkById: files.getDownloadLinkById,\n\t  getDownloadLink: files.getDownloadLinkByPath, // DEPRECATED, should be removed very soon\n\t  getDownloadLinkByPath: files.getDownloadLinkByPath,\n\t  getArchiveLink: function getArchiveLink() {\n\t    (0, _utils.warn)('getArchiveLink is deprecated, use cozy.files.getArchiveLinkByPaths instead.');\n\t    return files.getArchiveLinkByPaths.apply(files, arguments);\n\t  },\n\t  getArchiveLinkByPaths: files.getArchiveLinkByPaths,\n\t  getArchiveLinkByIds: files.getArchiveLinkByIds,\n\t  getFilePath: files.getFilePath,\n\t  getCollectionShareLink: files.getCollectionShareLink,\n\t  query: mango.queryFiles,\n\t  listTrash: files.listTrash,\n\t  clearTrash: files.clearTrash,\n\t  restoreById: files.restoreById,\n\t  destroyById: files.destroyById\n\t};\n\t\n\tvar intentsProto = {\n\t  create: intents.create,\n\t  createService: intents.createService,\n\t  getRedirectionURL: intents.getRedirectionURL,\n\t  redirect: intents.redirect\n\t};\n\t\n\tvar jobsProto = {\n\t  create: jobs.create,\n\t  count: jobs.count,\n\t  queued: jobs.queued\n\t};\n\t\n\tvar offlineProto = {\n\t  init: offline.init,\n\t  getDoctypes: offline.getDoctypes,\n\t  // database\n\t  hasDatabase: offline.hasDatabase,\n\t  getDatabase: offline.getDatabase,\n\t  createDatabase: offline.createDatabase,\n\t  destroyDatabase: offline.destroyDatabase,\n\t  destroyAllDatabase: offline.destroyAllDatabase,\n\t  // replication\n\t  hasReplication: offline.hasReplication,\n\t  replicateFromCozy: offline.replicateFromCozy,\n\t  stopReplication: offline.stopReplication,\n\t  stopAllReplication: offline.stopAllReplication,\n\t  // repeated replication\n\t  hasRepeatedReplication: offline.hasRepeatedReplication,\n\t  startRepeatedReplication: offline.startRepeatedReplication,\n\t  stopRepeatedReplication: offline.stopRepeatedReplication,\n\t  stopAllRepeatedReplication: offline.stopAllRepeatedReplication\n\t};\n\t\n\tvar settingsProto = {\n\t  diskUsage: settings.diskUsage,\n\t  changePassphrase: settings.changePassphrase,\n\t  getInstance: settings.getInstance,\n\t  updateInstance: settings.updateInstance,\n\t  getClients: settings.getClients,\n\t  deleteClientById: settings.deleteClientById,\n\t  updateLastSync: settings.updateLastSync\n\t};\n\t\n\tvar ensureHasReconnectParam = function ensureHasReconnectParam(_url) {\n\t  var url = new URL(_url);\n\t  if (url.searchParams && !url.searchParams.has('reconnect')) {\n\t    url.searchParams.append('reconnect', 1);\n\t  } else if (!url.search || url.search.indexOf('reconnect') === -1) {\n\t    // Some old navigators do not have the searchParams API\n\t    // and it is not polyfilled by babel-polyfill\n\t    url.search = url.search + '&reconnect=1';\n\t  }\n\t  return url.toString();\n\t};\n\t\n\tvar Client = function () {\n\t  function Client(options) {\n\t    _classCallCheck(this, Client);\n\t\n\t    this.data = {};\n\t    this.files = {};\n\t    this.intents = {};\n\t    this.jobs = {};\n\t    this.offline = {};\n\t    this.settings = {};\n\t    this.auth = {\n\t      Client: ClientV3,\n\t      AccessToken: AccessTokenV3,\n\t      AppToken: AppTokenV3,\n\t      AppTokenV2: _auth_v.AppToken,\n\t      LocalStorage: _auth_storage.LocalStorage,\n\t      MemoryStorage: _auth_storage.MemoryStorage\n\t    };\n\t    this._inited = false;\n\t    if (options) {\n\t      this.init(options);\n\t    }\n\t  }\n\t\n\t  _createClass(Client, [{\n\t    key: 'init',\n\t    value: function init() {\n\t      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t      this._inited = true;\n\t      this._oauth = false; // is oauth activated or not\n\t      this._token = null; // application token\n\t      this._authstate = AuthNone;\n\t      this._authcreds = null;\n\t      this._storage = null;\n\t      this._version = options.version || null;\n\t      this._offline = null;\n\t\n\t      var token = options.token;\n\t      var oauth = options.oauth;\n\t      if (token && oauth) {\n\t        throw new Error('Cannot specify an application token with a oauth activated');\n\t      }\n\t\n\t      if (token) {\n\t        this._token = new AppTokenV3({ token: token });\n\t      } else if (oauth) {\n\t        this._oauth = true;\n\t        this._storage = oauth.storage;\n\t        this._clientParams = Object.assign({}, defaultClientParams, oauth.clientParams);\n\t        this._onRegistered = oauth.onRegistered || nopOnRegistered;\n\t      }\n\t\n\t      var url = options.cozyURL || '';\n\t      while (url[url.length - 1] === '/') {\n\t        url = url.slice(0, -1);\n\t      }\n\t\n\t      this._url = url;\n\t\n\t      this._invalidTokenErrorHandler = options.onInvalidTokenError !== undefined ? options.onInvalidTokenError : cozyFetch.handleInvalidTokenError;\n\t\n\t      var disablePromises = !!options.disablePromises;\n\t      addToProto(this, this.data, dataProto, disablePromises);\n\t      addToProto(this, this.auth, authProto, disablePromises);\n\t      addToProto(this, this.files, filesProto, disablePromises);\n\t      addToProto(this, this.intents, intentsProto, disablePromises);\n\t      addToProto(this, this.jobs, jobsProto, disablePromises);\n\t      addToProto(this, this.offline, offlineProto, disablePromises);\n\t      addToProto(this, this.settings, settingsProto, disablePromises);\n\t\n\t      if (options.offline) {\n\t        this.offline.init(options.offline);\n\t      }\n\t\n\t      // Exposing cozyFetchJSON to make some development easier. Should be temporary.\n\t      this.fetchJSON = function _fetchJSON() {\n\t        var args = [this].concat(Array.prototype.slice.call(arguments));\n\t        return cozyFetch.cozyFetchJSON.apply(this, args);\n\t      };\n\t    }\n\t  }, {\n\t    key: 'authorize',\n\t    value: function authorize() {\n\t      var _this = this;\n\t\n\t      var forceTokenRefresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t      var state = this._authstate;\n\t      if (state === AuthOK || state === AuthRunning) {\n\t        return this._authcreds;\n\t      }\n\t\n\t      this._authstate = AuthRunning;\n\t      this._authcreds = this.isV2().then(function (isV2) {\n\t        if (isV2 && _this._oauth) {\n\t          throw new Error('OAuth is not supported on the V2 stack');\n\t        }\n\t        if (_this._oauth) {\n\t          if (forceTokenRefresh && _this._clientParams.redirectURI) {\n\t            _this._clientParams.redirectURI = ensureHasReconnectParam(_this._clientParams.redirectURI);\n\t          }\n\t          return auth.oauthFlow(_this, _this._storage, _this._clientParams, _this._onRegistered, forceTokenRefresh);\n\t        }\n\t        // we expect to be on a client side application running in a browser\n\t        // with cookie-based authentication.\n\t        if (isV2) {\n\t          return (0, _auth_v.getAppToken)();\n\t        } else if (_this._token) {\n\t          return Promise.resolve({ client: null, token: _this._token });\n\t        } else {\n\t          throw new Error('Missing application token');\n\t        }\n\t      });\n\t\n\t      this._authcreds.then(function () {\n\t        _this._authstate = AuthOK;\n\t      }, function () {\n\t        _this._authstate = AuthError;\n\t      });\n\t\n\t      return this._authcreds;\n\t    }\n\t  }, {\n\t    key: 'saveCredentials',\n\t    value: function saveCredentials(client, token) {\n\t      var creds = { client: client, token: token };\n\t      if (!this._storage || this._authstate === AuthRunning) {\n\t        return Promise.resolve(creds);\n\t      }\n\t      this._storage.save(auth.CredsKey, creds);\n\t      this._authcreds = Promise.resolve(creds);\n\t      return this._authcreds;\n\t    }\n\t  }, {\n\t    key: 'fullpath',\n\t    value: function fullpath(path) {\n\t      var _this2 = this;\n\t\n\t      return this.isV2().then(function (isV2) {\n\t        var pathprefix = isV2 ? '/ds-api' : '';\n\t        return _this2._url + pathprefix + path;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'isV2',\n\t    value: function isV2() {\n\t      var _this3 = this;\n\t\n\t      if (!this._version) {\n\t        return (0, _utils.retry)(function () {\n\t          return fetch(_this3._url + '/status/');\n\t        }, 3)().then(function (res) {\n\t          if (!res.ok) {\n\t            throw new Error('Could not fetch cozy status');\n\t          } else {\n\t            return res.json();\n\t          }\n\t        }).then(function (status) {\n\t          _this3._version = status.datasystem !== undefined ? 2 : 3;\n\t          return _this3.isV2();\n\t        });\n\t      }\n\t      return Promise.resolve(this._version === 2);\n\t    }\n\t  }]);\n\t\n\t  return Client;\n\t}();\n\t\n\tfunction nopOnRegistered() {\n\t  throw new Error('Missing onRegistered callback');\n\t}\n\t\n\tfunction protoify(context, fn) {\n\t  return function prototyped() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return fn.apply(undefined, [context].concat(args));\n\t  };\n\t}\n\t\n\tfunction addToProto(ctx, obj, proto, disablePromises) {\n\t  for (var attr in proto) {\n\t    var fn = protoify(ctx, proto[attr]);\n\t    if (disablePromises) {\n\t      fn = (0, _utils.unpromiser)(fn);\n\t    }\n\t    obj[attr] = fn;\n\t  }\n\t}\n\t\n\tmodule.exports = new Client();\n\tObject.assign(module.exports, { Client: Client, LocalStorage: _auth_storage.LocalStorage, MemoryStorage: _auth_storage.MemoryStorage });\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _regenerator = __webpack_require__(20);\n\t\n\tvar _regenerator2 = _interopRequireDefault(_regenerator);\n\t\n\tvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\t\n\texports.start = start;\n\t\n\tvar _helpers = __webpack_require__(9);\n\t\n\tvar _ = __webpack_require__(18);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step(\"next\", value); }, function (err) { step(\"throw\", err); }); } } return step(\"next\"); }); }; }\n\t\n\tvar intentClass = 'coz-intent';\n\t\n\tfunction hideIntentIframe(iframe) {\n\t  iframe.style.display = 'none';\n\t}\n\t\n\tfunction showIntentFrame(iframe) {\n\t  iframe.style.display = 'block';\n\t}\n\t\n\tfunction buildIntentIframe(intent, element, url) {\n\t  var document = element.ownerDocument;\n\t  if (!document) return Promise.reject(new Error('Cannot retrieve document object from given element'));\n\t\n\t  var iframe = document.createElement('iframe');\n\t  // TODO: implement 'title' attribute\n\t  iframe.setAttribute('id', 'intent-' + intent._id);\n\t  iframe.setAttribute('src', url);\n\t  iframe.classList.add(intentClass);\n\t  return iframe;\n\t}\n\t\n\tfunction injectIntentIframe(intent, element, url, options) {\n\t  var onReadyCallback = options.onReadyCallback;\n\t\n\t  var iframe = buildIntentIframe(intent, element, url, options.onReadyCallback);\n\t  // if callback provided for when iframe is loaded\n\t  if (typeof onReadyCallback === 'function') iframe.onload = onReadyCallback;\n\t  element.appendChild(iframe);\n\t  iframe.focus();\n\t  return iframe;\n\t}\n\t\n\t// inject iframe for service in given element\n\tfunction connectIntentIframe(cozy, iframe, element, intent, data) {\n\t  var _this = this;\n\t\n\t  var compose = function () {\n\t    var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee(cozy, action, doctype, data) {\n\t      var intent, doc;\n\t      return _regenerator2.default.wrap(function _callee$(_context) {\n\t        while (1) {\n\t          switch (_context.prev = _context.next) {\n\t            case 0:\n\t              _context.next = 2;\n\t              return (0, _.create)(cozy, action, doctype, data);\n\t\n\t            case 2:\n\t              intent = _context.sent;\n\t\n\t              hideIntentIframe(iframe);\n\t              _context.next = 6;\n\t              return start(cozy, intent, element, _extends({}, data, {\n\t                exposeIntentFrameRemoval: false\n\t              }));\n\t\n\t            case 6:\n\t              doc = _context.sent;\n\t\n\t              showIntentFrame(iframe);\n\t              return _context.abrupt('return', doc);\n\t\n\t            case 9:\n\t            case 'end':\n\t              return _context.stop();\n\t          }\n\t        }\n\t      }, _callee, this);\n\t    }));\n\t\n\t    return function compose(_x, _x2, _x3, _x4) {\n\t      return _ref.apply(this, arguments);\n\t    };\n\t  }();\n\t\n\t  var document = element.ownerDocument;\n\t  if (!document) return Promise.reject(new Error('Cannot retrieve document object from given element'));\n\t\n\t  var window = document.defaultView;\n\t  if (!window) return Promise.reject(new Error('Cannot retrieve window object from document'));\n\t\n\t  // Keeps only http://domain:port/\n\t  var serviceOrigin = iframe.src.split('/', 3).join('/');\n\t\n\t  return new Promise(function (resolve, reject) {\n\t    var handshaken = false;\n\t    var messageHandler = function () {\n\t      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regenerator2.default.mark(function _callee2(event) {\n\t        var eventType, _event$data, action, doctype, _data, doc, removeIntentFrame;\n\t\n\t        return _regenerator2.default.wrap(function _callee2$(_context2) {\n\t          while (1) {\n\t            switch (_context2.prev = _context2.next) {\n\t              case 0:\n\t                if (!(event.origin !== serviceOrigin)) {\n\t                  _context2.next = 2;\n\t                  break;\n\t                }\n\t\n\t                return _context2.abrupt('return');\n\t\n\t              case 2:\n\t                eventType = event.data.type;\n\t\n\t                if (!(eventType === 'load')) {\n\t                  _context2.next = 6;\n\t                  break;\n\t                }\n\t\n\t                // Safari 9.1 (At least) send a MessageEvent when the iframe loads,\n\t                // making the handshake fails.\n\t                console.warn && console.warn('Cozy Client ignored MessageEvent having data.type `load`.');\n\t                return _context2.abrupt('return');\n\t\n\t              case 6:\n\t                if (!(eventType === 'intent-' + intent._id + ':ready')) {\n\t                  _context2.next = 9;\n\t                  break;\n\t                }\n\t\n\t                handshaken = true;\n\t                return _context2.abrupt('return', event.source.postMessage(data, event.origin));\n\t\n\t              case 9:\n\t                if (!(handshaken && eventType === 'intent-' + intent._id + ':resize')) {\n\t                  _context2.next = 13;\n\t                  break;\n\t                }\n\t\n\t                ;['width', 'height', 'maxWidth', 'maxHeight'].forEach(function (prop) {\n\t                  if (event.data.transition) element.style.transition = event.data.transition;\n\t                  if (event.data.dimensions[prop]) element.style[prop] = event.data.dimensions[prop] + 'px';\n\t                });\n\t\n\t                return _context2.abrupt('return', true);\n\t\n\t              case 13:\n\t                if (!(handshaken && eventType === 'intent-' + intent._id + ':compose')) {\n\t                  _context2.next = 19;\n\t                  break;\n\t                }\n\t\n\t                // Let start to name `type` as `doctype`, as `event.data` already have a `type` attribute.\n\t                _event$data = event.data, action = _event$data.action, doctype = _event$data.doctype, _data = _event$data.data;\n\t                _context2.next = 17;\n\t                return compose(cozy, action, doctype, _data);\n\t\n\t              case 17:\n\t                doc = _context2.sent;\n\t                return _context2.abrupt('return', event.source.postMessage(doc, event.origin));\n\t\n\t              case 19:\n\t\n\t                window.removeEventListener('message', messageHandler);\n\t\n\t                removeIntentFrame = function removeIntentFrame() {\n\t                  // check if the parent node has not been already removed from the DOM\n\t                  iframe.parentNode && iframe.parentNode.removeChild(iframe);\n\t                };\n\t\n\t                if (!(handshaken && eventType === 'intent-' + intent._id + ':exposeFrameRemoval')) {\n\t                  _context2.next = 23;\n\t                  break;\n\t                }\n\t\n\t                return _context2.abrupt('return', resolve({ removeIntentFrame: removeIntentFrame, doc: event.data.document }));\n\t\n\t              case 23:\n\t\n\t                removeIntentFrame();\n\t\n\t                if (!(eventType === 'intent-' + intent._id + ':error')) {\n\t                  _context2.next = 26;\n\t                  break;\n\t                }\n\t\n\t                return _context2.abrupt('return', reject(_helpers.errorSerializer.deserialize(event.data.error)));\n\t\n\t              case 26:\n\t                if (!(handshaken && eventType === 'intent-' + intent._id + ':cancel')) {\n\t                  _context2.next = 28;\n\t                  break;\n\t                }\n\t\n\t                return _context2.abrupt('return', resolve(null));\n\t\n\t              case 28:\n\t                if (!(handshaken && eventType === 'intent-' + intent._id + ':done')) {\n\t                  _context2.next = 30;\n\t                  break;\n\t                }\n\t\n\t                return _context2.abrupt('return', resolve(event.data.document));\n\t\n\t              case 30:\n\t                if (handshaken) {\n\t                  _context2.next = 32;\n\t                  break;\n\t                }\n\t\n\t                return _context2.abrupt('return', reject(new Error('Unexpected handshake message from intent service')));\n\t\n\t              case 32:\n\t              case 'end':\n\t                return _context2.stop();\n\t            }\n\t          }\n\t        }, _callee2, _this);\n\t      }));\n\t\n\t      return function messageHandler(_x5) {\n\t        return _ref2.apply(this, arguments);\n\t      };\n\t    }();\n\t\n\t    window.addEventListener('message', messageHandler);\n\t  });\n\t}\n\t\n\tfunction start(cozy, intent, element) {\n\t  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\t\n\t  var service = (0, _helpers.pickService)(intent, options.filterServices);\n\t\n\t  if (!service) {\n\t    throw new Error('Unable to find a service');\n\t  }\n\t\n\t  var iframe = injectIntentIframe(intent, element, service.href, options);\n\t\n\t  return connectIntentIframe(cozy, iframe, element, intent, data, options.onReadyCallback);\n\t}\n\n/***/ },\n/* 43 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.start = start;\n\t\n\tvar _fetch = __webpack_require__(1);\n\t\n\tvar _helpers = __webpack_require__(9);\n\t\n\tfunction listenClientData(intent, window) {\n\t  return new Promise(function (resolve) {\n\t    var messageEventListener = function messageEventListener(event) {\n\t      if (event.origin !== intent.attributes.client) return;\n\t\n\t      window.removeEventListener('message', messageEventListener);\n\t      resolve(event.data);\n\t    };\n\t\n\t    window.addEventListener('message', messageEventListener);\n\t    window.parent.postMessage({\n\t      type: 'intent-' + intent._id + ':ready'\n\t    }, intent.attributes.client);\n\t  });\n\t}\n\t\n\t// maximize the height of an element\n\tfunction maximize(element) {\n\t  if (element && element.style) {\n\t    element.style.height = '100%';\n\t  }\n\t}\n\t\n\tfunction start(cozy, intentId, serviceWindow) {\n\t  serviceWindow = serviceWindow || typeof window !== 'undefined' && window;\n\t  if (!serviceWindow || !serviceWindow.document) {\n\t    return Promise.reject(new Error('Intent service should be used in browser'));\n\t  }\n\t\n\t  // Maximize document, the whole iframe is handled by intents, clients and\n\t  // services\n\t  serviceWindow.addEventListener('load', function () {\n\t    var _serviceWindow = serviceWindow,\n\t        document = _serviceWindow.document;\n\t    [document.documentElement, document.body].forEach(maximize);\n\t  });\n\t\n\t  intentId = intentId || serviceWindow.location.search.split('=')[1];\n\t  if (!intentId) return Promise.reject(new Error('Cannot retrieve intent from URL'));\n\t\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/intents/' + intentId).then(function (intent) {\n\t    var terminated = false;\n\t\n\t    var sendMessage = function sendMessage(message) {\n\t      if (terminated) throw new Error('Intent service has already been terminated');\n\t      serviceWindow.parent.postMessage(message, intent.attributes.client);\n\t    };\n\t\n\t    var compose = function compose(action, doctype, data) {\n\t      return new Promise(function (resolve) {\n\t        var composeEventListener = function composeEventListener(event) {\n\t          if (event.origin !== intent.attributes.client) return;\n\t          serviceWindow.removeEventListener('message', composeEventListener);\n\t          return resolve(event.data);\n\t        };\n\t\n\t        serviceWindow.addEventListener('message', composeEventListener);\n\t\n\t        sendMessage({\n\t          type: 'intent-' + intent._id + ':compose',\n\t          action: action,\n\t          doctype: doctype,\n\t          data: data\n\t        });\n\t      });\n\t    };\n\t\n\t    var _terminate = function _terminate(message) {\n\t      sendMessage(message);\n\t      terminated = true;\n\t    };\n\t\n\t    var resizeClient = function resizeClient(dimensions, transitionProperty) {\n\t      if (terminated) throw new Error('Intent service has been terminated');\n\t\n\t      sendMessage({\n\t        type: 'intent-' + intent._id + ':resize',\n\t        // if a dom element is passed, calculate its size\n\t        dimensions: dimensions.element ? Object.assign({}, dimensions, {\n\t          maxHeight: dimensions.element.clientHeight,\n\t          maxWidth: dimensions.element.clientWidth\n\t        }) : dimensions,\n\t        transition: transitionProperty\n\t      });\n\t    };\n\t\n\t    var cancel = function cancel() {\n\t      _terminate({ type: 'intent-' + intent._id + ':cancel' });\n\t    };\n\t\n\t    // Prevent unfulfilled client promises when this window unloads for a\n\t    // reason or another.\n\t    serviceWindow.addEventListener('unload', function () {\n\t      if (!terminated) cancel();\n\t    });\n\t\n\t    return listenClientData(intent, serviceWindow).then(function (data) {\n\t      return {\n\t        compose: compose,\n\t        getData: function getData() {\n\t          return data;\n\t        },\n\t        getIntent: function getIntent() {\n\t          return intent;\n\t        },\n\t        terminate: function terminate(doc) {\n\t          var eventName = data && data.exposeIntentFrameRemoval ? 'exposeFrameRemoval' : 'done';\n\t          return _terminate({\n\t            type: 'intent-' + intent._id + ':' + eventName,\n\t            document: doc\n\t          });\n\t        },\n\t        throw: function _throw(error) {\n\t          return _terminate({\n\t            type: 'intent-' + intent._id + ':error',\n\t            error: _helpers.errorSerializer.serialize(error)\n\t          });\n\t        },\n\t        resizeClient: resizeClient,\n\t        cancel: cancel\n\t      };\n\t    });\n\t  });\n\t}\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.count = count;\n\texports.queued = queued;\n\texports.create = create;\n\t\n\tvar _fetch = __webpack_require__(1);\n\t\n\tfunction count(cozy, workerType) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/jobs/queue/' + workerType).then(function (data) {\n\t    return data.length;\n\t  });\n\t}\n\t\n\tfunction queued(cozy, workerType) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/jobs/queue/' + workerType);\n\t}\n\t\n\tfunction create(cozy, workerType, args, options) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/jobs/queue/' + workerType, {\n\t    data: {\n\t      type: 'io.cozy.jobs',\n\t      attributes: {\n\t        arguments: args || {},\n\t        options: options || {}\n\t      }\n\t    }\n\t  });\n\t}\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.defineIndex = defineIndex;\n\texports.query = query;\n\texports.queryFiles = queryFiles;\n\texports.parseSelector = parseSelector;\n\texports.normalizeSelector = normalizeSelector;\n\texports.makeMapReduceQuery = makeMapReduceQuery;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _doctypes = __webpack_require__(3);\n\t\n\tvar _fetch = __webpack_require__(1);\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction defineIndex(cozy, doctype, fields) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    if (!Array.isArray(fields) || fields.length === 0) {\n\t      throw new Error('defineIndex fields should be a non-empty array');\n\t    }\n\t    if (isV2) {\n\t      return defineIndexV2(cozy, doctype, fields);\n\t    } else {\n\t      return defineIndexV3(cozy, doctype, fields);\n\t    }\n\t  });\n\t}\n\t\n\tfunction query(cozy, indexRef, options) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    if (!indexRef) {\n\t      throw new Error('query should be passed the indexRef');\n\t    }\n\t    if (isV2) {\n\t      return queryV2(cozy, indexRef, options);\n\t    } else {\n\t      return queryV3(cozy, indexRef, options);\n\t    }\n\t  });\n\t}\n\t\n\tfunction queryFiles(cozy, indexRef, options) {\n\t  var opts = getV3Options(indexRef, options);\n\t  return (0, _fetch.cozyFetchRawJSON)(cozy, 'POST', '/files/_find', opts).then(function (response) {\n\t    return options.wholeResponse ? response : response.docs;\n\t  });\n\t}\n\t\n\t// Internals\n\t\n\tvar VALUEOPERATORS = ['$eq', '$gt', '$gte', '$lt', '$lte'];\n\tvar LOGICOPERATORS = ['$or', '$and', '$not'];\n\t\n\t/* eslint-disable */\n\tvar MAP_TEMPLATE = function (doc) {\n\t  if (doc.docType.toLowerCase() === 'DOCTYPEPLACEHOLDER') {\n\t    emit(FIELDSPLACEHOLDER, doc);\n\t  }\n\t}.toString().replace(/ /g, '').replace(/\\n/g, '');\n\tvar COUCHDB_INFINITY = { '\\uFFFF': '\\uFFFF' };\n\tvar COUCHDB_LOWEST = null;\n\t/* eslint-enable */\n\t\n\t// defineIndexV2 is equivalent to defineIndex but only works for V2.\n\t// It transforms the index fields into a map reduce view.\n\tfunction defineIndexV2(cozy, doctype, fields) {\n\t  var indexName = 'by' + fields.map(capitalize).join('');\n\t  var indexDefinition = {\n\t    map: makeMapFunction(doctype, fields),\n\t    reduce: '_count'\n\t  };\n\t  var path = '/request/' + doctype + '/' + indexName + '/';\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'PUT', path, indexDefinition).then(function () {\n\t    return {\n\t      doctype: doctype,\n\t      type: 'mapreduce',\n\t      name: indexName,\n\t      fields: fields\n\t    };\n\t  });\n\t}\n\t\n\tfunction defineIndexV3(cozy, doctype, fields) {\n\t  var path = (0, _utils.createPath)(cozy, false, doctype, '_index');\n\t  var indexDefinition = { index: { fields: fields } };\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, indexDefinition).then(function (response) {\n\t    var indexResult = {\n\t      doctype: doctype,\n\t      type: 'mango',\n\t      name: response.id,\n\t      fields: fields\n\t    };\n\t\n\t    if (response.result === 'exists') return indexResult;\n\t\n\t    // indexes might not be usable right after being created; so we delay the resolving until they are\n\t    var selector = {};\n\t    selector[fields[0]] = { $gt: null };\n\t\n\t    var opts = getV3Options(indexResult, { selector: selector });\n\t    var path = (0, _utils.createPath)(cozy, false, indexResult.doctype, '_find');\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, opts).then(function () {\n\t      return indexResult;\n\t    }).catch(function () {\n\t      // one retry\n\t      return (0, _utils.sleep)(1000).then(function () {\n\t        return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, opts);\n\t      }).then(function () {\n\t        return indexResult;\n\t      }).catch(function () {\n\t        return (0, _utils.sleep)(500).then(function () {\n\t          return indexResult;\n\t        });\n\t      });\n\t    });\n\t  });\n\t}\n\t\n\t// queryV2 is equivalent to query but only works for V2.\n\t// It transforms the query into a _views call using makeMapReduceQuery\n\tfunction queryV2(cozy, indexRef, options) {\n\t  if (indexRef.type !== 'mapreduce') {\n\t    throw new Error('query indexRef should be the return value of defineIndexV2');\n\t  }\n\t  if (options.fields) {\n\t    (0, _utils.warn)('query fields will be ignored on v2');\n\t  }\n\t\n\t  var path = '/request/' + indexRef.doctype + '/' + indexRef.name + '/';\n\t  var opts = makeMapReduceQuery(indexRef, options);\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, opts).then(function (response) {\n\t    return response.map(function (r) {\n\t      return r.value;\n\t    });\n\t  });\n\t}\n\t\n\t// queryV3 is equivalent to query but only works for V3\n\tfunction queryV3(cozy, indexRef, options) {\n\t  var opts = getV3Options(indexRef, options);\n\t\n\t  var path = (0, _utils.createPath)(cozy, false, indexRef.doctype, '_find');\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, opts).then(function (response) {\n\t    return options.wholeResponse ? response : response.docs;\n\t  });\n\t}\n\t\n\tfunction getV3Options(indexRef, options) {\n\t  if (indexRef.type !== 'mango') {\n\t    throw new Error('indexRef should be the return value of defineIndexV3');\n\t  }\n\t\n\t  var opts = {\n\t    use_index: indexRef.name,\n\t    fields: options.fields,\n\t    selector: options.selector,\n\t    limit: options.limit,\n\t    skip: options.skip,\n\t    since: options.since,\n\t    sort: options.sort\n\t  };\n\t\n\t  if (options.descending) {\n\t    opts.sort = indexRef.fields.map(function (f) {\n\t      return _defineProperty({}, f, 'desc');\n\t    });\n\t  }\n\t\n\t  return opts;\n\t}\n\t\n\t// misc\n\tfunction capitalize(name) {\n\t  return name.charAt(0).toUpperCase() + name.slice(1);\n\t}\n\t\n\tfunction makeMapFunction(doctype, fields) {\n\t  fields = '[' + fields.map(function (name) {\n\t    return 'doc.' + name;\n\t  }).join(',') + ']';\n\t\n\t  return MAP_TEMPLATE.replace('DOCTYPEPLACEHOLDER', doctype.toLowerCase()).replace('FIELDSPLACEHOLDER', fields);\n\t}\n\t\n\t// parseSelector takes a mango selector and returns it as an array of filter\n\t// a filter is [path, operator, value] array\n\t// a path is an array of field names\n\t// This function is only exported so it can be unit tested.\n\t// Example :\n\t// parseSelector({\"test\":{\"deep\": {\"$gt\": 3}}})\n\t// [[['test', 'deep'], '$gt', 3 ]]\n\tfunction parseSelector(selector) {\n\t  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '$eq';\n\t\n\t  if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) !== 'object') {\n\t    return [[path, operator, selector]];\n\t  }\n\t\n\t  var keys = Object.keys(selector);\n\t  if (keys.length === 0) {\n\t    throw new Error('empty selector');\n\t  } else {\n\t    return keys.reduce(function (acc, k) {\n\t      if (LOGICOPERATORS.indexOf(k) !== -1) {\n\t        throw new Error('cozy-client-js does not support mango logic ops');\n\t      } else if (VALUEOPERATORS.indexOf(k) !== -1) {\n\t        return acc.concat(parseSelector(selector[k], path, k));\n\t      } else {\n\t        return acc.concat(parseSelector(selector[k], path.concat(k), '$eq'));\n\t      }\n\t    }, []);\n\t  }\n\t}\n\t\n\t// normalizeSelector takes a mango selector and returns it as an object\n\t// normalized.\n\t// This function is only exported so it can be unit tested.\n\t// Example :\n\t// parseSelector({\"test\":{\"deep\": {\"$gt\": 3}}})\n\t// {\"test.deep\": {\"$gt\": 3}}\n\tfunction normalizeSelector(selector) {\n\t  var filters = parseSelector(selector);\n\t  return filters.reduce(function (acc, filter) {\n\t    var _filter = _slicedToArray(filter, 3),\n\t        path = _filter[0],\n\t        op = _filter[1],\n\t        value = _filter[2];\n\t\n\t    var field = path.join('.');\n\t    acc[field] = acc[field] || {};\n\t    acc[field][op] = value;\n\t    return acc;\n\t  }, {});\n\t}\n\t\n\t// applySelector takes the normalized selector for the current field\n\t// and append the proper values to opts.startkey, opts.endkey\n\tfunction applySelector(selector, opts) {\n\t  var value = selector['$eq'];\n\t  var lower = COUCHDB_LOWEST;\n\t  var upper = COUCHDB_INFINITY;\n\t  var inclusiveEnd = void 0;\n\t\n\t  if (value) {\n\t    opts.startkey.push(value);\n\t    opts.endkey.push(value);\n\t    return false;\n\t  }\n\t\n\t  value = selector['$gt'];\n\t  if (value) {\n\t    throw new Error('operator $gt (strict greater than) not supported');\n\t  }\n\t\n\t  value = selector['$gte'];\n\t  if (value) {\n\t    lower = value;\n\t  }\n\t\n\t  value = selector['$lte'];\n\t  if (value) {\n\t    upper = value;\n\t    inclusiveEnd = true;\n\t  }\n\t\n\t  value = selector['$lt'];\n\t  if (value) {\n\t    upper = value;\n\t    inclusiveEnd = false;\n\t  }\n\t\n\t  opts.startkey.push(lower);\n\t  opts.endkey.push(upper);\n\t  if (inclusiveEnd !== undefined) opts.inclusive_end = inclusiveEnd;\n\t  return true;\n\t}\n\t\n\t// makeMapReduceQuery takes a mango query and generate _views call parameters\n\t// to obtain same results depending on fields in the passed indexRef.\n\tfunction makeMapReduceQuery(indexRef, query) {\n\t  var mrquery = {\n\t    startkey: [],\n\t    endkey: [],\n\t    reduce: false\n\t  };\n\t  var firstFreeValueField = null;\n\t  var normalizedSelector = normalizeSelector(query.selector);\n\t\n\t  indexRef.fields.forEach(function (field) {\n\t    var selector = normalizedSelector[field];\n\t\n\t    if (selector && firstFreeValueField != null) {\n\t      throw new Error('Selector on field ' + field + ', but not on ' + firstFreeValueField + ' which is higher in index fields.');\n\t    } else if (selector) {\n\t      selector.used = true;\n\t      var isFreeValue = applySelector(selector, mrquery);\n\t      if (isFreeValue) firstFreeValueField = field;\n\t    } else if (firstFreeValueField == null) {\n\t      firstFreeValueField = field;\n\t      mrquery.endkey.push(COUCHDB_INFINITY);\n\t    }\n\t  });\n\t\n\t  Object.keys(normalizedSelector).forEach(function (field) {\n\t    if (!normalizedSelector[field].used) {\n\t      throw new Error('Cant apply selector on ' + field + ', it is not in index');\n\t    }\n\t  });\n\t\n\t  if (query.descending) {\n\t    mrquery = {\n\t      descending: true,\n\t      reduce: false,\n\t      startkey: mrquery.endkey,\n\t      endkey: mrquery.startkey,\n\t      inclusive_end: mrquery.inclusive_end\n\t    };\n\t  }\n\t\n\t  return mrquery;\n\t}\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.replicationOfflineError = undefined;\n\texports.init = init;\n\texports.getDoctypes = getDoctypes;\n\texports.hasDatabase = hasDatabase;\n\texports.getDatabase = getDatabase;\n\texports.setDatabase = setDatabase;\n\texports.createDatabase = createDatabase;\n\texports.destroyDatabase = destroyDatabase;\n\texports.destroyAllDatabase = destroyAllDatabase;\n\texports.hasReplication = hasReplication;\n\texports.replicateFromCozy = replicateFromCozy;\n\texports.stopReplication = stopReplication;\n\texports.stopAllReplication = stopAllReplication;\n\texports.hasRepeatedReplication = hasRepeatedReplication;\n\texports.startRepeatedReplication = startRepeatedReplication;\n\texports.stopRepeatedReplication = stopRepeatedReplication;\n\texports.stopAllRepeatedReplication = stopAllRepeatedReplication;\n\t\n\tvar _doctypes = __webpack_require__(3);\n\t\n\tvar _auth_v = __webpack_require__(8);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _pouchdb = __webpack_require__(82);\n\t\n\tvar _pouchdb2 = _interopRequireDefault(_pouchdb);\n\t\n\tvar _pouchdbFind = __webpack_require__(78);\n\t\n\tvar _pouchdbFind2 = _interopRequireDefault(_pouchdbFind);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar replicationOfflineError = exports.replicationOfflineError = 'Replication abort, your device is actually offline.'; /* global pouchdbAdapterCordovaSqlite */\n\t\n\t\n\tvar pluginLoaded = false;\n\t\n\t/*\n\t  For each doctype we have some parameters:\n\t  cozy._offline[doctype] = {\n\t    database: pouchdb database\n\t    replication: the pouchdb replication\n\t    replicationPromise: promise of replication\n\t    interval: repeated replication interval\n\t  }\n\t*/\n\t\n\tfunction init(cozy, _ref) {\n\t  var _ref$options = _ref.options,\n\t      options = _ref$options === undefined ? {} : _ref$options,\n\t      _ref$doctypes = _ref.doctypes,\n\t      doctypes = _ref$doctypes === undefined ? [] : _ref$doctypes;\n\t  var _iteratorNormalCompletion = true;\n\t  var _didIteratorError = false;\n\t  var _iteratorError = undefined;\n\t\n\t  try {\n\t    for (var _iterator = doctypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t      var doctype = _step.value;\n\t\n\t      createDatabase(cozy, doctype, options);\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError = true;\n\t    _iteratorError = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion && _iterator.return) {\n\t        _iterator.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError) {\n\t        throw _iteratorError;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// helper\n\t\n\tfunction getInfo(cozy, doctype) {\n\t  cozy._offline = cozy._offline || [];\n\t  cozy._offline[doctype] = cozy._offline[doctype] || {};\n\t  return cozy._offline[doctype];\n\t}\n\t\n\tfunction getDoctypes(cozy) {\n\t  cozy._offline = cozy._offline || [];\n\t  return Object.keys(cozy._offline);\n\t}\n\t\n\t//\n\t// DATABASE\n\t//\n\t\n\tfunction hasDatabase(cozy, doctype) {\n\t  return getDatabase(cozy, doctype) !== undefined;\n\t}\n\t\n\tfunction getDatabase(cozy, doctype) {\n\t  return getInfo(cozy, doctype).database;\n\t}\n\t\n\tfunction setDatabase(cozy, doctype, database) {\n\t  cozy._offline[doctype].database = database;\n\t  return getDatabase(cozy, doctype);\n\t}\n\t\n\tfunction createDatabase(cozy, doctype) {\n\t  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  if (!pluginLoaded) {\n\t    _pouchdb2.default.plugin(_pouchdbFind2.default);\n\t    if (typeof pouchdbAdapterCordovaSqlite !== 'undefined') _pouchdb2.default.plugin(pouchdbAdapterCordovaSqlite);\n\t    pluginLoaded = true;\n\t  }\n\t\n\t  if (hasDatabase(cozy, doctype)) {\n\t    return Promise.resolve(getDatabase(cozy, doctype));\n\t  }\n\t\n\t  setDatabase(cozy, doctype, new _pouchdb2.default(doctype, options));\n\t  return createIndexes(cozy, doctype).then(function () {\n\t    return getDatabase(cozy, doctype);\n\t  });\n\t}\n\t\n\tfunction destroyDatabase(cozy, doctype) {\n\t  if (!hasDatabase(cozy, doctype)) {\n\t    return Promise.resolve(false);\n\t  }\n\t\n\t  return stopRepeatedReplication(cozy, doctype).then(function () {\n\t    return stopReplication(cozy, doctype);\n\t  }).then(function () {\n\t    return getDatabase(cozy, doctype).destroy();\n\t  }).then(function (response) {\n\t    setDatabase(cozy, doctype, undefined);\n\t    return response;\n\t  });\n\t}\n\t\n\tfunction destroyAllDatabase(cozy) {\n\t  var doctypes = getDoctypes(cozy);\n\t  var destroy = function destroy(doctype) {\n\t    return destroyDatabase(cozy, doctype);\n\t  };\n\t  return Promise.all(doctypes.map(destroy));\n\t}\n\t\n\tfunction createIndexes(cozy, doctype) {\n\t  if (doctype === _doctypes.DOCTYPE_FILES) {\n\t    return getDatabase(cozy, doctype).createIndex({\n\t      index: { fields: ['dir_id'] }\n\t    });\n\t  }\n\t  return Promise.resolve();\n\t}\n\t\n\t//\n\t// REPLICATION\n\t//\n\t\n\tfunction hasReplication(cozy, doctype) {\n\t  return getReplication(cozy, doctype) !== undefined;\n\t}\n\t\n\tfunction getReplication(cozy, doctype) {\n\t  return getInfo(cozy, doctype).replication;\n\t}\n\t\n\tfunction setReplication(cozy, doctype, replication) {\n\t  cozy._offline[doctype].replication = replication;\n\t  return getReplication(cozy, doctype);\n\t}\n\t\n\tfunction getReplicationUrl(cozy, doctype) {\n\t  return cozy.authorize().then(function (credentials) {\n\t    var basic = credentials.token.toBasicAuth();\n\t    return (cozy._url + '/data/' + doctype).replace('//', '//' + basic);\n\t  });\n\t}\n\t\n\tfunction getReplicationPromise(cozy, doctype) {\n\t  return getInfo(cozy, doctype).replicationPromise;\n\t}\n\t\n\tfunction setReplicationPromise(cozy, doctype, promise) {\n\t  cozy._offline[doctype].replicationPromise = promise;\n\t  return getReplicationPromise(cozy, doctype);\n\t}\n\t\n\tfunction replicateFromCozy(cozy, doctype) {\n\t  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  return setReplicationPromise(cozy, doctype, new Promise(function (resolve, reject) {\n\t    if (!hasDatabase(cozy, doctype)) {\n\t      createDatabase(cozy, doctype);\n\t    }\n\t    if (options.live === true) {\n\t      return reject(new Error(\"You can't use `live` option with Cozy couchdb.\"));\n\t    }\n\t\n\t    if ((0, _utils.isOffline)()) {\n\t      reject(replicationOfflineError);\n\t      options.onError && options.onError(replicationOfflineError);\n\t      return;\n\t    }\n\t\n\t    getReplicationUrl(cozy, doctype).then(function (url) {\n\t      return setReplication(cozy, doctype, getDatabase(cozy, doctype).replicate.from(url, options).on('complete', function (info) {\n\t        setReplication(cozy, doctype, undefined);\n\t        resolve(info);\n\t        options.onComplete && options.onComplete(info);\n\t      }).on('error', function (err) {\n\t        if (err.error === 'code=400, message=Expired token') {\n\t          cozy.authorize().then(function (_ref2) {\n\t            var client = _ref2.client,\n\t                token = _ref2.token;\n\t\n\t            (0, _auth_v.refreshToken)(cozy, client, token).then(function (newToken) {\n\t              return cozy.saveCredentials(client, newToken);\n\t            }).then(function () {\n\t              return replicateFromCozy(cozy, doctype, options);\n\t            });\n\t          });\n\t        } else {\n\t          console.warn('ReplicateFromCozy \\'' + doctype + '\\' Error:');\n\t          console.warn(err);\n\t          setReplication(cozy, doctype, undefined);\n\t          reject(err);\n\t          options.onError && options.onError(err);\n\t        }\n\t      }));\n\t    });\n\t  }));\n\t}\n\t\n\tfunction stopReplication(cozy, doctype) {\n\t  if (!getDatabase(cozy, doctype) || !hasReplication(cozy, doctype)) {\n\t    return Promise.resolve();\n\t  }\n\t\n\t  return new Promise(function (resolve) {\n\t    try {\n\t      getReplicationPromise(cozy, doctype).then(function () {\n\t        resolve();\n\t      });\n\t      getReplication(cozy, doctype).cancel();\n\t      // replication is set to undefined by complete replication\n\t    } catch (e) {\n\t      resolve();\n\t    }\n\t  });\n\t}\n\t\n\tfunction stopAllReplication(cozy) {\n\t  var doctypes = getDoctypes(cozy);\n\t  var stop = function stop(doctype) {\n\t    return stopReplication(cozy, doctype);\n\t  };\n\t  return Promise.all(doctypes.map(stop));\n\t}\n\t\n\t//\n\t// REPEATED REPLICATION\n\t//\n\t\n\tfunction getRepeatedReplication(cozy, doctype) {\n\t  return getInfo(cozy, doctype).interval;\n\t}\n\t\n\tfunction setRepeatedReplication(cozy, doctype, interval) {\n\t  cozy._offline[doctype].interval = interval;\n\t}\n\t\n\tfunction hasRepeatedReplication(cozy, doctype) {\n\t  return getRepeatedReplication(cozy, doctype) !== undefined;\n\t}\n\t\n\tfunction startRepeatedReplication(cozy, doctype, timer) {\n\t  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\n\t  // TODO: add timer limitation for not flooding Gozy\n\t  if (hasRepeatedReplication(cozy, doctype)) {\n\t    return getRepeatedReplication(cozy, doctype);\n\t  }\n\t\n\t  return setRepeatedReplication(cozy, doctype, setInterval(function () {\n\t    if ((0, _utils.isOffline)()) {\n\t      // network is offline, replication cannot be launched\n\t      console.info(replicationOfflineError);\n\t      return;\n\t    }\n\t    if (!hasReplication(cozy, doctype)) {\n\t      replicateFromCozy(cozy, doctype, options);\n\t      // TODO: add replicationToCozy\n\t    }\n\t  }, timer * 1000));\n\t}\n\t\n\tfunction stopRepeatedReplication(cozy, doctype) {\n\t  if (hasRepeatedReplication(cozy, doctype)) {\n\t    clearInterval(getRepeatedReplication(cozy, doctype));\n\t    setRepeatedReplication(cozy, doctype, undefined);\n\t  }\n\t  if (hasReplication(cozy, doctype)) {\n\t    return stopReplication(cozy, doctype);\n\t  }\n\t\n\t  return Promise.resolve();\n\t}\n\t\n\tfunction stopAllRepeatedReplication(cozy) {\n\t  var doctypes = getDoctypes(cozy);\n\t  var stop = function stop(doctype) {\n\t    return stopRepeatedReplication(cozy, doctype);\n\t  };\n\t  return Promise.all(doctypes.map(stop));\n\t}\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.removeReferencedFiles = exports.addReferencedFiles = undefined;\n\texports.listReferencedFiles = listReferencedFiles;\n\texports.fetchReferencedFiles = fetchReferencedFiles;\n\t\n\tvar _fetch = __webpack_require__(1);\n\t\n\tvar _doctypes = __webpack_require__(3);\n\t\n\tfunction updateRelations(verb) {\n\t  return function (cozy, doc, ids) {\n\t    if (!doc) throw new Error('missing doc argument');\n\t    if (!Array.isArray(ids)) ids = [ids];\n\t\n\t    var refs = ids.map(function (id) {\n\t      return { type: _doctypes.DOCTYPE_FILES, id: id };\n\t    });\n\t\n\t    return (0, _fetch.cozyFetchJSON)(cozy, verb, makeReferencesPath(doc), { data: refs });\n\t  };\n\t}\n\t\n\tvar addReferencedFiles = exports.addReferencedFiles = updateRelations('POST');\n\tvar removeReferencedFiles = exports.removeReferencedFiles = updateRelations('DELETE');\n\t\n\tfunction listReferencedFiles(cozy, doc) {\n\t  if (!doc) throw new Error('missing doc argument');\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', makeReferencesPath(doc)).then(function (files) {\n\t    return files.map(function (file) {\n\t      return file._id;\n\t    });\n\t  });\n\t}\n\t\n\tfunction fetchReferencedFiles(cozy, doc, options) {\n\t  if (!doc) throw new Error('missing doc argument');\n\t  var params = Object.keys(options).map(function (key) {\n\t    return '&page[' + key + ']=' + options[key];\n\t  }).join('');\n\t  // As datetime is the only sort option available, I see no reason to not have it by default\n\t  return (0, _fetch.cozyFetchRawJSON)(cozy, 'GET', makeReferencesPath(doc) + '?include=files&sort=datetime' + params);\n\t}\n\t\n\tfunction makeReferencesPath(doc) {\n\t  var type = encodeURIComponent(doc._type);\n\t  var id = encodeURIComponent(doc._id);\n\t  return '/data/' + type + '/' + id + '/relationships/references';\n\t}\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.diskUsage = diskUsage;\n\texports.changePassphrase = changePassphrase;\n\texports.getInstance = getInstance;\n\texports.updateInstance = updateInstance;\n\texports.getClients = getClients;\n\texports.deleteClientById = deleteClientById;\n\texports.updateLastSync = updateLastSync;\n\t\n\tvar _fetch = __webpack_require__(1);\n\t\n\tfunction diskUsage(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/settings/disk-usage');\n\t}\n\t\n\tfunction changePassphrase(cozy, currentPassPhrase, newPassPhrase) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'PUT', '/settings/passphrase', {\n\t    current_passphrase: currentPassPhrase,\n\t    new_passphrase: newPassPhrase\n\t  });\n\t}\n\t\n\tfunction getInstance(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/settings/instance');\n\t}\n\t\n\tfunction updateInstance(cozy, instance) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'PUT', '/settings/instance', instance);\n\t}\n\t\n\tfunction getClients(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/settings/clients');\n\t}\n\t\n\tfunction deleteClientById(cozy, id) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', '/settings/clients/' + id);\n\t}\n\t\n\tfunction updateLastSync(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/settings/synchronized');\n\t}\n\n/***/ },\n/* 49 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * Copyright (c) 2014-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */\n\t\n\t// This method of obtaining a reference to the global object needs to be\n\t// kept identical to the way it is obtained in runtime.js\n\tvar g = (function() { return this })() || Function(\"return this\")();\n\t\n\t// Use `getOwnPropertyNames` because not all browsers support calling\n\t// `hasOwnProperty` on the global `self` object in a worker. See #183.\n\tvar hadRuntime = g.regeneratorRuntime &&\n\t  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\t\n\t// Save the old regeneratorRuntime in case it needs to be restored later.\n\tvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\t\n\t// Force reevalutation of runtime.js.\n\tg.regeneratorRuntime = undefined;\n\t\n\tmodule.exports = __webpack_require__(50);\n\t\n\tif (hadRuntime) {\n\t  // Restore the original runtime.\n\t  g.regeneratorRuntime = oldRuntime;\n\t} else {\n\t  // Remove the global property added by runtime.js.\n\t  try {\n\t    delete g.regeneratorRuntime;\n\t  } catch(e) {\n\t    g.regeneratorRuntime = undefined;\n\t  }\n\t}\n\n\n/***/ },\n/* 50 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Copyright (c) 2014-present, Facebook, Inc.\n\t *\n\t * This source code is licensed under the MIT license found in the\n\t * LICENSE file in the root directory of this source tree.\n\t */\n\t\n\t!(function(global) {\n\t  \"use strict\";\n\t\n\t  var Op = Object.prototype;\n\t  var hasOwn = Op.hasOwnProperty;\n\t  var undefined; // More compressible than void 0.\n\t  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n\t  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n\t  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n\t  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\t\n\t  var inModule = typeof module === \"object\";\n\t  var runtime = global.regeneratorRuntime;\n\t  if (runtime) {\n\t    if (inModule) {\n\t      // If regeneratorRuntime is defined globally and we're in a module,\n\t      // make the exports object identical to regeneratorRuntime.\n\t      module.exports = runtime;\n\t    }\n\t    // Don't bother evaluating the rest of this file if the runtime was\n\t    // already defined globally.\n\t    return;\n\t  }\n\t\n\t  // Define the runtime globally (as expected by generated code) as either\n\t  // module.exports (if we're in a module) or a new, empty object.\n\t  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\t\n\t  function wrap(innerFn, outerFn, self, tryLocsList) {\n\t    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n\t    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n\t    var generator = Object.create(protoGenerator.prototype);\n\t    var context = new Context(tryLocsList || []);\n\t\n\t    // The ._invoke method unifies the implementations of the .next,\n\t    // .throw, and .return methods.\n\t    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\t\n\t    return generator;\n\t  }\n\t  runtime.wrap = wrap;\n\t\n\t  // Try/catch helper to minimize deoptimizations. Returns a completion\n\t  // record like context.tryEntries[i].completion. This interface could\n\t  // have been (and was previously) designed to take a closure to be\n\t  // invoked without arguments, but in all the cases we care about we\n\t  // already have an existing method we want to call, so there's no need\n\t  // to create a new function object. We can even get away with assuming\n\t  // the method takes exactly one argument, since that happens to be true\n\t  // in every case, so we don't have to touch the arguments object. The\n\t  // only additional allocation required is the completion record, which\n\t  // has a stable shape and so hopefully should be cheap to allocate.\n\t  function tryCatch(fn, obj, arg) {\n\t    try {\n\t      return { type: \"normal\", arg: fn.call(obj, arg) };\n\t    } catch (err) {\n\t      return { type: \"throw\", arg: err };\n\t    }\n\t  }\n\t\n\t  var GenStateSuspendedStart = \"suspendedStart\";\n\t  var GenStateSuspendedYield = \"suspendedYield\";\n\t  var GenStateExecuting = \"executing\";\n\t  var GenStateCompleted = \"completed\";\n\t\n\t  // Returning this object from the innerFn has the same effect as\n\t  // breaking out of the dispatch switch statement.\n\t  var ContinueSentinel = {};\n\t\n\t  // Dummy constructor functions that we use as the .constructor and\n\t  // .constructor.prototype properties for functions that return Generator\n\t  // objects. For full spec compliance, you may wish to configure your\n\t  // minifier not to mangle the names of these two functions.\n\t  function Generator() {}\n\t  function GeneratorFunction() {}\n\t  function GeneratorFunctionPrototype() {}\n\t\n\t  // This is a polyfill for %IteratorPrototype% for environments that\n\t  // don't natively support it.\n\t  var IteratorPrototype = {};\n\t  IteratorPrototype[iteratorSymbol] = function () {\n\t    return this;\n\t  };\n\t\n\t  var getProto = Object.getPrototypeOf;\n\t  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\t  if (NativeIteratorPrototype &&\n\t      NativeIteratorPrototype !== Op &&\n\t      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n\t    // This environment has a native %IteratorPrototype%; use it instead\n\t    // of the polyfill.\n\t    IteratorPrototype = NativeIteratorPrototype;\n\t  }\n\t\n\t  var Gp = GeneratorFunctionPrototype.prototype =\n\t    Generator.prototype = Object.create(IteratorPrototype);\n\t  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n\t  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n\t  GeneratorFunctionPrototype[toStringTagSymbol] =\n\t    GeneratorFunction.displayName = \"GeneratorFunction\";\n\t\n\t  // Helper for defining the .next, .throw, and .return methods of the\n\t  // Iterator interface in terms of a single ._invoke method.\n\t  function defineIteratorMethods(prototype) {\n\t    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n\t      prototype[method] = function(arg) {\n\t        return this._invoke(method, arg);\n\t      };\n\t    });\n\t  }\n\t\n\t  runtime.isGeneratorFunction = function(genFun) {\n\t    var ctor = typeof genFun === \"function\" && genFun.constructor;\n\t    return ctor\n\t      ? ctor === GeneratorFunction ||\n\t        // For the native GeneratorFunction constructor, the best we can\n\t        // do is to check its .name property.\n\t        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n\t      : false;\n\t  };\n\t\n\t  runtime.mark = function(genFun) {\n\t    if (Object.setPrototypeOf) {\n\t      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n\t    } else {\n\t      genFun.__proto__ = GeneratorFunctionPrototype;\n\t      if (!(toStringTagSymbol in genFun)) {\n\t        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n\t      }\n\t    }\n\t    genFun.prototype = Object.create(Gp);\n\t    return genFun;\n\t  };\n\t\n\t  // Within the body of any async function, `await x` is transformed to\n\t  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n\t  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n\t  // meant to be awaited.\n\t  runtime.awrap = function(arg) {\n\t    return { __await: arg };\n\t  };\n\t\n\t  function AsyncIterator(generator) {\n\t    function invoke(method, arg, resolve, reject) {\n\t      var record = tryCatch(generator[method], generator, arg);\n\t      if (record.type === \"throw\") {\n\t        reject(record.arg);\n\t      } else {\n\t        var result = record.arg;\n\t        var value = result.value;\n\t        if (value &&\n\t            typeof value === \"object\" &&\n\t            hasOwn.call(value, \"__await\")) {\n\t          return Promise.resolve(value.__await).then(function(value) {\n\t            invoke(\"next\", value, resolve, reject);\n\t          }, function(err) {\n\t            invoke(\"throw\", err, resolve, reject);\n\t          });\n\t        }\n\t\n\t        return Promise.resolve(value).then(function(unwrapped) {\n\t          // When a yielded Promise is resolved, its final value becomes\n\t          // the .value of the Promise<{value,done}> result for the\n\t          // current iteration. If the Promise is rejected, however, the\n\t          // result for this iteration will be rejected with the same\n\t          // reason. Note that rejections of yielded Promises are not\n\t          // thrown back into the generator function, as is the case\n\t          // when an awaited Promise is rejected. This difference in\n\t          // behavior between yield and await is important, because it\n\t          // allows the consumer to decide what to do with the yielded\n\t          // rejection (swallow it and continue, manually .throw it back\n\t          // into the generator, abandon iteration, whatever). With\n\t          // await, by contrast, there is no opportunity to examine the\n\t          // rejection reason outside the generator function, so the\n\t          // only option is to throw it from the await expression, and\n\t          // let the generator function handle the exception.\n\t          result.value = unwrapped;\n\t          resolve(result);\n\t        }, reject);\n\t      }\n\t    }\n\t\n\t    var previousPromise;\n\t\n\t    function enqueue(method, arg) {\n\t      function callInvokeWithMethodAndArg() {\n\t        return new Promise(function(resolve, reject) {\n\t          invoke(method, arg, resolve, reject);\n\t        });\n\t      }\n\t\n\t      return previousPromise =\n\t        // If enqueue has been called before, then we want to wait until\n\t        // all previous Promises have been resolved before calling invoke,\n\t        // so that results are always delivered in the correct order. If\n\t        // enqueue has not been called before, then it is important to\n\t        // call invoke immediately, without waiting on a callback to fire,\n\t        // so that the async generator function has the opportunity to do\n\t        // any necessary setup in a predictable way. This predictability\n\t        // is why the Promise constructor synchronously invokes its\n\t        // executor callback, and why async functions synchronously\n\t        // execute code before the first await. Since we implement simple\n\t        // async functions in terms of async generators, it is especially\n\t        // important to get this right, even though it requires care.\n\t        previousPromise ? previousPromise.then(\n\t          callInvokeWithMethodAndArg,\n\t          // Avoid propagating failures to Promises returned by later\n\t          // invocations of the iterator.\n\t          callInvokeWithMethodAndArg\n\t        ) : callInvokeWithMethodAndArg();\n\t    }\n\t\n\t    // Define the unified helper method that is used to implement .next,\n\t    // .throw, and .return (see defineIteratorMethods).\n\t    this._invoke = enqueue;\n\t  }\n\t\n\t  defineIteratorMethods(AsyncIterator.prototype);\n\t  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n\t    return this;\n\t  };\n\t  runtime.AsyncIterator = AsyncIterator;\n\t\n\t  // Note that simple async functions are implemented on top of\n\t  // AsyncIterator objects; they just return a Promise for the value of\n\t  // the final result produced by the iterator.\n\t  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n\t    var iter = new AsyncIterator(\n\t      wrap(innerFn, outerFn, self, tryLocsList)\n\t    );\n\t\n\t    return runtime.isGeneratorFunction(outerFn)\n\t      ? iter // If outerFn is a generator, return the full iterator.\n\t      : iter.next().then(function(result) {\n\t          return result.done ? result.value : iter.next();\n\t        });\n\t  };\n\t\n\t  function makeInvokeMethod(innerFn, self, context) {\n\t    var state = GenStateSuspendedStart;\n\t\n\t    return function invoke(method, arg) {\n\t      if (state === GenStateExecuting) {\n\t        throw new Error(\"Generator is already running\");\n\t      }\n\t\n\t      if (state === GenStateCompleted) {\n\t        if (method === \"throw\") {\n\t          throw arg;\n\t        }\n\t\n\t        // Be forgiving, per 25.3.3.3.3 of the spec:\n\t        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\t        return doneResult();\n\t      }\n\t\n\t      context.method = method;\n\t      context.arg = arg;\n\t\n\t      while (true) {\n\t        var delegate = context.delegate;\n\t        if (delegate) {\n\t          var delegateResult = maybeInvokeDelegate(delegate, context);\n\t          if (delegateResult) {\n\t            if (delegateResult === ContinueSentinel) continue;\n\t            return delegateResult;\n\t          }\n\t        }\n\t\n\t        if (context.method === \"next\") {\n\t          // Setting context._sent for legacy support of Babel's\n\t          // function.sent implementation.\n\t          context.sent = context._sent = context.arg;\n\t\n\t        } else if (context.method === \"throw\") {\n\t          if (state === GenStateSuspendedStart) {\n\t            state = GenStateCompleted;\n\t            throw context.arg;\n\t          }\n\t\n\t          context.dispatchException(context.arg);\n\t\n\t        } else if (context.method === \"return\") {\n\t          context.abrupt(\"return\", context.arg);\n\t        }\n\t\n\t        state = GenStateExecuting;\n\t\n\t        var record = tryCatch(innerFn, self, context);\n\t        if (record.type === \"normal\") {\n\t          // If an exception is thrown from innerFn, we leave state ===\n\t          // GenStateExecuting and loop back for another invocation.\n\t          state = context.done\n\t            ? GenStateCompleted\n\t            : GenStateSuspendedYield;\n\t\n\t          if (record.arg === ContinueSentinel) {\n\t            continue;\n\t          }\n\t\n\t          return {\n\t            value: record.arg,\n\t            done: context.done\n\t          };\n\t\n\t        } else if (record.type === \"throw\") {\n\t          state = GenStateCompleted;\n\t          // Dispatch the exception by looping back around to the\n\t          // context.dispatchException(context.arg) call above.\n\t          context.method = \"throw\";\n\t          context.arg = record.arg;\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  // Call delegate.iterator[context.method](context.arg) and handle the\n\t  // result, either by returning a { value, done } result from the\n\t  // delegate iterator, or by modifying context.method and context.arg,\n\t  // setting context.delegate to null, and returning the ContinueSentinel.\n\t  function maybeInvokeDelegate(delegate, context) {\n\t    var method = delegate.iterator[context.method];\n\t    if (method === undefined) {\n\t      // A .throw or .return when the delegate iterator has no .throw\n\t      // method always terminates the yield* loop.\n\t      context.delegate = null;\n\t\n\t      if (context.method === \"throw\") {\n\t        if (delegate.iterator.return) {\n\t          // If the delegate iterator has a return method, give it a\n\t          // chance to clean up.\n\t          context.method = \"return\";\n\t          context.arg = undefined;\n\t          maybeInvokeDelegate(delegate, context);\n\t\n\t          if (context.method === \"throw\") {\n\t            // If maybeInvokeDelegate(context) changed context.method from\n\t            // \"return\" to \"throw\", let that override the TypeError below.\n\t            return ContinueSentinel;\n\t          }\n\t        }\n\t\n\t        context.method = \"throw\";\n\t        context.arg = new TypeError(\n\t          \"The iterator does not provide a 'throw' method\");\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    var record = tryCatch(method, delegate.iterator, context.arg);\n\t\n\t    if (record.type === \"throw\") {\n\t      context.method = \"throw\";\n\t      context.arg = record.arg;\n\t      context.delegate = null;\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    var info = record.arg;\n\t\n\t    if (! info) {\n\t      context.method = \"throw\";\n\t      context.arg = new TypeError(\"iterator result is not an object\");\n\t      context.delegate = null;\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    if (info.done) {\n\t      // Assign the result of the finished delegate to the temporary\n\t      // variable specified by delegate.resultName (see delegateYield).\n\t      context[delegate.resultName] = info.value;\n\t\n\t      // Resume execution at the desired location (see delegateYield).\n\t      context.next = delegate.nextLoc;\n\t\n\t      // If context.method was \"throw\" but the delegate handled the\n\t      // exception, let the outer generator proceed normally. If\n\t      // context.method was \"next\", forget context.arg since it has been\n\t      // \"consumed\" by the delegate iterator. If context.method was\n\t      // \"return\", allow the original .return call to continue in the\n\t      // outer generator.\n\t      if (context.method !== \"return\") {\n\t        context.method = \"next\";\n\t        context.arg = undefined;\n\t      }\n\t\n\t    } else {\n\t      // Re-yield the result returned by the delegate method.\n\t      return info;\n\t    }\n\t\n\t    // The delegate iterator is finished, so forget it and continue with\n\t    // the outer generator.\n\t    context.delegate = null;\n\t    return ContinueSentinel;\n\t  }\n\t\n\t  // Define Generator.prototype.{next,throw,return} in terms of the\n\t  // unified ._invoke helper method.\n\t  defineIteratorMethods(Gp);\n\t\n\t  Gp[toStringTagSymbol] = \"Generator\";\n\t\n\t  // A Generator should always return itself as the iterator object when the\n\t  // @@iterator function is called on it. Some browsers' implementations of the\n\t  // iterator prototype chain incorrectly implement this, causing the Generator\n\t  // object to not be returned from this call. This ensures that doesn't happen.\n\t  // See https://github.com/facebook/regenerator/issues/274 for more details.\n\t  Gp[iteratorSymbol] = function() {\n\t    return this;\n\t  };\n\t\n\t  Gp.toString = function() {\n\t    return \"[object Generator]\";\n\t  };\n\t\n\t  function pushTryEntry(locs) {\n\t    var entry = { tryLoc: locs[0] };\n\t\n\t    if (1 in locs) {\n\t      entry.catchLoc = locs[1];\n\t    }\n\t\n\t    if (2 in locs) {\n\t      entry.finallyLoc = locs[2];\n\t      entry.afterLoc = locs[3];\n\t    }\n\t\n\t    this.tryEntries.push(entry);\n\t  }\n\t\n\t  function resetTryEntry(entry) {\n\t    var record = entry.completion || {};\n\t    record.type = \"normal\";\n\t    delete record.arg;\n\t    entry.completion = record;\n\t  }\n\t\n\t  function Context(tryLocsList) {\n\t    // The root entry object (effectively a try statement without a catch\n\t    // or a finally block) gives us a place to store values thrown from\n\t    // locations where there is no enclosing try statement.\n\t    this.tryEntries = [{ tryLoc: \"root\" }];\n\t    tryLocsList.forEach(pushTryEntry, this);\n\t    this.reset(true);\n\t  }\n\t\n\t  runtime.keys = function(object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t      keys.push(key);\n\t    }\n\t    keys.reverse();\n\t\n\t    // Rather than returning an object with a next method, we keep\n\t    // things simple and return the next function itself.\n\t    return function next() {\n\t      while (keys.length) {\n\t        var key = keys.pop();\n\t        if (key in object) {\n\t          next.value = key;\n\t          next.done = false;\n\t          return next;\n\t        }\n\t      }\n\t\n\t      // To avoid creating an additional object, we just hang the .value\n\t      // and .done properties off the next function object itself. This\n\t      // also ensures that the minifier will not anonymize the function.\n\t      next.done = true;\n\t      return next;\n\t    };\n\t  };\n\t\n\t  function values(iterable) {\n\t    if (iterable) {\n\t      var iteratorMethod = iterable[iteratorSymbol];\n\t      if (iteratorMethod) {\n\t        return iteratorMethod.call(iterable);\n\t      }\n\t\n\t      if (typeof iterable.next === \"function\") {\n\t        return iterable;\n\t      }\n\t\n\t      if (!isNaN(iterable.length)) {\n\t        var i = -1, next = function next() {\n\t          while (++i < iterable.length) {\n\t            if (hasOwn.call(iterable, i)) {\n\t              next.value = iterable[i];\n\t              next.done = false;\n\t              return next;\n\t            }\n\t          }\n\t\n\t          next.value = undefined;\n\t          next.done = true;\n\t\n\t          return next;\n\t        };\n\t\n\t        return next.next = next;\n\t      }\n\t    }\n\t\n\t    // Return an iterator with no values.\n\t    return { next: doneResult };\n\t  }\n\t  runtime.values = values;\n\t\n\t  function doneResult() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  Context.prototype = {\n\t    constructor: Context,\n\t\n\t    reset: function(skipTempReset) {\n\t      this.prev = 0;\n\t      this.next = 0;\n\t      // Resetting context._sent for legacy support of Babel's\n\t      // function.sent implementation.\n\t      this.sent = this._sent = undefined;\n\t      this.done = false;\n\t      this.delegate = null;\n\t\n\t      this.method = \"next\";\n\t      this.arg = undefined;\n\t\n\t      this.tryEntries.forEach(resetTryEntry);\n\t\n\t      if (!skipTempReset) {\n\t        for (var name in this) {\n\t          // Not sure about the optimal order of these conditions:\n\t          if (name.charAt(0) === \"t\" &&\n\t              hasOwn.call(this, name) &&\n\t              !isNaN(+name.slice(1))) {\n\t            this[name] = undefined;\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    stop: function() {\n\t      this.done = true;\n\t\n\t      var rootEntry = this.tryEntries[0];\n\t      var rootRecord = rootEntry.completion;\n\t      if (rootRecord.type === \"throw\") {\n\t        throw rootRecord.arg;\n\t      }\n\t\n\t      return this.rval;\n\t    },\n\t\n\t    dispatchException: function(exception) {\n\t      if (this.done) {\n\t        throw exception;\n\t      }\n\t\n\t      var context = this;\n\t      function handle(loc, caught) {\n\t        record.type = \"throw\";\n\t        record.arg = exception;\n\t        context.next = loc;\n\t\n\t        if (caught) {\n\t          // If the dispatched exception was caught by a catch block,\n\t          // then let that catch block handle the exception normally.\n\t          context.method = \"next\";\n\t          context.arg = undefined;\n\t        }\n\t\n\t        return !! caught;\n\t      }\n\t\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        var record = entry.completion;\n\t\n\t        if (entry.tryLoc === \"root\") {\n\t          // Exception thrown outside of any try block that could handle\n\t          // it, so set the completion value of the entire function to\n\t          // throw the exception.\n\t          return handle(\"end\");\n\t        }\n\t\n\t        if (entry.tryLoc <= this.prev) {\n\t          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n\t          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\t\n\t          if (hasCatch && hasFinally) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            } else if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else if (hasCatch) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            }\n\t\n\t          } else if (hasFinally) {\n\t            if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else {\n\t            throw new Error(\"try statement without catch or finally\");\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    abrupt: function(type, arg) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc <= this.prev &&\n\t            hasOwn.call(entry, \"finallyLoc\") &&\n\t            this.prev < entry.finallyLoc) {\n\t          var finallyEntry = entry;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (finallyEntry &&\n\t          (type === \"break\" ||\n\t           type === \"continue\") &&\n\t          finallyEntry.tryLoc <= arg &&\n\t          arg <= finallyEntry.finallyLoc) {\n\t        // Ignore the finally entry if control is not jumping to a\n\t        // location outside the try/catch block.\n\t        finallyEntry = null;\n\t      }\n\t\n\t      var record = finallyEntry ? finallyEntry.completion : {};\n\t      record.type = type;\n\t      record.arg = arg;\n\t\n\t      if (finallyEntry) {\n\t        this.method = \"next\";\n\t        this.next = finallyEntry.finallyLoc;\n\t        return ContinueSentinel;\n\t      }\n\t\n\t      return this.complete(record);\n\t    },\n\t\n\t    complete: function(record, afterLoc) {\n\t      if (record.type === \"throw\") {\n\t        throw record.arg;\n\t      }\n\t\n\t      if (record.type === \"break\" ||\n\t          record.type === \"continue\") {\n\t        this.next = record.arg;\n\t      } else if (record.type === \"return\") {\n\t        this.rval = this.arg = record.arg;\n\t        this.method = \"return\";\n\t        this.next = \"end\";\n\t      } else if (record.type === \"normal\" && afterLoc) {\n\t        this.next = afterLoc;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    },\n\t\n\t    finish: function(finallyLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.finallyLoc === finallyLoc) {\n\t          this.complete(entry.completion, entry.afterLoc);\n\t          resetTryEntry(entry);\n\t          return ContinueSentinel;\n\t        }\n\t      }\n\t    },\n\t\n\t    \"catch\": function(tryLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc === tryLoc) {\n\t          var record = entry.completion;\n\t          if (record.type === \"throw\") {\n\t            var thrown = record.arg;\n\t            resetTryEntry(entry);\n\t          }\n\t          return thrown;\n\t        }\n\t      }\n\t\n\t      // The context.catch method must only be called with a location\n\t      // argument that corresponds to a known catch block.\n\t      throw new Error(\"illegal catch attempt\");\n\t    },\n\t\n\t    delegateYield: function(iterable, resultName, nextLoc) {\n\t      this.delegate = {\n\t        iterator: values(iterable),\n\t        resultName: resultName,\n\t        nextLoc: nextLoc\n\t      };\n\t\n\t      if (this.method === \"next\") {\n\t        // Deliberately forget the last sent value so that we don't\n\t        // accidentally pass it on to the delegate.\n\t        this.arg = undefined;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    }\n\t  };\n\t})(\n\t  // In sloppy mode, unbound `this` refers to the global object, fallback to\n\t  // Function constructor if we're in global strict mode. That is sadly a form\n\t  // of indirect eval which violates Content Security Policy.\n\t  (function() { return this })() || Function(\"return this\")()\n\t);\n\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (it) {\n\t  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n\n/***/ },\n/* 52 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(13);\n\tmodule.exports = function (it) {\n\t  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(26);\n\tvar toLength = __webpack_require__(72);\n\tvar toAbsoluteIndex = __webpack_require__(71);\n\tmodule.exports = function (IS_INCLUDES) {\n\t  return function ($this, el, fromIndex) {\n\t    var O = toIObject($this);\n\t    var length = toLength(O.length);\n\t    var index = toAbsoluteIndex(fromIndex, length);\n\t    var value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    // eslint-disable-next-line no-self-compare\n\t    if (IS_INCLUDES && el != el) while (length > index) {\n\t      value = O[index++];\n\t      // eslint-disable-next-line no-self-compare\n\t      if (value != value) return true;\n\t    // Array#indexOf ignores holes, Array#includes - not\n\t    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n\t      if (O[index] === el) return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function (it) {\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(51);\n\tmodule.exports = function (fn, that, length) {\n\t  aFunction(fn);\n\t  if (that === undefined) return fn;\n\t  switch (length) {\n\t    case 1: return function (a) {\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function (a, b) {\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function (a, b, c) {\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function (/* ...args */) {\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(13);\n\tvar document = __webpack_require__(4).document;\n\t// typeof document.createElement is 'object' in old IE\n\tvar is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function (it) {\n\t  return is ? document.createElement(it) : {};\n\t};\n\n\n/***/ },\n/* 57 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\n\tmodule.exports = (\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n\t).split(',');\n\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(4);\n\tvar core = __webpack_require__(10);\n\tvar hide = __webpack_require__(23);\n\tvar redefine = __webpack_require__(68);\n\tvar ctx = __webpack_require__(55);\n\tvar PROTOTYPE = 'prototype';\n\t\n\tvar $export = function (type, name, source) {\n\t  var IS_FORCED = type & $export.F;\n\t  var IS_GLOBAL = type & $export.G;\n\t  var IS_STATIC = type & $export.S;\n\t  var IS_PROTO = type & $export.P;\n\t  var IS_BIND = type & $export.B;\n\t  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n\t  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n\t  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n\t  var key, own, out, exp;\n\t  if (IS_GLOBAL) source = name;\n\t  for (key in source) {\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    // export native or passed\n\t    out = (own ? target : source)[key];\n\t    // bind timers to global for call from export context\n\t    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // extend global\n\t    if (target) redefine(target, key, out, type & $export.U);\n\t    // export\n\t    if (exports[key] != out) hide(exports, key, exp);\n\t    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n\t  }\n\t};\n\tglobal.core = core;\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library`\n\tmodule.exports = $export;\n\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(11) && !__webpack_require__(12)(function () {\n\t  return Object.defineProperty(__webpack_require__(56)('div'), 'a', { get: function () { return 7; } }).a != 7;\n\t});\n\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\tmodule.exports = false;\n\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// 19.1.2.1 Object.assign(target, source, ...)\n\tvar getKeys = __webpack_require__(65);\n\tvar gOPS = __webpack_require__(63);\n\tvar pIE = __webpack_require__(66);\n\tvar toObject = __webpack_require__(73);\n\tvar IObject = __webpack_require__(24);\n\tvar $assign = Object.assign;\n\t\n\t// should work with symbols and should have deterministic property order (V8 bug)\n\tmodule.exports = !$assign || __webpack_require__(12)(function () {\n\t  var A = {};\n\t  var B = {};\n\t  // eslint-disable-next-line no-undef\n\t  var S = Symbol();\n\t  var K = 'abcdefghijklmnopqrst';\n\t  A[S] = 7;\n\t  K.split('').forEach(function (k) { B[k] = k; });\n\t  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n\t}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n\t  var T = toObject(target);\n\t  var aLen = arguments.length;\n\t  var index = 1;\n\t  var getSymbols = gOPS.f;\n\t  var isEnum = pIE.f;\n\t  while (aLen > index) {\n\t    var S = IObject(arguments[index++]);\n\t    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n\t    var length = keys.length;\n\t    var j = 0;\n\t    var key;\n\t    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n\t  } return T;\n\t} : $assign;\n\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject = __webpack_require__(52);\n\tvar IE8_DOM_DEFINE = __webpack_require__(59);\n\tvar toPrimitive = __webpack_require__(74);\n\tvar dP = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(11) ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if (IE8_DOM_DEFINE) try {\n\t    return dP(O, P, Attributes);\n\t  } catch (e) { /* empty */ }\n\t  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n\t  if ('value' in Attributes) O[P] = Attributes.value;\n\t  return O;\n\t};\n\n\n/***/ },\n/* 63 */\n/***/ function(module, exports) {\n\n\texports.f = Object.getOwnPropertySymbols;\n\n\n/***/ },\n/* 64 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has = __webpack_require__(22);\n\tvar toIObject = __webpack_require__(26);\n\tvar arrayIndexOf = __webpack_require__(53)(false);\n\tvar IE_PROTO = __webpack_require__(69)('IE_PROTO');\n\t\n\tmodule.exports = function (object, names) {\n\t  var O = toIObject(object);\n\t  var i = 0;\n\t  var result = [];\n\t  var key;\n\t  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while (names.length > i) if (has(O, key = names[i++])) {\n\t    ~arrayIndexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n\n/***/ },\n/* 65 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\tvar $keys = __webpack_require__(64);\n\tvar enumBugKeys = __webpack_require__(57);\n\t\n\tmodule.exports = Object.keys || function keys(O) {\n\t  return $keys(O, enumBugKeys);\n\t};\n\n\n/***/ },\n/* 66 */\n/***/ function(module, exports) {\n\n\texports.f = {}.propertyIsEnumerable;\n\n\n/***/ },\n/* 67 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function (bitmap, value) {\n\t  return {\n\t    enumerable: !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable: !(bitmap & 4),\n\t    value: value\n\t  };\n\t};\n\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(4);\n\tvar hide = __webpack_require__(23);\n\tvar has = __webpack_require__(22);\n\tvar SRC = __webpack_require__(27)('src');\n\tvar TO_STRING = 'toString';\n\tvar $toString = Function[TO_STRING];\n\tvar TPL = ('' + $toString).split(TO_STRING);\n\t\n\t__webpack_require__(10).inspectSource = function (it) {\n\t  return $toString.call(it);\n\t};\n\t\n\t(module.exports = function (O, key, val, safe) {\n\t  var isFunction = typeof val == 'function';\n\t  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n\t  if (O[key] === val) return;\n\t  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n\t  if (O === global) {\n\t    O[key] = val;\n\t  } else if (!safe) {\n\t    delete O[key];\n\t    hide(O, key, val);\n\t  } else if (O[key]) {\n\t    O[key] = val;\n\t  } else {\n\t    hide(O, key, val);\n\t  }\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, TO_STRING, function toString() {\n\t  return typeof this == 'function' && this[SRC] || $toString.call(this);\n\t});\n\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(70)('keys');\n\tvar uid = __webpack_require__(27);\n\tmodule.exports = function (key) {\n\t  return shared[key] || (shared[key] = uid(key));\n\t};\n\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar core = __webpack_require__(10);\n\tvar global = __webpack_require__(4);\n\tvar SHARED = '__core-js_shared__';\n\tvar store = global[SHARED] || (global[SHARED] = {});\n\t\n\t(module.exports = function (key, value) {\n\t  return store[key] || (store[key] = value !== undefined ? value : {});\n\t})('versions', []).push({\n\t  version: core.version,\n\t  mode: __webpack_require__(60) ? 'pure' : 'global',\n\t  copyright: 'Â© 2018 Denis Pushkarev (zloirock.ru)'\n\t});\n\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(25);\n\tvar max = Math.max;\n\tvar min = Math.min;\n\tmodule.exports = function (index, length) {\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(25);\n\tvar min = Math.min;\n\tmodule.exports = function (it) {\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(21);\n\tmodule.exports = function (it) {\n\t  return Object(defined(it));\n\t};\n\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(13);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function (it, S) {\n\t  if (!isObject(it)) return it;\n\t  var fn, val;\n\t  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n\t  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n\t  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n\n/***/ },\n/* 75 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.1 Object.assign(target, source)\n\tvar $export = __webpack_require__(58);\n\t\n\t$export($export.S + $export.F, 'Object', { assign: __webpack_require__(61) });\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// the whatwg-fetch polyfill installs the fetch() function\n\t// on the global object (window or self)\n\t//\n\t// Return that as the export for use in Webpack, Browserify etc.\n\t__webpack_require__(89);\n\tmodule.exports = self.fetch.bind(self);\n\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar Promise = _interopDefault(__webpack_require__(17));\n\tvar pouchdbUtils = __webpack_require__(6);\n\tvar pouchdbMd5 = __webpack_require__(31);\n\tvar pouchdbCollections = __webpack_require__(16);\n\tvar pouchdbBinaryUtils = __webpack_require__(30);\n\tvar pouchdbCollate = __webpack_require__(15);\n\tvar pouchdbMapreduceUtils = __webpack_require__(79);\n\t\n\t/*\n\t * Simple task queue to sequentialize actions. Assumes\n\t * callbacks will eventually fire (once).\n\t */\n\t\n\t\n\tfunction TaskQueue() {\n\t  this.promise = new Promise(function (fulfill) {fulfill(); });\n\t}\n\tTaskQueue.prototype.add = function (promiseFactory) {\n\t  this.promise = this.promise.catch(function () {\n\t    // just recover\n\t  }).then(function () {\n\t    return promiseFactory();\n\t  });\n\t  return this.promise;\n\t};\n\tTaskQueue.prototype.finish = function () {\n\t  return this.promise;\n\t};\n\t\n\tfunction stringify(input) {\n\t  if (!input) {\n\t    return 'undefined'; // backwards compat for empty reduce\n\t  }\n\t  // for backwards compat with mapreduce, functions/strings are stringified\n\t  // as-is. everything else is JSON-stringified.\n\t  switch (typeof input) {\n\t    case 'function':\n\t      // e.g. a mapreduce map\n\t      return input.toString();\n\t    case 'string':\n\t      // e.g. a mapreduce built-in _reduce function\n\t      return input.toString();\n\t    default:\n\t      // e.g. a JSON object in the case of mango queries\n\t      return JSON.stringify(input);\n\t  }\n\t}\n\t\n\t/* create a string signature for a view so we can cache it and uniq it */\n\tfunction createViewSignature(mapFun, reduceFun) {\n\t  // the \"undefined\" part is for backwards compatibility\n\t  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n\t}\n\t\n\tfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n\t  var viewSignature = createViewSignature(mapFun, reduceFun);\n\t\n\t  var cachedViews;\n\t  if (!temporary) {\n\t    // cache this to ensure we don't try to update the same view twice\n\t    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n\t    if (cachedViews[viewSignature]) {\n\t      return cachedViews[viewSignature];\n\t    }\n\t  }\n\t\n\t  var promiseForView = sourceDB.info().then(function (info) {\n\t\n\t    var depDbName = info.db_name + '-mrview-' +\n\t      (temporary ? 'temp' : pouchdbMd5.stringMd5(viewSignature));\n\t\n\t    // save the view name in the source db so it can be cleaned up if necessary\n\t    // (e.g. when the _design doc is deleted, remove all associated view data)\n\t    function diffFunction(doc) {\n\t      doc.views = doc.views || {};\n\t      var fullViewName = viewName;\n\t      if (fullViewName.indexOf('/') === -1) {\n\t        fullViewName = viewName + '/' + viewName;\n\t      }\n\t      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n\t      /* istanbul ignore if */\n\t      if (depDbs[depDbName]) {\n\t        return; // no update necessary\n\t      }\n\t      depDbs[depDbName] = true;\n\t      return doc;\n\t    }\n\t    return pouchdbUtils.upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n\t      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n\t        var db = res.db;\n\t        db.auto_compaction = true;\n\t        var view = {\n\t          name: depDbName,\n\t          db: db,\n\t          sourceDB: sourceDB,\n\t          adapter: sourceDB.adapter,\n\t          mapFun: mapFun,\n\t          reduceFun: reduceFun\n\t        };\n\t        return view.db.get('_local/lastSeq').catch(function (err) {\n\t          /* istanbul ignore if */\n\t          if (err.status !== 404) {\n\t            throw err;\n\t          }\n\t        }).then(function (lastSeqDoc) {\n\t          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n\t          if (cachedViews) {\n\t            view.db.once('destroyed', function () {\n\t              delete cachedViews[viewSignature];\n\t            });\n\t          }\n\t          return view;\n\t        });\n\t      });\n\t    });\n\t  });\n\t\n\t  if (cachedViews) {\n\t    cachedViews[viewSignature] = promiseForView;\n\t  }\n\t  return promiseForView;\n\t}\n\t\n\tvar persistentQueues = {};\n\tvar tempViewQueue = new TaskQueue();\n\tvar CHANGES_BATCH_SIZE = 50;\n\t\n\tfunction parseViewName(name) {\n\t  // can be either 'ddocname/viewname' or just 'viewname'\n\t  // (where the ddoc name is the same)\n\t  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n\t}\n\t\n\tfunction isGenOne(changes) {\n\t  // only return true if the current change is 1-\n\t  // and there are no other leafs\n\t  return changes.length === 1 && /^1-/.test(changes[0].rev);\n\t}\n\t\n\tfunction emitError(db, e) {\n\t  try {\n\t    db.emit('error', e);\n\t  } catch (err) {\n\t    pouchdbUtils.guardedConsole('error',\n\t      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n\t      'You can debug this error by doing:\\n' +\n\t      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n\t      'Please double-check your map/reduce function.');\n\t    pouchdbUtils.guardedConsole('error', e);\n\t  }\n\t}\n\t\n\t/**\n\t * Returns an \"abstract\" mapreduce object of the form:\n\t *\n\t *   {\n\t *     query: queryFun,\n\t *     viewCleanup: viewCleanupFun\n\t *   }\n\t *\n\t * Arguments are:\n\t *\n\t * localDoc: string\n\t *   This is for the local doc that gets saved in order to track the\n\t *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n\t *   unique, so that indexer plugins don't collide with each other.\n\t * mapper: function (mapFunDef, emit)\n\t *   Returns a map function based on the mapFunDef, which in the case of\n\t *   normal map/reduce is just the de-stringified function, but may be\n\t *   something else, such as an object in the case of pouchdb-find.\n\t * reducer: function (reduceFunDef)\n\t *   Ditto, but for reducing. Modules don't have to support reducing\n\t *   (e.g. pouchdb-find).\n\t * ddocValidator: function (ddoc, viewName)\n\t *   Throws an error if the ddoc or viewName is not valid.\n\t *   This could be a way to communicate to the user that the configuration for the\n\t *   indexer is invalid.\n\t */\n\tfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\t\n\t  function tryMap(db, fun, doc) {\n\t    // emit an event if there was an error thrown by a map function.\n\t    // putting try/catches in a single function also avoids deoptimizations.\n\t    try {\n\t      fun(doc);\n\t    } catch (e) {\n\t      emitError(db, e);\n\t    }\n\t  }\n\t\n\t  function tryReduce(db, fun, keys, values, rereduce) {\n\t    // same as above, but returning the result or an error. there are two separate\n\t    // functions to avoid extra memory allocations since the tryCode() case is used\n\t    // for custom map functions (common) vs this function, which is only used for\n\t    // custom reduce functions (rare)\n\t    try {\n\t      return {output : fun(keys, values, rereduce)};\n\t    } catch (e) {\n\t      emitError(db, e);\n\t      return {error: e};\n\t    }\n\t  }\n\t\n\t  function sortByKeyThenValue(x, y) {\n\t    var keyCompare = pouchdbCollate.collate(x.key, y.key);\n\t    return keyCompare !== 0 ? keyCompare : pouchdbCollate.collate(x.value, y.value);\n\t  }\n\t\n\t  function sliceResults(results, limit, skip) {\n\t    skip = skip || 0;\n\t    if (typeof limit === 'number') {\n\t      return results.slice(skip, limit + skip);\n\t    } else if (skip > 0) {\n\t      return results.slice(skip);\n\t    }\n\t    return results;\n\t  }\n\t\n\t  function rowToDocId(row) {\n\t    var val = row.value;\n\t    // Users can explicitly specify a joined doc _id, or it\n\t    // defaults to the doc _id that emitted the key/value.\n\t    var docId = (val && typeof val === 'object' && val._id) || row.id;\n\t    return docId;\n\t  }\n\t\n\t  function readAttachmentsAsBlobOrBuffer(res) {\n\t    res.rows.forEach(function (row) {\n\t      var atts = row.doc && row.doc._attachments;\n\t      if (!atts) {\n\t        return;\n\t      }\n\t      Object.keys(atts).forEach(function (filename) {\n\t        var att = atts[filename];\n\t        atts[filename].data = pouchdbBinaryUtils.base64StringToBlobOrBuffer(att.data, att.content_type);\n\t      });\n\t    });\n\t  }\n\t\n\t  function postprocessAttachments(opts) {\n\t    return function (res) {\n\t      if (opts.include_docs && opts.attachments && opts.binary) {\n\t        readAttachmentsAsBlobOrBuffer(res);\n\t      }\n\t      return res;\n\t    };\n\t  }\n\t\n\t  function addHttpParam(paramName, opts, params, asJson) {\n\t    // add an http param from opts to params, optionally json-encoded\n\t    var val = opts[paramName];\n\t    if (typeof val !== 'undefined') {\n\t      if (asJson) {\n\t        val = encodeURIComponent(JSON.stringify(val));\n\t      }\n\t      params.push(paramName + '=' + val);\n\t    }\n\t  }\n\t\n\t  function coerceInteger(integerCandidate) {\n\t    if (typeof integerCandidate !== 'undefined') {\n\t      var asNumber = Number(integerCandidate);\n\t      // prevents e.g. '1foo' or '1.1' being coerced to 1\n\t      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n\t        return asNumber;\n\t      } else {\n\t        return integerCandidate;\n\t      }\n\t    }\n\t  }\n\t\n\t  function coerceOptions(opts) {\n\t    opts.group_level = coerceInteger(opts.group_level);\n\t    opts.limit = coerceInteger(opts.limit);\n\t    opts.skip = coerceInteger(opts.skip);\n\t    return opts;\n\t  }\n\t\n\t  function checkPositiveInteger(number) {\n\t    if (number) {\n\t      if (typeof number !== 'number') {\n\t        return  new pouchdbMapreduceUtils.QueryParseError('Invalid value for integer: \"' +\n\t          number + '\"');\n\t      }\n\t      if (number < 0) {\n\t        return new pouchdbMapreduceUtils.QueryParseError('Invalid value for positive integer: ' +\n\t          '\"' + number + '\"');\n\t      }\n\t    }\n\t  }\n\t\n\t  function checkQueryParseError(options, fun) {\n\t    var startkeyName = options.descending ? 'endkey' : 'startkey';\n\t    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\t\n\t    if (typeof options[startkeyName] !== 'undefined' &&\n\t      typeof options[endkeyName] !== 'undefined' &&\n\t      pouchdbCollate.collate(options[startkeyName], options[endkeyName]) > 0) {\n\t      throw new pouchdbMapreduceUtils.QueryParseError('No rows can match your key range, ' +\n\t        'reverse your start_key and end_key or set {descending : true}');\n\t    } else if (fun.reduce && options.reduce !== false) {\n\t      if (options.include_docs) {\n\t        throw new pouchdbMapreduceUtils.QueryParseError('{include_docs:true} is invalid for reduce');\n\t      } else if (options.keys && options.keys.length > 1 &&\n\t        !options.group && !options.group_level) {\n\t        throw new pouchdbMapreduceUtils.QueryParseError('Multi-key fetches for reduce views must use ' +\n\t          '{group: true}');\n\t      }\n\t    }\n\t    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n\t      var error = checkPositiveInteger(options[optionName]);\n\t      if (error) {\n\t        throw error;\n\t      }\n\t    });\n\t  }\n\t\n\t  function httpQuery(db, fun, opts) {\n\t    // List of parameters to add to the PUT request\n\t    var params = [];\n\t    var body;\n\t    var method = 'GET';\n\t\n\t    // If opts.reduce exists and is defined, then add it to the list\n\t    // of parameters.\n\t    // If reduce=false then the results are that of only the map function\n\t    // not the final result of map and reduce.\n\t    addHttpParam('reduce', opts, params);\n\t    addHttpParam('include_docs', opts, params);\n\t    addHttpParam('attachments', opts, params);\n\t    addHttpParam('limit', opts, params);\n\t    addHttpParam('descending', opts, params);\n\t    addHttpParam('group', opts, params);\n\t    addHttpParam('group_level', opts, params);\n\t    addHttpParam('skip', opts, params);\n\t    addHttpParam('stale', opts, params);\n\t    addHttpParam('conflicts', opts, params);\n\t    addHttpParam('startkey', opts, params, true);\n\t    addHttpParam('start_key', opts, params, true);\n\t    addHttpParam('endkey', opts, params, true);\n\t    addHttpParam('end_key', opts, params, true);\n\t    addHttpParam('inclusive_end', opts, params);\n\t    addHttpParam('key', opts, params, true);\n\t    addHttpParam('update_seq', opts, params);\n\t\n\t    // Format the list of parameters into a valid URI query string\n\t    params = params.join('&');\n\t    params = params === '' ? '' : '?' + params;\n\t\n\t    // If keys are supplied, issue a POST to circumvent GET query string limits\n\t    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n\t    if (typeof opts.keys !== 'undefined') {\n\t      var MAX_URL_LENGTH = 2000;\n\t      // according to http://stackoverflow.com/a/417184/680742,\n\t      // the de facto URL length limit is 2000 characters\n\t\n\t      var keysAsString =\n\t        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n\t      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n\t        // If the keys are short enough, do a GET. we do this to work around\n\t        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n\t        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n\t      } else {\n\t        method = 'POST';\n\t        if (typeof fun === 'string') {\n\t          body = {keys: opts.keys};\n\t        } else { // fun is {map : mapfun}, so append to this\n\t          fun.keys = opts.keys;\n\t        }\n\t      }\n\t    }\n\t\n\t    // We are referencing a query defined in the design doc\n\t    if (typeof fun === 'string') {\n\t      var parts = parseViewName(fun);\n\t      return db.request({\n\t        method: method,\n\t        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n\t        body: body\n\t      }).then(\n\t        /* istanbul ignore next */\n\t        function (result) {\n\t          // fail the entire request if the result contains an error\n\t          result.rows.forEach(function (row) {\n\t            if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n\t              throw new Error(row.reason);\n\t            }\n\t          });\n\t\n\t          return result;\n\t      })\n\t      .then(postprocessAttachments(opts));\n\t    }\n\t\n\t    // We are using a temporary view, terrible for performance, good for testing\n\t    body = body || {};\n\t    Object.keys(fun).forEach(function (key) {\n\t      if (Array.isArray(fun[key])) {\n\t        body[key] = fun[key];\n\t      } else {\n\t        body[key] = fun[key].toString();\n\t      }\n\t    });\n\t    return db.request({\n\t      method: 'POST',\n\t      url: '_temp_view' + params,\n\t      body: body\n\t    }).then(postprocessAttachments(opts));\n\t  }\n\t\n\t  // custom adapters can define their own api._query\n\t  // and override the default behavior\n\t  /* istanbul ignore next */\n\t  function customQuery(db, fun, opts) {\n\t    return new Promise(function (resolve, reject) {\n\t      db._query(fun, opts, function (err, res) {\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  // custom adapters can define their own api._viewCleanup\n\t  // and override the default behavior\n\t  /* istanbul ignore next */\n\t  function customViewCleanup(db) {\n\t    return new Promise(function (resolve, reject) {\n\t      db._viewCleanup(function (err, res) {\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  function defaultsTo(value) {\n\t    return function (reason) {\n\t      /* istanbul ignore else */\n\t      if (reason.status === 404) {\n\t        return value;\n\t      } else {\n\t        throw reason;\n\t      }\n\t    };\n\t  }\n\t\n\t  // returns a promise for a list of docs to update, based on the input docId.\n\t  // the order doesn't matter, because post-3.2.0, bulkDocs\n\t  // is an atomic operation in all three adapters.\n\t  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n\t    var metaDocId = '_local/doc_' + docId;\n\t    var defaultMetaDoc = {_id: metaDocId, keys: []};\n\t    var docData = docIdsToChangesAndEmits.get(docId);\n\t    var indexableKeysToKeyValues = docData[0];\n\t    var changes = docData[1];\n\t\n\t    function getMetaDoc() {\n\t      if (isGenOne(changes)) {\n\t        // generation 1, so we can safely assume initial state\n\t        // for performance reasons (avoids unnecessary GETs)\n\t        return Promise.resolve(defaultMetaDoc);\n\t      }\n\t      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n\t    }\n\t\n\t    function getKeyValueDocs(metaDoc) {\n\t      if (!metaDoc.keys.length) {\n\t        // no keys, no need for a lookup\n\t        return Promise.resolve({rows: []});\n\t      }\n\t      return view.db.allDocs({\n\t        keys: metaDoc.keys,\n\t        include_docs: true\n\t      });\n\t    }\n\t\n\t    function processKeyValueDocs(metaDoc, kvDocsRes) {\n\t      var kvDocs = [];\n\t      var oldKeys = new pouchdbCollections.Set();\n\t\n\t      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n\t        var row = kvDocsRes.rows[i];\n\t        var doc = row.doc;\n\t        if (!doc) { // deleted\n\t          continue;\n\t        }\n\t        kvDocs.push(doc);\n\t        oldKeys.add(doc._id);\n\t        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n\t        if (!doc._deleted) {\n\t          var keyValue = indexableKeysToKeyValues.get(doc._id);\n\t          if ('value' in keyValue) {\n\t            doc.value = keyValue.value;\n\t          }\n\t        }\n\t      }\n\t      var newKeys = pouchdbMapreduceUtils.mapToKeysArray(indexableKeysToKeyValues);\n\t      newKeys.forEach(function (key) {\n\t        if (!oldKeys.has(key)) {\n\t          // new doc\n\t          var kvDoc = {\n\t            _id: key\n\t          };\n\t          var keyValue = indexableKeysToKeyValues.get(key);\n\t          if ('value' in keyValue) {\n\t            kvDoc.value = keyValue.value;\n\t          }\n\t          kvDocs.push(kvDoc);\n\t        }\n\t      });\n\t      metaDoc.keys = pouchdbMapreduceUtils.uniq(newKeys.concat(metaDoc.keys));\n\t      kvDocs.push(metaDoc);\n\t\n\t      return kvDocs;\n\t    }\n\t\n\t    return getMetaDoc().then(function (metaDoc) {\n\t      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n\t        return processKeyValueDocs(metaDoc, kvDocsRes);\n\t      });\n\t    });\n\t  }\n\t\n\t  // updates all emitted key/value docs and metaDocs in the mrview database\n\t  // for the given batch of documents from the source database\n\t  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n\t    var seqDocId = '_local/lastSeq';\n\t    return view.db.get(seqDocId)\n\t      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n\t      .then(function (lastSeqDoc) {\n\t        var docIds = pouchdbMapreduceUtils.mapToKeysArray(docIdsToChangesAndEmits);\n\t        return Promise.all(docIds.map(function (docId) {\n\t          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n\t        })).then(function (listOfDocsToPersist) {\n\t          var docsToPersist = pouchdbUtils.flatten(listOfDocsToPersist);\n\t          lastSeqDoc.seq = seq;\n\t          docsToPersist.push(lastSeqDoc);\n\t          // write all docs in a single operation, update the seq once\n\t          return view.db.bulkDocs({docs : docsToPersist});\n\t        });\n\t      });\n\t  }\n\t\n\t  function getQueue(view) {\n\t    var viewName = typeof view === 'string' ? view : view.name;\n\t    var queue = persistentQueues[viewName];\n\t    if (!queue) {\n\t      queue = persistentQueues[viewName] = new TaskQueue();\n\t    }\n\t    return queue;\n\t  }\n\t\n\t  function updateView(view) {\n\t    return pouchdbMapreduceUtils.sequentialize(getQueue(view), function () {\n\t      return updateViewInQueue(view);\n\t    })();\n\t  }\n\t\n\t  function updateViewInQueue(view) {\n\t    // bind the emit function once\n\t    var mapResults;\n\t    var doc;\n\t\n\t    function emit(key, value) {\n\t      var output = {id: doc._id, key: pouchdbCollate.normalizeKey(key)};\n\t      // Don't explicitly store the value unless it's defined and non-null.\n\t      // This saves on storage space, because often people don't use it.\n\t      if (typeof value !== 'undefined' && value !== null) {\n\t        output.value = pouchdbCollate.normalizeKey(value);\n\t      }\n\t      mapResults.push(output);\n\t    }\n\t\n\t    var mapFun = mapper(view.mapFun, emit);\n\t\n\t    var currentSeq = view.seq || 0;\n\t\n\t    function processChange(docIdsToChangesAndEmits, seq) {\n\t      return function () {\n\t        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n\t      };\n\t    }\n\t\n\t    var queue = new TaskQueue();\n\t\n\t    function processNextBatch() {\n\t      return view.sourceDB.changes({\n\t        conflicts: true,\n\t        include_docs: true,\n\t        style: 'all_docs',\n\t        since: currentSeq,\n\t        limit: CHANGES_BATCH_SIZE\n\t      }).then(processBatch);\n\t    }\n\t\n\t    function processBatch(response) {\n\t      var results = response.results;\n\t      if (!results.length) {\n\t        return;\n\t      }\n\t      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n\t      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\t      if (results.length < CHANGES_BATCH_SIZE) {\n\t        return;\n\t      }\n\t      return processNextBatch();\n\t    }\n\t\n\t    function createDocIdsToChangesAndEmits(results) {\n\t      var docIdsToChangesAndEmits = new pouchdbCollections.Map();\n\t      for (var i = 0, len = results.length; i < len; i++) {\n\t        var change = results[i];\n\t        if (change.doc._id[0] !== '_') {\n\t          mapResults = [];\n\t          doc = change.doc;\n\t\n\t          if (!doc._deleted) {\n\t            tryMap(view.sourceDB, mapFun, doc);\n\t          }\n\t          mapResults.sort(sortByKeyThenValue);\n\t\n\t          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n\t          docIdsToChangesAndEmits.set(change.doc._id, [\n\t            indexableKeysToKeyValues,\n\t            change.changes\n\t          ]);\n\t        }\n\t        currentSeq = change.seq;\n\t      }\n\t      return docIdsToChangesAndEmits;\n\t    }\n\t\n\t    function createIndexableKeysToKeyValues(mapResults) {\n\t      var indexableKeysToKeyValues = new pouchdbCollections.Map();\n\t      var lastKey;\n\t      for (var i = 0, len = mapResults.length; i < len; i++) {\n\t        var emittedKeyValue = mapResults[i];\n\t        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n\t        if (i > 0 && pouchdbCollate.collate(emittedKeyValue.key, lastKey) === 0) {\n\t          complexKey.push(i); // dup key+id, so make it unique\n\t        }\n\t        indexableKeysToKeyValues.set(pouchdbCollate.toIndexableString(complexKey), emittedKeyValue);\n\t        lastKey = emittedKeyValue.key;\n\t      }\n\t      return indexableKeysToKeyValues;\n\t    }\n\t\n\t    return processNextBatch().then(function () {\n\t      return queue.finish();\n\t    }).then(function () {\n\t      view.seq = currentSeq;\n\t    });\n\t  }\n\t\n\t  function reduceView(view, results, options) {\n\t    if (options.group_level === 0) {\n\t      delete options.group_level;\n\t    }\n\t\n\t    var shouldGroup = options.group || options.group_level;\n\t\n\t    var reduceFun = reducer(view.reduceFun);\n\t\n\t    var groups = [];\n\t    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n\t      options.group_level;\n\t    results.forEach(function (e) {\n\t      var last = groups[groups.length - 1];\n\t      var groupKey = shouldGroup ? e.key : null;\n\t\n\t      // only set group_level for array keys\n\t      if (shouldGroup && Array.isArray(groupKey)) {\n\t        groupKey = groupKey.slice(0, lvl);\n\t      }\n\t\n\t      if (last && pouchdbCollate.collate(last.groupKey, groupKey) === 0) {\n\t        last.keys.push([e.key, e.id]);\n\t        last.values.push(e.value);\n\t        return;\n\t      }\n\t      groups.push({\n\t        keys: [[e.key, e.id]],\n\t        values: [e.value],\n\t        groupKey: groupKey\n\t      });\n\t    });\n\t    results = [];\n\t    for (var i = 0, len = groups.length; i < len; i++) {\n\t      var e = groups[i];\n\t      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n\t      if (reduceTry.error && reduceTry.error instanceof pouchdbMapreduceUtils.BuiltInError) {\n\t        // CouchDB returns an error if a built-in errors out\n\t        throw reduceTry.error;\n\t      }\n\t      results.push({\n\t        // CouchDB just sets the value to null if a non-built-in errors out\n\t        value: reduceTry.error ? null : reduceTry.output,\n\t        key: e.groupKey\n\t      });\n\t    }\n\t    // no total_rows/offset when reducing\n\t    return {rows: sliceResults(results, options.limit, options.skip)};\n\t  }\n\t\n\t  function queryView(view, opts) {\n\t    return pouchdbMapreduceUtils.sequentialize(getQueue(view), function () {\n\t      return queryViewInQueue(view, opts);\n\t    })();\n\t  }\n\t\n\t  function queryViewInQueue(view, opts) {\n\t    var totalRows;\n\t    var shouldReduce = view.reduceFun && opts.reduce !== false;\n\t    var skip = opts.skip || 0;\n\t    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n\t      // equivalent query\n\t      opts.limit = 0;\n\t      delete opts.keys;\n\t    }\n\t\n\t    function fetchFromView(viewOpts) {\n\t      viewOpts.include_docs = true;\n\t      return view.db.allDocs(viewOpts).then(function (res) {\n\t        totalRows = res.total_rows;\n\t        return res.rows.map(function (result) {\n\t\n\t          // implicit migration - in older versions of PouchDB,\n\t          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n\t          // this is tested in a migration test\n\t          /* istanbul ignore next */\n\t          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n\t            result.doc.value !== null) {\n\t            var keys = Object.keys(result.doc.value).sort();\n\t            // this detection method is not perfect, but it's unlikely the user\n\t            // emitted a value which was an object with these 3 exact keys\n\t            var expectedKeys = ['id', 'key', 'value'];\n\t            if (!(keys < expectedKeys || keys > expectedKeys)) {\n\t              return result.doc.value;\n\t            }\n\t          }\n\t\n\t          var parsedKeyAndDocId = pouchdbCollate.parseIndexableString(result.doc._id);\n\t          return {\n\t            key: parsedKeyAndDocId[0],\n\t            id: parsedKeyAndDocId[1],\n\t            value: ('value' in result.doc ? result.doc.value : null)\n\t          };\n\t        });\n\t      });\n\t    }\n\t\n\t    function onMapResultsReady(rows) {\n\t      var finalResults;\n\t      if (shouldReduce) {\n\t        finalResults = reduceView(view, rows, opts);\n\t      } else {\n\t        finalResults = {\n\t          total_rows: totalRows,\n\t          offset: skip,\n\t          rows: rows\n\t        };\n\t      }\n\t      /* istanbul ignore if */\n\t      if (opts.update_seq) {\n\t        finalResults.update_seq = view.seq;\n\t      }\n\t      if (opts.include_docs) {\n\t        var docIds = pouchdbMapreduceUtils.uniq(rows.map(rowToDocId));\n\t\n\t        return view.sourceDB.allDocs({\n\t          keys: docIds,\n\t          include_docs: true,\n\t          conflicts: opts.conflicts,\n\t          attachments: opts.attachments,\n\t          binary: opts.binary\n\t        }).then(function (allDocsRes) {\n\t          var docIdsToDocs = new pouchdbCollections.Map();\n\t          allDocsRes.rows.forEach(function (row) {\n\t            docIdsToDocs.set(row.id, row.doc);\n\t          });\n\t          rows.forEach(function (row) {\n\t            var docId = rowToDocId(row);\n\t            var doc = docIdsToDocs.get(docId);\n\t            if (doc) {\n\t              row.doc = doc;\n\t            }\n\t          });\n\t          return finalResults;\n\t        });\n\t      } else {\n\t        return finalResults;\n\t      }\n\t    }\n\t\n\t    if (typeof opts.keys !== 'undefined') {\n\t      var keys = opts.keys;\n\t      var fetchPromises = keys.map(function (key) {\n\t        var viewOpts = {\n\t          startkey : pouchdbCollate.toIndexableString([key]),\n\t          endkey   : pouchdbCollate.toIndexableString([key, {}])\n\t        };\n\t        /* istanbul ignore if */\n\t        if (opts.update_seq) {\n\t          viewOpts.update_seq = true;\n\t        }\n\t        return fetchFromView(viewOpts);\n\t      });\n\t      return Promise.all(fetchPromises).then(pouchdbUtils.flatten).then(onMapResultsReady);\n\t    } else { // normal query, no 'keys'\n\t      var viewOpts = {\n\t        descending : opts.descending\n\t      };\n\t      /* istanbul ignore if */\n\t      if (opts.update_seq) {\n\t        viewOpts.update_seq = true;\n\t      }\n\t      var startkey;\n\t      var endkey;\n\t      if ('start_key' in opts) {\n\t        startkey = opts.start_key;\n\t      }\n\t      if ('startkey' in opts) {\n\t        startkey = opts.startkey;\n\t      }\n\t      if ('end_key' in opts) {\n\t        endkey = opts.end_key;\n\t      }\n\t      if ('endkey' in opts) {\n\t        endkey = opts.endkey;\n\t      }\n\t      if (typeof startkey !== 'undefined') {\n\t        viewOpts.startkey = opts.descending ?\n\t          pouchdbCollate.toIndexableString([startkey, {}]) :\n\t          pouchdbCollate.toIndexableString([startkey]);\n\t      }\n\t      if (typeof endkey !== 'undefined') {\n\t        var inclusiveEnd = opts.inclusive_end !== false;\n\t        if (opts.descending) {\n\t          inclusiveEnd = !inclusiveEnd;\n\t        }\n\t\n\t        viewOpts.endkey = pouchdbCollate.toIndexableString(\n\t          inclusiveEnd ? [endkey, {}] : [endkey]);\n\t      }\n\t      if (typeof opts.key !== 'undefined') {\n\t        var keyStart = pouchdbCollate.toIndexableString([opts.key]);\n\t        var keyEnd = pouchdbCollate.toIndexableString([opts.key, {}]);\n\t        if (viewOpts.descending) {\n\t          viewOpts.endkey = keyStart;\n\t          viewOpts.startkey = keyEnd;\n\t        } else {\n\t          viewOpts.startkey = keyStart;\n\t          viewOpts.endkey = keyEnd;\n\t        }\n\t      }\n\t      if (!shouldReduce) {\n\t        if (typeof opts.limit === 'number') {\n\t          viewOpts.limit = opts.limit;\n\t        }\n\t        viewOpts.skip = skip;\n\t      }\n\t      return fetchFromView(viewOpts).then(onMapResultsReady);\n\t    }\n\t  }\n\t\n\t  function httpViewCleanup(db) {\n\t    return db.request({\n\t      method: 'POST',\n\t      url: '_view_cleanup'\n\t    });\n\t  }\n\t\n\t  function localViewCleanup(db) {\n\t    return db.get('_local/' + localDocName).then(function (metaDoc) {\n\t      var docsToViews = new pouchdbCollections.Map();\n\t      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n\t        var parts = parseViewName(fullViewName);\n\t        var designDocName = '_design/' + parts[0];\n\t        var viewName = parts[1];\n\t        var views = docsToViews.get(designDocName);\n\t        if (!views) {\n\t          views = new pouchdbCollections.Set();\n\t          docsToViews.set(designDocName, views);\n\t        }\n\t        views.add(viewName);\n\t      });\n\t      var opts = {\n\t        keys : pouchdbMapreduceUtils.mapToKeysArray(docsToViews),\n\t        include_docs : true\n\t      };\n\t      return db.allDocs(opts).then(function (res) {\n\t        var viewsToStatus = {};\n\t        res.rows.forEach(function (row) {\n\t          var ddocName = row.key.substring(8); // cuts off '_design/'\n\t          docsToViews.get(row.key).forEach(function (viewName) {\n\t            var fullViewName = ddocName + '/' + viewName;\n\t            /* istanbul ignore if */\n\t            if (!metaDoc.views[fullViewName]) {\n\t              // new format, without slashes, to support PouchDB 2.2.0\n\t              // migration test in pouchdb's browser.migration.js verifies this\n\t              fullViewName = viewName;\n\t            }\n\t            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n\t            // design doc deleted, or view function nonexistent\n\t            var statusIsGood = row.doc && row.doc.views &&\n\t              row.doc.views[viewName];\n\t            viewDBNames.forEach(function (viewDBName) {\n\t              viewsToStatus[viewDBName] =\n\t                viewsToStatus[viewDBName] || statusIsGood;\n\t            });\n\t          });\n\t        });\n\t        var dbsToDelete = Object.keys(viewsToStatus).filter(\n\t          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n\t        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n\t          return pouchdbMapreduceUtils.sequentialize(getQueue(viewDBName), function () {\n\t            return new db.constructor(viewDBName, db.__opts).destroy();\n\t          })();\n\t        });\n\t        return Promise.all(destroyPromises).then(function () {\n\t          return {ok: true};\n\t        });\n\t      });\n\t    }, defaultsTo({ok: true}));\n\t  }\n\t\n\t  function queryPromised(db, fun, opts) {\n\t    /* istanbul ignore next */\n\t    if (typeof db._query === 'function') {\n\t      return customQuery(db, fun, opts);\n\t    }\n\t    if (pouchdbUtils.isRemote(db)) {\n\t      return httpQuery(db, fun, opts);\n\t    }\n\t    \n\t    if (typeof fun !== 'string') {\n\t      // temp_view\n\t      checkQueryParseError(opts, fun);\n\t\n\t      tempViewQueue.add(function () {\n\t        var createViewPromise = createView(\n\t          /* sourceDB */ db,\n\t          /* viewName */ 'temp_view/temp_view',\n\t          /* mapFun */ fun.map,\n\t          /* reduceFun */ fun.reduce,\n\t          /* temporary */ true,\n\t          /* localDocName */ localDocName);\n\t        return createViewPromise.then(function (view) {\n\t          return pouchdbMapreduceUtils.fin(updateView(view).then(function () {\n\t            return queryView(view, opts);\n\t          }), function () {\n\t            return view.db.destroy();\n\t          });\n\t        });\n\t      });\n\t      return tempViewQueue.finish();\n\t    } else {\n\t      // persistent view\n\t      var fullViewName = fun;\n\t      var parts = parseViewName(fullViewName);\n\t      var designDocName = parts[0];\n\t      var viewName = parts[1];\n\t      return db.get('_design/' + designDocName).then(function (doc) {\n\t        var fun = doc.views && doc.views[viewName];\n\t\n\t        if (!fun) {\n\t          // basic validator; it's assumed that every subclass would want this\n\t          throw new pouchdbMapreduceUtils.NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n\t            viewName);\n\t        }\n\t\n\t        ddocValidator(doc, viewName);\n\t        checkQueryParseError(opts, fun);\n\t\n\t        var createViewPromise = createView(\n\t          /* sourceDB */ db,\n\t          /* viewName */ fullViewName,\n\t          /* mapFun */ fun.map,\n\t          /* reduceFun */ fun.reduce,\n\t          /* temporary */ false,\n\t          /* localDocName */ localDocName);\n\t        return createViewPromise.then(function (view) {\n\t          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n\t            if (opts.stale === 'update_after') {\n\t              pouchdbUtils.nextTick(function () {\n\t                updateView(view);\n\t              });\n\t            }\n\t            return queryView(view, opts);\n\t          } else { // stale not ok\n\t            return updateView(view).then(function () {\n\t              return queryView(view, opts);\n\t            });\n\t          }\n\t        });\n\t      });\n\t    }\n\t  }\n\t\n\t  function abstractQuery(fun, opts, callback) {\n\t    var db = this;\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = opts ? coerceOptions(opts) : {};\n\t\n\t    if (typeof fun === 'function') {\n\t      fun = {map : fun};\n\t    }\n\t\n\t    var promise = Promise.resolve().then(function () {\n\t      return queryPromised(db, fun, opts);\n\t    });\n\t    pouchdbMapreduceUtils.promisedCallback(promise, callback);\n\t    return promise;\n\t  }\n\t\n\t  var abstractViewCleanup = pouchdbMapreduceUtils.callbackify(function () {\n\t    var db = this;\n\t    /* istanbul ignore next */\n\t    if (typeof db._viewCleanup === 'function') {\n\t      return customViewCleanup(db);\n\t    }\n\t    if (pouchdbUtils.isRemote(db)) {\n\t      return httpViewCleanup(db);\n\t    }\n\t    return localViewCleanup(db);\n\t  });\n\t\n\t  return {\n\t    query: abstractQuery,\n\t    viewCleanup: abstractViewCleanup\n\t  };\n\t}\n\t\n\tmodule.exports = createAbstractMapReduce;\n\n\n/***/ },\n/* 78 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar pouchdbUtils = __webpack_require__(6);\n\tvar Promise = _interopDefault(__webpack_require__(17));\n\tvar pouchdbSelectorCore = __webpack_require__(80);\n\tvar abstractMapReduce = _interopDefault(__webpack_require__(77));\n\tvar pouchdbCollate = __webpack_require__(15);\n\tvar pouchdbMd5 = __webpack_require__(31);\n\t\n\t// we restucture the supplied JSON considerably, because the official\n\t// Mango API is very particular about a lot of this stuff, but we like\n\t// to be liberal with what we accept in order to prevent mental\n\t// breakdowns in our users\n\tfunction massageCreateIndexRequest(requestDef) {\n\t  requestDef = pouchdbUtils.clone(requestDef);\n\t\n\t  if (!requestDef.index) {\n\t    requestDef.index = {};\n\t  }\n\t\n\t  ['type', 'name', 'ddoc'].forEach(function (key) {\n\t    if (requestDef.index[key]) {\n\t      requestDef[key] = requestDef.index[key];\n\t      delete requestDef.index[key];\n\t    }\n\t  });\n\t\n\t  if (requestDef.fields) {\n\t    requestDef.index.fields = requestDef.fields;\n\t    delete requestDef.fields;\n\t  }\n\t\n\t  if (!requestDef.type) {\n\t    requestDef.type = 'json';\n\t  }\n\t  return requestDef;\n\t}\n\t\n\tfunction createIndex(db, requestDef, callback) {\n\t  requestDef = massageCreateIndexRequest(requestDef);\n\t\n\t  db.request({\n\t    method: 'POST',\n\t    url: '_index',\n\t    body: requestDef\n\t  }, callback);\n\t}\n\t\n\tfunction find(db, requestDef, callback) {\n\t  db.request({\n\t    method: 'POST',\n\t    url: '_find',\n\t    body: requestDef\n\t  }, callback);\n\t}\n\t\n\tfunction explain(db, requestDef, callback) {\n\t  db.request({\n\t    method: 'POST',\n\t    url: '_explain',\n\t    body: requestDef\n\t  }, callback);\n\t}\n\t\n\tfunction getIndexes(db, callback) {\n\t  db.request({\n\t    method: 'GET',\n\t    url: '_index'\n\t  }, callback);\n\t}\n\t\n\tfunction deleteIndex(db, indexDef, callback) {\n\t\n\t\n\t  var ddoc = indexDef.ddoc;\n\t  var type = indexDef.type || 'json';\n\t  var name = indexDef.name;\n\t\n\t  if (!ddoc) {\n\t    return callback(new Error('you must provide an index\\'s ddoc'));\n\t  }\n\t\n\t  if (!name) {\n\t    return callback(new Error('you must provide an index\\'s name'));\n\t  }\n\t\n\t  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\t\n\t  db.request({\n\t    method: 'DELETE',\n\t    url: url\n\t  }, callback);\n\t}\n\t\n\tfunction getArguments(fun) {\n\t  return function () {\n\t    var len = arguments.length;\n\t    var args = new Array(len);\n\t    var i = -1;\n\t    while (++i < len) {\n\t      args[i] = arguments[i];\n\t    }\n\t    return fun.call(this, args);\n\t  };\n\t}\n\tfunction callbackify(fun) {\n\t  return getArguments(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    promisedCallback(promise, cb);\n\t    return promise;\n\t  });\n\t}\n\t\n\tfunction promisedCallback(promise, callback) {\n\t  promise.then(function (res) {\n\t    process.nextTick(function () {\n\t      callback(null, res);\n\t    });\n\t  }, function (reason) {\n\t    process.nextTick(function () {\n\t      callback(reason);\n\t    });\n\t  });\n\t  return promise;\n\t}\n\t\n\tvar flatten = getArguments(function (args) {\n\t  var res = [];\n\t  for (var i = 0, len = args.length; i < len; i++) {\n\t    var subArr = args[i];\n\t    if (Array.isArray(subArr)) {\n\t      res = res.concat(flatten.apply(null, subArr));\n\t    } else {\n\t      res.push(subArr);\n\t    }\n\t  }\n\t  return res;\n\t});\n\t\n\tfunction mergeObjects(arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    res = pouchdbUtils.assign(res, arr[i]);\n\t  }\n\t  return res;\n\t}\n\t\n\t// Selects a list of fields defined in dot notation from one doc\n\t// and copies them to a new doc. Like underscore _.pick but supports nesting.\n\tfunction pick(obj, arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var parsedField = pouchdbSelectorCore.parseField(arr[i]);\n\t    var value = pouchdbSelectorCore.getFieldFromDoc(obj, parsedField);\n\t    if (typeof value !== 'undefined') {\n\t      pouchdbSelectorCore.setFieldInDoc(res, parsedField, value);\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\n\tfunction oneArrayIsSubArrayOfOther(left, right) {\n\t\n\t  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n\t    if (left[i] !== right[i]) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\t// e.g.['a', 'b', 'c'], ['a', 'b'] is false\n\tfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n\t\n\t  if (left.length > right.length) {\n\t    return false;\n\t  }\n\t\n\t  return oneArrayIsSubArrayOfOther(left, right);\n\t}\n\t\n\t// same as above, but treat the left array as an unordered set\n\t// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\n\tfunction oneSetIsSubArrayOfOther(left, right) {\n\t  left = left.slice();\n\t  for (var i = 0, len = right.length; i < len; i++) {\n\t    var field = right[i];\n\t    if (!left.length) {\n\t      break;\n\t    }\n\t    var leftIdx = left.indexOf(field);\n\t    if (leftIdx === -1) {\n\t      return false;\n\t    } else {\n\t      left.splice(leftIdx, 1);\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction arrayToObject(arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    res[arr[i]] = true;\n\t  }\n\t  return res;\n\t}\n\t\n\tfunction max(arr, fun) {\n\t  var max = null;\n\t  var maxScore = -1;\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var element = arr[i];\n\t    var score = fun(element);\n\t    if (score > maxScore) {\n\t      maxScore = score;\n\t      max = element;\n\t    }\n\t  }\n\t  return max;\n\t}\n\t\n\tfunction arrayEquals(arr1, arr2) {\n\t  if (arr1.length !== arr2.length) {\n\t    return false;\n\t  }\n\t  for (var i = 0, len = arr1.length; i < len; i++) {\n\t    if (arr1[i] !== arr2[i]) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction uniq(arr) {\n\t  var obj = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    obj['$' + arr[i]] = true;\n\t  }\n\t  return Object.keys(obj).map(function (key) {\n\t    return key.substring(1);\n\t  });\n\t}\n\t\n\t//\n\t// One thing about these mappers:\n\t//\n\t// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n\t// what you want to do in this case is optimize for the smallest possible\n\t// function, since that's the thing that gets run over and over again.\n\t//\n\t// This code would be a lot simpler if all the if/elses were inside\n\t// the function, but it would also be a lot less performant.\n\t//\n\t\n\t\n\tfunction createDeepMultiMapper(fields, emit) {\n\t  return function (doc) {\n\t    var toEmit = [];\n\t    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n\t      var parsedField = pouchdbSelectorCore.parseField(fields[i]);\n\t      var value = doc;\n\t      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n\t        var key = parsedField[j];\n\t        value = value[key];\n\t        if (typeof value === 'undefined') {\n\t          return; // don't emit\n\t        }\n\t      }\n\t      toEmit.push(value);\n\t    }\n\t    emit(toEmit);\n\t  };\n\t}\n\t\n\tfunction createDeepSingleMapper(field, emit) {\n\t  var parsedField = pouchdbSelectorCore.parseField(field);\n\t  return function (doc) {\n\t    var value = doc;\n\t    for (var i = 0, len = parsedField.length; i < len; i++) {\n\t      var key = parsedField[i];\n\t      value = value[key];\n\t      if (typeof value === 'undefined') {\n\t        return; // do nothing\n\t      }\n\t    }\n\t    emit(value);\n\t  };\n\t}\n\t\n\tfunction createShallowSingleMapper(field, emit) {\n\t  return function (doc) {\n\t    emit(doc[field]);\n\t  };\n\t}\n\t\n\tfunction createShallowMultiMapper(fields, emit) {\n\t  return function (doc) {\n\t    var toEmit = [];\n\t    for (var i = 0, len = fields.length; i < len; i++) {\n\t      toEmit.push(doc[fields[i]]);\n\t    }\n\t    emit(toEmit);\n\t  };\n\t}\n\t\n\tfunction checkShallow(fields) {\n\t  for (var i = 0, len = fields.length; i < len; i++) {\n\t    var field = fields[i];\n\t    if (field.indexOf('.') !== -1) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction createMapper(fields, emit) {\n\t  var isShallow = checkShallow(fields);\n\t  var isSingle = fields.length === 1;\n\t\n\t  // notice we try to optimize for the most common case,\n\t  // i.e. single shallow indexes\n\t  if (isShallow) {\n\t    if (isSingle) {\n\t      return createShallowSingleMapper(fields[0], emit);\n\t    } else { // multi\n\t      return createShallowMultiMapper(fields, emit);\n\t    }\n\t  } else { // deep\n\t    if (isSingle) {\n\t      return createDeepSingleMapper(fields[0], emit);\n\t    } else { // multi\n\t      return createDeepMultiMapper(fields, emit);\n\t    }\n\t  }\n\t}\n\t\n\tfunction mapper(mapFunDef, emit) {\n\t  // mapFunDef is a list of fields\n\t\n\t  var fields = Object.keys(mapFunDef.fields);\n\t\n\t  return createMapper(fields, emit);\n\t}\n\t\n\t/* istanbul ignore next */\n\tfunction reducer(/*reduceFunDef*/) {\n\t  throw new Error('reduce not supported');\n\t}\n\t\n\tfunction ddocValidator(ddoc, viewName) {\n\t  var view = ddoc.views[viewName];\n\t  // This doesn't actually need to be here apparently, but\n\t  // I feel safer keeping it.\n\t  /* istanbul ignore if */\n\t  if (!view.map || !view.map.fields) {\n\t    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n\t      ' doesn\\'t have map.fields defined. ' +\n\t      'maybe it wasn\\'t created by this plugin?');\n\t  }\n\t}\n\t\n\tvar abstractMapper = abstractMapReduce(\n\t  /* localDocName */ 'indexes',\n\t  mapper,\n\t  reducer,\n\t  ddocValidator\n\t);\n\t\n\t// normalize the \"sort\" value\n\tfunction massageSort(sort) {\n\t  if (!Array.isArray(sort)) {\n\t    throw new Error('invalid sort json - should be an array');\n\t  }\n\t  return sort.map(function (sorting) {\n\t    if (typeof sorting === 'string') {\n\t      var obj = {};\n\t      obj[sorting] = 'asc';\n\t      return obj;\n\t    } else {\n\t      return sorting;\n\t    }\n\t  });\n\t}\n\t\n\tfunction massageUseIndex(useIndex) {\n\t  var cleanedUseIndex = [];\n\t  if (typeof useIndex === 'string') {\n\t    cleanedUseIndex.push(useIndex);\n\t  } else {\n\t    cleanedUseIndex = useIndex;\n\t  }\n\t\n\t  return cleanedUseIndex.map(function (name) {\n\t    return name.replace('_design/', '');\n\t  });\n\t}\n\t\n\tfunction massageIndexDef(indexDef) {\n\t  indexDef.fields = indexDef.fields.map(function (field) {\n\t    if (typeof field === 'string') {\n\t      var obj = {};\n\t      obj[field] = 'asc';\n\t      return obj;\n\t    }\n\t    return field;\n\t  });\n\t  return indexDef;\n\t}\n\t\n\tfunction getKeyFromDoc(doc, index) {\n\t  var res = [];\n\t  for (var i = 0; i < index.def.fields.length; i++) {\n\t    var field = pouchdbSelectorCore.getKey(index.def.fields[i]);\n\t    res.push(doc[field]);\n\t  }\n\t  return res;\n\t}\n\t\n\t// have to do this manually because REASONS. I don't know why\n\t// CouchDB didn't implement inclusive_start\n\tfunction filterInclusiveStart(rows, targetValue, index) {\n\t  var indexFields = index.def.fields;\n\t  for (var i = 0, len = rows.length; i < len; i++) {\n\t    var row = rows[i];\n\t\n\t    // shave off any docs at the beginning that are <= the\n\t    // target value\n\t\n\t    var docKey = getKeyFromDoc(row.doc, index);\n\t    if (indexFields.length === 1) {\n\t      docKey = docKey[0]; // only one field, not multi-field\n\t    } else { // more than one field in index\n\t      // in the case where e.g. the user is searching {$gt: {a: 1}}\n\t      // but the index is [a, b], then we need to shorten the doc key\n\t      while (docKey.length > targetValue.length) {\n\t        docKey.pop();\n\t      }\n\t    }\n\t    //ABS as we just looking for values that don't match\n\t    if (Math.abs(pouchdbCollate.collate(docKey, targetValue)) > 0) {\n\t      // no need to filter any further; we're past the key\n\t      break;\n\t    }\n\t  }\n\t  return i > 0 ? rows.slice(i) : rows;\n\t}\n\t\n\tfunction reverseOptions(opts) {\n\t  var newOpts = pouchdbUtils.clone(opts);\n\t  delete newOpts.startkey;\n\t  delete newOpts.endkey;\n\t  delete newOpts.inclusive_start;\n\t  delete newOpts.inclusive_end;\n\t\n\t  if ('endkey' in opts) {\n\t    newOpts.startkey = opts.endkey;\n\t  }\n\t  if ('startkey' in opts) {\n\t    newOpts.endkey = opts.startkey;\n\t  }\n\t  if ('inclusive_start' in opts) {\n\t    newOpts.inclusive_end = opts.inclusive_start;\n\t  }\n\t  if ('inclusive_end' in opts) {\n\t    newOpts.inclusive_start = opts.inclusive_end;\n\t  }\n\t  return newOpts;\n\t}\n\t\n\tfunction validateIndex(index) {\n\t  var ascFields = index.fields.filter(function (field) {\n\t    return pouchdbSelectorCore.getValue(field) === 'asc';\n\t  });\n\t  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n\t    throw new Error('unsupported mixed sorting');\n\t  }\n\t}\n\t\n\tfunction validateSort(requestDef, index) {\n\t  if (index.defaultUsed && requestDef.sort) {\n\t    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n\t      return Object.keys(sortItem)[0] !== '_id';\n\t    }).map(function (sortItem) {\n\t      return Object.keys(sortItem)[0];\n\t    });\n\t\n\t    if (noneIdSorts.length > 0) {\n\t      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n\t      '\" when using the default index');\n\t    }\n\t  }\n\t\n\t  if (index.defaultUsed) {\n\t    return;\n\t  }\n\t}\n\t\n\tfunction validateFindRequest(requestDef) {\n\t  if (typeof requestDef.selector !== 'object') {\n\t    throw new Error('you must provide a selector when you find()');\n\t  }\n\t\n\t  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n\t  for (var i = 0; i < selectors.length; i++) {\n\t    var selector = selectors[i];\n\t    var keys = Object.keys(selector);\n\t    if (keys.length === 0) {\n\t      throw new Error('invalid empty selector');\n\t    }\n\t    //var selection = selector[keys[0]];\n\t    /*if (Object.keys(selection).length !== 1) {\n\t      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n\t        ' - it must have exactly one key/value');\n\t    }\n\t  }*/\n\t}\n\t\n\t// determine the maximum number of fields\n\t// we're going to need to query, e.g. if the user\n\t// has selection ['a'] and sorting ['a', 'b'], then we\n\t// need to use the longer of the two: ['a', 'b']\n\tfunction getUserFields(selector, sort) {\n\t  var selectorFields = Object.keys(selector);\n\t  var sortFields = sort? sort.map(pouchdbSelectorCore.getKey) : [];\n\t  var userFields;\n\t  if (selectorFields.length >= sortFields.length) {\n\t    userFields = selectorFields;\n\t  } else {\n\t    userFields = sortFields;\n\t  }\n\t\n\t  if (sortFields.length === 0) {\n\t    return {\n\t      fields: userFields\n\t    };\n\t  }\n\t\n\t  // sort according to the user's preferred sorting\n\t  userFields = userFields.sort(function (left, right) {\n\t    var leftIdx = sortFields.indexOf(left);\n\t    if (leftIdx === -1) {\n\t      leftIdx = Number.MAX_VALUE;\n\t    }\n\t    var rightIdx = sortFields.indexOf(right);\n\t    if (rightIdx === -1) {\n\t      rightIdx = Number.MAX_VALUE;\n\t    }\n\t    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n\t  });\n\t\n\t  return {\n\t    fields: userFields,\n\t    sortOrder: sort.map(pouchdbSelectorCore.getKey)\n\t  };\n\t}\n\t\n\tfunction createIndex$1(db, requestDef) {\n\t  requestDef = massageCreateIndexRequest(requestDef);\n\t  var originalIndexDef = pouchdbUtils.clone(requestDef.index);\n\t  requestDef.index = massageIndexDef(requestDef.index);\n\t\n\t  validateIndex(requestDef.index);\n\t\n\t  // calculating md5 is expensive - memoize and only\n\t  // run if required\n\t  var md5;\n\t  function getMd5() {\n\t    return md5 || (md5 = pouchdbMd5.stringMd5(JSON.stringify(requestDef)));\n\t  }\n\t\n\t  var viewName = requestDef.name || ('idx-' + getMd5());\n\t\n\t  var ddocName = requestDef.ddoc || ('idx-' + getMd5());\n\t  var ddocId = '_design/' + ddocName;\n\t\n\t  var hasInvalidLanguage = false;\n\t  var viewExists = false;\n\t\n\t  function updateDdoc(doc) {\n\t    if (doc._rev && doc.language !== 'query') {\n\t      hasInvalidLanguage = true;\n\t    }\n\t    doc.language = 'query';\n\t    doc.views = doc.views || {};\n\t\n\t    viewExists = !!doc.views[viewName];\n\t\n\t    if (viewExists) {\n\t      return false;\n\t    }\n\t\n\t    doc.views[viewName] = {\n\t      map: {\n\t        fields: mergeObjects(requestDef.index.fields)\n\t      },\n\t      reduce: '_count',\n\t      options: {\n\t        def: originalIndexDef\n\t      }\n\t    };\n\t\n\t    return doc;\n\t  }\n\t\n\t  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n\t\n\t  return pouchdbUtils.upsert(db, ddocId, updateDdoc).then(function () {\n\t    if (hasInvalidLanguage) {\n\t      throw new Error('invalid language for ddoc with id \"' +\n\t      ddocId +\n\t      '\" (should be \"query\")');\n\t    }\n\t  }).then(function () {\n\t    // kick off a build\n\t    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n\t    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n\t    var signature = ddocName + '/' + viewName;\n\t    return abstractMapper.query.call(db, signature, {\n\t      limit: 0,\n\t      reduce: false\n\t    }).then(function () {\n\t      return {\n\t        id: ddocId,\n\t        name: viewName,\n\t        result: viewExists ? 'exists' : 'created'\n\t      };\n\t    });\n\t  });\n\t}\n\t\n\tfunction getIndexes$1(db) {\n\t  // just search through all the design docs and filter in-memory.\n\t  // hopefully there aren't that many ddocs.\n\t  return db.allDocs({\n\t    startkey: '_design/',\n\t    endkey: '_design/\\uffff',\n\t    include_docs: true\n\t  }).then(function (allDocsRes) {\n\t    var res = {\n\t      indexes: [{\n\t        ddoc: null,\n\t        name: '_all_docs',\n\t        type: 'special',\n\t        def: {\n\t          fields: [{_id: 'asc'}]\n\t        }\n\t      }]\n\t    };\n\t\n\t    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n\t      return row.doc.language === 'query';\n\t    }).map(function (row) {\n\t      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\t\n\t      return viewNames.map(function (viewName) {\n\t        var view = row.doc.views[viewName];\n\t        return {\n\t          ddoc: row.id,\n\t          name: viewName,\n\t          type: 'json',\n\t          def: massageIndexDef(view.options.def)\n\t        };\n\t      });\n\t    }));\n\t\n\t    // these are sorted by view name for some reason\n\t    res.indexes.sort(function (left, right) {\n\t      return pouchdbSelectorCore.compare(left.name, right.name);\n\t    });\n\t    res.total_rows = res.indexes.length;\n\t    return res;\n\t  });\n\t}\n\t\n\t// couchdb lowest collation value\n\tvar COLLATE_LO = null;\n\t\n\t// couchdb highest collation value (TODO: well not really, but close enough amirite)\n\tvar COLLATE_HI = {\"\\uffff\": {}};\n\t\n\t// couchdb second-lowest collation value\n\t\n\tfunction checkFieldInIndex(index, field) {\n\t  var indexFields = index.def.fields.map(pouchdbSelectorCore.getKey);\n\t  for (var i = 0, len = indexFields.length; i < len; i++) {\n\t    var indexField = indexFields[i];\n\t    if (field === indexField) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n\t// but when you do e.g. $gt/$eq, the first part can be done\n\t// in the database, but the second part has to be done in-memory,\n\t// because $gt has forced us to lose precision.\n\t// so that's what this determines\n\tfunction userOperatorLosesPrecision(selector, field) {\n\t  var matcher = selector[field];\n\t  var userOperator = pouchdbSelectorCore.getKey(matcher);\n\t\n\t  return userOperator !== '$eq';\n\t}\n\t\n\t// sort the user fields by their position in the index,\n\t// if they're in the index\n\tfunction sortFieldsByIndex(userFields, index) {\n\t  var indexFields = index.def.fields.map(pouchdbSelectorCore.getKey);\n\t\n\t  return userFields.slice().sort(function (a, b) {\n\t    var aIdx = indexFields.indexOf(a);\n\t    var bIdx = indexFields.indexOf(b);\n\t    if (aIdx === -1) {\n\t      aIdx = Number.MAX_VALUE;\n\t    }\n\t    if (bIdx === -1) {\n\t      bIdx = Number.MAX_VALUE;\n\t    }\n\t    return pouchdbSelectorCore.compare(aIdx, bIdx);\n\t  });\n\t}\n\t\n\t// first pass to try to find fields that will need to be sorted in-memory\n\tfunction getBasicInMemoryFields(index, selector, userFields) {\n\t\n\t  userFields = sortFieldsByIndex(userFields, index);\n\t\n\t  // check if any of the user selectors lose precision\n\t  var needToFilterInMemory = false;\n\t  for (var i = 0, len = userFields.length; i < len; i++) {\n\t    var field = userFields[i];\n\t    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n\t      return userFields.slice(i);\n\t    }\n\t    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n\t      needToFilterInMemory = true;\n\t    }\n\t  }\n\t  return [];\n\t}\n\t\n\tfunction getInMemoryFieldsFromNe(selector) {\n\t  var fields = [];\n\t  Object.keys(selector).forEach(function (field) {\n\t    var matcher = selector[field];\n\t    Object.keys(matcher).forEach(function (operator) {\n\t      if (operator === '$ne') {\n\t        fields.push(field);\n\t      }\n\t    });\n\t  });\n\t  return fields;\n\t}\n\t\n\tfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n\t  var result = flatten(\n\t    // in-memory fields reported as necessary by the query planner\n\t    coreInMemoryFields,\n\t    // combine with another pass that checks for any we may have missed\n\t    getBasicInMemoryFields(index, selector, userFields),\n\t    // combine with another pass that checks for $ne's\n\t    getInMemoryFieldsFromNe(selector)\n\t  );\n\t\n\t  return sortFieldsByIndex(uniq(result), index);\n\t}\n\t\n\t// check that at least one field in the user's query is represented\n\t// in the index. order matters in the case of sorts\n\tfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n\t  if (sortOrder) {\n\t    // array has to be a strict subarray of index array. furthermore,\n\t    // the sortOrder fields need to all be represented in the index\n\t    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n\t    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\t\n\t    return sortMatches && selectorMatches;\n\t  }\n\t\n\t  // all of the user's specified fields still need to be\n\t  // on the left side of the index array, although the order\n\t  // doesn't matter\n\t  return oneSetIsSubArrayOfOther(fields, indexFields);\n\t}\n\t\n\tvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\n\tfunction isNonLogicalMatcher(matcher) {\n\t  return logicalMatchers.indexOf(matcher) === -1;\n\t}\n\t\n\t// check all the index fields for usages of '$ne'\n\t// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n\t// then we can neither use an index on ['foo'] nor an index on\n\t// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\n\tfunction checkFieldsLogicallySound(indexFields, selector) {\n\t  var firstField = indexFields[0];\n\t  var matcher = selector[firstField];\n\t\n\t  if (typeof matcher === 'undefined') {\n\t    /* istanbul ignore next */\n\t    return true;\n\t  }\n\t\n\t  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n\t    return !(isNonLogicalMatcher(matcherKey));\n\t  });\n\t\n\t  if (!hasLogicalOperator) {\n\t    return false;\n\t  }\n\t\n\t  var isInvalidNe = Object.keys(matcher).length === 1 &&\n\t    pouchdbSelectorCore.getKey(matcher) === '$ne';\n\t\n\t  return !isInvalidNe;\n\t}\n\t\n\tfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\t\n\t  var indexFields = index.def.fields.map(pouchdbSelectorCore.getKey);\n\t\n\t  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\t\n\t  if (!fieldsMatch) {\n\t    return false;\n\t  }\n\t\n\t  return checkFieldsLogicallySound(indexFields, selector);\n\t}\n\t\n\t//\n\t// the algorithm is very simple:\n\t// take all the fields the user supplies, and if those fields\n\t// are a strict subset of the fields in some index,\n\t// then use that index\n\t//\n\t//\n\tfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n\t\n\t  return indexes.reduce(function (res, index) {\n\t    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n\t    if (indexMatches) {\n\t      res.push(index);\n\t    }\n\t    return res;\n\t  }, []);\n\t}\n\t\n\t// find the best index, i.e. the one that matches the most fields\n\t// in the user's query\n\tfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n\t\n\t  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\t\n\t  if (matchingIndexes.length === 0) {\n\t    if (useIndex) {\n\t      throw {\n\t        error: \"no_usable_index\",\n\t        message: \"There is no index available for this selector.\"\n\t      };\n\t    }\n\t    //return `all_docs` as a default index;\n\t    //I'm assuming that _all_docs is always first\n\t    var defaultIndex = indexes[0];\n\t    defaultIndex.defaultUsed = true;\n\t    return defaultIndex;\n\t  }\n\t  if (matchingIndexes.length === 1 && !useIndex) {\n\t    return matchingIndexes[0];\n\t  }\n\t\n\t  var userFieldsMap = arrayToObject(userFields);\n\t\n\t  function scoreIndex(index) {\n\t    var indexFields = index.def.fields.map(pouchdbSelectorCore.getKey);\n\t    var score = 0;\n\t    for (var i = 0, len = indexFields.length; i < len; i++) {\n\t      var indexField = indexFields[i];\n\t      if (userFieldsMap[indexField]) {\n\t        score++;\n\t      }\n\t    }\n\t    return score;\n\t  }\n\t\n\t  if (useIndex) {\n\t    var useIndexDdoc = '_design/' + useIndex[0];\n\t    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n\t    var index = matchingIndexes.find(function (index) {\n\t      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n\t        return true;\n\t      }\n\t\n\t      if (index.ddoc === useIndexDdoc) {\n\t        /* istanbul ignore next */\n\t        return true;\n\t      }\n\t\n\t      return false;\n\t    });\n\t\n\t    if (!index) {\n\t      throw {\n\t        error: \"unknown_error\",\n\t        message: \"Could not find that index or could not use that index for the query\"\n\t      };\n\t    }\n\t    return index;\n\t  }\n\t\n\t  return max(matchingIndexes, scoreIndex);\n\t}\n\t\n\tfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n\t  switch (userOperator) {\n\t    case '$eq':\n\t      return {key: userValue};\n\t    case '$lte':\n\t      return {endkey: userValue};\n\t    case '$gte':\n\t      return {startkey: userValue};\n\t    case '$lt':\n\t      return {\n\t        endkey: userValue,\n\t        inclusive_end: false\n\t      };\n\t    case '$gt':\n\t      return {\n\t        startkey: userValue,\n\t        inclusive_start: false\n\t      };\n\t  }\n\t}\n\t\n\tfunction getSingleFieldCoreQueryPlan(selector, index) {\n\t  var field = pouchdbSelectorCore.getKey(index.def.fields[0]);\n\t  //ignoring this because the test to exercise the branch is skipped at the moment\n\t  /* istanbul ignore next */\n\t  var matcher = selector[field] || {};\n\t  var inMemoryFields = [];\n\t\n\t  var userOperators = Object.keys(matcher);\n\t\n\t  var combinedOpts;\n\t\n\t  userOperators.forEach(function (userOperator) {\n\t\n\t    if (isNonLogicalMatcher(userOperator)) {\n\t      inMemoryFields.push(field);\n\t      return;\n\t    }\n\t\n\t    var userValue = matcher[userOperator];\n\t\n\t    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\t\n\t    if (combinedOpts) {\n\t      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n\t    } else {\n\t      combinedOpts = newQueryOpts;\n\t    }\n\t  });\n\t\n\t  return {\n\t    queryOpts: combinedOpts,\n\t    inMemoryFields: inMemoryFields\n\t  };\n\t}\n\t\n\tfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n\t  switch (userOperator) {\n\t    case '$eq':\n\t      return {\n\t        startkey: userValue,\n\t        endkey: userValue\n\t      };\n\t    case '$lte':\n\t      return {\n\t        endkey: userValue\n\t      };\n\t    case '$gte':\n\t      return {\n\t        startkey: userValue\n\t      };\n\t    case '$lt':\n\t      return {\n\t        endkey: userValue,\n\t        inclusive_end: false\n\t      };\n\t    case '$gt':\n\t      return {\n\t        startkey: userValue,\n\t        inclusive_start: false\n\t      };\n\t  }\n\t}\n\t\n\tfunction getMultiFieldQueryOpts(selector, index) {\n\t\n\t  var indexFields = index.def.fields.map(pouchdbSelectorCore.getKey);\n\t\n\t  var inMemoryFields = [];\n\t  var startkey = [];\n\t  var endkey = [];\n\t  var inclusiveStart;\n\t  var inclusiveEnd;\n\t\n\t\n\t  function finish(i) {\n\t\n\t    if (inclusiveStart !== false) {\n\t      startkey.push(COLLATE_LO);\n\t    }\n\t    if (inclusiveEnd !== false) {\n\t      endkey.push(COLLATE_HI);\n\t    }\n\t    // keep track of the fields where we lost specificity,\n\t    // and therefore need to filter in-memory\n\t    inMemoryFields = indexFields.slice(i);\n\t  }\n\t\n\t  for (var i = 0, len = indexFields.length; i < len; i++) {\n\t    var indexField = indexFields[i];\n\t\n\t    var matcher = selector[indexField];\n\t\n\t    if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n\t      finish(i);\n\t      break;\n\t    } else if (i > 0) {\n\t      if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n\t        finish(i);\n\t        break;\n\t      }\n\t      var usingGtlt = (\n\t        '$gt' in matcher || '$gte' in matcher ||\n\t        '$lt' in matcher || '$lte' in matcher);\n\t      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n\t      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n\t      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n\t      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n\t      if (gtltLostSpecificity) {\n\t        finish(i);\n\t        break;\n\t      }\n\t    }\n\t\n\t    var userOperators = Object.keys(matcher);\n\t\n\t    var combinedOpts = null;\n\t\n\t    for (var j = 0; j < userOperators.length; j++) {\n\t      var userOperator = userOperators[j];\n\t      var userValue = matcher[userOperator];\n\t\n\t      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\t\n\t      if (combinedOpts) {\n\t        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n\t      } else {\n\t        combinedOpts = newOpts;\n\t      }\n\t    }\n\t\n\t    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n\t    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n\t    if ('inclusive_start' in combinedOpts) {\n\t      inclusiveStart = combinedOpts.inclusive_start;\n\t    }\n\t    if ('inclusive_end' in combinedOpts) {\n\t      inclusiveEnd = combinedOpts.inclusive_end;\n\t    }\n\t  }\n\t\n\t  var res = {\n\t    startkey: startkey,\n\t    endkey: endkey\n\t  };\n\t\n\t  if (typeof inclusiveStart !== 'undefined') {\n\t    res.inclusive_start = inclusiveStart;\n\t  }\n\t  if (typeof inclusiveEnd !== 'undefined') {\n\t    res.inclusive_end = inclusiveEnd;\n\t  }\n\t\n\t  return {\n\t    queryOpts: res,\n\t    inMemoryFields: inMemoryFields\n\t  };\n\t}\n\t\n\tfunction getDefaultQueryPlan(selector) {\n\t  //using default index, so all fields need to be done in memory\n\t  return {\n\t    queryOpts: {startkey: null},\n\t    inMemoryFields: [Object.keys(selector)]\n\t  };\n\t}\n\t\n\tfunction getCoreQueryPlan(selector, index) {\n\t  if (index.defaultUsed) {\n\t    return getDefaultQueryPlan(selector, index);\n\t  }\n\t\n\t  if (index.def.fields.length === 1) {\n\t    // one field in index, so the value was indexed as a singleton\n\t    return getSingleFieldCoreQueryPlan(selector, index);\n\t  }\n\t  // else index has multiple fields, so the value was indexed as an array\n\t  return getMultiFieldQueryOpts(selector, index);\n\t}\n\t\n\tfunction planQuery(request, indexes) {\n\t\n\t  var selector = request.selector;\n\t  var sort = request.sort;\n\t\n\t  var userFieldsRes = getUserFields(selector, sort);\n\t\n\t  var userFields = userFieldsRes.fields;\n\t  var sortOrder = userFieldsRes.sortOrder;\n\t  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\t\n\t  var coreQueryPlan = getCoreQueryPlan(selector, index);\n\t  var queryOpts = coreQueryPlan.queryOpts;\n\t  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\t\n\t  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\t\n\t  var res = {\n\t    queryOpts: queryOpts,\n\t    index: index,\n\t    inMemoryFields: inMemoryFields\n\t  };\n\t  return res;\n\t}\n\t\n\tfunction indexToSignature(index) {\n\t  // remove '_design/'\n\t  return index.ddoc.substring(8) + '/' + index.name;\n\t}\n\t\n\tfunction doAllDocs(db, originalOpts) {\n\t  var opts = pouchdbUtils.clone(originalOpts);\n\t\n\t  // CouchDB responds in weird ways when you provide a non-string to _id;\n\t  // we mimic the behavior for consistency. See issue66 tests for details.\n\t\n\t  if (opts.descending) {\n\t    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n\t      opts.endkey = '';\n\t    }\n\t    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n\t      opts.limit = 0;\n\t    }\n\t  } else {\n\t    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n\t      opts.startkey = '';\n\t    }\n\t    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n\t      opts.limit = 0;\n\t    }\n\t  }\n\t  if ('key' in opts && typeof opts.key !== 'string') {\n\t    opts.limit = 0;\n\t  }\n\t\n\t  return db.allDocs(opts)\n\t  .then(function (res) {\n\t    // filter out any design docs that _all_docs might return\n\t    res.rows = res.rows.filter(function (row) {\n\t      return !/^_design\\//.test(row.id);\n\t    });\n\t    return res;\n\t  });\n\t}\n\t\n\tfunction find$1(db, requestDef, explain) {\n\t  if (requestDef.selector) {\n\t    requestDef.selector = pouchdbSelectorCore.massageSelector(requestDef.selector);\n\t  }\n\t\n\t  if (requestDef.sort) {\n\t    requestDef.sort = massageSort(requestDef.sort);\n\t  }\n\t\n\t  if (requestDef.use_index) {\n\t    requestDef.use_index = massageUseIndex(requestDef.use_index);\n\t  }\n\t\n\t  validateFindRequest(requestDef);\n\t\n\t  return getIndexes$1(db).then(function (getIndexesRes) {\n\t\n\t    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n\t    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n\t    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n\t\n\t    var indexToUse = queryPlan.index;\n\t\n\t    validateSort(requestDef, indexToUse);\n\t\n\t    var opts = pouchdbUtils.assign({\n\t      include_docs: true,\n\t      reduce: false\n\t    }, queryPlan.queryOpts);\n\t\n\t    if ('startkey' in opts && 'endkey' in opts &&\n\t        pouchdbCollate.collate(opts.startkey, opts.endkey) > 0) {\n\t      // can't possibly return any results, startkey > endkey\n\t      /* istanbul ignore next */\n\t      return {docs: []};\n\t    }\n\t\n\t    var isDescending = requestDef.sort &&\n\t      typeof requestDef.sort[0] !== 'string' &&\n\t      pouchdbSelectorCore.getValue(requestDef.sort[0]) === 'desc';\n\t\n\t    if (isDescending) {\n\t      // either all descending or all ascending\n\t      opts.descending = true;\n\t      opts = reverseOptions(opts);\n\t    }\n\t\n\t    if (!queryPlan.inMemoryFields.length) {\n\t      // no in-memory filtering necessary, so we can let the\n\t      // database do the limit/skip for us\n\t      if ('limit' in requestDef) {\n\t        opts.limit = requestDef.limit;\n\t      }\n\t      if ('skip' in requestDef) {\n\t        opts.skip = requestDef.skip;\n\t      }\n\t    }\n\t\n\t    if (explain) {\n\t      return Promise.resolve(queryPlan, opts);\n\t    }\n\t\n\t    return Promise.resolve().then(function () {\n\t      if (indexToUse.name === '_all_docs') {\n\t        return doAllDocs(db, opts);\n\t      } else {\n\t        var signature = indexToSignature(indexToUse);\n\t        return abstractMapper.query.call(db, signature, opts);\n\t      }\n\t    }).then(function (res) {\n\t      if (opts.inclusive_start === false) {\n\t        // may have to manually filter the first one,\n\t        // since couchdb has no true inclusive_start option\n\t        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n\t      }\n\t\n\t      if (queryPlan.inMemoryFields.length) {\n\t        // need to filter some stuff in-memory\n\t        res.rows = pouchdbSelectorCore.filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n\t      }\n\t\n\t      var resp = {\n\t        docs: res.rows.map(function (row) {\n\t          var doc = row.doc;\n\t          if (requestDef.fields) {\n\t            return pick(doc, requestDef.fields);\n\t          }\n\t          return doc;\n\t        })\n\t      };\n\t\n\t      if (indexToUse.defaultUsed) {\n\t        resp.warning = 'no matching index found, create an index to optimize query time';\n\t      }\n\t\n\t      return resp;\n\t    });\n\t  });\n\t}\n\t\n\tfunction explain$1(db, requestDef) {\n\t  return find$1(db, requestDef, true)\n\t  .then(function (queryPlan) {\n\t    return {\n\t      dbname: db.name,\n\t      index: queryPlan.index,\n\t      selector: requestDef.selector,\n\t      range: {\n\t        start_key: queryPlan.queryOpts.startkey,\n\t        end_key: queryPlan.queryOpts.endkey,\n\t      },\n\t      opts: {\n\t        use_index: requestDef.use_index || [],\n\t        bookmark: \"nil\", //hardcoded to match CouchDB since its not supported,\n\t        limit: requestDef.limit,\n\t        skip: requestDef.skip,\n\t        sort: requestDef.sort || {},\n\t        fields: requestDef.fields,\n\t        conflicts: false, //hardcoded to match CouchDB since its not supported,\n\t        r: [49], // hardcoded to match CouchDB since its not support\n\t      },\n\t      limit: requestDef.limit,\n\t      skip: requestDef.skip || 0,\n\t      fields: requestDef.fields,\n\t    };\n\t  });\n\t}\n\t\n\tfunction deleteIndex$1(db, index) {\n\t\n\t  if (!index.ddoc) {\n\t    throw new Error('you must supply an index.ddoc when deleting');\n\t  }\n\t\n\t  if (!index.name) {\n\t    throw new Error('you must supply an index.name when deleting');\n\t  }\n\t\n\t  var docId = index.ddoc;\n\t  var viewName = index.name;\n\t\n\t  function deltaFun(doc) {\n\t    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n\t      // only one view in this ddoc, delete the whole ddoc\n\t      return {_id: docId, _deleted: true};\n\t    }\n\t    // more than one view here, just remove the view\n\t    delete doc.views[viewName];\n\t    return doc;\n\t  }\n\t\n\t  return pouchdbUtils.upsert(db, docId, deltaFun).then(function () {\n\t    return abstractMapper.viewCleanup.apply(db);\n\t  }).then(function () {\n\t    return {ok: true};\n\t  });\n\t}\n\t\n\tvar createIndexAsCallback = callbackify(createIndex$1);\n\tvar findAsCallback = callbackify(find$1);\n\tvar explainAsCallback = callbackify(explain$1);\n\tvar getIndexesAsCallback = callbackify(getIndexes$1);\n\tvar deleteIndexAsCallback = callbackify(deleteIndex$1);\n\t\n\tvar plugin = {};\n\tplugin.createIndex = pouchdbUtils.toPromise(function (requestDef, callback) {\n\t\n\t  if (typeof requestDef !== 'object') {\n\t    return callback(new Error('you must provide an index to create'));\n\t  }\n\t\n\t  var createIndex$$1 = pouchdbUtils.isRemote(this) ?\n\t    createIndex : createIndexAsCallback;\n\t  createIndex$$1(this, requestDef, callback);\n\t});\n\t\n\tplugin.find = pouchdbUtils.toPromise(function (requestDef, callback) {\n\t\n\t  if (typeof callback === 'undefined') {\n\t    callback = requestDef;\n\t    requestDef = undefined;\n\t  }\n\t\n\t  if (typeof requestDef !== 'object') {\n\t    return callback(new Error('you must provide search parameters to find()'));\n\t  }\n\t\n\t  var find$$1 = pouchdbUtils.isRemote(this) ? find : findAsCallback;\n\t  find$$1(this, requestDef, callback);\n\t});\n\t\n\tplugin.explain = pouchdbUtils.toPromise(function (requestDef, callback) {\n\t\n\t  if (typeof callback === 'undefined') {\n\t    callback = requestDef;\n\t    requestDef = undefined;\n\t  }\n\t\n\t  if (typeof requestDef !== 'object') {\n\t    return callback(new Error('you must provide search parameters to explain()'));\n\t  }\n\t\n\t  var find$$1 = pouchdbUtils.isRemote(this) ? explain : explainAsCallback;\n\t  find$$1(this, requestDef, callback);\n\t});\n\t\n\tplugin.getIndexes = pouchdbUtils.toPromise(function (callback) {\n\t\n\t  var getIndexes$$1 = pouchdbUtils.isRemote(this) ? getIndexes : getIndexesAsCallback;\n\t  getIndexes$$1(this, callback);\n\t});\n\t\n\tplugin.deleteIndex = pouchdbUtils.toPromise(function (indexDef, callback) {\n\t\n\t  if (typeof indexDef !== 'object') {\n\t    return callback(new Error('you must provide an index to delete'));\n\t  }\n\t\n\t  var deleteIndex$$1 = pouchdbUtils.isRemote(this) ?\n\t    deleteIndex : deleteIndexAsCallback;\n\t  deleteIndex$$1(this, indexDef, callback);\n\t});\n\t\n\tmodule.exports = plugin;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32)))\n\n/***/ },\n/* 79 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar inherits = _interopDefault(__webpack_require__(5));\n\tvar pouchdbCollections = __webpack_require__(16);\n\tvar argsarray = _interopDefault(__webpack_require__(7));\n\tvar pouchdbUtils = __webpack_require__(6);\n\t\n\tfunction QueryParseError(message) {\n\t  this.status = 400;\n\t  this.name = 'query_parse_error';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, QueryParseError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(QueryParseError, Error);\n\t\n\tfunction NotFoundError(message) {\n\t  this.status = 404;\n\t  this.name = 'not_found';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, NotFoundError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(NotFoundError, Error);\n\t\n\tfunction BuiltInError(message) {\n\t  this.status = 500;\n\t  this.name = 'invalid_value';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, BuiltInError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(BuiltInError, Error);\n\t\n\tfunction promisedCallback(promise, callback) {\n\t  if (callback) {\n\t    promise.then(function (res) {\n\t      pouchdbUtils.nextTick(function () {\n\t        callback(null, res);\n\t      });\n\t    }, function (reason) {\n\t      pouchdbUtils.nextTick(function () {\n\t        callback(reason);\n\t      });\n\t    });\n\t  }\n\t  return promise;\n\t}\n\t\n\tfunction callbackify(fun) {\n\t  return argsarray(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    if (typeof cb === 'function') {\n\t      promisedCallback(promise, cb);\n\t    }\n\t    return promise;\n\t  });\n\t}\n\t\n\t// Promise finally util similar to Q.finally\n\tfunction fin(promise, finalPromiseFactory) {\n\t  return promise.then(function (res) {\n\t    return finalPromiseFactory().then(function () {\n\t      return res;\n\t    });\n\t  }, function (reason) {\n\t    return finalPromiseFactory().then(function () {\n\t      throw reason;\n\t    });\n\t  });\n\t}\n\t\n\tfunction sequentialize(queue, promiseFactory) {\n\t  return function () {\n\t    var args = arguments;\n\t    var that = this;\n\t    return queue.add(function () {\n\t      return promiseFactory.apply(that, args);\n\t    });\n\t  };\n\t}\n\t\n\t// uniq an array of strings, order not guaranteed\n\t// similar to underscore/lodash _.uniq\n\tfunction uniq(arr) {\n\t  var theSet = new pouchdbCollections.Set(arr);\n\t  var result = new Array(theSet.size);\n\t  var index = -1;\n\t  theSet.forEach(function (value) {\n\t    result[++index] = value;\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction mapToKeysArray(map) {\n\t  var result = new Array(map.size);\n\t  var index = -1;\n\t  map.forEach(function (value, key) {\n\t    result[++index] = key;\n\t  });\n\t  return result;\n\t}\n\t\n\texports.uniq = uniq;\n\texports.sequentialize = sequentialize;\n\texports.fin = fin;\n\texports.callbackify = callbackify;\n\texports.promisedCallback = promisedCallback;\n\texports.mapToKeysArray = mapToKeysArray;\n\texports.QueryParseError = QueryParseError;\n\texports.NotFoundError = NotFoundError;\n\texports.BuiltInError = BuiltInError;\n\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tvar pouchdbUtils = __webpack_require__(6);\n\tvar pouchdbCollate = __webpack_require__(15);\n\t\n\t// this would just be \"return doc[field]\", but fields\n\t// can be \"deep\" due to dot notation\n\tfunction getFieldFromDoc(doc, parsedField) {\n\t  var value = doc;\n\t  for (var i = 0, len = parsedField.length; i < len; i++) {\n\t    var key = parsedField[i];\n\t    value = value[key];\n\t    if (!value) {\n\t      break;\n\t    }\n\t  }\n\t  return value;\n\t}\n\t\n\tfunction setFieldInDoc(doc, parsedField, value) {\n\t  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n\t    var elem = parsedField[i];\n\t    doc = doc[elem] = {};\n\t  }\n\t  doc[parsedField[len-1]] = value;\n\t}\n\t\n\tfunction compare(left, right) {\n\t  return left < right ? -1 : left > right ? 1 : 0;\n\t}\n\t\n\t// Converts a string in dot notation to an array of its components, with backslash escaping\n\tfunction parseField(fieldName) {\n\t  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n\t  var fields = [];\n\t  var current = '';\n\t  for (var i = 0, len = fieldName.length; i < len; i++) {\n\t    var ch = fieldName[i];\n\t    if (ch === '.') {\n\t      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n\t        current = current.substring(0, current.length - 1) + '.';\n\t      } else { // not escaped, so delimiter\n\t        fields.push(current);\n\t        current = '';\n\t      }\n\t    } else { // normal character\n\t      current += ch;\n\t    }\n\t  }\n\t  fields.push(current);\n\t  return fields;\n\t}\n\t\n\tvar combinationFields = ['$or', '$nor', '$not'];\n\tfunction isCombinationalField(field) {\n\t  return combinationFields.indexOf(field) > -1;\n\t}\n\t\n\tfunction getKey(obj) {\n\t  return Object.keys(obj)[0];\n\t}\n\t\n\tfunction getValue(obj) {\n\t  return obj[getKey(obj)];\n\t}\n\t\n\t\n\t// flatten an array of selectors joined by an $and operator\n\tfunction mergeAndedSelectors(selectors) {\n\t\n\t  // sort to ensure that e.g. if the user specified\n\t  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n\t  // just {$gt: 'b'}\n\t  var res = {};\n\t\n\t  selectors.forEach(function (selector) {\n\t    Object.keys(selector).forEach(function (field) {\n\t      var matcher = selector[field];\n\t      if (typeof matcher !== 'object') {\n\t        matcher = {$eq: matcher};\n\t      }\n\t\n\t      if (isCombinationalField(field)) {\n\t        if (matcher instanceof Array) {\n\t          res[field] = matcher.map(function (m) {\n\t            return mergeAndedSelectors([m]);\n\t          });\n\t        } else {\n\t          res[field] = mergeAndedSelectors([matcher]);\n\t        }\n\t      } else {\n\t        var fieldMatchers = res[field] = res[field] || {};\n\t        Object.keys(matcher).forEach(function (operator) {\n\t          var value = matcher[operator];\n\t\n\t          if (operator === '$gt' || operator === '$gte') {\n\t            return mergeGtGte(operator, value, fieldMatchers);\n\t          } else if (operator === '$lt' || operator === '$lte') {\n\t            return mergeLtLte(operator, value, fieldMatchers);\n\t          } else if (operator === '$ne') {\n\t            return mergeNe(value, fieldMatchers);\n\t          } else if (operator === '$eq') {\n\t            return mergeEq(value, fieldMatchers);\n\t          }\n\t          fieldMatchers[operator] = value;\n\t        });\n\t      }\n\t    });\n\t  });\n\t\n\t  return res;\n\t}\n\t\n\t\n\t\n\t// collapse logically equivalent gt/gte values\n\tfunction mergeGtGte(operator, value, fieldMatchers) {\n\t  if (typeof fieldMatchers.$eq !== 'undefined') {\n\t    return; // do nothing\n\t  }\n\t  if (typeof fieldMatchers.$gte !== 'undefined') {\n\t    if (operator === '$gte') {\n\t      if (value > fieldMatchers.$gte) { // more specificity\n\t        fieldMatchers.$gte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value >= fieldMatchers.$gte) { // more specificity\n\t        delete fieldMatchers.$gte;\n\t        fieldMatchers.$gt = value;\n\t      }\n\t    }\n\t  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n\t    if (operator === '$gte') {\n\t      if (value > fieldMatchers.$gt) { // more specificity\n\t        delete fieldMatchers.$gt;\n\t        fieldMatchers.$gte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value > fieldMatchers.$gt) { // more specificity\n\t        fieldMatchers.$gt = value;\n\t      }\n\t    }\n\t  } else {\n\t    fieldMatchers[operator] = value;\n\t  }\n\t}\n\t\n\t// collapse logically equivalent lt/lte values\n\tfunction mergeLtLte(operator, value, fieldMatchers) {\n\t  if (typeof fieldMatchers.$eq !== 'undefined') {\n\t    return; // do nothing\n\t  }\n\t  if (typeof fieldMatchers.$lte !== 'undefined') {\n\t    if (operator === '$lte') {\n\t      if (value < fieldMatchers.$lte) { // more specificity\n\t        fieldMatchers.$lte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value <= fieldMatchers.$lte) { // more specificity\n\t        delete fieldMatchers.$lte;\n\t        fieldMatchers.$lt = value;\n\t      }\n\t    }\n\t  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n\t    if (operator === '$lte') {\n\t      if (value < fieldMatchers.$lt) { // more specificity\n\t        delete fieldMatchers.$lt;\n\t        fieldMatchers.$lte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value < fieldMatchers.$lt) { // more specificity\n\t        fieldMatchers.$lt = value;\n\t      }\n\t    }\n\t  } else {\n\t    fieldMatchers[operator] = value;\n\t  }\n\t}\n\t\n\t// combine $ne values into one array\n\tfunction mergeNe(value, fieldMatchers) {\n\t  if ('$ne' in fieldMatchers) {\n\t    // there are many things this could \"not\" be\n\t    fieldMatchers.$ne.push(value);\n\t  } else { // doesn't exist yet\n\t    fieldMatchers.$ne = [value];\n\t  }\n\t}\n\t\n\t// add $eq into the mix\n\tfunction mergeEq(value, fieldMatchers) {\n\t  // these all have less specificity than the $eq\n\t  // TODO: check for user errors here\n\t  delete fieldMatchers.$gt;\n\t  delete fieldMatchers.$gte;\n\t  delete fieldMatchers.$lt;\n\t  delete fieldMatchers.$lte;\n\t  delete fieldMatchers.$ne;\n\t  fieldMatchers.$eq = value;\n\t}\n\t\n\t\n\t//\n\t// normalize the selector\n\t//\n\tfunction massageSelector(input) {\n\t  var result = pouchdbUtils.clone(input);\n\t  var wasAnded = false;\n\t  if ('$and' in result) {\n\t    result = mergeAndedSelectors(result['$and']);\n\t    wasAnded = true;\n\t  }\n\t\n\t  ['$or', '$nor'].forEach(function (orOrNor) {\n\t    if (orOrNor in result) {\n\t      // message each individual selector\n\t      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n\t      result[orOrNor].forEach(function (subSelector) {\n\t        var fields = Object.keys(subSelector);\n\t        for (var i = 0; i < fields.length; i++) {\n\t          var field = fields[i];\n\t          var matcher = subSelector[field];\n\t          if (typeof matcher !== 'object' || matcher === null) {\n\t            subSelector[field] = {$eq: matcher};\n\t          }\n\t        }\n\t      });\n\t    }\n\t  });\n\t\n\t  if ('$not' in result) {\n\t    //This feels a little like forcing, but it will work for now,\n\t    //I would like to come back to this and make the merging of selectors a little more generic\n\t    result['$not'] = mergeAndedSelectors([result['$not']]);\n\t  }\n\t\n\t  var fields = Object.keys(result);\n\t\n\t  for (var i = 0; i < fields.length; i++) {\n\t    var field = fields[i];\n\t    var matcher = result[field];\n\t\n\t    if (typeof matcher !== 'object' || matcher === null) {\n\t      matcher = {$eq: matcher};\n\t    } else if ('$ne' in matcher && !wasAnded) {\n\t      // I put these in an array, since there may be more than one\n\t      // but in the \"mergeAnded\" operation, I already take care of that\n\t      matcher.$ne = [matcher.$ne];\n\t    }\n\t    result[field] = matcher;\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\t// create a comparator based on the sort object\n\tfunction createFieldSorter(sort) {\n\t\n\t  function getFieldValuesAsArray(doc) {\n\t    return sort.map(function (sorting) {\n\t      var fieldName = getKey(sorting);\n\t      var parsedField = parseField(fieldName);\n\t      var docFieldValue = getFieldFromDoc(doc, parsedField);\n\t      return docFieldValue;\n\t    });\n\t  }\n\t\n\t  return function (aRow, bRow) {\n\t    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n\t    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n\t    var collation = pouchdbCollate.collate(aFieldValues, bFieldValues);\n\t    if (collation !== 0) {\n\t      return collation;\n\t    }\n\t    // this is what mango seems to do\n\t    return compare(aRow.doc._id, bRow.doc._id);\n\t  };\n\t}\n\t\n\tfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n\t  rows = rows.filter(function (row) {\n\t    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n\t  });\n\t\n\t  if (requestDef.sort) {\n\t    // in-memory sort\n\t    var fieldSorter = createFieldSorter(requestDef.sort);\n\t    rows = rows.sort(fieldSorter);\n\t    if (typeof requestDef.sort[0] !== 'string' &&\n\t        getValue(requestDef.sort[0]) === 'desc') {\n\t      rows = rows.reverse();\n\t    }\n\t  }\n\t\n\t  if ('limit' in requestDef || 'skip' in requestDef) {\n\t    // have to do the limit in-memory\n\t    var skip = requestDef.skip || 0;\n\t    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n\t    rows = rows.slice(skip, limit);\n\t  }\n\t  return rows;\n\t}\n\t\n\tfunction rowFilter(doc, selector, inMemoryFields) {\n\t  return inMemoryFields.every(function (field) {\n\t    var matcher = selector[field];\n\t    var parsedField = parseField(field);\n\t    var docFieldValue = getFieldFromDoc(doc, parsedField);\n\t    if (isCombinationalField(field)) {\n\t      return matchCominationalSelector(field, matcher, doc);\n\t    }\n\t\n\t    return matchSelector(matcher, doc, parsedField, docFieldValue);\n\t  });\n\t}\n\t\n\tfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n\t  if (!matcher) {\n\t    // no filtering necessary; this field is just needed for sorting\n\t    return true;\n\t  }\n\t\n\t  return Object.keys(matcher).every(function (userOperator) {\n\t    var userValue = matcher[userOperator];\n\t    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n\t  });\n\t}\n\t\n\tfunction matchCominationalSelector(field, matcher, doc) {\n\t\n\t  if (field === '$or') {\n\t    return matcher.some(function (orMatchers) {\n\t      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n\t    });\n\t  }\n\t\n\t  if (field === '$not') {\n\t    return !rowFilter(doc, matcher, Object.keys(matcher));\n\t  }\n\t\n\t  //`$nor`\n\t  return !matcher.find(function (orMatchers) {\n\t    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n\t  });\n\t\n\t}\n\t\n\tfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n\t  if (!matchers[userOperator]) {\n\t    throw new Error('unknown operator \"' + userOperator +\n\t      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n\t      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n\t  }\n\t  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n\t}\n\t\n\tfunction fieldExists(docFieldValue) {\n\t  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n\t}\n\t\n\tfunction fieldIsNotUndefined(docFieldValue) {\n\t  return typeof docFieldValue !== 'undefined';\n\t}\n\t\n\tfunction modField(docFieldValue, userValue) {\n\t  var divisor = userValue[0];\n\t  var mod = userValue[1];\n\t  if (divisor === 0) {\n\t    throw new Error('Bad divisor, cannot divide by zero');\n\t  }\n\t\n\t  if (parseInt(divisor, 10) !== divisor ) {\n\t    throw new Error('Divisor is not an integer');\n\t  }\n\t\n\t  if (parseInt(mod, 10) !== mod ) {\n\t    throw new Error('Modulus is not an integer');\n\t  }\n\t\n\t  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n\t    return false;\n\t  }\n\t\n\t  return docFieldValue % divisor === mod;\n\t}\n\t\n\tfunction arrayContainsValue(docFieldValue, userValue) {\n\t  return userValue.some(function (val) {\n\t    if (docFieldValue instanceof Array) {\n\t      return docFieldValue.indexOf(val) > -1;\n\t    }\n\t\n\t    return docFieldValue === val;\n\t  });\n\t}\n\t\n\tfunction arrayContainsAllValues(docFieldValue, userValue) {\n\t  return userValue.every(function (val) {\n\t    return docFieldValue.indexOf(val) > -1;\n\t  });\n\t}\n\t\n\tfunction arraySize(docFieldValue, userValue) {\n\t  return docFieldValue.length === userValue;\n\t}\n\t\n\tfunction regexMatch(docFieldValue, userValue) {\n\t  var re = new RegExp(userValue);\n\t\n\t  return re.test(docFieldValue);\n\t}\n\t\n\tfunction typeMatch(docFieldValue, userValue) {\n\t\n\t  switch (userValue) {\n\t    case 'null':\n\t      return docFieldValue === null;\n\t    case 'boolean':\n\t      return typeof (docFieldValue) === 'boolean';\n\t    case 'number':\n\t      return typeof (docFieldValue) === 'number';\n\t    case 'string':\n\t      return typeof (docFieldValue) === 'string';\n\t    case 'array':\n\t      return docFieldValue instanceof Array;\n\t    case 'object':\n\t      return ({}).toString.call(docFieldValue) === '[object Object]';\n\t  }\n\t\n\t  throw new Error(userValue + ' not supported as a type.' +\n\t                  'Please use one of object, string, array, number, boolean or null.');\n\t\n\t}\n\t\n\tvar matchers = {\n\t\n\t  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n\t    if (!Array.isArray(docFieldValue)) {\n\t      return false;\n\t    }\n\t\n\t    if (docFieldValue.length === 0) {\n\t      return false;\n\t    }\n\t\n\t    if (typeof docFieldValue[0] === 'object') {\n\t      return docFieldValue.some(function (val) {\n\t        return rowFilter(val, userValue, Object.keys(userValue));\n\t      });\n\t    }\n\t\n\t    return docFieldValue.some(function (val) {\n\t      return matchSelector(userValue, doc, parsedField, val);\n\t    });\n\t  },\n\t\n\t  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n\t    if (!Array.isArray(docFieldValue)) {\n\t      return false;\n\t    }\n\t\n\t    /* istanbul ignore next */\n\t    if (docFieldValue.length === 0) {\n\t      return false;\n\t    }\n\t\n\t    if (typeof docFieldValue[0] === 'object') {\n\t      return docFieldValue.every(function (val) {\n\t        return rowFilter(val, userValue, Object.keys(userValue));\n\t      });\n\t    }\n\t\n\t    return docFieldValue.every(function (val) {\n\t      return matchSelector(userValue, doc, parsedField, val);\n\t    });\n\t  },\n\t\n\t  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && pouchdbCollate.collate(docFieldValue, userValue) === 0;\n\t  },\n\t\n\t  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && pouchdbCollate.collate(docFieldValue, userValue) >= 0;\n\t  },\n\t\n\t  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && pouchdbCollate.collate(docFieldValue, userValue) > 0;\n\t  },\n\t\n\t  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && pouchdbCollate.collate(docFieldValue, userValue) <= 0;\n\t  },\n\t\n\t  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && pouchdbCollate.collate(docFieldValue, userValue) < 0;\n\t  },\n\t\n\t  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n\t    //a field that is null is still considered to exist\n\t    if (userValue) {\n\t      return fieldIsNotUndefined(docFieldValue);\n\t    }\n\t\n\t    return !fieldIsNotUndefined(docFieldValue);\n\t  },\n\t\n\t  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n\t  },\n\t\n\t  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n\t    return userValue.every(function (neValue) {\n\t      return pouchdbCollate.collate(docFieldValue, neValue) !== 0;\n\t    });\n\t  },\n\t  '$in': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n\t  },\n\t\n\t  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n\t  },\n\t\n\t  '$size': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n\t  },\n\t\n\t  '$all': function (doc, userValue, parsedField, docFieldValue) {\n\t    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n\t  },\n\t\n\t  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n\t  },\n\t\n\t  '$type': function (doc, userValue, parsedField, docFieldValue) {\n\t    return typeMatch(docFieldValue, userValue);\n\t  }\n\t};\n\t\n\t// return true if the given doc matches the supplied selector\n\tfunction matchesSelector(doc, selector) {\n\t  /* istanbul ignore if */\n\t  if (typeof selector !== 'object') {\n\t    // match the CouchDB error message\n\t    throw new Error('Selector error: expected a JSON object');\n\t  }\n\t\n\t  selector = massageSelector(selector);\n\t  var row = {\n\t    'doc': doc\n\t  };\n\t\n\t  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n\t  return rowsMatched && rowsMatched.length === 1;\n\t}\n\t\n\texports.massageSelector = massageSelector;\n\texports.matchesSelector = matchesSelector;\n\texports.filterInMemoryFields = filterInMemoryFields;\n\texports.createFieldSorter = createFieldSorter;\n\texports.rowFilter = rowFilter;\n\texports.isCombinationalField = isCombinationalField;\n\texports.getKey = getKey;\n\texports.getValue = getValue;\n\texports.getFieldFromDoc = getFieldFromDoc;\n\texports.setFieldInDoc = setFieldInDoc;\n\texports.compare = compare;\n\texports.parseField = parseField;\n\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar inherits = _interopDefault(__webpack_require__(5));\n\t\n\tinherits(PouchError, Error);\n\t\n\tfunction PouchError(status, error, reason) {\n\t  Error.call(this, reason);\n\t  this.status = status;\n\t  this.name = error;\n\t  this.message = reason;\n\t  this.error = true;\n\t}\n\t\n\tPouchError.prototype.toString = function () {\n\t  return JSON.stringify({\n\t    status: this.status,\n\t    name: this.name,\n\t    message: this.message,\n\t    reason: this.reason\n\t  });\n\t};\n\t\n\tvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\n\tvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\n\tvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\n\tvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\n\tvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\n\tvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\n\tvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\n\tvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\n\tvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\n\tvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\n\tvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\n\tvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\n\tvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\n\tvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\n\tvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\n\tvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\n\tvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\n\tvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\n\tvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\n\tvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\n\tvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\n\tvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\n\tvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\n\tvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\t\n\tfunction createError(error, reason) {\n\t  function CustomPouchError(reason) {\n\t    // inherit error properties from our parent error manually\n\t    // so as to allow proper JSON parsing.\n\t    /* jshint ignore:start */\n\t    for (var p in error) {\n\t      if (typeof error[p] !== 'function') {\n\t        this[p] = error[p];\n\t      }\n\t    }\n\t    /* jshint ignore:end */\n\t    if (reason !== undefined) {\n\t      this.reason = reason;\n\t    }\n\t  }\n\t  CustomPouchError.prototype = PouchError.prototype;\n\t  return new CustomPouchError(reason);\n\t}\n\t\n\tfunction generateErrorFromResponse(err) {\n\t\n\t  if (typeof err !== 'object') {\n\t    var data = err;\n\t    err = UNKNOWN_ERROR;\n\t    err.data = data;\n\t  }\n\t\n\t  if ('error' in err && err.error === 'conflict') {\n\t    err.name = 'conflict';\n\t    err.status = 409;\n\t  }\n\t\n\t  if (!('name' in err)) {\n\t    err.name = err.error || 'unknown';\n\t  }\n\t\n\t  if (!('status' in err)) {\n\t    err.status = 500;\n\t  }\n\t\n\t  if (!('message' in err)) {\n\t    err.message = err.message || err.reason;\n\t  }\n\t\n\t  return err;\n\t}\n\t\n\texports.UNAUTHORIZED = UNAUTHORIZED;\n\texports.MISSING_BULK_DOCS = MISSING_BULK_DOCS;\n\texports.MISSING_DOC = MISSING_DOC;\n\texports.REV_CONFLICT = REV_CONFLICT;\n\texports.INVALID_ID = INVALID_ID;\n\texports.MISSING_ID = MISSING_ID;\n\texports.RESERVED_ID = RESERVED_ID;\n\texports.NOT_OPEN = NOT_OPEN;\n\texports.UNKNOWN_ERROR = UNKNOWN_ERROR;\n\texports.BAD_ARG = BAD_ARG;\n\texports.INVALID_REQUEST = INVALID_REQUEST;\n\texports.QUERY_PARSE_ERROR = QUERY_PARSE_ERROR;\n\texports.DOC_VALIDATION = DOC_VALIDATION;\n\texports.BAD_REQUEST = BAD_REQUEST;\n\texports.NOT_AN_OBJECT = NOT_AN_OBJECT;\n\texports.DB_MISSING = DB_MISSING;\n\texports.WSQ_ERROR = WSQ_ERROR;\n\texports.LDB_ERROR = LDB_ERROR;\n\texports.FORBIDDEN = FORBIDDEN;\n\texports.INVALID_REV = INVALID_REV;\n\texports.FILE_EXISTS = FILE_EXISTS;\n\texports.MISSING_STUB = MISSING_STUB;\n\texports.IDB_ERROR = IDB_ERROR;\n\texports.INVALID_URL = INVALID_URL;\n\texports.createError = createError;\n\texports.generateErrorFromResponse = generateErrorFromResponse;\n\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar lie = _interopDefault(__webpack_require__(29));\n\tvar getArguments = _interopDefault(__webpack_require__(7));\n\tvar nextTick = _interopDefault(__webpack_require__(14));\n\tvar events = __webpack_require__(28);\n\tvar inherits = _interopDefault(__webpack_require__(5));\n\tvar uuidV4 = _interopDefault(__webpack_require__(34));\n\tvar debug = _interopDefault(__webpack_require__(83));\n\tvar Md5 = _interopDefault(__webpack_require__(33));\n\tvar vuvuzela = _interopDefault(__webpack_require__(88));\n\t\n\t/* istanbul ignore next */\n\tvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\t\n\tfunction isBinaryObject(object) {\n\t  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n\t    (typeof Blob !== 'undefined' && object instanceof Blob);\n\t}\n\t\n\tfunction cloneArrayBuffer(buff) {\n\t  if (typeof buff.slice === 'function') {\n\t    return buff.slice(0);\n\t  }\n\t  // IE10-11 slice() polyfill\n\t  var target = new ArrayBuffer(buff.byteLength);\n\t  var targetArray = new Uint8Array(target);\n\t  var sourceArray = new Uint8Array(buff);\n\t  targetArray.set(sourceArray);\n\t  return target;\n\t}\n\t\n\tfunction cloneBinaryObject(object) {\n\t  if (object instanceof ArrayBuffer) {\n\t    return cloneArrayBuffer(object);\n\t  }\n\t  var size = object.size;\n\t  var type = object.type;\n\t  // Blob\n\t  if (typeof object.slice === 'function') {\n\t    return object.slice(0, size, type);\n\t  }\n\t  // PhantomJS slice() replacement\n\t  return object.webkitSlice(0, size, type);\n\t}\n\t\n\t// most of this is borrowed from lodash.isPlainObject:\n\t// https://github.com/fis-components/lodash.isplainobject/\n\t// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\t\n\tvar funcToString = Function.prototype.toString;\n\tvar objectCtorString = funcToString.call(Object);\n\t\n\tfunction isPlainObject(value) {\n\t  var proto = Object.getPrototypeOf(value);\n\t  /* istanbul ignore if */\n\t  if (proto === null) { // not sure when this happens, but I guess it can\n\t    return true;\n\t  }\n\t  var Ctor = proto.constructor;\n\t  return (typeof Ctor == 'function' &&\n\t    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n\t}\n\t\n\tfunction clone(object) {\n\t  var newObject;\n\t  var i;\n\t  var len;\n\t\n\t  if (!object || typeof object !== 'object') {\n\t    return object;\n\t  }\n\t\n\t  if (Array.isArray(object)) {\n\t    newObject = [];\n\t    for (i = 0, len = object.length; i < len; i++) {\n\t      newObject[i] = clone(object[i]);\n\t    }\n\t    return newObject;\n\t  }\n\t\n\t  // special case: to avoid inconsistencies between IndexedDB\n\t  // and other backends, we automatically stringify Dates\n\t  if (object instanceof Date) {\n\t    return object.toISOString();\n\t  }\n\t\n\t  if (isBinaryObject(object)) {\n\t    return cloneBinaryObject(object);\n\t  }\n\t\n\t  if (!isPlainObject(object)) {\n\t    return object; // don't clone objects like Workers\n\t  }\n\t\n\t  newObject = {};\n\t  for (i in object) {\n\t    /* istanbul ignore else */\n\t    if (Object.prototype.hasOwnProperty.call(object, i)) {\n\t      var value = clone(object[i]);\n\t      if (typeof value !== 'undefined') {\n\t        newObject[i] = value;\n\t      }\n\t    }\n\t  }\n\t  return newObject;\n\t}\n\t\n\tfunction once(fun) {\n\t  var called = false;\n\t  return getArguments(function (args) {\n\t    /* istanbul ignore if */\n\t    if (called) {\n\t      // this is a smoke test and should never actually happen\n\t      throw new Error('once called more than once');\n\t    } else {\n\t      called = true;\n\t      fun.apply(this, args);\n\t    }\n\t  });\n\t}\n\t\n\tfunction toPromise(func) {\n\t  //create the function we will be returning\n\t  return getArguments(function (args) {\n\t    // Clone arguments\n\t    args = clone(args);\n\t    var self = this;\n\t    // if the last argument is a function, assume its a callback\n\t    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n\t    var promise = new PouchPromise(function (fulfill, reject) {\n\t      var resp;\n\t      try {\n\t        var callback = once(function (err, mesg) {\n\t          if (err) {\n\t            reject(err);\n\t          } else {\n\t            fulfill(mesg);\n\t          }\n\t        });\n\t        // create a callback for this invocation\n\t        // apply the function in the orig context\n\t        args.push(callback);\n\t        resp = func.apply(self, args);\n\t        if (resp && typeof resp.then === 'function') {\n\t          fulfill(resp);\n\t        }\n\t      } catch (e) {\n\t        reject(e);\n\t      }\n\t    });\n\t    // if there is a callback, call it back\n\t    if (usedCB) {\n\t      promise.then(function (result) {\n\t        usedCB(null, result);\n\t      }, usedCB);\n\t    }\n\t    return promise;\n\t  });\n\t}\n\t\n\tfunction logApiCall(self, name, args) {\n\t  /* istanbul ignore if */\n\t  if (self.constructor.listeners('debug').length) {\n\t    var logArgs = ['api', self.name, name];\n\t    for (var i = 0; i < args.length - 1; i++) {\n\t      logArgs.push(args[i]);\n\t    }\n\t    self.constructor.emit('debug', logArgs);\n\t\n\t    // override the callback itself to log the response\n\t    var origCallback = args[args.length - 1];\n\t    args[args.length - 1] = function (err, res) {\n\t      var responseArgs = ['api', self.name, name];\n\t      responseArgs = responseArgs.concat(\n\t        err ? ['error', err] : ['success', res]\n\t      );\n\t      self.constructor.emit('debug', responseArgs);\n\t      origCallback(err, res);\n\t    };\n\t  }\n\t}\n\t\n\tfunction adapterFun(name, callback) {\n\t  return toPromise(getArguments(function (args) {\n\t    if (this._closed) {\n\t      return PouchPromise.reject(new Error('database is closed'));\n\t    }\n\t    if (this._destroyed) {\n\t      return PouchPromise.reject(new Error('database is destroyed'));\n\t    }\n\t    var self = this;\n\t    logApiCall(self, name, args);\n\t    if (!this.taskqueue.isReady) {\n\t      return new PouchPromise(function (fulfill, reject) {\n\t        self.taskqueue.addTask(function (failed) {\n\t          if (failed) {\n\t            reject(failed);\n\t          } else {\n\t            fulfill(self[name].apply(self, args));\n\t          }\n\t        });\n\t      });\n\t    }\n\t    return callback.apply(this, args);\n\t  }));\n\t}\n\t\n\tfunction mangle(key) {\n\t  return '$' + key;\n\t}\n\tfunction unmangle(key) {\n\t  return key.substring(1);\n\t}\n\tfunction Map$1() {\n\t  this._store = {};\n\t}\n\tMap$1.prototype.get = function (key) {\n\t  var mangled = mangle(key);\n\t  return this._store[mangled];\n\t};\n\tMap$1.prototype.set = function (key, value) {\n\t  var mangled = mangle(key);\n\t  this._store[mangled] = value;\n\t  return true;\n\t};\n\tMap$1.prototype.has = function (key) {\n\t  var mangled = mangle(key);\n\t  return mangled in this._store;\n\t};\n\tMap$1.prototype.delete = function (key) {\n\t  var mangled = mangle(key);\n\t  var res = mangled in this._store;\n\t  delete this._store[mangled];\n\t  return res;\n\t};\n\tMap$1.prototype.forEach = function (cb) {\n\t  var keys = Object.keys(this._store);\n\t  for (var i = 0, len = keys.length; i < len; i++) {\n\t    var key = keys[i];\n\t    var value = this._store[key];\n\t    key = unmangle(key);\n\t    cb(value, key);\n\t  }\n\t};\n\tObject.defineProperty(Map$1.prototype, 'size', {\n\t  get: function () {\n\t    return Object.keys(this._store).length;\n\t  }\n\t});\n\t\n\tfunction Set$1(array) {\n\t  this._store = new Map$1();\n\t\n\t  // init with an array\n\t  if (array && Array.isArray(array)) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      this.add(array[i]);\n\t    }\n\t  }\n\t}\n\tSet$1.prototype.add = function (key) {\n\t  return this._store.set(key, true);\n\t};\n\tSet$1.prototype.has = function (key) {\n\t  return this._store.has(key);\n\t};\n\tSet$1.prototype.forEach = function (cb) {\n\t  this._store.forEach(function (value, key) {\n\t    cb(key);\n\t  });\n\t};\n\tObject.defineProperty(Set$1.prototype, 'size', {\n\t  get: function () {\n\t    return this._store.size;\n\t  }\n\t});\n\t\n\t/* global Map,Set,Symbol */\n\t// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n\t// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n\t// Notably they fail in IE11 and iOS 8.4, which this prevents.\n\tfunction supportsMapAndSet() {\n\t  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n\t    return false;\n\t  }\n\t  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n\t  return prop && 'get' in prop && Map[Symbol.species] === Map;\n\t}\n\t\n\t// based on https://github.com/montagejs/collections\n\t/* global Map,Set */\n\t\n\tvar ExportedSet;\n\tvar ExportedMap;\n\t\n\t{\n\t  if (supportsMapAndSet()) { // prefer built-in Map/Set\n\t    ExportedSet = Set;\n\t    ExportedMap = Map;\n\t  } else { // fall back to our polyfill\n\t    ExportedSet = Set$1;\n\t    ExportedMap = Map$1;\n\t  }\n\t}\n\t\n\t// like underscore/lodash _.pick()\n\tfunction pick(obj, arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var prop = arr[i];\n\t    if (prop in obj) {\n\t      res[prop] = obj[prop];\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\t// Most browsers throttle concurrent requests at 6, so it's silly\n\t// to shim _bulk_get by trying to launch potentially hundreds of requests\n\t// and then letting the majority time out. We can handle this ourselves.\n\tvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\t\n\tfunction identityFunction(x) {\n\t  return x;\n\t}\n\t\n\tfunction formatResultForOpenRevsGet(result) {\n\t  return [{\n\t    ok: result\n\t  }];\n\t}\n\t\n\t// shim for P/CouchDB adapters that don't directly implement _bulk_get\n\tfunction bulkGet(db, opts, callback) {\n\t  var requests = opts.docs;\n\t\n\t  // consolidate into one request per doc if possible\n\t  var requestsById = new ExportedMap();\n\t  requests.forEach(function (request) {\n\t    if (requestsById.has(request.id)) {\n\t      requestsById.get(request.id).push(request);\n\t    } else {\n\t      requestsById.set(request.id, [request]);\n\t    }\n\t  });\n\t\n\t  var numDocs = requestsById.size;\n\t  var numDone = 0;\n\t  var perDocResults = new Array(numDocs);\n\t\n\t  function collapseResultsAndFinish() {\n\t    var results = [];\n\t    perDocResults.forEach(function (res) {\n\t      res.docs.forEach(function (info) {\n\t        results.push({\n\t          id: res.id,\n\t          docs: [info]\n\t        });\n\t      });\n\t    });\n\t    callback(null, {results: results});\n\t  }\n\t\n\t  function checkDone() {\n\t    if (++numDone === numDocs) {\n\t      collapseResultsAndFinish();\n\t    }\n\t  }\n\t\n\t  function gotResult(docIndex, id, docs) {\n\t    perDocResults[docIndex] = {id: id, docs: docs};\n\t    checkDone();\n\t  }\n\t\n\t  var allRequests = [];\n\t  requestsById.forEach(function (value, key) {\n\t    allRequests.push(key);\n\t  });\n\t\n\t  var i = 0;\n\t\n\t  function nextBatch() {\n\t\n\t    if (i >= allRequests.length) {\n\t      return;\n\t    }\n\t\n\t    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n\t    var batch = allRequests.slice(i, upTo);\n\t    processBatch(batch, i);\n\t    i += batch.length;\n\t  }\n\t\n\t  function processBatch(batch, offset) {\n\t    batch.forEach(function (docId, j) {\n\t      var docIdx = offset + j;\n\t      var docRequests = requestsById.get(docId);\n\t\n\t      // just use the first request as the \"template\"\n\t      // TODO: The _bulk_get API allows for more subtle use cases than this,\n\t      // but for now it is unlikely that there will be a mix of different\n\t      // \"atts_since\" or \"attachments\" in the same request, since it's just\n\t      // replicate.js that is using this for the moment.\n\t      // Also, atts_since is aspirational, since we don't support it yet.\n\t      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n\t      docOpts.open_revs = docRequests.map(function (request) {\n\t        // rev is optional, open_revs disallowed\n\t        return request.rev;\n\t      });\n\t\n\t      // remove falsey / undefined revisions\n\t      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\t\n\t      var formatResult = identityFunction;\n\t\n\t      if (docOpts.open_revs.length === 0) {\n\t        delete docOpts.open_revs;\n\t\n\t        // when fetching only the \"winning\" leaf,\n\t        // transform the result so it looks like an open_revs\n\t        // request\n\t        formatResult = formatResultForOpenRevsGet;\n\t      }\n\t\n\t      // globally-supplied options\n\t      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n\t        if (param in opts) {\n\t          docOpts[param] = opts[param];\n\t        }\n\t      });\n\t      db.get(docId, docOpts, function (err, res) {\n\t        var result;\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          result = [{error: err}];\n\t        } else {\n\t          result = formatResult(res);\n\t        }\n\t        gotResult(docIdx, docId, result);\n\t        nextBatch();\n\t      });\n\t    });\n\t  }\n\t\n\t  nextBatch();\n\t\n\t}\n\t\n\tfunction isChromeApp() {\n\t  return (typeof chrome !== \"undefined\" &&\n\t    typeof chrome.storage !== \"undefined\" &&\n\t    typeof chrome.storage.local !== \"undefined\");\n\t}\n\t\n\tvar hasLocal;\n\t\n\tif (isChromeApp()) {\n\t  hasLocal = false;\n\t} else {\n\t  try {\n\t    localStorage.setItem('_pouch_check_localstorage', 1);\n\t    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n\t  } catch (e) {\n\t    hasLocal = false;\n\t  }\n\t}\n\t\n\tfunction hasLocalStorage() {\n\t  return hasLocal;\n\t}\n\t\n\t// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n\t// avoid using process.nextTick() directly because the polyfill is very large and we don't\n\t// need all of it (see: https://github.com/defunctzombie/node-process).\n\t// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n\t// package, so it's the one we use.\n\t// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n\t// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n\t// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n\t// (least latency) option, which is \"immediate\" due to use of microtasks.\n\t// All of our nextTicks are isolated to this one function so we can easily swap out one\n\t// implementation for another.\n\t\n\tinherits(Changes, events.EventEmitter);\n\t\n\t/* istanbul ignore next */\n\tfunction attachBrowserEvents(self) {\n\t  if (isChromeApp()) {\n\t    chrome.storage.onChanged.addListener(function (e) {\n\t      // make sure it's event addressed to us\n\t      if (e.db_name != null) {\n\t        //object only has oldValue, newValue members\n\t        self.emit(e.dbName.newValue);\n\t      }\n\t    });\n\t  } else if (hasLocalStorage()) {\n\t    if (typeof addEventListener !== 'undefined') {\n\t      addEventListener(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    } else { // old IE\n\t      window.attachEvent(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    }\n\t  }\n\t}\n\t\n\tfunction Changes() {\n\t  events.EventEmitter.call(this);\n\t  this._listeners = {};\n\t\n\t  attachBrowserEvents(this);\n\t}\n\tChanges.prototype.addListener = function (dbName, id, db, opts) {\n\t  /* istanbul ignore if */\n\t  if (this._listeners[id]) {\n\t    return;\n\t  }\n\t  var self = this;\n\t  var inprogress = false;\n\t  function eventFunction() {\n\t    /* istanbul ignore if */\n\t    if (!self._listeners[id]) {\n\t      return;\n\t    }\n\t    if (inprogress) {\n\t      inprogress = 'waiting';\n\t      return;\n\t    }\n\t    inprogress = true;\n\t    var changesOpts = pick(opts, [\n\t      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n\t      'doc_ids', 'view', 'since', 'query_params', 'binary'\n\t    ]);\n\t\n\t    /* istanbul ignore next */\n\t    function onError() {\n\t      inprogress = false;\n\t    }\n\t\n\t    db.changes(changesOpts).on('change', function (c) {\n\t      if (c.seq > opts.since && !opts.cancelled) {\n\t        opts.since = c.seq;\n\t        opts.onChange(c);\n\t      }\n\t    }).on('complete', function () {\n\t      if (inprogress === 'waiting') {\n\t        nextTick(eventFunction);\n\t      }\n\t      inprogress = false;\n\t    }).on('error', onError);\n\t  }\n\t  this._listeners[id] = eventFunction;\n\t  this.on(dbName, eventFunction);\n\t};\n\t\n\tChanges.prototype.removeListener = function (dbName, id) {\n\t  /* istanbul ignore if */\n\t  if (!(id in this._listeners)) {\n\t    return;\n\t  }\n\t  events.EventEmitter.prototype.removeListener.call(this, dbName,\n\t    this._listeners[id]);\n\t  delete this._listeners[id];\n\t};\n\t\n\t\n\t/* istanbul ignore next */\n\tChanges.prototype.notifyLocalWindows = function (dbName) {\n\t  //do a useless change on a storage thing\n\t  //in order to get other windows's listeners to activate\n\t  if (isChromeApp()) {\n\t    chrome.storage.local.set({dbName: dbName});\n\t  } else if (hasLocalStorage()) {\n\t    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n\t  }\n\t};\n\t\n\tChanges.prototype.notify = function (dbName) {\n\t  this.emit(dbName);\n\t  this.notifyLocalWindows(dbName);\n\t};\n\t\n\tfunction guardedConsole(method) {\n\t  /* istanbul ignore else */\n\t  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    console[method].apply(console, args);\n\t  }\n\t}\n\t\n\tfunction randomNumber(min, max) {\n\t  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n\t  min = parseInt(min, 10) || 0;\n\t  max = parseInt(max, 10);\n\t  if (max !== max || max <= min) {\n\t    max = (min || 1) << 1; //doubling\n\t  } else {\n\t    max = max + 1;\n\t  }\n\t  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n\t  if (max > maxTimeout) {\n\t    min = maxTimeout >> 1; // divide by two\n\t    max = maxTimeout;\n\t  }\n\t  var ratio = Math.random();\n\t  var range = max - min;\n\t\n\t  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n\t}\n\t\n\tfunction defaultBackOff(min) {\n\t  var max = 0;\n\t  if (!min) {\n\t    max = 2000;\n\t  }\n\t  return randomNumber(min, max);\n\t}\n\t\n\t// designed to give info to browser users, who are disturbed\n\t// when they see http errors in the console\n\tfunction explainError(status, str) {\n\t  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n\t}\n\t\n\tvar assign;\n\t{\n\t  if (typeof Object.assign === 'function') {\n\t    assign = Object.assign;\n\t  } else {\n\t    // lite Object.assign polyfill based on\n\t    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t    assign = function (target) {\n\t      var to = Object(target);\n\t\n\t      for (var index = 1; index < arguments.length; index++) {\n\t        var nextSource = arguments[index];\n\t\n\t        if (nextSource != null) { // Skip over if undefined or null\n\t          for (var nextKey in nextSource) {\n\t            // Avoid bugs when hasOwnProperty is shadowed\n\t            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n\t              to[nextKey] = nextSource[nextKey];\n\t            }\n\t          }\n\t        }\n\t      }\n\t      return to;\n\t    };\n\t  }\n\t}\n\t\n\tvar $inject_Object_assign = assign;\n\t\n\tinherits(PouchError, Error);\n\t\n\tfunction PouchError(status, error, reason) {\n\t  Error.call(this, reason);\n\t  this.status = status;\n\t  this.name = error;\n\t  this.message = reason;\n\t  this.error = true;\n\t}\n\t\n\tPouchError.prototype.toString = function () {\n\t  return JSON.stringify({\n\t    status: this.status,\n\t    name: this.name,\n\t    message: this.message,\n\t    reason: this.reason\n\t  });\n\t};\n\t\n\tvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\n\tvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\n\tvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\n\tvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\n\tvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\n\tvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\n\tvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\n\tvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\n\tvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\n\tvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\n\tvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\n\tvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\n\tvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\n\tvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\n\tvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\n\tvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\n\tvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\n\tvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\n\tvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\n\tvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\n\tvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\n\tvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\n\tvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\n\tvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\t\n\tfunction createError(error, reason) {\n\t  function CustomPouchError(reason) {\n\t    // inherit error properties from our parent error manually\n\t    // so as to allow proper JSON parsing.\n\t    /* jshint ignore:start */\n\t    for (var p in error) {\n\t      if (typeof error[p] !== 'function') {\n\t        this[p] = error[p];\n\t      }\n\t    }\n\t    /* jshint ignore:end */\n\t    if (reason !== undefined) {\n\t      this.reason = reason;\n\t    }\n\t  }\n\t  CustomPouchError.prototype = PouchError.prototype;\n\t  return new CustomPouchError(reason);\n\t}\n\t\n\tfunction generateErrorFromResponse(err) {\n\t\n\t  if (typeof err !== 'object') {\n\t    var data = err;\n\t    err = UNKNOWN_ERROR;\n\t    err.data = data;\n\t  }\n\t\n\t  if ('error' in err && err.error === 'conflict') {\n\t    err.name = 'conflict';\n\t    err.status = 409;\n\t  }\n\t\n\t  if (!('name' in err)) {\n\t    err.name = err.error || 'unknown';\n\t  }\n\t\n\t  if (!('status' in err)) {\n\t    err.status = 500;\n\t  }\n\t\n\t  if (!('message' in err)) {\n\t    err.message = err.message || err.reason;\n\t  }\n\t\n\t  return err;\n\t}\n\t\n\tfunction tryFilter(filter, doc, req) {\n\t  try {\n\t    return !filter(doc, req);\n\t  } catch (err) {\n\t    var msg = 'Filter function threw: ' + err.toString();\n\t    return createError(BAD_REQUEST, msg);\n\t  }\n\t}\n\t\n\tfunction filterChange(opts) {\n\t  var req = {};\n\t  var hasFilter = opts.filter && typeof opts.filter === 'function';\n\t  req.query = opts.query_params;\n\t\n\t  return function filter(change) {\n\t    if (!change.doc) {\n\t      // CSG sends events on the changes feed that don't have documents,\n\t      // this hack makes a whole lot of existing code robust.\n\t      change.doc = {};\n\t    }\n\t\n\t    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\t\n\t    if (typeof filterReturn === 'object') {\n\t      return filterReturn;\n\t    }\n\t\n\t    if (filterReturn) {\n\t      return false;\n\t    }\n\t\n\t    if (!opts.include_docs) {\n\t      delete change.doc;\n\t    } else if (!opts.attachments) {\n\t      for (var att in change.doc._attachments) {\n\t        /* istanbul ignore else */\n\t        if (change.doc._attachments.hasOwnProperty(att)) {\n\t          change.doc._attachments[att].stub = true;\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  };\n\t}\n\t\n\tfunction flatten(arrs) {\n\t  var res = [];\n\t  for (var i = 0, len = arrs.length; i < len; i++) {\n\t    res = res.concat(arrs[i]);\n\t  }\n\t  return res;\n\t}\n\t\n\t// shim for Function.prototype.name,\n\t// for browsers that don't support it like IE\n\t\n\t/* istanbul ignore next */\n\t\n\t// Determine id an ID is valid\n\t//   - invalid IDs begin with an underescore that does not begin '_design' or\n\t//     '_local'\n\t//   - any other string value is a valid id\n\t// Returns the specific error object for each case\n\tfunction invalidIdError(id) {\n\t  var err;\n\t  if (!id) {\n\t    err = createError(MISSING_ID);\n\t  } else if (typeof id !== 'string') {\n\t    err = createError(INVALID_ID);\n\t  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n\t    err = createError(RESERVED_ID);\n\t  }\n\t  if (err) {\n\t    throw err;\n\t  }\n\t}\n\t\n\t// Checks if a PouchDB object is \"remote\" or not. This is\n\t// designed to opt-in to certain optimizations, such as\n\t// avoiding checks for \"dependentDbs\" and other things that\n\t// we know only apply to local databases. In general, \"remote\"\n\t// should be true for the http adapter, and for third-party\n\t// adapters with similar expensive boundaries to cross for\n\t// every API call, such as socket-pouch and worker-pouch.\n\t// Previously, this was handled via db.type() === 'http'\n\t// which is now deprecated.\n\t\n\tfunction isRemote(db) {\n\t  if (typeof db._remote === 'boolean') {\n\t    return db._remote;\n\t  }\n\t  /* istanbul ignore next */\n\t  if (typeof db.type === 'function') {\n\t    guardedConsole('warn',\n\t      'db.type() is deprecated and will be removed in ' +\n\t      'a future version of PouchDB');\n\t    return db.type() === 'http';\n\t  }\n\t  /* istanbul ignore next */\n\t  return false;\n\t}\n\t\n\tfunction listenerCount(ee, type) {\n\t  return 'listenerCount' in ee ? ee.listenerCount(type) :\n\t                                 events.EventEmitter.listenerCount(ee, type);\n\t}\n\t\n\tfunction parseDesignDocFunctionName(s) {\n\t  if (!s) {\n\t    return null;\n\t  }\n\t  var parts = s.split('/');\n\t  if (parts.length === 2) {\n\t    return parts;\n\t  }\n\t  if (parts.length === 1) {\n\t    return [s, s];\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction normalizeDesignDocFunctionName(s) {\n\t  var normalized = parseDesignDocFunctionName(s);\n\t  return normalized ? normalized.join('/') : null;\n\t}\n\t\n\t// originally parseUri 1.2.2, now patched by us\n\t// (c) Steven Levithan <stevenlevithan.com>\n\t// MIT License\n\tvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n\t    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n\tvar qName =\"queryKey\";\n\tvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\t\n\t// use the \"loose\" parser\n\t/* eslint maxlen: 0, no-useless-escape: 0 */\n\tvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\t\n\tfunction parseUri(str) {\n\t  var m = parser.exec(str);\n\t  var uri = {};\n\t  var i = 14;\n\t\n\t  while (i--) {\n\t    var key = keys[i];\n\t    var value = m[i] || \"\";\n\t    var encoded = ['user', 'password'].indexOf(key) !== -1;\n\t    uri[key] = encoded ? decodeURIComponent(value) : value;\n\t  }\n\t\n\t  uri[qName] = {};\n\t  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n\t    if ($1) {\n\t      uri[qName][$1] = $2;\n\t    }\n\t  });\n\t\n\t  return uri;\n\t}\n\t\n\t// Based on https://github.com/alexdavid/scope-eval v0.0.3\n\t// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n\t// This is basically just a wrapper around new Function()\n\t\n\tfunction scopeEval(source, scope) {\n\t  var keys = [];\n\t  var values = [];\n\t  for (var key in scope) {\n\t    if (scope.hasOwnProperty(key)) {\n\t      keys.push(key);\n\t      values.push(scope[key]);\n\t    }\n\t  }\n\t  keys.push(source);\n\t  return Function.apply(null, keys).apply(null, values);\n\t}\n\t\n\t// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n\t// the diffFun tells us what delta to apply to the doc.  it either returns\n\t// the doc, or false if it doesn't need to do an update after all\n\tfunction upsert(db, docId, diffFun) {\n\t  return new PouchPromise(function (fulfill, reject) {\n\t    db.get(docId, function (err, doc) {\n\t      if (err) {\n\t        /* istanbul ignore next */\n\t        if (err.status !== 404) {\n\t          return reject(err);\n\t        }\n\t        doc = {};\n\t      }\n\t\n\t      // the user might change the _rev, so save it for posterity\n\t      var docRev = doc._rev;\n\t      var newDoc = diffFun(doc);\n\t\n\t      if (!newDoc) {\n\t        // if the diffFun returns falsy, we short-circuit as\n\t        // an optimization\n\t        return fulfill({updated: false, rev: docRev});\n\t      }\n\t\n\t      // users aren't allowed to modify these values,\n\t      // so reset them here\n\t      newDoc._id = docId;\n\t      newDoc._rev = docRev;\n\t      fulfill(tryAndPut(db, newDoc, diffFun));\n\t    });\n\t  });\n\t}\n\t\n\tfunction tryAndPut(db, doc, diffFun) {\n\t  return db.put(doc).then(function (res) {\n\t    return {\n\t      updated: true,\n\t      rev: res.rev\n\t    };\n\t  }, function (err) {\n\t    /* istanbul ignore next */\n\t    if (err.status !== 409) {\n\t      throw err;\n\t    }\n\t    return upsert(db, doc._id, diffFun);\n\t  });\n\t}\n\t\n\tfunction rev() {\n\t  return uuidV4.v4().replace(/-/g, '').toLowerCase();\n\t}\n\t\n\tvar uuid = uuidV4.v4;\n\t\n\t// We fetch all leafs of the revision tree, and sort them based on tree length\n\t// and whether they were deleted, undeleted documents with the longest revision\n\t// tree (most edits) win\n\t// The final sort algorithm is slightly documented in a sidebar here:\n\t// http://guide.couchdb.org/draft/conflicts.html\n\tfunction winningRev(metadata) {\n\t  var winningId;\n\t  var winningPos;\n\t  var winningDeleted;\n\t  var toVisit = metadata.rev_tree.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var tree = node.ids;\n\t    var branches = tree[2];\n\t    var pos = node.pos;\n\t    if (branches.length) { // non-leaf\n\t      for (var i = 0, len = branches.length; i < len; i++) {\n\t        toVisit.push({pos: pos + 1, ids: branches[i]});\n\t      }\n\t      continue;\n\t    }\n\t    var deleted = !!tree[1].deleted;\n\t    var id = tree[0];\n\t    // sort by deleted, then pos, then id\n\t    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n\t        winningPos !== pos ? winningPos < pos : winningId < id)) {\n\t      winningId = id;\n\t      winningPos = pos;\n\t      winningDeleted = deleted;\n\t    }\n\t  }\n\t\n\t  return winningPos + '-' + winningId;\n\t}\n\t\n\t// Pretty much all below can be combined into a higher order function to\n\t// traverse revisions\n\t// The return value from the callback will be passed as context to all\n\t// children of that node\n\tfunction traverseRevTree(revs, callback) {\n\t  var toVisit = revs.slice();\n\t\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var branches = tree[2];\n\t    var newCtx =\n\t      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n\t    }\n\t  }\n\t}\n\t\n\tfunction sortByPos(a, b) {\n\t  return a.pos - b.pos;\n\t}\n\t\n\tfunction collectLeaves(revs) {\n\t  var leaves = [];\n\t  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n\t    if (isLeaf) {\n\t      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n\t    }\n\t  });\n\t  leaves.sort(sortByPos).reverse();\n\t  for (var i = 0, len = leaves.length; i < len; i++) {\n\t    delete leaves[i].pos;\n\t  }\n\t  return leaves;\n\t}\n\t\n\t// returns revs of all conflicts that is leaves such that\n\t// 1. are not deleted and\n\t// 2. are different than winning revision\n\tfunction collectConflicts(metadata) {\n\t  var win = winningRev(metadata);\n\t  var leaves = collectLeaves(metadata.rev_tree);\n\t  var conflicts = [];\n\t  for (var i = 0, len = leaves.length; i < len; i++) {\n\t    var leaf = leaves[i];\n\t    if (leaf.rev !== win && !leaf.opts.deleted) {\n\t      conflicts.push(leaf.rev);\n\t    }\n\t  }\n\t  return conflicts;\n\t}\n\t\n\t// compact a tree by marking its non-leafs as missing,\n\t// and return a list of revs to delete\n\tfunction compactTree(metadata) {\n\t  var revs = [];\n\t  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                               revHash, ctx, opts) {\n\t    if (opts.status === 'available' && !isLeaf) {\n\t      revs.push(pos + '-' + revHash);\n\t      opts.status = 'missing';\n\t    }\n\t  });\n\t  return revs;\n\t}\n\t\n\t// build up a list of all the paths to the leafs in this revision tree\n\tfunction rootToLeaf(revs) {\n\t  var paths = [];\n\t  var toVisit = revs.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var id = tree[0];\n\t    var opts = tree[1];\n\t    var branches = tree[2];\n\t    var isLeaf = branches.length === 0;\n\t\n\t    var history = node.history ? node.history.slice() : [];\n\t    history.push({id: id, opts: opts});\n\t    if (isLeaf) {\n\t      paths.push({pos: (pos + 1 - history.length), ids: history});\n\t    }\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n\t    }\n\t  }\n\t  return paths.reverse();\n\t}\n\t\n\t// for a better overview of what this is doing, read:\n\t// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n\t//\n\t// But for a quick intro, CouchDB uses a revision tree to store a documents\n\t// history, A -> B -> C, when a document has conflicts, that is a branch in the\n\t// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n\t//\n\t// KeyTree = [Path ... ]\n\t// Path = {pos: position_from_root, ids: Tree}\n\t// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\t\n\tfunction sortByPos$1(a, b) {\n\t  return a.pos - b.pos;\n\t}\n\t\n\t// classic binary search\n\tfunction binarySearch(arr, item, comparator) {\n\t  var low = 0;\n\t  var high = arr.length;\n\t  var mid;\n\t  while (low < high) {\n\t    mid = (low + high) >>> 1;\n\t    if (comparator(arr[mid], item) < 0) {\n\t      low = mid + 1;\n\t    } else {\n\t      high = mid;\n\t    }\n\t  }\n\t  return low;\n\t}\n\t\n\t// assuming the arr is sorted, insert the item in the proper place\n\tfunction insertSorted(arr, item, comparator) {\n\t  var idx = binarySearch(arr, item, comparator);\n\t  arr.splice(idx, 0, item);\n\t}\n\t\n\t// Turn a path as a flat array into a tree with a single branch.\n\t// If any should be stemmed from the beginning of the array, that's passed\n\t// in as the second argument\n\tfunction pathToTree(path, numStemmed) {\n\t  var root;\n\t  var leaf;\n\t  for (var i = numStemmed, len = path.length; i < len; i++) {\n\t    var node = path[i];\n\t    var currentLeaf = [node.id, node.opts, []];\n\t    if (leaf) {\n\t      leaf[2].push(currentLeaf);\n\t      leaf = currentLeaf;\n\t    } else {\n\t      root = leaf = currentLeaf;\n\t    }\n\t  }\n\t  return root;\n\t}\n\t\n\t// compare the IDs of two trees\n\tfunction compareTree(a, b) {\n\t  return a[0] < b[0] ? -1 : 1;\n\t}\n\t\n\t// Merge two trees together\n\t// The roots of tree1 and tree2 must be the same revision\n\tfunction mergeTree(in_tree1, in_tree2) {\n\t  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n\t  var conflicts = false;\n\t  while (queue.length > 0) {\n\t    var item = queue.pop();\n\t    var tree1 = item.tree1;\n\t    var tree2 = item.tree2;\n\t\n\t    if (tree1[1].status || tree2[1].status) {\n\t      tree1[1].status =\n\t        (tree1[1].status ===  'available' ||\n\t        tree2[1].status === 'available') ? 'available' : 'missing';\n\t    }\n\t\n\t    for (var i = 0; i < tree2[2].length; i++) {\n\t      if (!tree1[2][0]) {\n\t        conflicts = 'new_leaf';\n\t        tree1[2][0] = tree2[2][i];\n\t        continue;\n\t      }\n\t\n\t      var merged = false;\n\t      for (var j = 0; j < tree1[2].length; j++) {\n\t        if (tree1[2][j][0] === tree2[2][i][0]) {\n\t          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n\t          merged = true;\n\t        }\n\t      }\n\t      if (!merged) {\n\t        conflicts = 'new_branch';\n\t        insertSorted(tree1[2], tree2[2][i], compareTree);\n\t      }\n\t    }\n\t  }\n\t  return {conflicts: conflicts, tree: in_tree1};\n\t}\n\t\n\tfunction doMerge(tree, path, dontExpand) {\n\t  var restree = [];\n\t  var conflicts = false;\n\t  var merged = false;\n\t  var res;\n\t\n\t  if (!tree.length) {\n\t    return {tree: [path], conflicts: 'new_leaf'};\n\t  }\n\t\n\t  for (var i = 0, len = tree.length; i < len; i++) {\n\t    var branch = tree[i];\n\t    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n\t      // Paths start at the same position and have the same root, so they need\n\t      // merged\n\t      res = mergeTree(branch.ids, path.ids);\n\t      restree.push({pos: branch.pos, ids: res.tree});\n\t      conflicts = conflicts || res.conflicts;\n\t      merged = true;\n\t    } else if (dontExpand !== true) {\n\t      // The paths start at a different position, take the earliest path and\n\t      // traverse up until it as at the same point from root as the path we\n\t      // want to merge.  If the keys match we return the longer path with the\n\t      // other merged After stemming we dont want to expand the trees\n\t\n\t      var t1 = branch.pos < path.pos ? branch : path;\n\t      var t2 = branch.pos < path.pos ? path : branch;\n\t      var diff = t2.pos - t1.pos;\n\t\n\t      var candidateParents = [];\n\t\n\t      var trees = [];\n\t      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n\t      while (trees.length > 0) {\n\t        var item = trees.pop();\n\t        if (item.diff === 0) {\n\t          if (item.ids[0] === t2.ids[0]) {\n\t            candidateParents.push(item);\n\t          }\n\t          continue;\n\t        }\n\t        var elements = item.ids[2];\n\t        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n\t          trees.push({\n\t            ids: elements[j],\n\t            diff: item.diff - 1,\n\t            parent: item.ids,\n\t            parentIdx: j\n\t          });\n\t        }\n\t      }\n\t\n\t      var el = candidateParents[0];\n\t\n\t      if (!el) {\n\t        restree.push(branch);\n\t      } else {\n\t        res = mergeTree(el.ids, t2.ids);\n\t        el.parent[2][el.parentIdx] = res.tree;\n\t        restree.push({pos: t1.pos, ids: t1.ids});\n\t        conflicts = conflicts || res.conflicts;\n\t        merged = true;\n\t      }\n\t    } else {\n\t      restree.push(branch);\n\t    }\n\t  }\n\t\n\t  // We didnt find\n\t  if (!merged) {\n\t    restree.push(path);\n\t  }\n\t\n\t  restree.sort(sortByPos$1);\n\t\n\t  return {\n\t    tree: restree,\n\t    conflicts: conflicts || 'internal_node'\n\t  };\n\t}\n\t\n\t// To ensure we dont grow the revision tree infinitely, we stem old revisions\n\tfunction stem(tree, depth) {\n\t  // First we break out the tree into a complete list of root to leaf paths\n\t  var paths = rootToLeaf(tree);\n\t  var stemmedRevs;\n\t\n\t  var result;\n\t  for (var i = 0, len = paths.length; i < len; i++) {\n\t    // Then for each path, we cut off the start of the path based on the\n\t    // `depth` to stem to, and generate a new set of flat trees\n\t    var path = paths[i];\n\t    var stemmed = path.ids;\n\t    var node;\n\t    if (stemmed.length > depth) {\n\t      // only do the stemming work if we actually need to stem\n\t      if (!stemmedRevs) {\n\t        stemmedRevs = {}; // avoid allocating this object unnecessarily\n\t      }\n\t      var numStemmed = stemmed.length - depth;\n\t      node = {\n\t        pos: path.pos + numStemmed,\n\t        ids: pathToTree(stemmed, numStemmed)\n\t      };\n\t\n\t      for (var s = 0; s < numStemmed; s++) {\n\t        var rev = (path.pos + s) + '-' + stemmed[s].id;\n\t        stemmedRevs[rev] = true;\n\t      }\n\t    } else { // no need to actually stem\n\t      node = {\n\t        pos: path.pos,\n\t        ids: pathToTree(stemmed, 0)\n\t      };\n\t    }\n\t\n\t    // Then we remerge all those flat trees together, ensuring that we dont\n\t    // connect trees that would go beyond the depth limit\n\t    if (result) {\n\t      result = doMerge(result, node, true).tree;\n\t    } else {\n\t      result = [node];\n\t    }\n\t  }\n\t\n\t  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n\t  if (stemmedRevs) {\n\t    traverseRevTree(result, function (isLeaf, pos, revHash) {\n\t      // some revisions may have been removed in a branch but not in another\n\t      delete stemmedRevs[pos + '-' + revHash];\n\t    });\n\t  }\n\t\n\t  return {\n\t    tree: result,\n\t    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n\t  };\n\t}\n\t\n\tfunction merge(tree, path, depth) {\n\t  var newTree = doMerge(tree, path);\n\t  var stemmed = stem(newTree.tree, depth);\n\t  return {\n\t    tree: stemmed.tree,\n\t    stemmedRevs: stemmed.revs,\n\t    conflicts: newTree.conflicts\n\t  };\n\t}\n\t\n\t// return true if a rev exists in the rev tree, false otherwise\n\tfunction revExists(revs, rev) {\n\t  var toVisit = revs.slice();\n\t  var splitRev = rev.split('-');\n\t  var targetPos = parseInt(splitRev[0], 10);\n\t  var targetId = splitRev[1];\n\t\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    if (node.pos === targetPos && node.ids[0] === targetId) {\n\t      return true;\n\t    }\n\t    var branches = node.ids[2];\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\tfunction getTrees(node) {\n\t  return node.ids;\n\t}\n\t\n\t// check if a specific revision of a doc has been deleted\n\t//  - metadata: the metadata object from the doc store\n\t//  - rev: (optional) the revision to check. defaults to winning revision\n\tfunction isDeleted(metadata, rev) {\n\t  if (!rev) {\n\t    rev = winningRev(metadata);\n\t  }\n\t  var id = rev.substring(rev.indexOf('-') + 1);\n\t  var toVisit = metadata.rev_tree.map(getTrees);\n\t\n\t  var tree;\n\t  while ((tree = toVisit.pop())) {\n\t    if (tree[0] === id) {\n\t      return !!tree[1].deleted;\n\t    }\n\t    toVisit = toVisit.concat(tree[2]);\n\t  }\n\t}\n\t\n\tfunction isLocalId(id) {\n\t  return (/^_local/).test(id);\n\t}\n\t\n\t// returns the current leaf node for a given revision\n\tfunction latest(rev, metadata) {\n\t  var toVisit = metadata.rev_tree.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var id = tree[0];\n\t    var opts = tree[1];\n\t    var branches = tree[2];\n\t    var isLeaf = branches.length === 0;\n\t\n\t    var history = node.history ? node.history.slice() : [];\n\t    history.push({id: id, pos: pos, opts: opts});\n\t\n\t    if (isLeaf) {\n\t      for (var i = 0, len = history.length; i < len; i++) {\n\t        var historyNode = history[i];\n\t        var historyRev = historyNode.pos + '-' + historyNode.id;\n\t\n\t        if (historyRev === rev) {\n\t          // return the rev of this leaf\n\t          return pos + '-' + id;\n\t        }\n\t      }\n\t    }\n\t\n\t    for (var j = 0, l = branches.length; j < l; j++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n\t    }\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n\t}\n\t\n\tinherits(Changes$2, events.EventEmitter);\n\t\n\tfunction tryCatchInChangeListener(self, change, pending, lastSeq) {\n\t  // isolate try/catches to avoid V8 deoptimizations\n\t  try {\n\t    self.emit('change', change, pending, lastSeq);\n\t  } catch (e) {\n\t    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n\t  }\n\t}\n\t\n\tfunction Changes$2(db, opts, callback) {\n\t  events.EventEmitter.call(this);\n\t  var self = this;\n\t  this.db = db;\n\t  opts = opts ? clone(opts) : {};\n\t  var complete = opts.complete = once(function (err, resp) {\n\t    if (err) {\n\t      if (listenerCount(self, 'error') > 0) {\n\t        self.emit('error', err);\n\t      }\n\t    } else {\n\t      self.emit('complete', resp);\n\t    }\n\t    self.removeAllListeners();\n\t    db.removeListener('destroyed', onDestroy);\n\t  });\n\t  if (callback) {\n\t    self.on('complete', function (resp) {\n\t      callback(null, resp);\n\t    });\n\t    self.on('error', callback);\n\t  }\n\t  function onDestroy() {\n\t    self.cancel();\n\t  }\n\t  db.once('destroyed', onDestroy);\n\t\n\t  opts.onChange = function (change, pending, lastSeq) {\n\t    /* istanbul ignore if */\n\t    if (self.isCancelled) {\n\t      return;\n\t    }\n\t    tryCatchInChangeListener(self, change, pending, lastSeq);\n\t  };\n\t\n\t  var promise = new PouchPromise(function (fulfill, reject) {\n\t    opts.complete = function (err, res) {\n\t      if (err) {\n\t        reject(err);\n\t      } else {\n\t        fulfill(res);\n\t      }\n\t    };\n\t  });\n\t  self.once('cancel', function () {\n\t    db.removeListener('destroyed', onDestroy);\n\t    opts.complete(null, {status: 'cancelled'});\n\t  });\n\t  this.then = promise.then.bind(promise);\n\t  this['catch'] = promise['catch'].bind(promise);\n\t  this.then(function (result) {\n\t    complete(null, result);\n\t  }, complete);\n\t\n\t\n\t\n\t  if (!db.taskqueue.isReady) {\n\t    db.taskqueue.addTask(function (failed) {\n\t      if (failed) {\n\t        opts.complete(failed);\n\t      } else if (self.isCancelled) {\n\t        self.emit('cancel');\n\t      } else {\n\t        self.validateChanges(opts);\n\t      }\n\t    });\n\t  } else {\n\t    self.validateChanges(opts);\n\t  }\n\t}\n\tChanges$2.prototype.cancel = function () {\n\t  this.isCancelled = true;\n\t  if (this.db.taskqueue.isReady) {\n\t    this.emit('cancel');\n\t  }\n\t};\n\tfunction processChange(doc, metadata, opts) {\n\t  var changeList = [{rev: doc._rev}];\n\t  if (opts.style === 'all_docs') {\n\t    changeList = collectLeaves(metadata.rev_tree)\n\t    .map(function (x) { return {rev: x.rev}; });\n\t  }\n\t  var change = {\n\t    id: metadata.id,\n\t    changes: changeList,\n\t    doc: doc\n\t  };\n\t\n\t  if (isDeleted(metadata, doc._rev)) {\n\t    change.deleted = true;\n\t  }\n\t  if (opts.conflicts) {\n\t    change.doc._conflicts = collectConflicts(metadata);\n\t    if (!change.doc._conflicts.length) {\n\t      delete change.doc._conflicts;\n\t    }\n\t  }\n\t  return change;\n\t}\n\t\n\tChanges$2.prototype.validateChanges = function (opts) {\n\t  var callback = opts.complete;\n\t  var self = this;\n\t\n\t  /* istanbul ignore else */\n\t  if (PouchDB._changesFilterPlugin) {\n\t    PouchDB._changesFilterPlugin.validate(opts, function (err) {\n\t      if (err) {\n\t        return callback(err);\n\t      }\n\t      self.doChanges(opts);\n\t    });\n\t  } else {\n\t    self.doChanges(opts);\n\t  }\n\t};\n\t\n\tChanges$2.prototype.doChanges = function (opts) {\n\t  var self = this;\n\t  var callback = opts.complete;\n\t\n\t  opts = clone(opts);\n\t  if ('live' in opts && !('continuous' in opts)) {\n\t    opts.continuous = opts.live;\n\t  }\n\t  opts.processChange = processChange;\n\t\n\t  if (opts.since === 'latest') {\n\t    opts.since = 'now';\n\t  }\n\t  if (!opts.since) {\n\t    opts.since = 0;\n\t  }\n\t  if (opts.since === 'now') {\n\t    this.db.info().then(function (info) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        callback(null, {status: 'cancelled'});\n\t        return;\n\t      }\n\t      opts.since = info.update_seq;\n\t      self.doChanges(opts);\n\t    }, callback);\n\t    return;\n\t  }\n\t\n\t  /* istanbul ignore else */\n\t  if (PouchDB._changesFilterPlugin) {\n\t    PouchDB._changesFilterPlugin.normalize(opts);\n\t    if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {\n\t      return PouchDB._changesFilterPlugin.filter(this, opts);\n\t    }\n\t  } else {\n\t    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n\t      if (key in opts) {\n\t        guardedConsole('warn',\n\t          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n\t          'but pouchdb-changes-filter plugin is not installed, so it ' +\n\t          'was ignored. Please install the plugin to enable filtering.'\n\t        );\n\t      }\n\t    });\n\t  }\n\t\n\t  if (!('descending' in opts)) {\n\t    opts.descending = false;\n\t  }\n\t\n\t  // 0 and 1 should return 1 document\n\t  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n\t  opts.complete = callback;\n\t  var newPromise = this.db._changes(opts);\n\t  /* istanbul ignore else */\n\t  if (newPromise && typeof newPromise.cancel === 'function') {\n\t    var cancel = self.cancel;\n\t    self.cancel = getArguments(function (args) {\n\t      newPromise.cancel();\n\t      cancel.apply(this, args);\n\t    });\n\t  }\n\t};\n\t\n\t/*\n\t * A generic pouch adapter\n\t */\n\t\n\tfunction compare(left, right) {\n\t  return left < right ? -1 : left > right ? 1 : 0;\n\t}\n\t\n\t// Wrapper for functions that call the bulkdocs api with a single doc,\n\t// if the first result is an error, return an error\n\tfunction yankError(callback, docId) {\n\t  return function (err, results) {\n\t    if (err || (results[0] && results[0].error)) {\n\t      err = err || results[0];\n\t      err.docId = docId;\n\t      callback(err);\n\t    } else {\n\t      callback(null, results.length ? results[0]  : results);\n\t    }\n\t  };\n\t}\n\t\n\t// clean docs given to us by the user\n\tfunction cleanDocs(docs) {\n\t  for (var i = 0; i < docs.length; i++) {\n\t    var doc = docs[i];\n\t    if (doc._deleted) {\n\t      delete doc._attachments; // ignore atts for deleted docs\n\t    } else if (doc._attachments) {\n\t      // filter out extraneous keys from _attachments\n\t      var atts = Object.keys(doc._attachments);\n\t      for (var j = 0; j < atts.length; j++) {\n\t        var att = atts[j];\n\t        doc._attachments[att] = pick(doc._attachments[att],\n\t          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// compare two docs, first by _id then by _rev\n\tfunction compareByIdThenRev(a, b) {\n\t  var idCompare = compare(a._id, b._id);\n\t  if (idCompare !== 0) {\n\t    return idCompare;\n\t  }\n\t  var aStart = a._revisions ? a._revisions.start : 0;\n\t  var bStart = b._revisions ? b._revisions.start : 0;\n\t  return compare(aStart, bStart);\n\t}\n\t\n\t// for every node in a revision tree computes its distance from the closest\n\t// leaf\n\tfunction computeHeight(revs) {\n\t  var height = {};\n\t  var edges = [];\n\t  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n\t    var rev$$1 = pos + \"-\" + id;\n\t    if (isLeaf) {\n\t      height[rev$$1] = 0;\n\t    }\n\t    if (prnt !== undefined) {\n\t      edges.push({from: prnt, to: rev$$1});\n\t    }\n\t    return rev$$1;\n\t  });\n\t\n\t  edges.reverse();\n\t  edges.forEach(function (edge) {\n\t    if (height[edge.from] === undefined) {\n\t      height[edge.from] = 1 + height[edge.to];\n\t    } else {\n\t      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n\t    }\n\t  });\n\t  return height;\n\t}\n\t\n\tfunction allDocsKeysParse(opts) {\n\t  var keys =  ('limit' in opts) ?\n\t    opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n\t    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n\t  opts.keys = keys;\n\t  opts.skip = 0;\n\t  delete opts.limit;\n\t  if (opts.descending) {\n\t    keys.reverse();\n\t    opts.descending = false;\n\t  }\n\t}\n\t\n\t// all compaction is done in a queue, to avoid attaching\n\t// too many listeners at once\n\tfunction doNextCompaction(self) {\n\t  var task = self._compactionQueue[0];\n\t  var opts = task.opts;\n\t  var callback = task.callback;\n\t  self.get('_local/compaction').catch(function () {\n\t    return false;\n\t  }).then(function (doc) {\n\t    if (doc && doc.last_seq) {\n\t      opts.last_seq = doc.last_seq;\n\t    }\n\t    self._compact(opts, function (err, res) {\n\t      /* istanbul ignore if */\n\t      if (err) {\n\t        callback(err);\n\t      } else {\n\t        callback(null, res);\n\t      }\n\t      nextTick(function () {\n\t        self._compactionQueue.shift();\n\t        if (self._compactionQueue.length) {\n\t          doNextCompaction(self);\n\t        }\n\t      });\n\t    });\n\t  });\n\t}\n\t\n\tfunction attachmentNameError(name) {\n\t  if (name.charAt(0) === '_') {\n\t    return name + ' is not a valid attachment name, attachment ' +\n\t      'names cannot start with \\'_\\'';\n\t  }\n\t  return false;\n\t}\n\t\n\tinherits(AbstractPouchDB, events.EventEmitter);\n\t\n\tfunction AbstractPouchDB() {\n\t  events.EventEmitter.call(this);\n\t}\n\t\n\tAbstractPouchDB.prototype.post =\n\t  adapterFun('post', function (doc, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof doc !== 'object' || Array.isArray(doc)) {\n\t    return callback(createError(NOT_AN_OBJECT));\n\t  }\n\t  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n\t});\n\t\n\tAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n\t  if (typeof opts === 'function') {\n\t    cb = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof doc !== 'object' || Array.isArray(doc)) {\n\t    return cb(createError(NOT_AN_OBJECT));\n\t  }\n\t  invalidIdError(doc._id);\n\t  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n\t    if (doc._deleted) {\n\t      return this._removeLocal(doc, cb);\n\t    } else {\n\t      return this._putLocal(doc, cb);\n\t    }\n\t  }\n\t  var self = this;\n\t  if (opts.force && doc._rev) {\n\t    transformForceOptionToNewEditsOption();\n\t    putDoc(function (err) {\n\t      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n\t      cb(err, result);\n\t    });\n\t  } else {\n\t    putDoc(cb);\n\t  }\n\t\n\t  function transformForceOptionToNewEditsOption() {\n\t    var parts = doc._rev.split('-');\n\t    var oldRevId = parts[1];\n\t    var oldRevNum = parseInt(parts[0], 10);\n\t\n\t    var newRevNum = oldRevNum + 1;\n\t    var newRevId = rev();\n\t\n\t    doc._revisions = {\n\t      start: newRevNum,\n\t      ids: [newRevId, oldRevId]\n\t    };\n\t    doc._rev = newRevNum + '-' + newRevId;\n\t    opts.new_edits = false;\n\t  }\n\t  function putDoc(next) {\n\t    if (typeof self._put === 'function' && opts.new_edits !== false) {\n\t      self._put(doc, opts, next);\n\t    } else {\n\t      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n\t    }\n\t  }\n\t});\n\t\n\tAbstractPouchDB.prototype.putAttachment =\n\t  adapterFun('putAttachment', function (docId, attachmentId, rev$$1,\n\t                                              blob, type) {\n\t  var api = this;\n\t  if (typeof type === 'function') {\n\t    type = blob;\n\t    blob = rev$$1;\n\t    rev$$1 = null;\n\t  }\n\t  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n\t  /* istanbul ignore if */\n\t  if (typeof type === 'undefined') {\n\t    type = blob;\n\t    blob = rev$$1;\n\t    rev$$1 = null;\n\t  }\n\t  if (!type) {\n\t    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n\t  }\n\t\n\t  function createAttachment(doc) {\n\t    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n\t    doc._attachments = doc._attachments || {};\n\t    doc._attachments[attachmentId] = {\n\t      content_type: type,\n\t      data: blob,\n\t      revpos: ++prevrevpos\n\t    };\n\t    return api.put(doc);\n\t  }\n\t\n\t  return api.get(docId).then(function (doc) {\n\t    if (doc._rev !== rev$$1) {\n\t      throw createError(REV_CONFLICT);\n\t    }\n\t\n\t    return createAttachment(doc);\n\t  }, function (err) {\n\t     // create new doc\n\t    /* istanbul ignore else */\n\t    if (err.reason === MISSING_DOC.message) {\n\t      return createAttachment({_id: docId});\n\t    } else {\n\t      throw err;\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.removeAttachment =\n\t  adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,\n\t                                                 callback) {\n\t  var self = this;\n\t  self.get(docId, function (err, obj) {\n\t    /* istanbul ignore if */\n\t    if (err) {\n\t      callback(err);\n\t      return;\n\t    }\n\t    if (obj._rev !== rev$$1) {\n\t      callback(createError(REV_CONFLICT));\n\t      return;\n\t    }\n\t    /* istanbul ignore if */\n\t    if (!obj._attachments) {\n\t      return callback();\n\t    }\n\t    delete obj._attachments[attachmentId];\n\t    if (Object.keys(obj._attachments).length === 0) {\n\t      delete obj._attachments;\n\t    }\n\t    self.put(obj, callback);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.remove =\n\t  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n\t  var doc;\n\t  if (typeof optsOrRev === 'string') {\n\t    // id, rev, opts, callback style\n\t    doc = {\n\t      _id: docOrId,\n\t      _rev: optsOrRev\n\t    };\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t  } else {\n\t    // doc, opts, callback style\n\t    doc = docOrId;\n\t    if (typeof optsOrRev === 'function') {\n\t      callback = optsOrRev;\n\t      opts = {};\n\t    } else {\n\t      callback = opts;\n\t      opts = optsOrRev;\n\t    }\n\t  }\n\t  opts = opts || {};\n\t  opts.was_delete = true;\n\t  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n\t  newDoc._deleted = true;\n\t  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n\t    return this._removeLocal(doc, callback);\n\t  }\n\t  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n\t});\n\t\n\tAbstractPouchDB.prototype.revsDiff =\n\t  adapterFun('revsDiff', function (req, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  var ids = Object.keys(req);\n\t\n\t  if (!ids.length) {\n\t    return callback(null, {});\n\t  }\n\t\n\t  var count = 0;\n\t  var missing = new ExportedMap();\n\t\n\t  function addToMissing(id, revId) {\n\t    if (!missing.has(id)) {\n\t      missing.set(id, {missing: []});\n\t    }\n\t    missing.get(id).missing.push(revId);\n\t  }\n\t\n\t  function processDoc(id, rev_tree) {\n\t    // Is this fast enough? Maybe we should switch to a set simulated by a map\n\t    var missingForId = req[id].slice(0);\n\t    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n\t      opts) {\n\t        var rev$$1 = pos + '-' + revHash;\n\t        var idx = missingForId.indexOf(rev$$1);\n\t        if (idx === -1) {\n\t          return;\n\t        }\n\t\n\t        missingForId.splice(idx, 1);\n\t        /* istanbul ignore if */\n\t        if (opts.status !== 'available') {\n\t          addToMissing(id, rev$$1);\n\t        }\n\t      });\n\t\n\t    // Traversing the tree is synchronous, so now `missingForId` contains\n\t    // revisions that were not found in the tree\n\t    missingForId.forEach(function (rev$$1) {\n\t      addToMissing(id, rev$$1);\n\t    });\n\t  }\n\t\n\t  ids.map(function (id) {\n\t    this._getRevisionTree(id, function (err, rev_tree) {\n\t      if (err && err.status === 404 && err.message === 'missing') {\n\t        missing.set(id, {missing: req[id]});\n\t      } else if (err) {\n\t        /* istanbul ignore next */\n\t        return callback(err);\n\t      } else {\n\t        processDoc(id, rev_tree);\n\t      }\n\t\n\t      if (++count === ids.length) {\n\t        // convert LazyMap to object\n\t        var missingObj = {};\n\t        missing.forEach(function (value, key) {\n\t          missingObj[key] = value;\n\t        });\n\t        return callback(null, missingObj);\n\t      }\n\t    });\n\t  }, this);\n\t});\n\t\n\t// _bulk_get API for faster replication, as described in\n\t// https://github.com/apache/couchdb-chttpd/pull/33\n\t// At the \"abstract\" level, it will just run multiple get()s in\n\t// parallel, because this isn't much of a performance cost\n\t// for local databases (except the cost of multiple transactions, which is\n\t// small). The http adapter overrides this in order\n\t// to do a more efficient single HTTP request.\n\tAbstractPouchDB.prototype.bulkGet =\n\t  adapterFun('bulkGet', function (opts, callback) {\n\t  bulkGet(this, opts, callback);\n\t});\n\t\n\t// compact one document and fire callback\n\t// by compacting we mean removing all revisions which\n\t// are further from the leaf in revision tree than max_height\n\tAbstractPouchDB.prototype.compactDocument =\n\t  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n\t  var self = this;\n\t  this._getRevisionTree(docId, function (err, revTree) {\n\t    /* istanbul ignore if */\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    var height = computeHeight(revTree);\n\t    var candidates = [];\n\t    var revs = [];\n\t    Object.keys(height).forEach(function (rev$$1) {\n\t      if (height[rev$$1] > maxHeight) {\n\t        candidates.push(rev$$1);\n\t      }\n\t    });\n\t\n\t    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n\t      var rev$$1 = pos + '-' + revHash;\n\t      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {\n\t        revs.push(rev$$1);\n\t      }\n\t    });\n\t    self._doCompaction(docId, revs, callback);\n\t  });\n\t});\n\t\n\t// compact the whole database using single document\n\t// compaction\n\tAbstractPouchDB.prototype.compact =\n\t  adapterFun('compact', function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  var self = this;\n\t  opts = opts || {};\n\t\n\t  self._compactionQueue = self._compactionQueue || [];\n\t  self._compactionQueue.push({opts: opts, callback: callback});\n\t  if (self._compactionQueue.length === 1) {\n\t    doNextCompaction(self);\n\t  }\n\t});\n\tAbstractPouchDB.prototype._compact = function (opts, callback) {\n\t  var self = this;\n\t  var changesOpts = {\n\t    return_docs: false,\n\t    last_seq: opts.last_seq || 0\n\t  };\n\t  var promises = [];\n\t\n\t  function onChange(row) {\n\t    promises.push(self.compactDocument(row.id, 0));\n\t  }\n\t  function onComplete(resp) {\n\t    var lastSeq = resp.last_seq;\n\t    PouchPromise.all(promises).then(function () {\n\t      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n\t        if (!doc.last_seq || doc.last_seq < lastSeq) {\n\t          doc.last_seq = lastSeq;\n\t          return doc;\n\t        }\n\t        return false; // somebody else got here first, don't update\n\t      });\n\t    }).then(function () {\n\t      callback(null, {ok: true});\n\t    }).catch(callback);\n\t  }\n\t  self.changes(changesOpts)\n\t    .on('change', onChange)\n\t    .on('complete', onComplete)\n\t    .on('error', callback);\n\t};\n\t\n\t/* Begin api wrappers. Specific functionality to storage belongs in the\n\t   _[method] */\n\tAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n\t  if (typeof opts === 'function') {\n\t    cb = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof id !== 'string') {\n\t    return cb(createError(INVALID_ID));\n\t  }\n\t  if (isLocalId(id) && typeof this._getLocal === 'function') {\n\t    return this._getLocal(id, cb);\n\t  }\n\t  var leaves = [], self = this;\n\t\n\t  function finishOpenRevs() {\n\t    var result = [];\n\t    var count = leaves.length;\n\t    /* istanbul ignore if */\n\t    if (!count) {\n\t      return cb(null, result);\n\t    }\n\t\n\t    // order with open_revs is unspecified\n\t    leaves.forEach(function (leaf) {\n\t      self.get(id, {\n\t        rev: leaf,\n\t        revs: opts.revs,\n\t        latest: opts.latest,\n\t        attachments: opts.attachments,\n\t        binary: opts.binary\n\t      }, function (err, doc) {\n\t        if (!err) {\n\t          // using latest=true can produce duplicates\n\t          var existing;\n\t          for (var i = 0, l = result.length; i < l; i++) {\n\t            if (result[i].ok && result[i].ok._rev === doc._rev) {\n\t              existing = true;\n\t              break;\n\t            }\n\t          }\n\t          if (!existing) {\n\t            result.push({ok: doc});\n\t          }\n\t        } else {\n\t          result.push({missing: leaf});\n\t        }\n\t        count--;\n\t        if (!count) {\n\t          cb(null, result);\n\t        }\n\t      });\n\t    });\n\t  }\n\t\n\t  if (opts.open_revs) {\n\t    if (opts.open_revs === \"all\") {\n\t      this._getRevisionTree(id, function (err, rev_tree) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t        leaves = collectLeaves(rev_tree).map(function (leaf) {\n\t          return leaf.rev;\n\t        });\n\t        finishOpenRevs();\n\t      });\n\t    } else {\n\t      if (Array.isArray(opts.open_revs)) {\n\t        leaves = opts.open_revs;\n\t        for (var i = 0; i < leaves.length; i++) {\n\t          var l = leaves[i];\n\t          // looks like it's the only thing couchdb checks\n\t          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n\t            return cb(createError(INVALID_REV));\n\t          }\n\t        }\n\t        finishOpenRevs();\n\t      } else {\n\t        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n\t      }\n\t    }\n\t    return; // open_revs does not like other options\n\t  }\n\t\n\t  return this._get(id, opts, function (err, result) {\n\t    if (err) {\n\t      err.docId = id;\n\t      return cb(err);\n\t    }\n\t\n\t    var doc = result.doc;\n\t    var metadata = result.metadata;\n\t    var ctx = result.ctx;\n\t\n\t    if (opts.conflicts) {\n\t      var conflicts = collectConflicts(metadata);\n\t      if (conflicts.length) {\n\t        doc._conflicts = conflicts;\n\t      }\n\t    }\n\t\n\t    if (isDeleted(metadata, doc._rev)) {\n\t      doc._deleted = true;\n\t    }\n\t\n\t    if (opts.revs || opts.revs_info) {\n\t      var splittedRev = doc._rev.split('-');\n\t      var revNo       = parseInt(splittedRev[0], 10);\n\t      var revHash     = splittedRev[1];\n\t\n\t      var paths = rootToLeaf(metadata.rev_tree);\n\t      var path = null;\n\t\n\t      for (var i = 0; i < paths.length; i++) {\n\t        var currentPath = paths[i];\n\t        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n\t          .indexOf(revHash);\n\t        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\t\n\t        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n\t          path = currentPath;\n\t        }\n\t      }\n\t\n\t      var indexOfRev = path.ids.map(function (x) { return x.id; })\n\t        .indexOf(doc._rev.split('-')[1]) + 1;\n\t      var howMany = path.ids.length - indexOfRev;\n\t      path.ids.splice(indexOfRev, howMany);\n\t      path.ids.reverse();\n\t\n\t      if (opts.revs) {\n\t        doc._revisions = {\n\t          start: (path.pos + path.ids.length) - 1,\n\t          ids: path.ids.map(function (rev$$1) {\n\t            return rev$$1.id;\n\t          })\n\t        };\n\t      }\n\t      if (opts.revs_info) {\n\t        var pos =  path.pos + path.ids.length;\n\t        doc._revs_info = path.ids.map(function (rev$$1) {\n\t          pos--;\n\t          return {\n\t            rev: pos + '-' + rev$$1.id,\n\t            status: rev$$1.opts.status\n\t          };\n\t        });\n\t      }\n\t    }\n\t\n\t    if (opts.attachments && doc._attachments) {\n\t      var attachments = doc._attachments;\n\t      var count = Object.keys(attachments).length;\n\t      if (count === 0) {\n\t        return cb(null, doc);\n\t      }\n\t      Object.keys(attachments).forEach(function (key) {\n\t        this._getAttachment(doc._id, key, attachments[key], {\n\t          // Previously the revision handling was done in adapter.js\n\t          // getAttachment, however since idb-next doesnt we need to\n\t          // pass the rev through\n\t          rev: doc._rev,\n\t          binary: opts.binary,\n\t          ctx: ctx\n\t        }, function (err, data) {\n\t          var att = doc._attachments[key];\n\t          att.data = data;\n\t          delete att.stub;\n\t          delete att.length;\n\t          if (!--count) {\n\t            cb(null, doc);\n\t          }\n\t        });\n\t      }, self);\n\t    } else {\n\t      if (doc._attachments) {\n\t        for (var key in doc._attachments) {\n\t          /* istanbul ignore else */\n\t          if (doc._attachments.hasOwnProperty(key)) {\n\t            doc._attachments[key].stub = true;\n\t          }\n\t        }\n\t      }\n\t      cb(null, doc);\n\t    }\n\t  });\n\t});\n\t\n\t// TODO: I dont like this, it forces an extra read for every\n\t// attachment read and enforces a confusing api between\n\t// adapter.js and the adapter implementation\n\tAbstractPouchDB.prototype.getAttachment =\n\t  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n\t  var self = this;\n\t  if (opts instanceof Function) {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  this._get(docId, opts, function (err, res) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n\t      opts.ctx = res.ctx;\n\t      opts.binary = true;\n\t      self._getAttachment(docId, attachmentId,\n\t                          res.doc._attachments[attachmentId], opts, callback);\n\t    } else {\n\t      return callback(createError(MISSING_DOC));\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.allDocs =\n\t  adapterFun('allDocs', function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n\t  if (opts.start_key) {\n\t    opts.startkey = opts.start_key;\n\t  }\n\t  if (opts.end_key) {\n\t    opts.endkey = opts.end_key;\n\t  }\n\t  if ('keys' in opts) {\n\t    if (!Array.isArray(opts.keys)) {\n\t      return callback(new TypeError('options.keys must be an array'));\n\t    }\n\t    var incompatibleOpt =\n\t      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n\t      return incompatibleOpt in opts;\n\t    })[0];\n\t    if (incompatibleOpt) {\n\t      callback(createError(QUERY_PARSE_ERROR,\n\t        'Query parameter `' + incompatibleOpt +\n\t        '` is not compatible with multi-get'\n\t      ));\n\t      return;\n\t    }\n\t    if (!isRemote(this)) {\n\t      allDocsKeysParse(opts);\n\t      if (opts.keys.length === 0) {\n\t        return this._allDocs({limit: 0}, callback);\n\t      }\n\t    }\n\t  }\n\t\n\t  return this._allDocs(opts, callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.changes = function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  return new Changes$2(this, opts, callback);\n\t};\n\t\n\tAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n\t  this._closed = true;\n\t  this.emit('closed');\n\t  return this._close(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n\t  var self = this;\n\t  this._info(function (err, info) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    // assume we know better than the adapter, unless it informs us\n\t    info.db_name = info.db_name || self.name;\n\t    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n\t    info.adapter = self.adapter;\n\t    callback(null, info);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n\t  return this._id(callback);\n\t});\n\t\n\t/* istanbul ignore next */\n\tAbstractPouchDB.prototype.type = function () {\n\t  return (typeof this._type === 'function') ? this._type() : this.adapter;\n\t};\n\t\n\tAbstractPouchDB.prototype.bulkDocs =\n\t  adapterFun('bulkDocs', function (req, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  opts = opts || {};\n\t\n\t  if (Array.isArray(req)) {\n\t    req = {\n\t      docs: req\n\t    };\n\t  }\n\t\n\t  if (!req || !req.docs || !Array.isArray(req.docs)) {\n\t    return callback(createError(MISSING_BULK_DOCS));\n\t  }\n\t\n\t  for (var i = 0; i < req.docs.length; ++i) {\n\t    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n\t      return callback(createError(NOT_AN_OBJECT));\n\t    }\n\t  }\n\t\n\t  var attachmentError;\n\t  req.docs.forEach(function (doc) {\n\t    if (doc._attachments) {\n\t      Object.keys(doc._attachments).forEach(function (name) {\n\t        attachmentError = attachmentError || attachmentNameError(name);\n\t        if (!doc._attachments[name].content_type) {\n\t          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n\t        }\n\t      });\n\t    }\n\t  });\n\t\n\t  if (attachmentError) {\n\t    return callback(createError(BAD_REQUEST, attachmentError));\n\t  }\n\t\n\t  if (!('new_edits' in opts)) {\n\t    if ('new_edits' in req) {\n\t      opts.new_edits = req.new_edits;\n\t    } else {\n\t      opts.new_edits = true;\n\t    }\n\t  }\n\t\n\t  var adapter = this;\n\t  if (!opts.new_edits && !isRemote(adapter)) {\n\t    // ensure revisions of the same doc are sorted, so that\n\t    // the local adapter processes them correctly (#2935)\n\t    req.docs.sort(compareByIdThenRev);\n\t  }\n\t\n\t  cleanDocs(req.docs);\n\t\n\t  // in the case of conflicts, we want to return the _ids to the user\n\t  // however, the underlying adapter may destroy the docs array, so\n\t  // create a copy here\n\t  var ids = req.docs.map(function (doc) {\n\t    return doc._id;\n\t  });\n\t\n\t  return this._bulkDocs(req, opts, function (err, res) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (!opts.new_edits) {\n\t      // this is what couch does when new_edits is false\n\t      res = res.filter(function (x) {\n\t        return x.error;\n\t      });\n\t    }\n\t    // add ids for error/conflict responses (not required for CouchDB)\n\t    if (!isRemote(adapter)) {\n\t      for (var i = 0, l = res.length; i < l; i++) {\n\t        res[i].id = res[i].id || ids[i];\n\t      }\n\t    }\n\t\n\t    callback(null, res);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.registerDependentDatabase =\n\t  adapterFun('registerDependentDatabase', function (dependentDb,\n\t                                                          callback) {\n\t  var depDB = new this.constructor(dependentDb, this.__opts);\n\t\n\t  function diffFun(doc) {\n\t    doc.dependentDbs = doc.dependentDbs || {};\n\t    if (doc.dependentDbs[dependentDb]) {\n\t      return false; // no update required\n\t    }\n\t    doc.dependentDbs[dependentDb] = true;\n\t    return doc;\n\t  }\n\t  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n\t    .then(function () {\n\t      callback(null, {db: depDB});\n\t    }).catch(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.destroy =\n\t  adapterFun('destroy', function (opts, callback) {\n\t\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  var self = this;\n\t  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\t\n\t  function destroyDb() {\n\t    // call destroy method of the particular adaptor\n\t    self._destroy(opts, function (err, resp) {\n\t      if (err) {\n\t        return callback(err);\n\t      }\n\t      self._destroyed = true;\n\t      self.emit('destroyed');\n\t      callback(null, resp || { 'ok': true });\n\t    });\n\t  }\n\t\n\t  if (isRemote(self)) {\n\t    // no need to check for dependent DBs if it's a remote DB\n\t    return destroyDb();\n\t  }\n\t\n\t  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n\t    if (err) {\n\t      /* istanbul ignore if */\n\t      if (err.status !== 404) {\n\t        return callback(err);\n\t      } else { // no dependencies\n\t        return destroyDb();\n\t      }\n\t    }\n\t    var dependentDbs = localDoc.dependentDbs;\n\t    var PouchDB = self.constructor;\n\t    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n\t      // use_prefix is only false in the browser\n\t      /* istanbul ignore next */\n\t      var trueName = usePrefix ?\n\t        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n\t      return new PouchDB(trueName, self.__opts).destroy();\n\t    });\n\t    PouchPromise.all(deletedMap).then(destroyDb, callback);\n\t  });\n\t});\n\t\n\tfunction TaskQueue$1() {\n\t  this.isReady = false;\n\t  this.failed = false;\n\t  this.queue = [];\n\t}\n\t\n\tTaskQueue$1.prototype.execute = function () {\n\t  var fun;\n\t  if (this.failed) {\n\t    while ((fun = this.queue.shift())) {\n\t      fun(this.failed);\n\t    }\n\t  } else {\n\t    while ((fun = this.queue.shift())) {\n\t      fun();\n\t    }\n\t  }\n\t};\n\t\n\tTaskQueue$1.prototype.fail = function (err) {\n\t  this.failed = err;\n\t  this.execute();\n\t};\n\t\n\tTaskQueue$1.prototype.ready = function (db) {\n\t  this.isReady = true;\n\t  this.db = db;\n\t  this.execute();\n\t};\n\t\n\tTaskQueue$1.prototype.addTask = function (fun) {\n\t  this.queue.push(fun);\n\t  if (this.failed) {\n\t    this.execute();\n\t  }\n\t};\n\t\n\tfunction parseAdapter(name, opts) {\n\t  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n\t  if (match) {\n\t    // the http adapter expects the fully qualified name\n\t    return {\n\t      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n\t      adapter: match[1]\n\t    };\n\t  }\n\t\n\t  var adapters = PouchDB.adapters;\n\t  var preferredAdapters = PouchDB.preferredAdapters;\n\t  var prefix = PouchDB.prefix;\n\t  var adapterName = opts.adapter;\n\t\n\t  if (!adapterName) { // automatically determine adapter\n\t    for (var i = 0; i < preferredAdapters.length; ++i) {\n\t      adapterName = preferredAdapters[i];\n\t      // check for browsers that have been upgraded from websql-only to websql+idb\n\t      /* istanbul ignore if */\n\t      if (adapterName === 'idb' && 'websql' in adapters &&\n\t          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n\t        // log it, because this can be confusing during development\n\t        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n\t          ' avoid data loss, because it was already opened with WebSQL.');\n\t        continue; // keep using websql to avoid user data loss\n\t      }\n\t      break;\n\t    }\n\t  }\n\t\n\t  var adapter = adapters[adapterName];\n\t\n\t  // if adapter is invalid, then an error will be thrown later\n\t  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n\t    adapter.use_prefix : true;\n\t\n\t  return {\n\t    name: usePrefix ? (prefix + name) : name,\n\t    adapter: adapterName\n\t  };\n\t}\n\t\n\t// OK, so here's the deal. Consider this code:\n\t//     var db1 = new PouchDB('foo');\n\t//     var db2 = new PouchDB('foo');\n\t//     db1.destroy();\n\t// ^ these two both need to emit 'destroyed' events,\n\t// as well as the PouchDB constructor itself.\n\t// So we have one db object (whichever one got destroy() called on it)\n\t// responsible for emitting the initial event, which then gets emitted\n\t// by the constructor, which then broadcasts it to any other dbs\n\t// that may have been created with the same name.\n\tfunction prepareForDestruction(self) {\n\t\n\t  function onDestroyed(from_constructor) {\n\t    self.removeListener('closed', onClosed);\n\t    if (!from_constructor) {\n\t      self.constructor.emit('destroyed', self.name);\n\t    }\n\t  }\n\t\n\t  function onClosed() {\n\t    self.removeListener('destroyed', onDestroyed);\n\t    self.constructor.emit('unref', self);\n\t  }\n\t\n\t  self.once('destroyed', onDestroyed);\n\t  self.once('closed', onClosed);\n\t  self.constructor.emit('ref', self);\n\t}\n\t\n\tinherits(PouchDB, AbstractPouchDB);\n\tfunction PouchDB(name, opts) {\n\t  // In Node our test suite only tests this for PouchAlt unfortunately\n\t  /* istanbul ignore if */\n\t  if (!(this instanceof PouchDB)) {\n\t    return new PouchDB(name, opts);\n\t  }\n\t\n\t  var self = this;\n\t  opts = opts || {};\n\t\n\t  if (name && typeof name === 'object') {\n\t    opts = name;\n\t    name = opts.name;\n\t    delete opts.name;\n\t  }\n\t\n\t  this.__opts = opts = clone(opts);\n\t\n\t  self.auto_compaction = opts.auto_compaction;\n\t  self.prefix = PouchDB.prefix;\n\t\n\t  if (typeof name !== 'string') {\n\t    throw new Error('Missing/invalid DB name');\n\t  }\n\t\n\t  var prefixedName = (opts.prefix || '') + name;\n\t  var backend = parseAdapter(prefixedName, opts);\n\t\n\t  opts.name = backend.name;\n\t  opts.adapter = opts.adapter || backend.adapter;\n\t\n\t  self.name = name;\n\t  self._adapter = opts.adapter;\n\t  PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\t\n\t  if (!PouchDB.adapters[opts.adapter] ||\n\t      !PouchDB.adapters[opts.adapter].valid()) {\n\t    throw new Error('Invalid Adapter: ' + opts.adapter);\n\t  }\n\t\n\t  AbstractPouchDB.call(self);\n\t  self.taskqueue = new TaskQueue$1();\n\t\n\t  self.adapter = opts.adapter;\n\t\n\t  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {\n\t    if (err) {\n\t      return self.taskqueue.fail(err);\n\t    }\n\t    prepareForDestruction(self);\n\t\n\t    self.emit('created', self);\n\t    PouchDB.emit('created', self.name);\n\t    self.taskqueue.ready(self);\n\t  });\n\t\n\t}\n\t\n\tPouchDB.adapters = {};\n\tPouchDB.preferredAdapters = [];\n\t\n\tPouchDB.prefix = '_pouch_';\n\t\n\tvar eventEmitter = new events.EventEmitter();\n\t\n\tfunction setUpEventEmitter(Pouch) {\n\t  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n\t    if (typeof events.EventEmitter.prototype[key] === 'function') {\n\t      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n\t    }\n\t  });\n\t\n\t  // these are created in constructor.js, and allow us to notify each DB with\n\t  // the same name that it was destroyed, via the constructor object\n\t  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\t\n\t  Pouch.on('ref', function onConstructorRef(db) {\n\t    if (!destructListeners.has(db.name)) {\n\t      destructListeners.set(db.name, []);\n\t    }\n\t    destructListeners.get(db.name).push(db);\n\t  });\n\t\n\t  Pouch.on('unref', function onConstructorUnref(db) {\n\t    if (!destructListeners.has(db.name)) {\n\t      return;\n\t    }\n\t    var dbList = destructListeners.get(db.name);\n\t    var pos = dbList.indexOf(db);\n\t    if (pos < 0) {\n\t      /* istanbul ignore next */\n\t      return;\n\t    }\n\t    dbList.splice(pos, 1);\n\t    if (dbList.length > 1) {\n\t      /* istanbul ignore next */\n\t      destructListeners.set(db.name, dbList);\n\t    } else {\n\t      destructListeners.delete(db.name);\n\t    }\n\t  });\n\t\n\t  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n\t    if (!destructListeners.has(name)) {\n\t      return;\n\t    }\n\t    var dbList = destructListeners.get(name);\n\t    destructListeners.delete(name);\n\t    dbList.forEach(function (db) {\n\t      db.emit('destroyed',true);\n\t    });\n\t  });\n\t}\n\t\n\tsetUpEventEmitter(PouchDB);\n\t\n\tPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n\t  /* istanbul ignore else */\n\t  if (obj.valid()) {\n\t    PouchDB.adapters[id] = obj;\n\t    if (addToPreferredAdapters) {\n\t      PouchDB.preferredAdapters.push(id);\n\t    }\n\t  }\n\t};\n\t\n\tPouchDB.plugin = function (obj) {\n\t  if (typeof obj === 'function') { // function style for plugins\n\t    obj(PouchDB);\n\t  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n\t    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n\t  } else {\n\t    Object.keys(obj).forEach(function (id) { // object style for plugins\n\t      PouchDB.prototype[id] = obj[id];\n\t    });\n\t  }\n\t  if (this.__defaults) {\n\t    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);\n\t  }\n\t  return PouchDB;\n\t};\n\t\n\tPouchDB.defaults = function (defaultOpts) {\n\t  function PouchAlt(name, opts) {\n\t    if (!(this instanceof PouchAlt)) {\n\t      return new PouchAlt(name, opts);\n\t    }\n\t\n\t    opts = opts || {};\n\t\n\t    if (name && typeof name === 'object') {\n\t      opts = name;\n\t      name = opts.name;\n\t      delete opts.name;\n\t    }\n\t\n\t    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n\t    PouchDB.call(this, name, opts);\n\t  }\n\t\n\t  inherits(PouchAlt, PouchDB);\n\t\n\t  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();\n\t  Object.keys(PouchDB).forEach(function (key) {\n\t    if (!(key in PouchAlt)) {\n\t      PouchAlt[key] = PouchDB[key];\n\t    }\n\t  });\n\t\n\t  // make default options transitive\n\t  // https://github.com/pouchdb/pouchdb/issues/5922\n\t  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\t\n\t  return PouchAlt;\n\t};\n\t\n\t// managed automatically by set-version.js\n\tvar version = \"6.4.3\";\n\t\n\tfunction debugPouch(PouchDB) {\n\t  PouchDB.debug = debug;\n\t  var logs = {};\n\t  /* istanbul ignore next */\n\t  PouchDB.on('debug', function (args) {\n\t    // first argument is log identifier\n\t    var logId = args[0];\n\t    // rest should be passed verbatim to debug module\n\t    var logArgs = args.slice(1);\n\t    if (!logs[logId]) {\n\t      logs[logId] = debug('pouchdb:' + logId);\n\t    }\n\t    logs[logId].apply(null, logArgs);\n\t  });\n\t}\n\t\n\t// this would just be \"return doc[field]\", but fields\n\t// can be \"deep\" due to dot notation\n\tfunction getFieldFromDoc(doc, parsedField) {\n\t  var value = doc;\n\t  for (var i = 0, len = parsedField.length; i < len; i++) {\n\t    var key = parsedField[i];\n\t    value = value[key];\n\t    if (!value) {\n\t      break;\n\t    }\n\t  }\n\t  return value;\n\t}\n\t\n\tfunction compare$1(left, right) {\n\t  return left < right ? -1 : left > right ? 1 : 0;\n\t}\n\t\n\t// Converts a string in dot notation to an array of its components, with backslash escaping\n\tfunction parseField(fieldName) {\n\t  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n\t  var fields = [];\n\t  var current = '';\n\t  for (var i = 0, len = fieldName.length; i < len; i++) {\n\t    var ch = fieldName[i];\n\t    if (ch === '.') {\n\t      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n\t        current = current.substring(0, current.length - 1) + '.';\n\t      } else { // not escaped, so delimiter\n\t        fields.push(current);\n\t        current = '';\n\t      }\n\t    } else { // normal character\n\t      current += ch;\n\t    }\n\t  }\n\t  fields.push(current);\n\t  return fields;\n\t}\n\t\n\tvar combinationFields = ['$or', '$nor', '$not'];\n\tfunction isCombinationalField(field) {\n\t  return combinationFields.indexOf(field) > -1;\n\t}\n\t\n\tfunction getKey(obj) {\n\t  return Object.keys(obj)[0];\n\t}\n\t\n\tfunction getValue(obj) {\n\t  return obj[getKey(obj)];\n\t}\n\t\n\t\n\t// flatten an array of selectors joined by an $and operator\n\tfunction mergeAndedSelectors(selectors) {\n\t\n\t  // sort to ensure that e.g. if the user specified\n\t  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n\t  // just {$gt: 'b'}\n\t  var res = {};\n\t\n\t  selectors.forEach(function (selector) {\n\t    Object.keys(selector).forEach(function (field) {\n\t      var matcher = selector[field];\n\t      if (typeof matcher !== 'object') {\n\t        matcher = {$eq: matcher};\n\t      }\n\t\n\t      if (isCombinationalField(field)) {\n\t        if (matcher instanceof Array) {\n\t          res[field] = matcher.map(function (m) {\n\t            return mergeAndedSelectors([m]);\n\t          });\n\t        } else {\n\t          res[field] = mergeAndedSelectors([matcher]);\n\t        }\n\t      } else {\n\t        var fieldMatchers = res[field] = res[field] || {};\n\t        Object.keys(matcher).forEach(function (operator) {\n\t          var value = matcher[operator];\n\t\n\t          if (operator === '$gt' || operator === '$gte') {\n\t            return mergeGtGte(operator, value, fieldMatchers);\n\t          } else if (operator === '$lt' || operator === '$lte') {\n\t            return mergeLtLte(operator, value, fieldMatchers);\n\t          } else if (operator === '$ne') {\n\t            return mergeNe(value, fieldMatchers);\n\t          } else if (operator === '$eq') {\n\t            return mergeEq(value, fieldMatchers);\n\t          }\n\t          fieldMatchers[operator] = value;\n\t        });\n\t      }\n\t    });\n\t  });\n\t\n\t  return res;\n\t}\n\t\n\t\n\t\n\t// collapse logically equivalent gt/gte values\n\tfunction mergeGtGte(operator, value, fieldMatchers) {\n\t  if (typeof fieldMatchers.$eq !== 'undefined') {\n\t    return; // do nothing\n\t  }\n\t  if (typeof fieldMatchers.$gte !== 'undefined') {\n\t    if (operator === '$gte') {\n\t      if (value > fieldMatchers.$gte) { // more specificity\n\t        fieldMatchers.$gte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value >= fieldMatchers.$gte) { // more specificity\n\t        delete fieldMatchers.$gte;\n\t        fieldMatchers.$gt = value;\n\t      }\n\t    }\n\t  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n\t    if (operator === '$gte') {\n\t      if (value > fieldMatchers.$gt) { // more specificity\n\t        delete fieldMatchers.$gt;\n\t        fieldMatchers.$gte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value > fieldMatchers.$gt) { // more specificity\n\t        fieldMatchers.$gt = value;\n\t      }\n\t    }\n\t  } else {\n\t    fieldMatchers[operator] = value;\n\t  }\n\t}\n\t\n\t// collapse logically equivalent lt/lte values\n\tfunction mergeLtLte(operator, value, fieldMatchers) {\n\t  if (typeof fieldMatchers.$eq !== 'undefined') {\n\t    return; // do nothing\n\t  }\n\t  if (typeof fieldMatchers.$lte !== 'undefined') {\n\t    if (operator === '$lte') {\n\t      if (value < fieldMatchers.$lte) { // more specificity\n\t        fieldMatchers.$lte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value <= fieldMatchers.$lte) { // more specificity\n\t        delete fieldMatchers.$lte;\n\t        fieldMatchers.$lt = value;\n\t      }\n\t    }\n\t  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n\t    if (operator === '$lte') {\n\t      if (value < fieldMatchers.$lt) { // more specificity\n\t        delete fieldMatchers.$lt;\n\t        fieldMatchers.$lte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value < fieldMatchers.$lt) { // more specificity\n\t        fieldMatchers.$lt = value;\n\t      }\n\t    }\n\t  } else {\n\t    fieldMatchers[operator] = value;\n\t  }\n\t}\n\t\n\t// combine $ne values into one array\n\tfunction mergeNe(value, fieldMatchers) {\n\t  if ('$ne' in fieldMatchers) {\n\t    // there are many things this could \"not\" be\n\t    fieldMatchers.$ne.push(value);\n\t  } else { // doesn't exist yet\n\t    fieldMatchers.$ne = [value];\n\t  }\n\t}\n\t\n\t// add $eq into the mix\n\tfunction mergeEq(value, fieldMatchers) {\n\t  // these all have less specificity than the $eq\n\t  // TODO: check for user errors here\n\t  delete fieldMatchers.$gt;\n\t  delete fieldMatchers.$gte;\n\t  delete fieldMatchers.$lt;\n\t  delete fieldMatchers.$lte;\n\t  delete fieldMatchers.$ne;\n\t  fieldMatchers.$eq = value;\n\t}\n\t\n\t\n\t//\n\t// normalize the selector\n\t//\n\tfunction massageSelector(input) {\n\t  var result = clone(input);\n\t  var wasAnded = false;\n\t  if ('$and' in result) {\n\t    result = mergeAndedSelectors(result['$and']);\n\t    wasAnded = true;\n\t  }\n\t\n\t  ['$or', '$nor'].forEach(function (orOrNor) {\n\t    if (orOrNor in result) {\n\t      // message each individual selector\n\t      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n\t      result[orOrNor].forEach(function (subSelector) {\n\t        var fields = Object.keys(subSelector);\n\t        for (var i = 0; i < fields.length; i++) {\n\t          var field = fields[i];\n\t          var matcher = subSelector[field];\n\t          if (typeof matcher !== 'object' || matcher === null) {\n\t            subSelector[field] = {$eq: matcher};\n\t          }\n\t        }\n\t      });\n\t    }\n\t  });\n\t\n\t  if ('$not' in result) {\n\t    //This feels a little like forcing, but it will work for now,\n\t    //I would like to come back to this and make the merging of selectors a little more generic\n\t    result['$not'] = mergeAndedSelectors([result['$not']]);\n\t  }\n\t\n\t  var fields = Object.keys(result);\n\t\n\t  for (var i = 0; i < fields.length; i++) {\n\t    var field = fields[i];\n\t    var matcher = result[field];\n\t\n\t    if (typeof matcher !== 'object' || matcher === null) {\n\t      matcher = {$eq: matcher};\n\t    } else if ('$ne' in matcher && !wasAnded) {\n\t      // I put these in an array, since there may be more than one\n\t      // but in the \"mergeAnded\" operation, I already take care of that\n\t      matcher.$ne = [matcher.$ne];\n\t    }\n\t    result[field] = matcher;\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\tfunction pad(str, padWith, upToLength) {\n\t  var padding = '';\n\t  var targetLength = upToLength - str.length;\n\t  /* istanbul ignore next */\n\t  while (padding.length < targetLength) {\n\t    padding += padWith;\n\t  }\n\t  return padding;\n\t}\n\t\n\tfunction padLeft(str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return padding + str;\n\t}\n\t\n\tvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\n\tvar MAGNITUDE_DIGITS = 3; // ditto\n\tvar SEP = ''; // set to '_' for easier debugging \n\t\n\tfunction collate(a, b) {\n\t\n\t  if (a === b) {\n\t    return 0;\n\t  }\n\t\n\t  a = normalizeKey(a);\n\t  b = normalizeKey(b);\n\t\n\t  var ai = collationIndex(a);\n\t  var bi = collationIndex(b);\n\t  if ((ai - bi) !== 0) {\n\t    return ai - bi;\n\t  }\n\t  switch (typeof a) {\n\t    case 'number':\n\t      return a - b;\n\t    case 'boolean':\n\t      return a < b ? -1 : 1;\n\t    case 'string':\n\t      return stringCollate(a, b);\n\t  }\n\t  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n\t}\n\t\n\t// couch considers null/NaN/Infinity/-Infinity === undefined,\n\t// for the purposes of mapreduce indexes. also, dates get stringified.\n\tfunction normalizeKey(key) {\n\t  switch (typeof key) {\n\t    case 'undefined':\n\t      return null;\n\t    case 'number':\n\t      if (key === Infinity || key === -Infinity || isNaN(key)) {\n\t        return null;\n\t      }\n\t      return key;\n\t    case 'object':\n\t      var origKey = key;\n\t      if (Array.isArray(key)) {\n\t        var len = key.length;\n\t        key = new Array(len);\n\t        for (var i = 0; i < len; i++) {\n\t          key[i] = normalizeKey(origKey[i]);\n\t        }\n\t      /* istanbul ignore next */\n\t      } else if (key instanceof Date) {\n\t        return key.toJSON();\n\t      } else if (key !== null) { // generic object\n\t        key = {};\n\t        for (var k in origKey) {\n\t          if (origKey.hasOwnProperty(k)) {\n\t            var val = origKey[k];\n\t            if (typeof val !== 'undefined') {\n\t              key[k] = normalizeKey(val);\n\t            }\n\t          }\n\t        }\n\t      }\n\t  }\n\t  return key;\n\t}\n\t\n\tfunction indexify(key) {\n\t  if (key !== null) {\n\t    switch (typeof key) {\n\t      case 'boolean':\n\t        return key ? 1 : 0;\n\t      case 'number':\n\t        return numToIndexableString(key);\n\t      case 'string':\n\t        // We've to be sure that key does not contain \\u0000\n\t        // Do order-preserving replacements:\n\t        // 0 -> 1, 1\n\t        // 1 -> 1, 2\n\t        // 2 -> 2, 2\n\t        return key\n\t          .replace(/\\u0002/g, '\\u0002\\u0002')\n\t          .replace(/\\u0001/g, '\\u0001\\u0002')\n\t          .replace(/\\u0000/g, '\\u0001\\u0001');\n\t      case 'object':\n\t        var isArray = Array.isArray(key);\n\t        var arr = isArray ? key : Object.keys(key);\n\t        var i = -1;\n\t        var len = arr.length;\n\t        var result = '';\n\t        if (isArray) {\n\t          while (++i < len) {\n\t            result += toIndexableString(arr[i]);\n\t          }\n\t        } else {\n\t          while (++i < len) {\n\t            var objKey = arr[i];\n\t            result += toIndexableString(objKey) +\n\t                toIndexableString(key[objKey]);\n\t          }\n\t        }\n\t        return result;\n\t    }\n\t  }\n\t  return '';\n\t}\n\t\n\t// convert the given key to a string that would be appropriate\n\t// for lexical sorting, e.g. within a database, where the\n\t// sorting is the same given by the collate() function.\n\tfunction toIndexableString(key) {\n\t  var zero = '\\u0000';\n\t  key = normalizeKey(key);\n\t  return collationIndex(key) + SEP + indexify(key) + zero;\n\t}\n\t\n\tfunction parseNumber(str, i) {\n\t  var originalIdx = i;\n\t  var num;\n\t  var zero = str[i] === '1';\n\t  if (zero) {\n\t    num = 0;\n\t    i++;\n\t  } else {\n\t    var neg = str[i] === '0';\n\t    i++;\n\t    var numAsString = '';\n\t    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n\t    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n\t    /* istanbul ignore next */\n\t    if (neg) {\n\t      magnitude = -magnitude;\n\t    }\n\t    i += MAGNITUDE_DIGITS;\n\t    while (true) {\n\t      var ch = str[i];\n\t      if (ch === '\\u0000') {\n\t        break;\n\t      } else {\n\t        numAsString += ch;\n\t      }\n\t      i++;\n\t    }\n\t    numAsString = numAsString.split('.');\n\t    if (numAsString.length === 1) {\n\t      num = parseInt(numAsString, 10);\n\t    } else {\n\t      /* istanbul ignore next */\n\t      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n\t    }\n\t    /* istanbul ignore next */\n\t    if (neg) {\n\t      num = num - 10;\n\t    }\n\t    /* istanbul ignore next */\n\t    if (magnitude !== 0) {\n\t      // parseFloat is more reliable than pow due to rounding errors\n\t      // e.g. Number.MAX_VALUE would return Infinity if we did\n\t      // num * Math.pow(10, magnitude);\n\t      num = parseFloat(num + 'e' + magnitude);\n\t    }\n\t  }\n\t  return {num: num, length : i - originalIdx};\n\t}\n\t\n\t// move up the stack while parsing\n\t// this function moved outside of parseIndexableString for performance\n\tfunction pop(stack, metaStack) {\n\t  var obj = stack.pop();\n\t\n\t  if (metaStack.length) {\n\t    var lastMetaElement = metaStack[metaStack.length - 1];\n\t    if (obj === lastMetaElement.element) {\n\t      // popping a meta-element, e.g. an object whose value is another object\n\t      metaStack.pop();\n\t      lastMetaElement = metaStack[metaStack.length - 1];\n\t    }\n\t    var element = lastMetaElement.element;\n\t    var lastElementIndex = lastMetaElement.index;\n\t    if (Array.isArray(element)) {\n\t      element.push(obj);\n\t    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t      var key = stack.pop();\n\t      element[key] = obj;\n\t    } else {\n\t      stack.push(obj); // obj with key only\n\t    }\n\t  }\n\t}\n\t\n\tfunction parseIndexableString(str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t\n\t  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\t  while (true) {\n\t    var collationIndex = str[i++];\n\t    if (collationIndex === '\\u0000') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case '1':\n\t        stack.push(null);\n\t        break;\n\t      case '2':\n\t        stack.push(str[i] === '1');\n\t        i++;\n\t        break;\n\t      case '3':\n\t        var parsedNum = parseNumber(str, i);\n\t        stack.push(parsedNum.num);\n\t        i += parsedNum.length;\n\t        break;\n\t      case '4':\n\t        var parsedStr = '';\n\t        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\t        while (true) {\n\t          var ch = str[i];\n\t          if (ch === '\\u0000') {\n\t            break;\n\t          }\n\t          parsedStr += ch;\n\t          i++;\n\t        }\n\t        // perform the reverse of the order-preserving replacement\n\t        // algorithm (see above)\n\t        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n\t          .replace(/\\u0001\\u0002/g, '\\u0001')\n\t          .replace(/\\u0002\\u0002/g, '\\u0002');\n\t        stack.push(parsedStr);\n\t        break;\n\t      case '5':\n\t        var arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '6':\n\t        var objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      /* istanbul ignore next */\n\t      default:\n\t        throw new Error(\n\t          'bad collationIndex or unexpectedly reached end of input: ' +\n\t            collationIndex);\n\t    }\n\t  }\n\t}\n\t\n\tfunction arrayCollate(a, b) {\n\t  var len = Math.min(a.length, b.length);\n\t  for (var i = 0; i < len; i++) {\n\t    var sort = collate(a[i], b[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t  }\n\t  return (a.length === b.length) ? 0 :\n\t    (a.length > b.length) ? 1 : -1;\n\t}\n\tfunction stringCollate(a, b) {\n\t  // See: https://github.com/daleharvey/pouchdb/issues/40\n\t  // This is incompatible with the CouchDB implementation, but its the\n\t  // best we can do for now\n\t  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n\t}\n\tfunction objectCollate(a, b) {\n\t  var ak = Object.keys(a), bk = Object.keys(b);\n\t  var len = Math.min(ak.length, bk.length);\n\t  for (var i = 0; i < len; i++) {\n\t    // First sort the keys\n\t    var sort = collate(ak[i], bk[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t    // if the keys are equal sort the values\n\t    sort = collate(a[ak[i]], b[bk[i]]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t\n\t  }\n\t  return (ak.length === bk.length) ? 0 :\n\t    (ak.length > bk.length) ? 1 : -1;\n\t}\n\t// The collation is defined by erlangs ordered terms\n\t// the atoms null, true, false come first, then numbers, strings,\n\t// arrays, then objects\n\t// null/undefined/NaN/Infinity/-Infinity are all considered null\n\tfunction collationIndex(x) {\n\t  var id = ['boolean', 'number', 'string', 'object'];\n\t  var idx = id.indexOf(typeof x);\n\t  //false if -1 otherwise true, but fast!!!!1\n\t  if (~idx) {\n\t    if (x === null) {\n\t      return 1;\n\t    }\n\t    if (Array.isArray(x)) {\n\t      return 5;\n\t    }\n\t    return idx < 3 ? (idx + 2) : (idx + 3);\n\t  }\n\t  /* istanbul ignore next */\n\t  if (Array.isArray(x)) {\n\t    return 5;\n\t  }\n\t}\n\t\n\t// conversion:\n\t// x yyy zz...zz\n\t// x = 0 for negative, 1 for 0, 2 for positive\n\t// y = exponent (for negative numbers negated) moved so that it's >= 0\n\t// z = mantisse\n\tfunction numToIndexableString(num) {\n\t\n\t  if (num === 0) {\n\t    return '1';\n\t  }\n\t\n\t  // convert number to exponential format for easier and\n\t  // more succinct string sorting\n\t  var expFormat = num.toExponential().split(/e\\+?/);\n\t  var magnitude = parseInt(expFormat[1], 10);\n\t\n\t  var neg = num < 0;\n\t\n\t  var result = neg ? '0' : '2';\n\t\n\t  // first sort by magnitude\n\t  // it's easier if all magnitudes are positive\n\t  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n\t  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\t\n\t  result += SEP + magString;\n\t\n\t  // then sort by the factor\n\t  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n\t  /* istanbul ignore next */\n\t  if (neg) { // for negative reverse ordering\n\t    factor = 10 - factor;\n\t  }\n\t\n\t  var factorStr = factor.toFixed(20);\n\t\n\t  // strip zeros from the end\n\t  factorStr = factorStr.replace(/\\.?0+$/, '');\n\t\n\t  result += SEP + factorStr;\n\t\n\t  return result;\n\t}\n\t\n\t// create a comparator based on the sort object\n\tfunction createFieldSorter(sort) {\n\t\n\t  function getFieldValuesAsArray(doc) {\n\t    return sort.map(function (sorting) {\n\t      var fieldName = getKey(sorting);\n\t      var parsedField = parseField(fieldName);\n\t      var docFieldValue = getFieldFromDoc(doc, parsedField);\n\t      return docFieldValue;\n\t    });\n\t  }\n\t\n\t  return function (aRow, bRow) {\n\t    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n\t    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n\t    var collation = collate(aFieldValues, bFieldValues);\n\t    if (collation !== 0) {\n\t      return collation;\n\t    }\n\t    // this is what mango seems to do\n\t    return compare$1(aRow.doc._id, bRow.doc._id);\n\t  };\n\t}\n\t\n\tfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n\t  rows = rows.filter(function (row) {\n\t    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n\t  });\n\t\n\t  if (requestDef.sort) {\n\t    // in-memory sort\n\t    var fieldSorter = createFieldSorter(requestDef.sort);\n\t    rows = rows.sort(fieldSorter);\n\t    if (typeof requestDef.sort[0] !== 'string' &&\n\t        getValue(requestDef.sort[0]) === 'desc') {\n\t      rows = rows.reverse();\n\t    }\n\t  }\n\t\n\t  if ('limit' in requestDef || 'skip' in requestDef) {\n\t    // have to do the limit in-memory\n\t    var skip = requestDef.skip || 0;\n\t    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n\t    rows = rows.slice(skip, limit);\n\t  }\n\t  return rows;\n\t}\n\t\n\tfunction rowFilter(doc, selector, inMemoryFields) {\n\t  return inMemoryFields.every(function (field) {\n\t    var matcher = selector[field];\n\t    var parsedField = parseField(field);\n\t    var docFieldValue = getFieldFromDoc(doc, parsedField);\n\t    if (isCombinationalField(field)) {\n\t      return matchCominationalSelector(field, matcher, doc);\n\t    }\n\t\n\t    return matchSelector(matcher, doc, parsedField, docFieldValue);\n\t  });\n\t}\n\t\n\tfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n\t  if (!matcher) {\n\t    // no filtering necessary; this field is just needed for sorting\n\t    return true;\n\t  }\n\t\n\t  return Object.keys(matcher).every(function (userOperator) {\n\t    var userValue = matcher[userOperator];\n\t    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n\t  });\n\t}\n\t\n\tfunction matchCominationalSelector(field, matcher, doc) {\n\t\n\t  if (field === '$or') {\n\t    return matcher.some(function (orMatchers) {\n\t      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n\t    });\n\t  }\n\t\n\t  if (field === '$not') {\n\t    return !rowFilter(doc, matcher, Object.keys(matcher));\n\t  }\n\t\n\t  //`$nor`\n\t  return !matcher.find(function (orMatchers) {\n\t    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n\t  });\n\t\n\t}\n\t\n\tfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n\t  if (!matchers[userOperator]) {\n\t    throw new Error('unknown operator \"' + userOperator +\n\t      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n\t      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n\t  }\n\t  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n\t}\n\t\n\tfunction fieldExists(docFieldValue) {\n\t  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n\t}\n\t\n\tfunction fieldIsNotUndefined(docFieldValue) {\n\t  return typeof docFieldValue !== 'undefined';\n\t}\n\t\n\tfunction modField(docFieldValue, userValue) {\n\t  var divisor = userValue[0];\n\t  var mod = userValue[1];\n\t  if (divisor === 0) {\n\t    throw new Error('Bad divisor, cannot divide by zero');\n\t  }\n\t\n\t  if (parseInt(divisor, 10) !== divisor ) {\n\t    throw new Error('Divisor is not an integer');\n\t  }\n\t\n\t  if (parseInt(mod, 10) !== mod ) {\n\t    throw new Error('Modulus is not an integer');\n\t  }\n\t\n\t  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n\t    return false;\n\t  }\n\t\n\t  return docFieldValue % divisor === mod;\n\t}\n\t\n\tfunction arrayContainsValue(docFieldValue, userValue) {\n\t  return userValue.some(function (val) {\n\t    if (docFieldValue instanceof Array) {\n\t      return docFieldValue.indexOf(val) > -1;\n\t    }\n\t\n\t    return docFieldValue === val;\n\t  });\n\t}\n\t\n\tfunction arrayContainsAllValues(docFieldValue, userValue) {\n\t  return userValue.every(function (val) {\n\t    return docFieldValue.indexOf(val) > -1;\n\t  });\n\t}\n\t\n\tfunction arraySize(docFieldValue, userValue) {\n\t  return docFieldValue.length === userValue;\n\t}\n\t\n\tfunction regexMatch(docFieldValue, userValue) {\n\t  var re = new RegExp(userValue);\n\t\n\t  return re.test(docFieldValue);\n\t}\n\t\n\tfunction typeMatch(docFieldValue, userValue) {\n\t\n\t  switch (userValue) {\n\t    case 'null':\n\t      return docFieldValue === null;\n\t    case 'boolean':\n\t      return typeof (docFieldValue) === 'boolean';\n\t    case 'number':\n\t      return typeof (docFieldValue) === 'number';\n\t    case 'string':\n\t      return typeof (docFieldValue) === 'string';\n\t    case 'array':\n\t      return docFieldValue instanceof Array;\n\t    case 'object':\n\t      return ({}).toString.call(docFieldValue) === '[object Object]';\n\t  }\n\t\n\t  throw new Error(userValue + ' not supported as a type.' +\n\t                  'Please use one of object, string, array, number, boolean or null.');\n\t\n\t}\n\t\n\tvar matchers = {\n\t\n\t  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n\t    if (!Array.isArray(docFieldValue)) {\n\t      return false;\n\t    }\n\t\n\t    if (docFieldValue.length === 0) {\n\t      return false;\n\t    }\n\t\n\t    if (typeof docFieldValue[0] === 'object') {\n\t      return docFieldValue.some(function (val) {\n\t        return rowFilter(val, userValue, Object.keys(userValue));\n\t      });\n\t    }\n\t\n\t    return docFieldValue.some(function (val) {\n\t      return matchSelector(userValue, doc, parsedField, val);\n\t    });\n\t  },\n\t\n\t  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n\t    if (!Array.isArray(docFieldValue)) {\n\t      return false;\n\t    }\n\t\n\t    /* istanbul ignore next */\n\t    if (docFieldValue.length === 0) {\n\t      return false;\n\t    }\n\t\n\t    if (typeof docFieldValue[0] === 'object') {\n\t      return docFieldValue.every(function (val) {\n\t        return rowFilter(val, userValue, Object.keys(userValue));\n\t      });\n\t    }\n\t\n\t    return docFieldValue.every(function (val) {\n\t      return matchSelector(userValue, doc, parsedField, val);\n\t    });\n\t  },\n\t\n\t  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n\t  },\n\t\n\t  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n\t  },\n\t\n\t  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n\t  },\n\t\n\t  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n\t  },\n\t\n\t  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n\t  },\n\t\n\t  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n\t    //a field that is null is still considered to exist\n\t    if (userValue) {\n\t      return fieldIsNotUndefined(docFieldValue);\n\t    }\n\t\n\t    return !fieldIsNotUndefined(docFieldValue);\n\t  },\n\t\n\t  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n\t  },\n\t\n\t  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n\t    return userValue.every(function (neValue) {\n\t      return collate(docFieldValue, neValue) !== 0;\n\t    });\n\t  },\n\t  '$in': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n\t  },\n\t\n\t  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n\t  },\n\t\n\t  '$size': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n\t  },\n\t\n\t  '$all': function (doc, userValue, parsedField, docFieldValue) {\n\t    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n\t  },\n\t\n\t  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n\t  },\n\t\n\t  '$type': function (doc, userValue, parsedField, docFieldValue) {\n\t    return typeMatch(docFieldValue, userValue);\n\t  }\n\t};\n\t\n\t// return true if the given doc matches the supplied selector\n\tfunction matchesSelector(doc, selector) {\n\t  /* istanbul ignore if */\n\t  if (typeof selector !== 'object') {\n\t    // match the CouchDB error message\n\t    throw new Error('Selector error: expected a JSON object');\n\t  }\n\t\n\t  selector = massageSelector(selector);\n\t  var row = {\n\t    'doc': doc\n\t  };\n\t\n\t  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n\t  return rowsMatched && rowsMatched.length === 1;\n\t}\n\t\n\tfunction evalFilter(input) {\n\t  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n\t}\n\t\n\tfunction evalView(input) {\n\t  var code = [\n\t    'return function(doc) {',\n\t    '  \"use strict\";',\n\t    '  var emitted = false;',\n\t    '  var emit = function (a, b) {',\n\t    '    emitted = true;',\n\t    '  };',\n\t    '  var view = ' + input + ';',\n\t    '  view(doc);',\n\t    '  if (emitted) {',\n\t    '    return true;',\n\t    '  }',\n\t    '};'\n\t  ].join('\\n');\n\t\n\t  return scopeEval(code, {});\n\t}\n\t\n\tfunction validate(opts, callback) {\n\t  if (opts.selector) {\n\t    if (opts.filter && opts.filter !== '_selector') {\n\t      var filterName = typeof opts.filter === 'string' ?\n\t        opts.filter : 'function';\n\t      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n\t    }\n\t  }\n\t  callback();\n\t}\n\t\n\tfunction normalize(opts) {\n\t  if (opts.view && !opts.filter) {\n\t    opts.filter = '_view';\n\t  }\n\t\n\t  if (opts.selector && !opts.filter) {\n\t    opts.filter = '_selector';\n\t  }\n\t\n\t  if (opts.filter && typeof opts.filter === 'string') {\n\t    if (opts.filter === '_view') {\n\t      opts.view = normalizeDesignDocFunctionName(opts.view);\n\t    } else {\n\t      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n\t    }\n\t  }\n\t}\n\t\n\tfunction shouldFilter(changesHandler, opts) {\n\t  return opts.filter && typeof opts.filter === 'string' &&\n\t    !opts.doc_ids && !isRemote(changesHandler.db);\n\t}\n\t\n\tfunction filter(changesHandler, opts) {\n\t  var callback = opts.complete;\n\t  if (opts.filter === '_view') {\n\t    if (!opts.view || typeof opts.view !== 'string') {\n\t      var err = createError(BAD_REQUEST,\n\t        '`view` filter parameter not found or invalid.');\n\t      return callback(err);\n\t    }\n\t    // fetch a view from a design doc, make it behave like a filter\n\t    var viewName = parseDesignDocFunctionName(opts.view);\n\t    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n\t      /* istanbul ignore if */\n\t      if (changesHandler.isCancelled) {\n\t        return callback(null, {status: 'cancelled'});\n\t      }\n\t      /* istanbul ignore next */\n\t      if (err) {\n\t        return callback(generateErrorFromResponse(err));\n\t      }\n\t      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n\t        ddoc.views[viewName[1]].map;\n\t      if (!mapFun) {\n\t        return callback(createError(MISSING_DOC,\n\t          (ddoc.views ? 'missing json key: ' + viewName[1] :\n\t            'missing json key: views')));\n\t      }\n\t      opts.filter = evalView(mapFun);\n\t      changesHandler.doChanges(opts);\n\t    });\n\t  } else if (opts.selector) {\n\t    opts.filter = function (doc) {\n\t      return matchesSelector(doc, opts.selector);\n\t    };\n\t    changesHandler.doChanges(opts);\n\t  } else {\n\t    // fetch a filter from a design doc\n\t    var filterName = parseDesignDocFunctionName(opts.filter);\n\t    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n\t      /* istanbul ignore if */\n\t      if (changesHandler.isCancelled) {\n\t        return callback(null, {status: 'cancelled'});\n\t      }\n\t      /* istanbul ignore next */\n\t      if (err) {\n\t        return callback(generateErrorFromResponse(err));\n\t      }\n\t      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n\t      if (!filterFun) {\n\t        return callback(createError(MISSING_DOC,\n\t          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n\t            : 'missing json key: filters')));\n\t      }\n\t      opts.filter = evalFilter(filterFun);\n\t      changesHandler.doChanges(opts);\n\t    });\n\t  }\n\t}\n\t\n\tfunction applyChangesFilterPlugin(PouchDB) {\n\t  PouchDB._changesFilterPlugin = {\n\t    validate: validate,\n\t    normalize: normalize,\n\t    shouldFilter: shouldFilter,\n\t    filter: filter\n\t  };\n\t}\n\t\n\t// TODO: remove from pouchdb-core (breaking)\n\tPouchDB.plugin(debugPouch);\n\t\n\t// TODO: remove from pouchdb-core (breaking)\n\tPouchDB.plugin(applyChangesFilterPlugin);\n\t\n\tPouchDB.version = version;\n\t\n\tfunction toObject(array) {\n\t  return array.reduce(function (obj, item) {\n\t    obj[item] = true;\n\t    return obj;\n\t  }, {});\n\t}\n\t// List of top level reserved words for doc\n\tvar reservedWords = toObject([\n\t  '_id',\n\t  '_rev',\n\t  '_attachments',\n\t  '_deleted',\n\t  '_revisions',\n\t  '_revs_info',\n\t  '_conflicts',\n\t  '_deleted_conflicts',\n\t  '_local_seq',\n\t  '_rev_tree',\n\t  //replication documents\n\t  '_replication_id',\n\t  '_replication_state',\n\t  '_replication_state_time',\n\t  '_replication_state_reason',\n\t  '_replication_stats',\n\t  // Specific to Couchbase Sync Gateway\n\t  '_removed'\n\t]);\n\t\n\t// List of reserved words that should end up the document\n\tvar dataWords = toObject([\n\t  '_attachments',\n\t  //replication documents\n\t  '_replication_id',\n\t  '_replication_state',\n\t  '_replication_state_time',\n\t  '_replication_state_reason',\n\t  '_replication_stats'\n\t]);\n\t\n\tfunction parseRevisionInfo(rev$$1) {\n\t  if (!/^\\d+-./.test(rev$$1)) {\n\t    return createError(INVALID_REV);\n\t  }\n\t  var idx = rev$$1.indexOf('-');\n\t  var left = rev$$1.substring(0, idx);\n\t  var right = rev$$1.substring(idx + 1);\n\t  return {\n\t    prefix: parseInt(left, 10),\n\t    id: right\n\t  };\n\t}\n\t\n\tfunction makeRevTreeFromRevisions(revisions, opts) {\n\t  var pos = revisions.start - revisions.ids.length + 1;\n\t\n\t  var revisionIds = revisions.ids;\n\t  var ids = [revisionIds[0], opts, []];\n\t\n\t  for (var i = 1, len = revisionIds.length; i < len; i++) {\n\t    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n\t  }\n\t\n\t  return [{\n\t    pos: pos,\n\t    ids: ids\n\t  }];\n\t}\n\t\n\t// Preprocess documents, parse their revisions, assign an id and a\n\t// revision for new writes that are missing them, etc\n\tfunction parseDoc(doc, newEdits) {\n\t\n\t  var nRevNum;\n\t  var newRevId;\n\t  var revInfo;\n\t  var opts = {status: 'available'};\n\t  if (doc._deleted) {\n\t    opts.deleted = true;\n\t  }\n\t\n\t  if (newEdits) {\n\t    if (!doc._id) {\n\t      doc._id = uuid();\n\t    }\n\t    newRevId = rev();\n\t    if (doc._rev) {\n\t      revInfo = parseRevisionInfo(doc._rev);\n\t      if (revInfo.error) {\n\t        return revInfo;\n\t      }\n\t      doc._rev_tree = [{\n\t        pos: revInfo.prefix,\n\t        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n\t      }];\n\t      nRevNum = revInfo.prefix + 1;\n\t    } else {\n\t      doc._rev_tree = [{\n\t        pos: 1,\n\t        ids : [newRevId, opts, []]\n\t      }];\n\t      nRevNum = 1;\n\t    }\n\t  } else {\n\t    if (doc._revisions) {\n\t      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n\t      nRevNum = doc._revisions.start;\n\t      newRevId = doc._revisions.ids[0];\n\t    }\n\t    if (!doc._rev_tree) {\n\t      revInfo = parseRevisionInfo(doc._rev);\n\t      if (revInfo.error) {\n\t        return revInfo;\n\t      }\n\t      nRevNum = revInfo.prefix;\n\t      newRevId = revInfo.id;\n\t      doc._rev_tree = [{\n\t        pos: nRevNum,\n\t        ids: [newRevId, opts, []]\n\t      }];\n\t    }\n\t  }\n\t\n\t  invalidIdError(doc._id);\n\t\n\t  doc._rev = nRevNum + '-' + newRevId;\n\t\n\t  var result = {metadata : {}, data : {}};\n\t  for (var key in doc) {\n\t    /* istanbul ignore else */\n\t    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n\t      var specialKey = key[0] === '_';\n\t      if (specialKey && !reservedWords[key]) {\n\t        var error = createError(DOC_VALIDATION, key);\n\t        error.message = DOC_VALIDATION.message + ': ' + key;\n\t        throw error;\n\t      } else if (specialKey && !dataWords[key]) {\n\t        result.metadata[key.slice(1)] = doc[key];\n\t      } else {\n\t        result.data[key] = doc[key];\n\t      }\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tvar thisAtob = function (str) {\n\t  return atob(str);\n\t};\n\t\n\tvar thisBtoa = function (str) {\n\t  return btoa(str);\n\t};\n\t\n\t// Abstracts constructing a Blob object, so it also works in older\n\t// browsers that don't support the native Blob constructor (e.g.\n\t// old QtWebKit versions, Android < 4.4).\n\tfunction createBlob(parts, properties) {\n\t  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n\t  parts = parts || [];\n\t  properties = properties || {};\n\t  try {\n\t    return new Blob(parts, properties);\n\t  } catch (e) {\n\t    if (e.name !== \"TypeError\") {\n\t      throw e;\n\t    }\n\t    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n\t                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n\t                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n\t                  WebKitBlobBuilder;\n\t    var builder = new Builder();\n\t    for (var i = 0; i < parts.length; i += 1) {\n\t      builder.append(parts[i]);\n\t    }\n\t    return builder.getBlob(properties.type);\n\t  }\n\t}\n\t\n\t// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n\t// encode-decode-image-with-base64-breaks-image (2013-04-21)\n\tfunction binaryStringToArrayBuffer(bin) {\n\t  var length = bin.length;\n\t  var buf = new ArrayBuffer(length);\n\t  var arr = new Uint8Array(buf);\n\t  for (var i = 0; i < length; i++) {\n\t    arr[i] = bin.charCodeAt(i);\n\t  }\n\t  return buf;\n\t}\n\t\n\tfunction binStringToBluffer(binString, type) {\n\t  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n\t}\n\t\n\tfunction b64ToBluffer(b64, type) {\n\t  return binStringToBluffer(thisAtob(b64), type);\n\t}\n\t\n\t//Can't find original post, but this is close\n\t//http://stackoverflow.com/questions/6965107/ (continues on next line)\n\t//converting-between-strings-and-arraybuffers\n\tfunction arrayBufferToBinaryString(buffer) {\n\t  var binary = '';\n\t  var bytes = new Uint8Array(buffer);\n\t  var length = bytes.byteLength;\n\t  for (var i = 0; i < length; i++) {\n\t    binary += String.fromCharCode(bytes[i]);\n\t  }\n\t  return binary;\n\t}\n\t\n\t// shim for browsers that don't support it\n\tfunction readAsBinaryString(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(arrayBufferToBinaryString(\n\t      new FileReaderSync().readAsArrayBuffer(blob)));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || '';\n\t    if (hasBinaryString) {\n\t      return callback(result);\n\t    }\n\t    callback(arrayBufferToBinaryString(result));\n\t  };\n\t  if (hasBinaryString) {\n\t    reader.readAsBinaryString(blob);\n\t  } else {\n\t    reader.readAsArrayBuffer(blob);\n\t  }\n\t}\n\t\n\tfunction blobToBinaryString(blobOrBuffer, callback) {\n\t  readAsBinaryString(blobOrBuffer, function (bin) {\n\t    callback(bin);\n\t  });\n\t}\n\t\n\tfunction blobToBase64(blobOrBuffer, callback) {\n\t  blobToBinaryString(blobOrBuffer, function (base64) {\n\t    callback(thisBtoa(base64));\n\t  });\n\t}\n\t\n\t// simplified API. universal browser support is assumed\n\tfunction readAsArrayBuffer(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker:\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || new ArrayBuffer(0);\n\t    callback(result);\n\t  };\n\t  reader.readAsArrayBuffer(blob);\n\t}\n\t\n\t// this is not used in the browser\n\t\n\tvar setImmediateShim = global.setImmediate || global.setTimeout;\n\tvar MD5_CHUNK_SIZE = 32768;\n\t\n\tfunction rawToBase64(raw) {\n\t  return thisBtoa(raw);\n\t}\n\t\n\tfunction sliceBlob(blob, start, end) {\n\t  if (blob.webkitSlice) {\n\t    return blob.webkitSlice(start, end);\n\t  }\n\t  return blob.slice(start, end);\n\t}\n\t\n\tfunction appendBlob(buffer, blob, start, end, callback) {\n\t  if (start > 0 || end < blob.size) {\n\t    // only slice blob if we really need to\n\t    blob = sliceBlob(blob, start, end);\n\t  }\n\t  readAsArrayBuffer(blob, function (arrayBuffer) {\n\t    buffer.append(arrayBuffer);\n\t    callback();\n\t  });\n\t}\n\t\n\tfunction appendString(buffer, string, start, end, callback) {\n\t  if (start > 0 || end < string.length) {\n\t    // only create a substring if we really need to\n\t    string = string.substring(start, end);\n\t  }\n\t  buffer.appendBinary(string);\n\t  callback();\n\t}\n\t\n\tfunction binaryMd5(data, callback) {\n\t  var inputIsString = typeof data === 'string';\n\t  var len = inputIsString ? data.length : data.size;\n\t  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n\t  var chunks = Math.ceil(len / chunkSize);\n\t  var currentChunk = 0;\n\t  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\t\n\t  var append = inputIsString ? appendString : appendBlob;\n\t\n\t  function next() {\n\t    setImmediateShim(loadNextChunk);\n\t  }\n\t\n\t  function done() {\n\t    var raw = buffer.end(true);\n\t    var base64 = rawToBase64(raw);\n\t    callback(base64);\n\t    buffer.destroy();\n\t  }\n\t\n\t  function loadNextChunk() {\n\t    var start = currentChunk * chunkSize;\n\t    var end = start + chunkSize;\n\t    currentChunk++;\n\t    if (currentChunk < chunks) {\n\t      append(buffer, data, start, end, next);\n\t    } else {\n\t      append(buffer, data, start, end, done);\n\t    }\n\t  }\n\t  loadNextChunk();\n\t}\n\t\n\tfunction stringMd5(string) {\n\t  return Md5.hash(string);\n\t}\n\t\n\tfunction parseBase64(data) {\n\t  try {\n\t    return thisAtob(data);\n\t  } catch (e) {\n\t    var err = createError(BAD_ARG,\n\t      'Attachment is not a valid base64 string');\n\t    return {error: err};\n\t  }\n\t}\n\t\n\tfunction preprocessString(att, blobType, callback) {\n\t  var asBinary = parseBase64(att.data);\n\t  if (asBinary.error) {\n\t    return callback(asBinary.error);\n\t  }\n\t\n\t  att.length = asBinary.length;\n\t  if (blobType === 'blob') {\n\t    att.data = binStringToBluffer(asBinary, att.content_type);\n\t  } else if (blobType === 'base64') {\n\t    att.data = thisBtoa(asBinary);\n\t  } else { // binary\n\t    att.data = asBinary;\n\t  }\n\t  binaryMd5(asBinary, function (result) {\n\t    att.digest = 'md5-' + result;\n\t    callback();\n\t  });\n\t}\n\t\n\tfunction preprocessBlob(att, blobType, callback) {\n\t  binaryMd5(att.data, function (md5) {\n\t    att.digest = 'md5-' + md5;\n\t    // size is for blobs (browser), length is for buffers (node)\n\t    att.length = att.data.size || att.data.length || 0;\n\t    if (blobType === 'binary') {\n\t      blobToBinaryString(att.data, function (binString) {\n\t        att.data = binString;\n\t        callback();\n\t      });\n\t    } else if (blobType === 'base64') {\n\t      blobToBase64(att.data, function (b64) {\n\t        att.data = b64;\n\t        callback();\n\t      });\n\t    } else {\n\t      callback();\n\t    }\n\t  });\n\t}\n\t\n\tfunction preprocessAttachment(att, blobType, callback) {\n\t  if (att.stub) {\n\t    return callback();\n\t  }\n\t  if (typeof att.data === 'string') { // input is a base64 string\n\t    preprocessString(att, blobType, callback);\n\t  } else { // input is a blob\n\t    preprocessBlob(att, blobType, callback);\n\t  }\n\t}\n\t\n\tfunction preprocessAttachments(docInfos, blobType, callback) {\n\t\n\t  if (!docInfos.length) {\n\t    return callback();\n\t  }\n\t\n\t  var docv = 0;\n\t  var overallErr;\n\t\n\t  docInfos.forEach(function (docInfo) {\n\t    var attachments = docInfo.data && docInfo.data._attachments ?\n\t      Object.keys(docInfo.data._attachments) : [];\n\t    var recv = 0;\n\t\n\t    if (!attachments.length) {\n\t      return done();\n\t    }\n\t\n\t    function processedAttachment(err) {\n\t      overallErr = err;\n\t      recv++;\n\t      if (recv === attachments.length) {\n\t        done();\n\t      }\n\t    }\n\t\n\t    for (var key in docInfo.data._attachments) {\n\t      if (docInfo.data._attachments.hasOwnProperty(key)) {\n\t        preprocessAttachment(docInfo.data._attachments[key],\n\t          blobType, processedAttachment);\n\t      }\n\t    }\n\t  });\n\t\n\t  function done() {\n\t    docv++;\n\t    if (docInfos.length === docv) {\n\t      if (overallErr) {\n\t        callback(overallErr);\n\t      } else {\n\t        callback();\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction updateDoc(revLimit, prev, docInfo, results,\n\t                   i, cb, writeDoc, newEdits) {\n\t\n\t  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n\t    results[i] = docInfo;\n\t    return cb();\n\t  }\n\t\n\t  // sometimes this is pre-calculated. historically not always\n\t  var previousWinningRev = prev.winningRev || winningRev(prev);\n\t  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n\t    isDeleted(prev, previousWinningRev);\n\t  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n\t    isDeleted(docInfo.metadata);\n\t  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\t\n\t  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n\t    var newDoc = docInfo.data;\n\t    newDoc._rev = previousWinningRev;\n\t    newDoc._id = docInfo.metadata.id;\n\t    docInfo = parseDoc(newDoc, newEdits);\n\t  }\n\t\n\t  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\t\n\t  var inConflict = newEdits && ((\n\t    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n\t    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n\t    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\t\n\t  if (inConflict) {\n\t    var err = createError(REV_CONFLICT);\n\t    results[i] = err;\n\t    return cb();\n\t  }\n\t\n\t  var newRev = docInfo.metadata.rev;\n\t  docInfo.metadata.rev_tree = merged.tree;\n\t  docInfo.stemmedRevs = merged.stemmedRevs || [];\n\t  /* istanbul ignore else */\n\t  if (prev.rev_map) {\n\t    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n\t  }\n\t\n\t  // recalculate\n\t  var winningRev$$1 = winningRev(docInfo.metadata);\n\t  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\t\n\t  // calculate the total number of documents that were added/removed,\n\t  // from the perspective of total_rows/doc_count\n\t  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n\t    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\t\n\t  var newRevIsDeleted;\n\t  if (newRev === winningRev$$1) {\n\t    // if the new rev is the same as the winning rev, we can reuse that value\n\t    newRevIsDeleted = winningRevIsDeleted;\n\t  } else {\n\t    // if they're not the same, then we need to recalculate\n\t    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n\t  }\n\t\n\t  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n\t    true, delta, i, cb);\n\t}\n\t\n\tfunction rootIsMissing(docInfo) {\n\t  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n\t}\n\t\n\tfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n\t                     writeDoc, opts, overallCallback) {\n\t\n\t  // Default to 1000 locally\n\t  revLimit = revLimit || 1000;\n\t\n\t  function insertDoc(docInfo, resultsIdx, callback) {\n\t    // Cant insert new deleted documents\n\t    var winningRev$$1 = winningRev(docInfo.metadata);\n\t    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n\t    if ('was_delete' in opts && deleted) {\n\t      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n\t      return callback();\n\t    }\n\t\n\t    // 4712 - detect whether a new document was inserted with a _rev\n\t    var inConflict = newEdits && rootIsMissing(docInfo);\n\t\n\t    if (inConflict) {\n\t      var err = createError(REV_CONFLICT);\n\t      results[resultsIdx] = err;\n\t      return callback();\n\t    }\n\t\n\t    var delta = deleted ? 0 : 1;\n\t\n\t    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n\t      delta, resultsIdx, callback);\n\t  }\n\t\n\t  var newEdits = opts.new_edits;\n\t  var idsToDocs = new ExportedMap();\n\t\n\t  var docsDone = 0;\n\t  var docsToDo = docInfos.length;\n\t\n\t  function checkAllDocsDone() {\n\t    if (++docsDone === docsToDo && overallCallback) {\n\t      overallCallback();\n\t    }\n\t  }\n\t\n\t  docInfos.forEach(function (currentDoc, resultsIdx) {\n\t\n\t    if (currentDoc._id && isLocalId(currentDoc._id)) {\n\t      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n\t      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n\t        results[resultsIdx] = err || res;\n\t        checkAllDocsDone();\n\t      });\n\t      return;\n\t    }\n\t\n\t    var id = currentDoc.metadata.id;\n\t    if (idsToDocs.has(id)) {\n\t      docsToDo--; // duplicate\n\t      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n\t    } else {\n\t      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n\t    }\n\t  });\n\t\n\t  // in the case of new_edits, the user can provide multiple docs\n\t  // with the same id. these need to be processed sequentially\n\t  idsToDocs.forEach(function (docs, id) {\n\t    var numDone = 0;\n\t\n\t    function docWritten() {\n\t      if (++numDone < docs.length) {\n\t        nextDoc();\n\t      } else {\n\t        checkAllDocsDone();\n\t      }\n\t    }\n\t    function nextDoc() {\n\t      var value = docs[numDone];\n\t      var currentDoc = value[0];\n\t      var resultsIdx = value[1];\n\t\n\t      if (fetchedDocs.has(id)) {\n\t        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n\t          resultsIdx, docWritten, writeDoc, newEdits);\n\t      } else {\n\t        // Ensure stemming applies to new writes as well\n\t        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n\t        currentDoc.metadata.rev_tree = merged.tree;\n\t        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n\t        insertDoc(currentDoc, resultsIdx, docWritten);\n\t      }\n\t    }\n\t    nextDoc();\n\t  });\n\t}\n\t\n\t// IndexedDB requires a versioned database structure, so we use the\n\t// version here to manage migrations.\n\tvar ADAPTER_VERSION = 5;\n\t\n\t// The object stores created for each database\n\t// DOC_STORE stores the document meta data, its revision history and state\n\t// Keyed by document id\n\tvar DOC_STORE = 'document-store';\n\t// BY_SEQ_STORE stores a particular version of a document, keyed by its\n\t// sequence id\n\tvar BY_SEQ_STORE = 'by-sequence';\n\t// Where we store attachments\n\tvar ATTACH_STORE = 'attach-store';\n\t// Where we store many-to-many relations\n\t// between attachment digests and seqs\n\tvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\t\n\t// Where we store database-wide meta data in a single record\n\t// keyed by id: META_STORE\n\tvar META_STORE = 'meta-store';\n\t// Where we store local documents\n\tvar LOCAL_STORE = 'local-store';\n\t// Where we detect blob support\n\tvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\t\n\tfunction safeJsonParse(str) {\n\t  // This try/catch guards against stack overflow errors.\n\t  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n\t  // cannot overflow.\n\t  try {\n\t    return JSON.parse(str);\n\t  } catch (e) {\n\t    /* istanbul ignore next */\n\t    return vuvuzela.parse(str);\n\t  }\n\t}\n\t\n\tfunction safeJsonStringify(json) {\n\t  try {\n\t    return JSON.stringify(json);\n\t  } catch (e) {\n\t    /* istanbul ignore next */\n\t    return vuvuzela.stringify(json);\n\t  }\n\t}\n\t\n\tfunction idbError(callback) {\n\t  return function (evt) {\n\t    var message = 'unknown_error';\n\t    if (evt.target && evt.target.error) {\n\t      message = evt.target.error.name || evt.target.error.message;\n\t    }\n\t    callback(createError(IDB_ERROR, message, evt.type));\n\t  };\n\t}\n\t\n\t// Unfortunately, the metadata has to be stringified\n\t// when it is put into the database, because otherwise\n\t// IndexedDB can throw errors for deeply-nested objects.\n\t// Originally we just used JSON.parse/JSON.stringify; now\n\t// we use this custom vuvuzela library that avoids recursion.\n\t// If we could do it all over again, we'd probably use a\n\t// format for the revision trees other than JSON.\n\tfunction encodeMetadata(metadata, winningRev, deleted) {\n\t  return {\n\t    data: safeJsonStringify(metadata),\n\t    winningRev: winningRev,\n\t    deletedOrLocal: deleted ? '1' : '0',\n\t    seq: metadata.seq, // highest seq for this doc\n\t    id: metadata.id\n\t  };\n\t}\n\t\n\tfunction decodeMetadata(storedObject) {\n\t  if (!storedObject) {\n\t    return null;\n\t  }\n\t  var metadata = safeJsonParse(storedObject.data);\n\t  metadata.winningRev = storedObject.winningRev;\n\t  metadata.deleted = storedObject.deletedOrLocal === '1';\n\t  metadata.seq = storedObject.seq;\n\t  return metadata;\n\t}\n\t\n\t// read the doc back out from the database. we don't store the\n\t// _id or _rev because we already have _doc_id_rev.\n\tfunction decodeDoc(doc) {\n\t  if (!doc) {\n\t    return doc;\n\t  }\n\t  var idx = doc._doc_id_rev.lastIndexOf(':');\n\t  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n\t  doc._rev = doc._doc_id_rev.substring(idx + 1);\n\t  delete doc._doc_id_rev;\n\t  return doc;\n\t}\n\t\n\t// Read a blob from the database, encoding as necessary\n\t// and translating from base64 if the IDB doesn't support\n\t// native Blobs\n\tfunction readBlobData(body, type, asBlob, callback) {\n\t  if (asBlob) {\n\t    if (!body) {\n\t      callback(createBlob([''], {type: type}));\n\t    } else if (typeof body !== 'string') { // we have blob support\n\t      callback(body);\n\t    } else { // no blob support\n\t      callback(b64ToBluffer(body, type));\n\t    }\n\t  } else { // as base64 string\n\t    if (!body) {\n\t      callback('');\n\t    } else if (typeof body !== 'string') { // we have blob support\n\t      readAsBinaryString(body, function (binary) {\n\t        callback(thisBtoa(binary));\n\t      });\n\t    } else { // no blob support\n\t      callback(body);\n\t    }\n\t  }\n\t}\n\t\n\tfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n\t  var attachments = Object.keys(doc._attachments || {});\n\t  if (!attachments.length) {\n\t    return cb && cb();\n\t  }\n\t  var numDone = 0;\n\t\n\t  function checkDone() {\n\t    if (++numDone === attachments.length && cb) {\n\t      cb();\n\t    }\n\t  }\n\t\n\t  function fetchAttachment(doc, att) {\n\t    var attObj = doc._attachments[att];\n\t    var digest = attObj.digest;\n\t    var req = txn.objectStore(ATTACH_STORE).get(digest);\n\t    req.onsuccess = function (e) {\n\t      attObj.body = e.target.result.body;\n\t      checkDone();\n\t    };\n\t  }\n\t\n\t  attachments.forEach(function (att) {\n\t    if (opts.attachments && opts.include_docs) {\n\t      fetchAttachment(doc, att);\n\t    } else {\n\t      doc._attachments[att].stub = true;\n\t      checkDone();\n\t    }\n\t  });\n\t}\n\t\n\t// IDB-specific postprocessing necessary because\n\t// we don't know whether we stored a true Blob or\n\t// a base64-encoded string, and if it's a Blob it\n\t// needs to be read outside of the transaction context\n\tfunction postProcessAttachments(results, asBlob) {\n\t  return PouchPromise.all(results.map(function (row) {\n\t    if (row.doc && row.doc._attachments) {\n\t      var attNames = Object.keys(row.doc._attachments);\n\t      return PouchPromise.all(attNames.map(function (att) {\n\t        var attObj = row.doc._attachments[att];\n\t        if (!('body' in attObj)) { // already processed\n\t          return;\n\t        }\n\t        var body = attObj.body;\n\t        var type = attObj.content_type;\n\t        return new PouchPromise(function (resolve) {\n\t          readBlobData(body, type, asBlob, function (data) {\n\t            row.doc._attachments[att] = $inject_Object_assign(\n\t              pick(attObj, ['digest', 'content_type']),\n\t              {data: data}\n\t            );\n\t            resolve();\n\t          });\n\t        });\n\t      }));\n\t    }\n\t  }));\n\t}\n\t\n\tfunction compactRevs(revs, docId, txn) {\n\t\n\t  var possiblyOrphanedDigests = [];\n\t  var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t  var attStore = txn.objectStore(ATTACH_STORE);\n\t  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t  var count = revs.length;\n\t\n\t  function checkDone() {\n\t    count--;\n\t    if (!count) { // done processing all revs\n\t      deleteOrphanedAttachments();\n\t    }\n\t  }\n\t\n\t  function deleteOrphanedAttachments() {\n\t    if (!possiblyOrphanedDigests.length) {\n\t      return;\n\t    }\n\t    possiblyOrphanedDigests.forEach(function (digest) {\n\t      var countReq = attAndSeqStore.index('digestSeq').count(\n\t        IDBKeyRange.bound(\n\t          digest + '::', digest + '::\\uffff', false, false));\n\t      countReq.onsuccess = function (e) {\n\t        var count = e.target.result;\n\t        if (!count) {\n\t          // orphaned\n\t          attStore.delete(digest);\n\t        }\n\t      };\n\t    });\n\t  }\n\t\n\t  revs.forEach(function (rev$$1) {\n\t    var index = seqStore.index('_doc_id_rev');\n\t    var key = docId + \"::\" + rev$$1;\n\t    index.getKey(key).onsuccess = function (e) {\n\t      var seq = e.target.result;\n\t      if (typeof seq !== 'number') {\n\t        return checkDone();\n\t      }\n\t      seqStore.delete(seq);\n\t\n\t      var cursor = attAndSeqStore.index('seq')\n\t        .openCursor(IDBKeyRange.only(seq));\n\t\n\t      cursor.onsuccess = function (event) {\n\t        var cursor = event.target.result;\n\t        if (cursor) {\n\t          var digest = cursor.value.digestSeq.split('::')[0];\n\t          possiblyOrphanedDigests.push(digest);\n\t          attAndSeqStore.delete(cursor.primaryKey);\n\t          cursor.continue();\n\t        } else { // done\n\t          checkDone();\n\t        }\n\t      };\n\t    };\n\t  });\n\t}\n\t\n\tfunction openTransactionSafely(idb, stores, mode) {\n\t  try {\n\t    return {\n\t      txn: idb.transaction(stores, mode)\n\t    };\n\t  } catch (err) {\n\t    return {\n\t      error: err\n\t    };\n\t  }\n\t}\n\t\n\tvar changesHandler$$1 = new Changes();\n\t\n\tfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n\t  var docInfos = req.docs;\n\t  var txn;\n\t  var docStore;\n\t  var bySeqStore;\n\t  var attachStore;\n\t  var attachAndSeqStore;\n\t  var metaStore;\n\t  var docInfoError;\n\t  var metaDoc;\n\t\n\t  for (var i = 0, len = docInfos.length; i < len; i++) {\n\t    var doc = docInfos[i];\n\t    if (doc._id && isLocalId(doc._id)) {\n\t      continue;\n\t    }\n\t    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n\t    if (doc.error && !docInfoError) {\n\t      docInfoError = doc;\n\t    }\n\t  }\n\t\n\t  if (docInfoError) {\n\t    return callback(docInfoError);\n\t  }\n\t\n\t  var allDocsProcessed = false;\n\t  var docCountDelta = 0;\n\t  var results = new Array(docInfos.length);\n\t  var fetchedDocs = new ExportedMap();\n\t  var preconditionErrored = false;\n\t  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\t\n\t  preprocessAttachments(docInfos, blobType, function (err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    startTransaction();\n\t  });\n\t\n\t  function startTransaction() {\n\t\n\t    var stores = [\n\t      DOC_STORE, BY_SEQ_STORE,\n\t      ATTACH_STORE,\n\t      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n\t      META_STORE\n\t    ];\n\t    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    txn = txnResult.txn;\n\t    txn.onabort = idbError(callback);\n\t    txn.ontimeout = idbError(callback);\n\t    txn.oncomplete = complete;\n\t    docStore = txn.objectStore(DOC_STORE);\n\t    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t    attachStore = txn.objectStore(ATTACH_STORE);\n\t    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t    metaStore = txn.objectStore(META_STORE);\n\t\n\t    metaStore.get(META_STORE).onsuccess = function (e) {\n\t      metaDoc = e.target.result;\n\t      updateDocCountIfReady();\n\t    };\n\t\n\t    verifyAttachments(function (err) {\n\t      if (err) {\n\t        preconditionErrored = true;\n\t        return callback(err);\n\t      }\n\t      fetchExistingDocs();\n\t    });\n\t  }\n\t\n\t  function onAllDocsProcessed() {\n\t    allDocsProcessed = true;\n\t    updateDocCountIfReady();\n\t  }\n\t\n\t  function idbProcessDocs() {\n\t    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n\t                txn, results, writeDoc, opts, onAllDocsProcessed);\n\t  }\n\t\n\t  function updateDocCountIfReady() {\n\t    if (!metaDoc || !allDocsProcessed) {\n\t      return;\n\t    }\n\t    // caching the docCount saves a lot of time in allDocs() and\n\t    // info(), which is why we go to all the trouble of doing this\n\t    metaDoc.docCount += docCountDelta;\n\t    metaStore.put(metaDoc);\n\t  }\n\t\n\t  function fetchExistingDocs() {\n\t\n\t    if (!docInfos.length) {\n\t      return;\n\t    }\n\t\n\t    var numFetched = 0;\n\t\n\t    function checkDone() {\n\t      if (++numFetched === docInfos.length) {\n\t        idbProcessDocs();\n\t      }\n\t    }\n\t\n\t    function readMetadata(event) {\n\t      var metadata = decodeMetadata(event.target.result);\n\t\n\t      if (metadata) {\n\t        fetchedDocs.set(metadata.id, metadata);\n\t      }\n\t      checkDone();\n\t    }\n\t\n\t    for (var i = 0, len = docInfos.length; i < len; i++) {\n\t      var docInfo = docInfos[i];\n\t      if (docInfo._id && isLocalId(docInfo._id)) {\n\t        checkDone(); // skip local docs\n\t        continue;\n\t      }\n\t      var req = docStore.get(docInfo.metadata.id);\n\t      req.onsuccess = readMetadata;\n\t    }\n\t  }\n\t\n\t  function complete() {\n\t    if (preconditionErrored) {\n\t      return;\n\t    }\n\t\n\t    changesHandler$$1.notify(api._meta.name);\n\t    callback(null, results);\n\t  }\n\t\n\t  function verifyAttachment(digest, callback) {\n\t\n\t    var req = attachStore.get(digest);\n\t    req.onsuccess = function (e) {\n\t      if (!e.target.result) {\n\t        var err = createError(MISSING_STUB,\n\t          'unknown stub attachment with digest ' +\n\t          digest);\n\t        err.status = 412;\n\t        callback(err);\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t  }\n\t\n\t  function verifyAttachments(finish) {\n\t\n\t\n\t    var digests = [];\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo.data && docInfo.data._attachments) {\n\t        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n\t          var att = docInfo.data._attachments[filename];\n\t          if (att.stub) {\n\t            digests.push(att.digest);\n\t          }\n\t        });\n\t      }\n\t    });\n\t    if (!digests.length) {\n\t      return finish();\n\t    }\n\t    var numDone = 0;\n\t    var err;\n\t\n\t    function checkDone() {\n\t      if (++numDone === digests.length) {\n\t        finish(err);\n\t      }\n\t    }\n\t    digests.forEach(function (digest) {\n\t      verifyAttachment(digest, function (attErr) {\n\t        if (attErr && !err) {\n\t          err = attErr;\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n\t                    isUpdate, delta, resultsIdx, callback) {\n\t\n\t    docInfo.metadata.winningRev = winningRev$$1;\n\t    docInfo.metadata.deleted = winningRevIsDeleted;\n\t\n\t    var doc = docInfo.data;\n\t    doc._id = docInfo.metadata.id;\n\t    doc._rev = docInfo.metadata.rev;\n\t\n\t    if (newRevIsDeleted) {\n\t      doc._deleted = true;\n\t    }\n\t\n\t    var hasAttachments = doc._attachments &&\n\t      Object.keys(doc._attachments).length;\n\t    if (hasAttachments) {\n\t      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n\t        isUpdate, resultsIdx, callback);\n\t    }\n\t\n\t    docCountDelta += delta;\n\t    updateDocCountIfReady();\n\t\n\t    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n\t      isUpdate, resultsIdx, callback);\n\t  }\n\t\n\t  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n\t                     isUpdate, resultsIdx, callback) {\n\t\n\t    var doc = docInfo.data;\n\t    var metadata = docInfo.metadata;\n\t\n\t    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n\t    delete doc._id;\n\t    delete doc._rev;\n\t\n\t    function afterPutDoc(e) {\n\t      var revsToDelete = docInfo.stemmedRevs || [];\n\t\n\t      if (isUpdate && api.auto_compaction) {\n\t        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n\t      }\n\t\n\t      if (revsToDelete && revsToDelete.length) {\n\t        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n\t      }\n\t\n\t      metadata.seq = e.target.result;\n\t      // Current _rev is calculated from _rev_tree on read\n\t      // delete metadata.rev;\n\t      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n\t        winningRevIsDeleted);\n\t      var metaDataReq = docStore.put(metadataToStore);\n\t      metaDataReq.onsuccess = afterPutMetadata;\n\t    }\n\t\n\t    function afterPutDocError(e) {\n\t      // ConstraintError, need to update, not put (see #1638 for details)\n\t      e.preventDefault(); // avoid transaction abort\n\t      e.stopPropagation(); // avoid transaction onerror\n\t      var index = bySeqStore.index('_doc_id_rev');\n\t      var getKeyReq = index.getKey(doc._doc_id_rev);\n\t      getKeyReq.onsuccess = function (e) {\n\t        var putReq = bySeqStore.put(doc, e.target.result);\n\t        putReq.onsuccess = afterPutDoc;\n\t      };\n\t    }\n\t\n\t    function afterPutMetadata() {\n\t      results[resultsIdx] = {\n\t        ok: true,\n\t        id: metadata.id,\n\t        rev: metadata.rev\n\t      };\n\t      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n\t      insertAttachmentMappings(docInfo, metadata.seq, callback);\n\t    }\n\t\n\t    var putReq = bySeqStore.put(doc);\n\t\n\t    putReq.onsuccess = afterPutDoc;\n\t    putReq.onerror = afterPutDocError;\n\t  }\n\t\n\t  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n\t                            isUpdate, resultsIdx, callback) {\n\t\n\t\n\t    var doc = docInfo.data;\n\t\n\t    var numDone = 0;\n\t    var attachments = Object.keys(doc._attachments);\n\t\n\t    function collectResults() {\n\t      if (numDone === attachments.length) {\n\t        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n\t          isUpdate, resultsIdx, callback);\n\t      }\n\t    }\n\t\n\t    function attachmentSaved() {\n\t      numDone++;\n\t      collectResults();\n\t    }\n\t\n\t    attachments.forEach(function (key) {\n\t      var att = docInfo.data._attachments[key];\n\t      if (!att.stub) {\n\t        var data = att.data;\n\t        delete att.data;\n\t        att.revpos = parseInt(winningRev$$1, 10);\n\t        var digest = att.digest;\n\t        saveAttachment(digest, data, attachmentSaved);\n\t      } else {\n\t        numDone++;\n\t        collectResults();\n\t      }\n\t    });\n\t  }\n\t\n\t  // map seqs to attachment digests, which\n\t  // we will need later during compaction\n\t  function insertAttachmentMappings(docInfo, seq, callback) {\n\t\n\t    var attsAdded = 0;\n\t    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\t\n\t    if (!attsToAdd.length) {\n\t      return callback();\n\t    }\n\t\n\t    function checkDone() {\n\t      if (++attsAdded === attsToAdd.length) {\n\t        callback();\n\t      }\n\t    }\n\t\n\t    function add(att) {\n\t      var digest = docInfo.data._attachments[att].digest;\n\t      var req = attachAndSeqStore.put({\n\t        seq: seq,\n\t        digestSeq: digest + '::' + seq\n\t      });\n\t\n\t      req.onsuccess = checkDone;\n\t      req.onerror = function (e) {\n\t        // this callback is for a constaint error, which we ignore\n\t        // because this docid/rev has already been associated with\n\t        // the digest (e.g. when new_edits == false)\n\t        e.preventDefault(); // avoid transaction abort\n\t        e.stopPropagation(); // avoid transaction onerror\n\t        checkDone();\n\t      };\n\t    }\n\t    for (var i = 0; i < attsToAdd.length; i++) {\n\t      add(attsToAdd[i]); // do in parallel\n\t    }\n\t  }\n\t\n\t  function saveAttachment(digest, data, callback) {\n\t\n\t\n\t    var getKeyReq = attachStore.count(digest);\n\t    getKeyReq.onsuccess = function (e) {\n\t      var count = e.target.result;\n\t      if (count) {\n\t        return callback(); // already exists\n\t      }\n\t      var newAtt = {\n\t        digest: digest,\n\t        body: data\n\t      };\n\t      var putReq = attachStore.put(newAtt);\n\t      putReq.onsuccess = callback;\n\t    };\n\t  }\n\t}\n\t\n\t// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n\t// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n\t// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n\t// we're not processing each document one-at-a-time.\n\tfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\t\n\t  // Bail out of getAll()/getAllKeys() in the following cases:\n\t  // 1) either method is unsupported - we need both\n\t  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n\t  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n\t  //    perhaps they are filtering on a per-doc basis)\n\t  // 3) descending â no real way to do this via getAll()/getAllKeys()\n\t\n\t  var useGetAll = typeof objectStore.getAll === 'function' &&\n\t    typeof objectStore.getAllKeys === 'function' &&\n\t    batchSize > 1 && !descending;\n\t\n\t  var keysBatch;\n\t  var valuesBatch;\n\t  var pseudoCursor;\n\t\n\t  function onGetAll(e) {\n\t    valuesBatch = e.target.result;\n\t    if (keysBatch) {\n\t      onBatch(keysBatch, valuesBatch, pseudoCursor);\n\t    }\n\t  }\n\t\n\t  function onGetAllKeys(e) {\n\t    keysBatch = e.target.result;\n\t    if (valuesBatch) {\n\t      onBatch(keysBatch, valuesBatch, pseudoCursor);\n\t    }\n\t  }\n\t\n\t  function continuePseudoCursor() {\n\t    if (!keysBatch.length) { // no more results\n\t      return onBatch();\n\t    }\n\t    // fetch next batch, exclusive start\n\t    var lastKey = keysBatch[keysBatch.length - 1];\n\t    var newKeyRange;\n\t    if (keyRange && keyRange.upper) {\n\t      try {\n\t        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n\t          true, keyRange.upperOpen);\n\t      } catch (e) {\n\t        if (e.name === \"DataError\" && e.code === 0) {\n\t          return onBatch(); // we're done, startkey and endkey are equal\n\t        }\n\t      }\n\t    } else {\n\t      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n\t    }\n\t    keyRange = newKeyRange;\n\t    keysBatch = null;\n\t    valuesBatch = null;\n\t    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n\t    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n\t  }\n\t\n\t  function onCursor(e) {\n\t    var cursor = e.target.result;\n\t    if (!cursor) { // done\n\t      return onBatch();\n\t    }\n\t    // regular IDBCursor acts like a batch where batch size is always 1\n\t    onBatch([cursor.key], [cursor.value], cursor);\n\t  }\n\t\n\t  if (useGetAll) {\n\t    pseudoCursor = {\"continue\": continuePseudoCursor};\n\t    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n\t    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n\t  } else if (descending) {\n\t    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n\t  } else {\n\t    objectStore.openCursor(keyRange).onsuccess = onCursor;\n\t  }\n\t}\n\t\n\t// simple shim for objectStore.getAll(), falling back to IDBCursor\n\tfunction getAll(objectStore, keyRange, onSuccess) {\n\t  if (typeof objectStore.getAll === 'function') {\n\t    // use native getAll\n\t    objectStore.getAll(keyRange).onsuccess = onSuccess;\n\t    return;\n\t  }\n\t  // fall back to cursors\n\t  var values = [];\n\t\n\t  function onCursor(e) {\n\t    var cursor = e.target.result;\n\t    if (cursor) {\n\t      values.push(cursor.value);\n\t      cursor.continue();\n\t    } else {\n\t      onSuccess({\n\t        target: {\n\t          result: values\n\t        }\n\t      });\n\t    }\n\t  }\n\t\n\t  objectStore.openCursor(keyRange).onsuccess = onCursor;\n\t}\n\t\n\tfunction allDocsKeys(keys, docStore, onBatch) {\n\t  // It's not guaranted to be returned in right order  \n\t  var valuesBatch = [];\n\t  var count = 0;\n\t  keys.forEach(function (key, index) {\n\t    docStore.get(key).onsuccess = function (event) {\n\t      if (event.target.result) {\n\t        valuesBatch[index] = event.target.result;\n\t      } else {\n\t        valuesBatch[index] = {key: key, error: 'not_found'};\n\t      }\n\t      count++;\n\t      if (count === keys.length) {\n\t        onBatch(keys, valuesBatch, {});\n\t      }\n\t    };\n\t  });\n\t}\n\t\n\tfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n\t  try {\n\t    if (start && end) {\n\t      if (descending) {\n\t        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n\t      } else {\n\t        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n\t      }\n\t    } else if (start) {\n\t      if (descending) {\n\t        return IDBKeyRange.upperBound(start);\n\t      } else {\n\t        return IDBKeyRange.lowerBound(start);\n\t      }\n\t    } else if (end) {\n\t      if (descending) {\n\t        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n\t      } else {\n\t        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n\t      }\n\t    } else if (key) {\n\t      return IDBKeyRange.only(key);\n\t    }\n\t  } catch (e) {\n\t    return {error: e};\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction idbAllDocs(opts, idb, callback) {\n\t  var start = 'startkey' in opts ? opts.startkey : false;\n\t  var end = 'endkey' in opts ? opts.endkey : false;\n\t  var key = 'key' in opts ? opts.key : false;\n\t  var keys = 'keys' in opts ? opts.keys : false; \n\t  var skip = opts.skip || 0;\n\t  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n\t  var inclusiveEnd = opts.inclusive_end !== false;\n\t\n\t  var keyRange; \n\t  var keyRangeError;\n\t  if (!keys) {\n\t    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n\t    keyRangeError = keyRange && keyRange.error;\n\t    if (keyRangeError && \n\t      !(keyRangeError.name === \"DataError\" && keyRangeError.code === 0)) {\n\t      // DataError with error code 0 indicates start is less than end, so\n\t      // can just do an empty query. Else need to throw\n\t      return callback(createError(IDB_ERROR,\n\t        keyRangeError.name, keyRangeError.message));\n\t    }\n\t  }\n\t\n\t  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\t\n\t  if (opts.attachments) {\n\t    stores.push(ATTACH_STORE);\n\t  }\n\t  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n\t  if (txnResult.error) {\n\t    return callback(txnResult.error);\n\t  }\n\t  var txn = txnResult.txn;\n\t  txn.oncomplete = onTxnComplete;\n\t  txn.onabort = idbError(callback);\n\t  var docStore = txn.objectStore(DOC_STORE);\n\t  var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t  var metaStore = txn.objectStore(META_STORE);\n\t  var docIdRevIndex = seqStore.index('_doc_id_rev');\n\t  var results = [];\n\t  var docCount;\n\t  var updateSeq;\n\t\n\t  metaStore.get(META_STORE).onsuccess = function (e) {\n\t    docCount = e.target.result.docCount;\n\t  };\n\t\n\t  /* istanbul ignore if */\n\t  if (opts.update_seq) {\n\t    getMaxUpdateSeq(seqStore, function (e) { \n\t      if (e.target.result && e.target.result.length > 0) {\n\t        updateSeq = e.target.result[0];\n\t      }\n\t    });\n\t  }\n\t\n\t  function getMaxUpdateSeq(objectStore, onSuccess) {\n\t    function onCursor(e) {\n\t      var cursor = e.target.result;\n\t      var maxKey = undefined;\n\t      if (cursor && cursor.key) {\n\t        maxKey = cursor.key;\n\t      } \n\t      return onSuccess({\n\t        target: {\n\t          result: [maxKey]\n\t        }\n\t      });\n\t    }\n\t    objectStore.openCursor(null, 'prev').onsuccess = onCursor;\n\t  }\n\t\n\t  // if the user specifies include_docs=true, then we don't\n\t  // want to block the main cursor while we're fetching the doc\n\t  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n\t    var key = metadata.id + \"::\" + winningRev$$1;\n\t    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n\t      row.doc = decodeDoc(e.target.result);\n\t      if (opts.conflicts) {\n\t        var conflicts = collectConflicts(metadata);\n\t        if (conflicts.length) {\n\t          row.doc._conflicts = conflicts;\n\t        }\n\t      }\n\t      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n\t    };\n\t  }\n\t\n\t  function allDocsInner(winningRev$$1, metadata) {\n\t    var row = {\n\t      id: metadata.id,\n\t      key: metadata.id,\n\t      value: {\n\t        rev: winningRev$$1\n\t      }\n\t    };\n\t    var deleted = metadata.deleted;\n\t    if (deleted) {\n\t      if (keys) {\n\t        results.push(row);\n\t        // deleted docs are okay with \"keys\" requests\n\t        row.value.deleted = true;\n\t        row.doc = null;\n\t      }\n\t    } else if (skip-- <= 0) {\n\t      results.push(row);\n\t      if (opts.include_docs) {\n\t        fetchDocAsynchronously(metadata, row, winningRev$$1);\n\t      }\n\t    }\n\t  }\n\t\n\t  function processBatch(batchValues) {\n\t    for (var i = 0, len = batchValues.length; i < len; i++) {\n\t      if (results.length === limit) {\n\t        break;\n\t      }\n\t      var batchValue = batchValues[i];\n\t      if (batchValue.error && keys) {\n\t        // key was not found with \"keys\" requests\n\t        results.push(batchValue);\n\t        continue;\n\t      }\n\t      var metadata = decodeMetadata(batchValue);\n\t      var winningRev$$1 = metadata.winningRev;\n\t      allDocsInner(winningRev$$1, metadata);\n\t    }\n\t  }\n\t\n\t  function onBatch(batchKeys, batchValues, cursor) {\n\t    if (!cursor) {\n\t      return;\n\t    }\n\t    processBatch(batchValues);\n\t    if (results.length < limit) {\n\t      cursor.continue();\n\t    }\n\t  }\n\t\n\t  function onGetAll(e) {\n\t    var values = e.target.result;\n\t    if (opts.descending) {\n\t      values = values.reverse();\n\t    }\n\t    processBatch(values);\n\t  }\n\t\n\t  function onResultsReady() {\n\t    var returnVal = {\n\t      total_rows: docCount,\n\t      offset: opts.skip,\n\t      rows: results\n\t    };\n\t    \n\t    /* istanbul ignore if */\n\t    if (opts.update_seq && updateSeq !== undefined) {\n\t      returnVal.update_seq = updateSeq;\n\t    }\n\t    callback(null, returnVal);\n\t  }\n\t\n\t  function onTxnComplete() {\n\t    if (opts.attachments) {\n\t      postProcessAttachments(results, opts.binary).then(onResultsReady);\n\t    } else {\n\t      onResultsReady();\n\t    }\n\t  }\n\t\n\t  // don't bother doing any requests if start > end or limit === 0\n\t  if (keyRangeError || limit === 0) {\n\t    return;\n\t  }\n\t  if (keys) {\n\t    return allDocsKeys(opts.keys, docStore, onBatch);\n\t  }\n\t  if (limit === -1) { // just fetch everything\n\t    return getAll(docStore, keyRange, onGetAll);\n\t  }\n\t  // else do a cursor\n\t  // choose a batch size based on the skip, since we'll need to skip that many\n\t  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n\t}\n\t\n\t//\n\t// Blobs are not supported in all versions of IndexedDB, notably\n\t// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n\t//\n\t// Various other blob bugs exist in Chrome v37-42 (inclusive).\n\t// Detecting them is expensive and confusing to users, and Chrome 37-42\n\t// is at very low usage worldwide, so we do a hacky userAgent check instead.\n\t//\n\t// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n\t// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n\t// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n\t//\n\tfunction checkBlobSupport(txn) {\n\t  return new PouchPromise(function (resolve) {\n\t    var blob$$1 = createBlob(['']);\n\t    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\t\n\t    req.onsuccess = function () {\n\t      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n\t      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n\t      // MS Edge pretends to be Chrome 42:\n\t      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n\t      resolve(matchedEdge || !matchedChrome ||\n\t        parseInt(matchedChrome[1], 10) >= 43);\n\t    };\n\t\n\t    txn.onabort = function (e) {\n\t      // If the transaction aborts now its due to not being able to\n\t      // write to the database, likely due to the disk being full\n\t      e.preventDefault();\n\t      e.stopPropagation();\n\t      resolve(false);\n\t    };\n\t  }).catch(function () {\n\t    return false; // error, so assume unsupported\n\t  });\n\t}\n\t\n\tfunction countDocs(txn, cb) {\n\t  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n\t  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n\t    cb(e.target.result);\n\t  };\n\t}\n\t\n\t// This task queue ensures that IDB open calls are done in their own tick\n\t// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n\t// before calling the next one. This works around IE/Edge race conditions in IDB.\n\t\n\tvar running = false;\n\tvar queue = [];\n\t\n\tfunction tryCode(fun, err, res, PouchDB) {\n\t  try {\n\t    fun(err, res);\n\t  } catch (err) {\n\t    // Shouldn't happen, but in some odd cases\n\t    // IndexedDB implementations might throw a sync\n\t    // error, in which case this will at least log it.\n\t    PouchDB.emit('error', err);\n\t  }\n\t}\n\t\n\tfunction applyNext() {\n\t  if (running || !queue.length) {\n\t    return;\n\t  }\n\t  running = true;\n\t  queue.shift()();\n\t}\n\t\n\tfunction enqueueTask(action, callback, PouchDB) {\n\t  queue.push(function runAction() {\n\t    action(function runCallback(err, res) {\n\t      tryCode(callback, err, res, PouchDB);\n\t      running = false;\n\t      nextTick(function runNext() {\n\t        applyNext(PouchDB);\n\t      });\n\t    });\n\t  });\n\t  applyNext();\n\t}\n\t\n\tfunction changes(opts, api, dbName, idb) {\n\t  opts = clone(opts);\n\t\n\t  if (opts.continuous) {\n\t    var id = dbName + ':' + uuid();\n\t    changesHandler$$1.addListener(dbName, id, api, opts);\n\t    changesHandler$$1.notify(dbName);\n\t    return {\n\t      cancel: function () {\n\t        changesHandler$$1.removeListener(dbName, id);\n\t      }\n\t    };\n\t  }\n\t\n\t  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\t\n\t  opts.since = opts.since || 0;\n\t  var lastSeq = opts.since;\n\t\n\t  var limit = 'limit' in opts ? opts.limit : -1;\n\t  if (limit === 0) {\n\t    limit = 1; // per CouchDB _changes spec\n\t  }\n\t  var returnDocs;\n\t  if ('return_docs' in opts) {\n\t    returnDocs = opts.return_docs;\n\t  } else if ('returnDocs' in opts) {\n\t    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t    returnDocs = opts.returnDocs;\n\t  } else {\n\t    returnDocs = true;\n\t  }\n\t\n\t  var results = [];\n\t  var numResults = 0;\n\t  var filter = filterChange(opts);\n\t  var docIdsToMetadata = new ExportedMap();\n\t\n\t  var txn;\n\t  var bySeqStore;\n\t  var docStore;\n\t  var docIdRevIndex;\n\t\n\t  function onBatch(batchKeys, batchValues, cursor) {\n\t    if (!cursor || !batchKeys.length) { // done\n\t      return;\n\t    }\n\t\n\t    var winningDocs = new Array(batchKeys.length);\n\t    var metadatas = new Array(batchKeys.length);\n\t\n\t    function processMetadataAndWinningDoc(metadata, winningDoc) {\n\t      var change = opts.processChange(winningDoc, metadata, opts);\n\t      lastSeq = change.seq = metadata.seq;\n\t\n\t      var filtered = filter(change);\n\t      if (typeof filtered === 'object') { // anything but true/false indicates error\n\t        return opts.complete(filtered);\n\t      }\n\t\n\t      if (filtered) {\n\t        numResults++;\n\t        if (returnDocs) {\n\t          results.push(change);\n\t        }\n\t        // process the attachment immediately\n\t        // for the benefit of live listeners\n\t        if (opts.attachments && opts.include_docs) {\n\t          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n\t            postProcessAttachments([change], opts.binary).then(function () {\n\t              opts.onChange(change);\n\t            });\n\t          });\n\t        } else {\n\t          opts.onChange(change);\n\t        }\n\t      }\n\t    }\n\t\n\t    function onBatchDone() {\n\t      for (var i = 0, len = winningDocs.length; i < len; i++) {\n\t        if (numResults === limit) {\n\t          break;\n\t        }\n\t        var winningDoc = winningDocs[i];\n\t        if (!winningDoc) {\n\t          continue;\n\t        }\n\t        var metadata = metadatas[i];\n\t        processMetadataAndWinningDoc(metadata, winningDoc);\n\t      }\n\t\n\t      if (numResults !== limit) {\n\t        cursor.continue();\n\t      }\n\t    }\n\t\n\t    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n\t    // them all only once all data has been collected. This is done in parallel\n\t    // because it's faster than doing it one-at-a-time.\n\t    var numDone = 0;\n\t    batchValues.forEach(function (value, i) {\n\t      var doc = decodeDoc(value);\n\t      var seq = batchKeys[i];\n\t      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n\t        metadatas[i] = metadata;\n\t        winningDocs[i] = winningDoc;\n\t        if (++numDone === batchKeys.length) {\n\t          onBatchDone();\n\t        }\n\t      });\n\t    });\n\t  }\n\t\n\t  function onGetMetadata(doc, seq, metadata, cb) {\n\t    if (metadata.seq !== seq) {\n\t      // some other seq is later\n\t      return cb();\n\t    }\n\t\n\t    if (metadata.winningRev === doc._rev) {\n\t      // this is the winning doc\n\t      return cb(metadata, doc);\n\t    }\n\t\n\t    // fetch winning doc in separate request\n\t    var docIdRev = doc._id + '::' + metadata.winningRev;\n\t    var req = docIdRevIndex.get(docIdRev);\n\t    req.onsuccess = function (e) {\n\t      cb(metadata, decodeDoc(e.target.result));\n\t    };\n\t  }\n\t\n\t  function fetchWinningDocAndMetadata(doc, seq, cb) {\n\t    if (docIds && !docIds.has(doc._id)) {\n\t      return cb();\n\t    }\n\t\n\t    var metadata = docIdsToMetadata.get(doc._id);\n\t    if (metadata) { // cached\n\t      return onGetMetadata(doc, seq, metadata, cb);\n\t    }\n\t    // metadata not cached, have to go fetch it\n\t    docStore.get(doc._id).onsuccess = function (e) {\n\t      metadata = decodeMetadata(e.target.result);\n\t      docIdsToMetadata.set(doc._id, metadata);\n\t      onGetMetadata(doc, seq, metadata, cb);\n\t    };\n\t  }\n\t\n\t  function finish() {\n\t    opts.complete(null, {\n\t      results: results,\n\t      last_seq: lastSeq\n\t    });\n\t  }\n\t\n\t  function onTxnComplete() {\n\t    if (!opts.continuous && opts.attachments) {\n\t      // cannot guarantee that postProcessing was already done,\n\t      // so do it again\n\t      postProcessAttachments(results).then(finish);\n\t    } else {\n\t      finish();\n\t    }\n\t  }\n\t\n\t  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n\t  if (opts.attachments) {\n\t    objectStores.push(ATTACH_STORE);\n\t  }\n\t  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n\t  if (txnResult.error) {\n\t    return opts.complete(txnResult.error);\n\t  }\n\t  txn = txnResult.txn;\n\t  txn.onabort = idbError(opts.complete);\n\t  txn.oncomplete = onTxnComplete;\n\t\n\t  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t  docStore = txn.objectStore(DOC_STORE);\n\t  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\t\n\t  var keyRange = (opts.since && !opts.descending) ?\n\t    IDBKeyRange.lowerBound(opts.since, true) : null;\n\t\n\t  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n\t}\n\t\n\tvar cachedDBs = new ExportedMap();\n\tvar blobSupportPromise;\n\tvar openReqList = new ExportedMap();\n\t\n\tfunction IdbPouch(opts, callback) {\n\t  var api = this;\n\t\n\t  enqueueTask(function (thisCallback) {\n\t    init(api, opts, thisCallback);\n\t  }, callback, api.constructor);\n\t}\n\t\n\tfunction init(api, opts, callback) {\n\t\n\t  var dbName = opts.name;\n\t\n\t  var idb = null;\n\t  api._meta = null;\n\t\n\t  // called when creating a fresh new database\n\t  function createSchema(db) {\n\t    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n\t    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n\t      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n\t    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n\t    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n\t    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\t\n\t    // added in v2\n\t    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\t\n\t    // added in v3\n\t    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\t\n\t    // added in v4\n\t    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n\t      {autoIncrement: true});\n\t    attAndSeqStore.createIndex('seq', 'seq');\n\t    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n\t  }\n\t\n\t  // migration to version 2\n\t  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n\t  // store local docs in the main doc-store, but whaddyagonnado\n\t  function addDeletedOrLocalIndex(txn, callback) {\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\t\n\t    docStore.openCursor().onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      if (cursor) {\n\t        var metadata = cursor.value;\n\t        var deleted = isDeleted(metadata);\n\t        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n\t        docStore.put(metadata);\n\t        cursor.continue();\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t  }\n\t\n\t  // migration to version 3 (part 1)\n\t  function createLocalStoreSchema(db) {\n\t    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n\t      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n\t  }\n\t\n\t  // migration to version 3 (part 2)\n\t  function migrateLocalStore(txn, cb) {\n\t    var localStore = txn.objectStore(LOCAL_STORE);\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t\n\t    var cursor = docStore.openCursor();\n\t    cursor.onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      if (cursor) {\n\t        var metadata = cursor.value;\n\t        var docId = metadata.id;\n\t        var local = isLocalId(docId);\n\t        var rev$$1 = winningRev(metadata);\n\t        if (local) {\n\t          var docIdRev = docId + \"::\" + rev$$1;\n\t          // remove all seq entries\n\t          // associated with this docId\n\t          var start = docId + \"::\";\n\t          var end = docId + \"::~\";\n\t          var index = seqStore.index('_doc_id_rev');\n\t          var range = IDBKeyRange.bound(start, end, false, false);\n\t          var seqCursor = index.openCursor(range);\n\t          seqCursor.onsuccess = function (e) {\n\t            seqCursor = e.target.result;\n\t            if (!seqCursor) {\n\t              // done\n\t              docStore.delete(cursor.primaryKey);\n\t              cursor.continue();\n\t            } else {\n\t              var data = seqCursor.value;\n\t              if (data._doc_id_rev === docIdRev) {\n\t                localStore.put(data);\n\t              }\n\t              seqStore.delete(seqCursor.primaryKey);\n\t              seqCursor.continue();\n\t            }\n\t          };\n\t        } else {\n\t          cursor.continue();\n\t        }\n\t      } else if (cb) {\n\t        cb();\n\t      }\n\t    };\n\t  }\n\t\n\t  // migration to version 4 (part 1)\n\t  function addAttachAndSeqStore(db) {\n\t    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n\t      {autoIncrement: true});\n\t    attAndSeqStore.createIndex('seq', 'seq');\n\t    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n\t  }\n\t\n\t  // migration to version 4 (part 2)\n\t  function migrateAttsAndSeqs(txn, callback) {\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var attStore = txn.objectStore(ATTACH_STORE);\n\t    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t\n\t    // need to actually populate the table. this is the expensive part,\n\t    // so as an optimization, check first that this database even\n\t    // contains attachments\n\t    var req = attStore.count();\n\t    req.onsuccess = function (e) {\n\t      var count = e.target.result;\n\t      if (!count) {\n\t        return callback(); // done\n\t      }\n\t\n\t      seqStore.openCursor().onsuccess = function (e) {\n\t        var cursor = e.target.result;\n\t        if (!cursor) {\n\t          return callback(); // done\n\t        }\n\t        var doc = cursor.value;\n\t        var seq = cursor.primaryKey;\n\t        var atts = Object.keys(doc._attachments || {});\n\t        var digestMap = {};\n\t        for (var j = 0; j < atts.length; j++) {\n\t          var att = doc._attachments[atts[j]];\n\t          digestMap[att.digest] = true; // uniq digests, just in case\n\t        }\n\t        var digests = Object.keys(digestMap);\n\t        for (j = 0; j < digests.length; j++) {\n\t          var digest = digests[j];\n\t          attAndSeqStore.put({\n\t            seq: seq,\n\t            digestSeq: digest + '::' + seq\n\t          });\n\t        }\n\t        cursor.continue();\n\t      };\n\t    };\n\t  }\n\t\n\t  // migration to version 5\n\t  // Instead of relying on on-the-fly migration of metadata,\n\t  // this brings the doc-store to its modern form:\n\t  // - metadata.winningrev\n\t  // - metadata.seq\n\t  // - stringify the metadata when storing it\n\t  function migrateMetadata(txn) {\n\t\n\t    function decodeMetadataCompat(storedObject) {\n\t      if (!storedObject.data) {\n\t        // old format, when we didn't store it stringified\n\t        storedObject.deleted = storedObject.deletedOrLocal === '1';\n\t        return storedObject;\n\t      }\n\t      return decodeMetadata(storedObject);\n\t    }\n\t\n\t    // ensure that every metadata has a winningRev and seq,\n\t    // which was previously created on-the-fly but better to migrate\n\t    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var cursor = docStore.openCursor();\n\t    cursor.onsuccess = function (e) {\n\t      var cursor = e.target.result;\n\t      if (!cursor) {\n\t        return; // done\n\t      }\n\t      var metadata = decodeMetadataCompat(cursor.value);\n\t\n\t      metadata.winningRev = metadata.winningRev ||\n\t        winningRev(metadata);\n\t\n\t      function fetchMetadataSeq() {\n\t        // metadata.seq was added post-3.2.0, so if it's missing,\n\t        // we need to fetch it manually\n\t        var start = metadata.id + '::';\n\t        var end = metadata.id + '::\\uffff';\n\t        var req = bySeqStore.index('_doc_id_rev').openCursor(\n\t          IDBKeyRange.bound(start, end));\n\t\n\t        var metadataSeq = 0;\n\t        req.onsuccess = function (e) {\n\t          var cursor = e.target.result;\n\t          if (!cursor) {\n\t            metadata.seq = metadataSeq;\n\t            return onGetMetadataSeq();\n\t          }\n\t          var seq = cursor.primaryKey;\n\t          if (seq > metadataSeq) {\n\t            metadataSeq = seq;\n\t          }\n\t          cursor.continue();\n\t        };\n\t      }\n\t\n\t      function onGetMetadataSeq() {\n\t        var metadataToStore = encodeMetadata(metadata,\n\t          metadata.winningRev, metadata.deleted);\n\t\n\t        var req = docStore.put(metadataToStore);\n\t        req.onsuccess = function () {\n\t          cursor.continue();\n\t        };\n\t      }\n\t\n\t      if (metadata.seq) {\n\t        return onGetMetadataSeq();\n\t      }\n\t\n\t      fetchMetadataSeq();\n\t    };\n\t\n\t  }\n\t\n\t  api._remote = false;\n\t  api.type = function () {\n\t    return 'idb';\n\t  };\n\t\n\t  api._id = toPromise(function (callback) {\n\t    callback(null, api._meta.instanceId);\n\t  });\n\t\n\t  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n\t    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n\t  };\n\t\n\t  // First we look up the metadata in the ids database, then we fetch the\n\t  // current revision(s) from the by sequence store\n\t  api._get = function idb_get(id, opts, callback) {\n\t    var doc;\n\t    var metadata;\n\t    var err;\n\t    var txn = opts.ctx;\n\t    if (!txn) {\n\t      var txnResult = openTransactionSafely(idb,\n\t        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t    }\n\t\n\t    function finish() {\n\t      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n\t    }\n\t\n\t    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n\t      metadata = decodeMetadata(e.target.result);\n\t      // we can determine the result here if:\n\t      // 1. there is no such document\n\t      // 2. the document is deleted and we don't ask about specific rev\n\t      // When we ask with opts.rev we expect the answer to be either\n\t      // doc (possibly with _deleted=true) or missing error\n\t      if (!metadata) {\n\t        err = createError(MISSING_DOC, 'missing');\n\t        return finish();\n\t      }\n\t\n\t      var rev$$1;\n\t      if (!opts.rev) {\n\t        rev$$1 = metadata.winningRev;\n\t        var deleted = isDeleted(metadata);\n\t        if (deleted) {\n\t          err = createError(MISSING_DOC, \"deleted\");\n\t          return finish();\n\t        }\n\t      } else {\n\t        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n\t      }\n\t\n\t      var objectStore = txn.objectStore(BY_SEQ_STORE);\n\t      var key = metadata.id + '::' + rev$$1;\n\t\n\t      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n\t        doc = e.target.result;\n\t        if (doc) {\n\t          doc = decodeDoc(doc);\n\t        }\n\t        if (!doc) {\n\t          err = createError(MISSING_DOC, 'missing');\n\t          return finish();\n\t        }\n\t        finish();\n\t      };\n\t    };\n\t  };\n\t\n\t  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n\t    var txn;\n\t    if (opts.ctx) {\n\t      txn = opts.ctx;\n\t    } else {\n\t      var txnResult = openTransactionSafely(idb,\n\t        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t    }\n\t    var digest = attachment.digest;\n\t    var type = attachment.content_type;\n\t\n\t    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n\t      var body = e.target.result.body;\n\t      readBlobData(body, type, opts.binary, function (blobData) {\n\t        callback(null, blobData);\n\t      });\n\t    };\n\t  };\n\t\n\t  api._info = function idb_info(callback) {\n\t    var updateSeq;\n\t    var docCount;\n\t\n\t    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n\t      docCount = e.target.result.docCount;\n\t    };\n\t    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n\t      var cursor = e.target.result;\n\t      updateSeq = cursor ? cursor.key : 0;\n\t    };\n\t\n\t    txn.oncomplete = function () {\n\t      callback(null, {\n\t        doc_count: docCount,\n\t        update_seq: updateSeq,\n\t        // for debugging\n\t        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n\t      });\n\t    };\n\t  };\n\t\n\t  api._allDocs = function idb_allDocs(opts, callback) {\n\t    idbAllDocs(opts, idb, callback);\n\t  };\n\t\n\t  api._changes = function idbChanges(opts) {\n\t    return changes(opts, api, dbName, idb);\n\t  };\n\t\n\t  api._close = function (callback) {\n\t    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n\t    // \"Returns immediately and closes the connection in a separate thread...\"\n\t    idb.close();\n\t    cachedDBs.delete(dbName);\n\t    callback();\n\t  };\n\t\n\t  api._getRevisionTree = function (docId, callback) {\n\t    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    var req = txn.objectStore(DOC_STORE).get(docId);\n\t    req.onsuccess = function (event) {\n\t      var doc = decodeMetadata(event.target.result);\n\t      if (!doc) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        callback(null, doc.rev_tree);\n\t      }\n\t    };\n\t  };\n\t\n\t  // This function removes revisions of document docId\n\t  // which are listed in revs and sets this document\n\t  // revision to to rev_tree\n\t  api._doCompaction = function (docId, revs, callback) {\n\t    var stores = [\n\t      DOC_STORE,\n\t      BY_SEQ_STORE,\n\t      ATTACH_STORE,\n\t      ATTACH_AND_SEQ_STORE\n\t    ];\n\t    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t\n\t    docStore.get(docId).onsuccess = function (event) {\n\t      var metadata = decodeMetadata(event.target.result);\n\t      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                                         revHash, ctx, opts) {\n\t        var rev$$1 = pos + '-' + revHash;\n\t        if (revs.indexOf(rev$$1) !== -1) {\n\t          opts.status = 'missing';\n\t        }\n\t      });\n\t      compactRevs(revs, docId, txn);\n\t      var winningRev$$1 = metadata.winningRev;\n\t      var deleted = metadata.deleted;\n\t      txn.objectStore(DOC_STORE).put(\n\t        encodeMetadata(metadata, winningRev$$1, deleted));\n\t    };\n\t    txn.onabort = idbError(callback);\n\t    txn.oncomplete = function () {\n\t      callback();\n\t    };\n\t  };\n\t\n\t\n\t  api._getLocal = function (id, callback) {\n\t    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var tx = txnResult.txn;\n\t    var req = tx.objectStore(LOCAL_STORE).get(id);\n\t\n\t    req.onerror = idbError(callback);\n\t    req.onsuccess = function (e) {\n\t      var doc = e.target.result;\n\t      if (!doc) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        delete doc['_doc_id_rev']; // for backwards compat\n\t        callback(null, doc);\n\t      }\n\t    };\n\t  };\n\t\n\t  api._putLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    delete doc._revisions; // ignore this, trust the rev\n\t    var oldRev = doc._rev;\n\t    var id = doc._id;\n\t    if (!oldRev) {\n\t      doc._rev = '0-1';\n\t    } else {\n\t      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n\t    }\n\t\n\t    var tx = opts.ctx;\n\t    var ret;\n\t    if (!tx) {\n\t      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      tx = txnResult.txn;\n\t      tx.onerror = idbError(callback);\n\t      tx.oncomplete = function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t\n\t    var oStore = tx.objectStore(LOCAL_STORE);\n\t    var req;\n\t    if (oldRev) {\n\t      req = oStore.get(id);\n\t      req.onsuccess = function (e) {\n\t        var oldDoc = e.target.result;\n\t        if (!oldDoc || oldDoc._rev !== oldRev) {\n\t          callback(createError(REV_CONFLICT));\n\t        } else { // update\n\t          var req = oStore.put(doc);\n\t          req.onsuccess = function () {\n\t            ret = {ok: true, id: doc._id, rev: doc._rev};\n\t            if (opts.ctx) { // return immediately\n\t              callback(null, ret);\n\t            }\n\t          };\n\t        }\n\t      };\n\t    } else { // new doc\n\t      req = oStore.add(doc);\n\t      req.onerror = function (e) {\n\t        // constraint error, already exists\n\t        callback(createError(REV_CONFLICT));\n\t        e.preventDefault(); // avoid transaction abort\n\t        e.stopPropagation(); // avoid transaction onerror\n\t      };\n\t      req.onsuccess = function () {\n\t        ret = {ok: true, id: doc._id, rev: doc._rev};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  api._removeLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var tx = opts.ctx;\n\t    if (!tx) {\n\t      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      tx = txnResult.txn;\n\t      tx.oncomplete = function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t    var ret;\n\t    var id = doc._id;\n\t    var oStore = tx.objectStore(LOCAL_STORE);\n\t    var req = oStore.get(id);\n\t\n\t    req.onerror = idbError(callback);\n\t    req.onsuccess = function (e) {\n\t      var oldDoc = e.target.result;\n\t      if (!oldDoc || oldDoc._rev !== doc._rev) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        oStore.delete(id);\n\t        ret = {ok: true, id: id, rev: '0-0'};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  api._destroy = function (opts, callback) {\n\t    changesHandler$$1.removeAllListeners(dbName);\n\t\n\t    //Close open request for \"dbName\" database to fix ie delay.\n\t    var openReq = openReqList.get(dbName);\n\t    if (openReq && openReq.result) {\n\t      openReq.result.close();\n\t      cachedDBs.delete(dbName);\n\t    }\n\t    var req = indexedDB.deleteDatabase(dbName);\n\t\n\t    req.onsuccess = function () {\n\t      //Remove open request from the list.\n\t      openReqList.delete(dbName);\n\t      if (hasLocalStorage() && (dbName in localStorage)) {\n\t        delete localStorage[dbName];\n\t      }\n\t      callback(null, { 'ok': true });\n\t    };\n\t\n\t    req.onerror = idbError(callback);\n\t  };\n\t\n\t  var cached = cachedDBs.get(dbName);\n\t\n\t  if (cached) {\n\t    idb = cached.idb;\n\t    api._meta = cached.global;\n\t    return nextTick(function () {\n\t      callback(null, api);\n\t    });\n\t  }\n\t\n\t  var req;\n\t  if (opts.storage) {\n\t    req = tryStorageOption(dbName, opts.storage);\n\t  } else {\n\t    req = indexedDB.open(dbName, ADAPTER_VERSION);\n\t  }\n\t\n\t  openReqList.set(dbName, req);\n\t\n\t  req.onupgradeneeded = function (e) {\n\t    var db = e.target.result;\n\t    if (e.oldVersion < 1) {\n\t      return createSchema(db); // new db, initial schema\n\t    }\n\t    // do migrations\n\t\n\t    var txn = e.currentTarget.transaction;\n\t    // these migrations have to be done in this function, before\n\t    // control is returned to the event loop, because IndexedDB\n\t\n\t    if (e.oldVersion < 3) {\n\t      createLocalStoreSchema(db); // v2 -> v3\n\t    }\n\t    if (e.oldVersion < 4) {\n\t      addAttachAndSeqStore(db); // v3 -> v4\n\t    }\n\t\n\t    var migrations = [\n\t      addDeletedOrLocalIndex, // v1 -> v2\n\t      migrateLocalStore,      // v2 -> v3\n\t      migrateAttsAndSeqs,     // v3 -> v4\n\t      migrateMetadata         // v4 -> v5\n\t    ];\n\t\n\t    var i = e.oldVersion;\n\t\n\t    function next() {\n\t      var migration = migrations[i - 1];\n\t      i++;\n\t      if (migration) {\n\t        migration(txn, next);\n\t      }\n\t    }\n\t\n\t    next();\n\t  };\n\t\n\t  req.onsuccess = function (e) {\n\t\n\t    idb = e.target.result;\n\t\n\t    idb.onversionchange = function () {\n\t      idb.close();\n\t      cachedDBs.delete(dbName);\n\t    };\n\t\n\t    idb.onabort = function (e) {\n\t      guardedConsole('error', 'Database has a global failure', e.target.error);\n\t      idb.close();\n\t      cachedDBs.delete(dbName);\n\t    };\n\t\n\t    // Do a few setup operations (in parallel as much as possible):\n\t    // 1. Fetch meta doc\n\t    // 2. Check blob support\n\t    // 3. Calculate docCount\n\t    // 4. Generate an instanceId if necessary\n\t    // 5. Store docCount and instanceId on meta doc\n\t\n\t    var txn = idb.transaction([\n\t      META_STORE,\n\t      DETECT_BLOB_SUPPORT_STORE,\n\t      DOC_STORE\n\t    ], 'readwrite');\n\t\n\t    var storedMetaDoc = false;\n\t    var metaDoc;\n\t    var docCount;\n\t    var blobSupport;\n\t    var instanceId;\n\t\n\t    function completeSetup() {\n\t      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n\t        return;\n\t      }\n\t      api._meta = {\n\t        name: dbName,\n\t        instanceId: instanceId,\n\t        blobSupport: blobSupport\n\t      };\n\t\n\t      cachedDBs.set(dbName, {\n\t        idb: idb,\n\t        global: api._meta\n\t      });\n\t      callback(null, api);\n\t    }\n\t\n\t    function storeMetaDocIfReady() {\n\t      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n\t        return;\n\t      }\n\t      var instanceKey = dbName + '_id';\n\t      if (instanceKey in metaDoc) {\n\t        instanceId = metaDoc[instanceKey];\n\t      } else {\n\t        metaDoc[instanceKey] = instanceId = uuid();\n\t      }\n\t      metaDoc.docCount = docCount;\n\t      txn.objectStore(META_STORE).put(metaDoc);\n\t    }\n\t\n\t    //\n\t    // fetch or generate the instanceId\n\t    //\n\t    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n\t      metaDoc = e.target.result || { id: META_STORE };\n\t      storeMetaDocIfReady();\n\t    };\n\t\n\t    //\n\t    // countDocs\n\t    //\n\t    countDocs(txn, function (count) {\n\t      docCount = count;\n\t      storeMetaDocIfReady();\n\t    });\n\t\n\t    //\n\t    // check blob support\n\t    //\n\t    if (!blobSupportPromise) {\n\t      // make sure blob support is only checked once\n\t      blobSupportPromise = checkBlobSupport(txn);\n\t    }\n\t\n\t    blobSupportPromise.then(function (val) {\n\t      blobSupport = val;\n\t      completeSetup();\n\t    });\n\t\n\t    // only when the metadata put transaction has completed,\n\t    // consider the setup done\n\t    txn.oncomplete = function () {\n\t      storedMetaDoc = true;\n\t      completeSetup();\n\t    };\n\t    txn.onabort = idbError(callback);\n\t  };\n\t\n\t  req.onerror = function () {\n\t    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n\t    guardedConsole('error', msg);\n\t    callback(createError(IDB_ERROR, msg));\n\t  };\n\t}\n\t\n\tIdbPouch.valid = function () {\n\t  // Issue #2533, we finally gave up on doing bug\n\t  // detection instead of browser sniffing. Safari brought us\n\t  // to our knees.\n\t  var isSafari = typeof openDatabase !== 'undefined' &&\n\t    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n\t    !/Chrome/.test(navigator.userAgent) &&\n\t    !/BlackBerry/.test(navigator.platform);\n\t\n\t  // Safari <10.1 does not meet our requirements for IDB support (#5572)\n\t  // since Safari 10.1 shipped with fetch, we can use that to detect it\n\t  var hasFetch = typeof fetch === 'function' &&\n\t    fetch.toString().indexOf('[native code') !== -1;\n\t\n\t  // On Firefox SecurityError is thrown while referencing indexedDB if cookies\n\t  // are not allowed. `typeof indexedDB` also triggers the error.\n\t  try {\n\t    // some outdated implementations of IDB that appear on Samsung\n\t    // and HTC Android devices <4.4 are missing IDBKeyRange\n\t    return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n\t      typeof IDBKeyRange !== 'undefined';\n\t  } catch (e) {\n\t    return false;\n\t  }\n\t};\n\t\n\tfunction tryStorageOption(dbName, storage) {\n\t  try { // option only available in Firefox 26+\n\t    return indexedDB.open(dbName, {\n\t      version: ADAPTER_VERSION,\n\t      storage: storage\n\t    });\n\t  } catch (err) {\n\t      return indexedDB.open(dbName, ADAPTER_VERSION);\n\t  }\n\t}\n\t\n\tfunction IDBPouch (PouchDB) {\n\t  PouchDB.adapter('idb', IdbPouch, true);\n\t}\n\t\n\t//\n\t// Parsing hex strings. Yeah.\n\t//\n\t// So basically we need this because of a bug in WebSQL:\n\t// https://code.google.com/p/chromium/issues/detail?id=422690\n\t// https://bugs.webkit.org/show_bug.cgi?id=137637\n\t//\n\t// UTF-8 and UTF-16 are provided as separate functions\n\t// for meager performance improvements\n\t//\n\t\n\tfunction decodeUtf8(str) {\n\t  return decodeURIComponent(escape(str));\n\t}\n\t\n\tfunction hexToInt(charCode) {\n\t  // '0'-'9' is 48-57\n\t  // 'A'-'F' is 65-70\n\t  // SQLite will only give us uppercase hex\n\t  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n\t}\n\t\n\t\n\t// Example:\n\t// pragma encoding=utf8;\n\t// select hex('A');\n\t// returns '41'\n\tfunction parseHexUtf8(str, start, end) {\n\t  var result = '';\n\t  while (start < end) {\n\t    result += String.fromCharCode(\n\t      (hexToInt(str.charCodeAt(start++)) << 4) |\n\t        hexToInt(str.charCodeAt(start++)));\n\t  }\n\t  return result;\n\t}\n\t\n\t// Example:\n\t// pragma encoding=utf16;\n\t// select hex('A');\n\t// returns '4100'\n\t// notice that the 00 comes after the 41 (i.e. it's swizzled)\n\tfunction parseHexUtf16(str, start, end) {\n\t  var result = '';\n\t  while (start < end) {\n\t    // UTF-16, so swizzle the bytes\n\t    result += String.fromCharCode(\n\t      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n\t        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n\t        (hexToInt(str.charCodeAt(start)) << 4) |\n\t        hexToInt(str.charCodeAt(start + 1)));\n\t    start += 4;\n\t  }\n\t  return result;\n\t}\n\t\n\tfunction parseHexString(str, encoding) {\n\t  if (encoding === 'UTF-8') {\n\t    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n\t  } else {\n\t    return parseHexUtf16(str, 0, str.length);\n\t  }\n\t}\n\t\n\tfunction quote(str) {\n\t  return \"'\" + str + \"'\";\n\t}\n\t\n\tvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\t\n\t// The object stores created for each database\n\t// DOC_STORE stores the document meta data, its revision history and state\n\tvar DOC_STORE$1 = quote('document-store');\n\t// BY_SEQ_STORE stores a particular version of a document, keyed by its\n\t// sequence id\n\tvar BY_SEQ_STORE$1 = quote('by-sequence');\n\t// Where we store attachments\n\tvar ATTACH_STORE$1 = quote('attach-store');\n\tvar LOCAL_STORE$1 = quote('local-store');\n\tvar META_STORE$1 = quote('metadata-store');\n\t// where we store many-to-many relations between attachment\n\t// digests and seqs\n\tvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\t\n\t// escapeBlob and unescapeBlob are workarounds for a websql bug:\n\t// https://code.google.com/p/chromium/issues/detail?id=422690\n\t// https://bugs.webkit.org/show_bug.cgi?id=137637\n\t// The goal is to never actually insert the \\u0000 character\n\t// in the database.\n\tfunction escapeBlob(str) {\n\t  return str\n\t    .replace(/\\u0002/g, '\\u0002\\u0002')\n\t    .replace(/\\u0001/g, '\\u0001\\u0002')\n\t    .replace(/\\u0000/g, '\\u0001\\u0001');\n\t}\n\t\n\tfunction unescapeBlob(str) {\n\t  return str\n\t    .replace(/\\u0001\\u0001/g, '\\u0000')\n\t    .replace(/\\u0001\\u0002/g, '\\u0001')\n\t    .replace(/\\u0002\\u0002/g, '\\u0002');\n\t}\n\t\n\tfunction stringifyDoc(doc) {\n\t  // don't bother storing the id/rev. it uses lots of space,\n\t  // in persistent map/reduce especially\n\t  delete doc._id;\n\t  delete doc._rev;\n\t  return JSON.stringify(doc);\n\t}\n\t\n\tfunction unstringifyDoc(doc, id, rev$$1) {\n\t  doc = JSON.parse(doc);\n\t  doc._id = id;\n\t  doc._rev = rev$$1;\n\t  return doc;\n\t}\n\t\n\t// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\n\tfunction qMarks(num) {\n\t  var s = '(';\n\t  while (num--) {\n\t    s += '?';\n\t    if (num) {\n\t      s += ',';\n\t    }\n\t  }\n\t  return s + ')';\n\t}\n\t\n\tfunction select(selector, table, joiner, where, orderBy) {\n\t  return 'SELECT ' + selector + ' FROM ' +\n\t    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n\t    (joiner ? (' ON ' + joiner) : '') +\n\t    (where ? (' WHERE ' +\n\t    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n\t    (orderBy ? (' ORDER BY ' + orderBy) : '');\n\t}\n\t\n\tfunction compactRevs$1(revs, docId, tx) {\n\t\n\t  if (!revs.length) {\n\t    return;\n\t  }\n\t\n\t  var numDone = 0;\n\t  var seqs = [];\n\t\n\t  function checkDone() {\n\t    if (++numDone === revs.length) { // done\n\t      deleteOrphans();\n\t    }\n\t  }\n\t\n\t  function deleteOrphans() {\n\t    // find orphaned attachment digests\n\t\n\t    if (!seqs.length) {\n\t      return;\n\t    }\n\t\n\t    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n\t      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\t\n\t    tx.executeSql(sql, seqs, function (tx, res) {\n\t\n\t      var digestsToCheck = [];\n\t      for (var i = 0; i < res.rows.length; i++) {\n\t        digestsToCheck.push(res.rows.item(i).digest);\n\t      }\n\t      if (!digestsToCheck.length) {\n\t        return;\n\t      }\n\t\n\t      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n\t        ' WHERE seq IN (' +\n\t        seqs.map(function () { return '?'; }).join(',') +\n\t        ')';\n\t      tx.executeSql(sql, seqs, function (tx) {\n\t\n\t        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n\t          ' WHERE digest IN (' +\n\t          digestsToCheck.map(function () { return '?'; }).join(',') +\n\t          ')';\n\t        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n\t          var nonOrphanedDigests = new ExportedSet();\n\t          for (var i = 0; i < res.rows.length; i++) {\n\t            nonOrphanedDigests.add(res.rows.item(i).digest);\n\t          }\n\t          digestsToCheck.forEach(function (digest) {\n\t            if (nonOrphanedDigests.has(digest)) {\n\t              return;\n\t            }\n\t            tx.executeSql(\n\t              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n\t              [digest]);\n\t            tx.executeSql(\n\t              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // update by-seq and attach stores in parallel\n\t  revs.forEach(function (rev$$1) {\n\t    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n\t      ' WHERE doc_id=? AND rev=?';\n\t\n\t    tx.executeSql(sql, [docId, rev$$1], function (tx, res) {\n\t      if (!res.rows.length) { // already deleted\n\t        return checkDone();\n\t      }\n\t      var seq = res.rows.item(0).seq;\n\t      seqs.push(seq);\n\t\n\t      tx.executeSql(\n\t        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n\t    });\n\t  });\n\t}\n\t\n\tfunction websqlError(callback) {\n\t  return function (event) {\n\t    guardedConsole('error', 'WebSQL threw an error', event);\n\t    // event may actually be a SQLError object, so report is as such\n\t    var errorNameMatch = event && event.constructor.toString()\n\t        .match(/function ([^(]+)/);\n\t    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n\t    var errorReason = event.target || event.message;\n\t    callback(createError(WSQ_ERROR, errorReason, errorName));\n\t  };\n\t}\n\t\n\tfunction getSize(opts) {\n\t  if ('size' in opts) {\n\t    // triggers immediate popup in iOS, fixes #2347\n\t    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n\t    return opts.size * 1000000;\n\t  }\n\t  // In iOS, doesn't matter as long as it's <= 5000000.\n\t  // Except that if you request too much, our tests fail\n\t  // because of the native \"do you accept?\" popup.\n\t  // In Android <=4.3, this value is actually used as an\n\t  // honest-to-god ceiling for data, so we need to\n\t  // set it to a decently high number.\n\t  var isAndroid = typeof navigator !== 'undefined' &&\n\t    /Android/.test(navigator.userAgent);\n\t  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n\t}\n\t\n\tfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n\t  var newEdits = opts.new_edits;\n\t  var userDocs = req.docs;\n\t\n\t  // Parse the docs, give them a sequence number for the result\n\t  var docInfos = userDocs.map(function (doc) {\n\t    if (doc._id && isLocalId(doc._id)) {\n\t      return doc;\n\t    }\n\t    var newDoc = parseDoc(doc, newEdits);\n\t    return newDoc;\n\t  });\n\t\n\t  var docInfoErrors = docInfos.filter(function (docInfo) {\n\t    return docInfo.error;\n\t  });\n\t  if (docInfoErrors.length) {\n\t    return callback(docInfoErrors[0]);\n\t  }\n\t\n\t  var tx;\n\t  var results = new Array(docInfos.length);\n\t  var fetchedDocs = new ExportedMap();\n\t\n\t  var preconditionErrored;\n\t  function complete() {\n\t    if (preconditionErrored) {\n\t      return callback(preconditionErrored);\n\t    }\n\t    websqlChanges.notify(api._name);\n\t    callback(null, results);\n\t  }\n\t\n\t  function verifyAttachment(digest, callback) {\n\t    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n\t      ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      if (result.rows.item(0).cnt === 0) {\n\t        var err = createError(MISSING_STUB,\n\t          'unknown stub attachment with digest ' +\n\t          digest);\n\t        callback(err);\n\t      } else {\n\t        callback();\n\t      }\n\t    });\n\t  }\n\t\n\t  function verifyAttachments(finish) {\n\t    var digests = [];\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo.data && docInfo.data._attachments) {\n\t        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n\t          var att = docInfo.data._attachments[filename];\n\t          if (att.stub) {\n\t            digests.push(att.digest);\n\t          }\n\t        });\n\t      }\n\t    });\n\t    if (!digests.length) {\n\t      return finish();\n\t    }\n\t    var numDone = 0;\n\t    var err;\n\t\n\t    function checkDone() {\n\t      if (++numDone === digests.length) {\n\t        finish(err);\n\t      }\n\t    }\n\t    digests.forEach(function (digest) {\n\t      verifyAttachment(digest, function (attErr) {\n\t        if (attErr && !err) {\n\t          err = attErr;\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n\t                    isUpdate, delta, resultsIdx, callback) {\n\t\n\t    function finish() {\n\t      var data = docInfo.data;\n\t      var deletedInt = newRevIsDeleted ? 1 : 0;\n\t\n\t      var id = data._id;\n\t      var rev = data._rev;\n\t      var json = stringifyDoc(data);\n\t      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n\t        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n\t      var sqlArgs = [id, rev, json, deletedInt];\n\t\n\t      // map seqs to attachment digests, which\n\t      // we will need later during compaction\n\t      function insertAttachmentMappings(seq, callback) {\n\t        var attsAdded = 0;\n\t        var attsToAdd = Object.keys(data._attachments || {});\n\t\n\t        if (!attsToAdd.length) {\n\t          return callback();\n\t        }\n\t        function checkDone() {\n\t          if (++attsAdded === attsToAdd.length) {\n\t            callback();\n\t          }\n\t          return false; // ack handling a constraint error\n\t        }\n\t        function add(att) {\n\t          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n\t            ' (digest, seq) VALUES (?,?)';\n\t          var sqlArgs = [data._attachments[att].digest, seq];\n\t          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n\t          // second callback is for a constaint error, which we ignore\n\t          // because this docid/rev has already been associated with\n\t          // the digest (e.g. when new_edits == false)\n\t        }\n\t        for (var i = 0; i < attsToAdd.length; i++) {\n\t          add(attsToAdd[i]); // do in parallel\n\t        }\n\t      }\n\t\n\t      tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t        var seq = result.insertId;\n\t        insertAttachmentMappings(seq, function () {\n\t          dataWritten(tx, seq);\n\t        });\n\t      }, function () {\n\t        // constraint error, recover by updating instead (see #1638)\n\t        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n\t          'doc_id=? AND rev=?');\n\t        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n\t          var seq = res.rows.item(0).seq;\n\t          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n\t            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n\t          var sqlArgs = [json, deletedInt, id, rev];\n\t          tx.executeSql(sql, sqlArgs, function (tx) {\n\t            insertAttachmentMappings(seq, function () {\n\t              dataWritten(tx, seq);\n\t            });\n\t          });\n\t        });\n\t        return false; // ack that we've handled the error\n\t      });\n\t    }\n\t\n\t    function collectResults(attachmentErr) {\n\t      if (!err) {\n\t        if (attachmentErr) {\n\t          err = attachmentErr;\n\t          callback(err);\n\t        } else if (recv === attachments.length) {\n\t          finish();\n\t        }\n\t      }\n\t    }\n\t\n\t    var err = null;\n\t    var recv = 0;\n\t\n\t    docInfo.data._id = docInfo.metadata.id;\n\t    docInfo.data._rev = docInfo.metadata.rev;\n\t    var attachments = Object.keys(docInfo.data._attachments || {});\n\t\n\t\n\t    if (newRevIsDeleted) {\n\t      docInfo.data._deleted = true;\n\t    }\n\t\n\t    function attachmentSaved(err) {\n\t      recv++;\n\t      collectResults(err);\n\t    }\n\t\n\t    attachments.forEach(function (key) {\n\t      var att = docInfo.data._attachments[key];\n\t      if (!att.stub) {\n\t        var data = att.data;\n\t        delete att.data;\n\t        att.revpos = parseInt(winningRev$$1, 10);\n\t        var digest = att.digest;\n\t        saveAttachment(digest, data, attachmentSaved);\n\t      } else {\n\t        recv++;\n\t        collectResults();\n\t      }\n\t    });\n\t\n\t    if (!attachments.length) {\n\t      finish();\n\t    }\n\t\n\t    function dataWritten(tx, seq) {\n\t      var id = docInfo.metadata.id;\n\t\n\t      var revsToCompact = docInfo.stemmedRevs || [];\n\t      if (isUpdate && api.auto_compaction) {\n\t        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n\t      }\n\t      if (revsToCompact.length) {\n\t        compactRevs$1(revsToCompact, id, tx);\n\t      }\n\t\n\t      docInfo.metadata.seq = seq;\n\t      var rev = docInfo.metadata.rev;\n\t      delete docInfo.metadata.rev;\n\t\n\t      var sql = isUpdate ?\n\t      'UPDATE ' + DOC_STORE$1 +\n\t      ' SET json=?, max_seq=?, winningseq=' +\n\t      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n\t      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n\t        : 'INSERT INTO ' + DOC_STORE$1 +\n\t      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n\t      var metadataStr = safeJsonStringify(docInfo.metadata);\n\t      var params = isUpdate ?\n\t        [metadataStr, seq, winningRev$$1, id] :\n\t        [id, seq, seq, metadataStr];\n\t      tx.executeSql(sql, params, function () {\n\t        results[resultsIdx] = {\n\t          ok: true,\n\t          id: docInfo.metadata.id,\n\t          rev: rev\n\t        };\n\t        fetchedDocs.set(id, docInfo.metadata);\n\t        callback();\n\t      });\n\t    }\n\t  }\n\t\n\t  function websqlProcessDocs() {\n\t    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n\t                results, writeDoc, opts);\n\t  }\n\t\n\t  function fetchExistingDocs(callback) {\n\t    if (!docInfos.length) {\n\t      return callback();\n\t    }\n\t\n\t    var numFetched = 0;\n\t\n\t    function checkDone() {\n\t      if (++numFetched === docInfos.length) {\n\t        callback();\n\t      }\n\t    }\n\t\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo._id && isLocalId(docInfo._id)) {\n\t        return checkDone(); // skip local docs\n\t      }\n\t      var id = docInfo.metadata.id;\n\t      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n\t      ' WHERE id = ?', [id], function (tx, result) {\n\t        if (result.rows.length) {\n\t          var metadata = safeJsonParse(result.rows.item(0).json);\n\t          fetchedDocs.set(id, metadata);\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function saveAttachment(digest, data, callback) {\n\t    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      if (result.rows.length) { // attachment already exists\n\t        return callback();\n\t      }\n\t      // we could just insert before selecting and catch the error,\n\t      // but my hunch is that it's cheaper not to serialize the blob\n\t      // from JS to C if we don't have to (TODO: confirm this)\n\t      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n\t      ' (digest, body, escaped) VALUES (?,?,1)';\n\t      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n\t        callback();\n\t      }, function () {\n\t        // ignore constaint errors, means it already exists\n\t        callback();\n\t        return false; // ack we handled the error\n\t      });\n\t    });\n\t  }\n\t\n\t  preprocessAttachments(docInfos, 'binary', function (err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    db.transaction(function (txn) {\n\t      tx = txn;\n\t      verifyAttachments(function (err) {\n\t        if (err) {\n\t          preconditionErrored = err;\n\t        } else {\n\t          fetchExistingDocs(websqlProcessDocs);\n\t        }\n\t      });\n\t    }, websqlError(callback), complete);\n\t  });\n\t}\n\t\n\tvar cachedDatabases = new ExportedMap();\n\t\n\t// openDatabase passed in through opts (e.g. for node-websql)\n\tfunction openDatabaseWithOpts(opts) {\n\t  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n\t}\n\t\n\tfunction openDBSafely(opts) {\n\t  try {\n\t    return {\n\t      db: openDatabaseWithOpts(opts)\n\t    };\n\t  } catch (err) {\n\t    return {\n\t      error: err\n\t    };\n\t  }\n\t}\n\t\n\tfunction openDB(opts) {\n\t  var cachedResult = cachedDatabases.get(opts.name);\n\t  if (!cachedResult) {\n\t    cachedResult = openDBSafely(opts);\n\t    cachedDatabases.set(opts.name, cachedResult);\n\t  }\n\t  return cachedResult;\n\t}\n\t\n\tvar websqlChanges = new Changes();\n\t\n\tfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n\t  var attachments = Object.keys(doc._attachments || {});\n\t  if (!attachments.length) {\n\t    return cb && cb();\n\t  }\n\t  var numDone = 0;\n\t\n\t  function checkDone() {\n\t    if (++numDone === attachments.length && cb) {\n\t      cb();\n\t    }\n\t  }\n\t\n\t  function fetchAttachment(doc, att) {\n\t    var attObj = doc._attachments[att];\n\t    var attOpts = {binary: opts.binary, ctx: txn};\n\t    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n\t      doc._attachments[att] = $inject_Object_assign(\n\t        pick(attObj, ['digest', 'content_type']),\n\t        { data: data }\n\t      );\n\t      checkDone();\n\t    });\n\t  }\n\t\n\t  attachments.forEach(function (att) {\n\t    if (opts.attachments && opts.include_docs) {\n\t      fetchAttachment(doc, att);\n\t    } else {\n\t      doc._attachments[att].stub = true;\n\t      checkDone();\n\t    }\n\t  });\n\t}\n\t\n\tvar POUCH_VERSION = 1;\n\t\n\t// these indexes cover the ground for most allDocs queries\n\tvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n\t  BY_SEQ_STORE$1 + ' (seq, deleted)';\n\tvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n\t  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n\t    BY_SEQ_STORE$1 + ' (doc_id, rev)';\n\tvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n\t  DOC_STORE$1 + ' (winningseq)';\n\tvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n\t    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\n\tvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n\t  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n\t    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\t\n\tvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n\t  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\t\n\tvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n\t  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n\t  BY_SEQ_STORE$1 + '.json AS data, ' +\n\t  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n\t  DOC_STORE$1 + '.json AS metadata';\n\t\n\tfunction WebSqlPouch(opts, callback) {\n\t  var api = this;\n\t  var instanceId = null;\n\t  var size = getSize(opts);\n\t  var idRequests = [];\n\t  var encoding;\n\t\n\t  api._name = opts.name;\n\t\n\t  // extend the options here, because sqlite plugin has a ton of options\n\t  // and they are constantly changing, so it's more prudent to allow anything\n\t  var websqlOpts = $inject_Object_assign({}, opts, {\n\t    version: POUCH_VERSION,\n\t    description: opts.name,\n\t    size: size\n\t  });\n\t  var openDBResult = openDB(websqlOpts);\n\t  if (openDBResult.error) {\n\t    return websqlError(callback)(openDBResult.error);\n\t  }\n\t  var db = openDBResult.db;\n\t  if (typeof db.readTransaction !== 'function') {\n\t    // doesn't exist in sqlite plugin\n\t    db.readTransaction = db.transaction;\n\t  }\n\t\n\t  function dbCreated() {\n\t    // note the db name in case the browser upgrades to idb\n\t    if (hasLocalStorage()) {\n\t      window.localStorage['_pouch__websqldb_' + api._name] = true;\n\t    }\n\t    callback(null, api);\n\t  }\n\t\n\t  // In this migration, we added the 'deleted' and 'local' columns to the\n\t  // by-seq and doc store tables.\n\t  // To preserve existing user data, we re-process all the existing JSON\n\t  // and add these values.\n\t  // Called migration2 because it corresponds to adapter version (db_version) #2\n\t  function runMigration2(tx, callback) {\n\t    // index used for the join in the allDocs query\n\t    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\t\n\t    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n\t      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n\t      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n\t      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n\t        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n\t        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n\t          DOC_STORE$1 + ' (local, id)');\n\t\n\t        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n\t          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n\t          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\t\n\t        tx.executeSql(sql, [], function (tx, result) {\n\t\n\t          var deleted = [];\n\t          var local = [];\n\t\n\t          for (var i = 0; i < result.rows.length; i++) {\n\t            var item = result.rows.item(i);\n\t            var seq = item.seq;\n\t            var metadata = JSON.parse(item.metadata);\n\t            if (isDeleted(metadata)) {\n\t              deleted.push(seq);\n\t            }\n\t            if (isLocalId(metadata.id)) {\n\t              local.push(metadata.id);\n\t            }\n\t          }\n\t          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n\t            qMarks(local.length), local, function () {\n\t            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n\t              ' SET deleted = 1 WHERE seq IN ' +\n\t              qMarks(deleted.length), deleted, callback);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we make all the local docs unversioned\n\t  function runMigration3(tx, callback) {\n\t    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n\t      ' (id UNIQUE, rev, json)';\n\t    tx.executeSql(local, [], function () {\n\t      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n\t        BY_SEQ_STORE$1 + '.json AS data ' +\n\t        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n\t        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n\t        DOC_STORE$1 + '.winningseq WHERE local = 1';\n\t      tx.executeSql(sql, [], function (tx, res) {\n\t        var rows = [];\n\t        for (var i = 0; i < res.rows.length; i++) {\n\t          rows.push(res.rows.item(i));\n\t        }\n\t        function doNext() {\n\t          if (!rows.length) {\n\t            return callback(tx);\n\t          }\n\t          var row = rows.shift();\n\t          var rev$$1 = JSON.parse(row.data)._rev;\n\t          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n\t              ' (id, rev, json) VALUES (?,?,?)',\n\t              [row.id, rev$$1, row.data], function (tx) {\n\t            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n\t                [row.id], function (tx) {\n\t              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n\t                  [row.seq], function () {\n\t                doNext();\n\t              });\n\t            });\n\t          });\n\t        }\n\t        doNext();\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we remove doc_id_rev and just use rev\n\t  function runMigration4(tx, callback) {\n\t\n\t    function updateRows(rows) {\n\t      function doNext() {\n\t        if (!rows.length) {\n\t          return callback(tx);\n\t        }\n\t        var row = rows.shift();\n\t        var doc_id_rev = parseHexString(row.hex, encoding);\n\t        var idx = doc_id_rev.lastIndexOf('::');\n\t        var doc_id = doc_id_rev.substring(0, idx);\n\t        var rev$$1 = doc_id_rev.substring(idx + 2);\n\t        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n\t          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n\t        tx.executeSql(sql, [doc_id, rev$$1, doc_id_rev], function () {\n\t          doNext();\n\t        });\n\t      }\n\t      doNext();\n\t    }\n\t\n\t    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n\t    tx.executeSql(sql, [], function (tx) {\n\t      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n\t      tx.executeSql(sql, [], function (tx) {\n\t        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n\t          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n\t          tx.executeSql(sql, [], function (tx, res) {\n\t            var rows = [];\n\t            for (var i = 0; i < res.rows.length; i++) {\n\t              rows.push(res.rows.item(i));\n\t            }\n\t            updateRows(rows);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we add the attach_and_seq table\n\t  // for issue #2818\n\t  function runMigration5(tx, callback) {\n\t\n\t    function migrateAttsAndSeqs(tx) {\n\t      // need to actually populate the table. this is the expensive part,\n\t      // so as an optimization, check first that this database even\n\t      // contains attachments\n\t      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n\t      tx.executeSql(sql, [], function (tx, res) {\n\t        var count = res.rows.item(0).cnt;\n\t        if (!count) {\n\t          return callback(tx);\n\t        }\n\t\n\t        var offset = 0;\n\t        var pageSize = 10;\n\t        function nextPage() {\n\t          var sql = select(\n\t            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n\t            [DOC_STORE$1, BY_SEQ_STORE$1],\n\t            DOC_STORE_AND_BY_SEQ_JOINER,\n\t            null,\n\t            DOC_STORE$1 + '.id '\n\t          );\n\t          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n\t          offset += pageSize;\n\t          tx.executeSql(sql, [], function (tx, res) {\n\t            if (!res.rows.length) {\n\t              return callback(tx);\n\t            }\n\t            var digestSeqs = {};\n\t            function addDigestSeq(digest, seq) {\n\t              // uniq digest/seq pairs, just in case there are dups\n\t              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n\t              if (seqs.indexOf(seq) === -1) {\n\t                seqs.push(seq);\n\t              }\n\t            }\n\t            for (var i = 0; i < res.rows.length; i++) {\n\t              var row = res.rows.item(i);\n\t              var doc = unstringifyDoc(row.data, row.id, row.rev);\n\t              var atts = Object.keys(doc._attachments || {});\n\t              for (var j = 0; j < atts.length; j++) {\n\t                var att = doc._attachments[atts[j]];\n\t                addDigestSeq(att.digest, row.seq);\n\t              }\n\t            }\n\t            var digestSeqPairs = [];\n\t            Object.keys(digestSeqs).forEach(function (digest) {\n\t              var seqs = digestSeqs[digest];\n\t              seqs.forEach(function (seq) {\n\t                digestSeqPairs.push([digest, seq]);\n\t              });\n\t            });\n\t            if (!digestSeqPairs.length) {\n\t              return nextPage();\n\t            }\n\t            var numDone = 0;\n\t            digestSeqPairs.forEach(function (pair) {\n\t              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n\t                ' (digest, seq) VALUES (?,?)';\n\t              tx.executeSql(sql, pair, function () {\n\t                if (++numDone === digestSeqPairs.length) {\n\t                  nextPage();\n\t                }\n\t              });\n\t            });\n\t          });\n\t        }\n\t        nextPage();\n\t      });\n\t    }\n\t\n\t    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n\t      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n\t    tx.executeSql(attachAndRev, [], function (tx) {\n\t      tx.executeSql(\n\t        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n\t          tx.executeSql(\n\t            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n\t            migrateAttsAndSeqs);\n\t        });\n\t    });\n\t  }\n\t\n\t  // in this migration, we use escapeBlob() and unescapeBlob()\n\t  // instead of reading out the binary as HEX, which is slow\n\t  function runMigration6(tx, callback) {\n\t    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n\t      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n\t    tx.executeSql(sql, [], callback);\n\t  }\n\t\n\t  // issue #3136, in this migration we need a \"latest seq\" as well\n\t  // as the \"winning seq\" in the doc store\n\t  function runMigration7(tx, callback) {\n\t    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n\t      ' ADD COLUMN max_seq INTEGER';\n\t    tx.executeSql(sql, [], function (tx) {\n\t      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n\t        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n\t      tx.executeSql(sql, [], function (tx) {\n\t        // add unique index after filling, else we'll get a constraint\n\t        // error when we do the ALTER TABLE\n\t        var sql =\n\t          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n\t          DOC_STORE$1 + ' (max_seq)';\n\t        tx.executeSql(sql, [], callback);\n\t      });\n\t    });\n\t  }\n\t\n\t  function checkEncoding(tx, cb) {\n\t    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n\t    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n\t        var hex = res.rows.item(0).hex;\n\t        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n\t        cb();\n\t      }\n\t    );\n\t  }\n\t\n\t  function onGetInstanceId() {\n\t    while (idRequests.length > 0) {\n\t      var idCallback = idRequests.pop();\n\t      idCallback(null, instanceId);\n\t    }\n\t  }\n\t\n\t  function onGetVersion(tx, dbVersion) {\n\t    if (dbVersion === 0) {\n\t      // initial schema\n\t\n\t      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n\t        ' (dbid, db_version INTEGER)';\n\t      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n\t        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n\t      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n\t        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n\t      // TODO: migrate winningseq to INTEGER\n\t      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n\t        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n\t      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n\t        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n\t        'json, deleted TINYINT(1), doc_id, rev)';\n\t      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n\t        ' (id UNIQUE, rev, json)';\n\t\n\t      // creates\n\t      tx.executeSql(attach);\n\t      tx.executeSql(local);\n\t      tx.executeSql(attachAndRev, [], function () {\n\t        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n\t        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n\t      });\n\t      tx.executeSql(doc, [], function () {\n\t        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\t        tx.executeSql(seq, [], function () {\n\t          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n\t          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n\t          tx.executeSql(meta, [], function () {\n\t            // mark the db version, and new dbid\n\t            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n\t              ' (db_version, dbid) VALUES (?,?)';\n\t            instanceId = uuid();\n\t            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n\t            tx.executeSql(initSeq, initSeqArgs, function () {\n\t              onGetInstanceId();\n\t            });\n\t          });\n\t        });\n\t      });\n\t    } else { // version > 0\n\t\n\t      var setupDone = function () {\n\t        var migrated = dbVersion < ADAPTER_VERSION$1;\n\t        if (migrated) {\n\t          // update the db version within this transaction\n\t          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n\t            ADAPTER_VERSION$1);\n\t        }\n\t        // notify db.id() callers\n\t        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n\t        tx.executeSql(sql, [], function (tx, result) {\n\t          instanceId = result.rows.item(0).dbid;\n\t          onGetInstanceId();\n\t        });\n\t      };\n\t\n\t      // would love to use promises here, but then websql\n\t      // ends the transaction early\n\t      var tasks = [\n\t        runMigration2,\n\t        runMigration3,\n\t        runMigration4,\n\t        runMigration5,\n\t        runMigration6,\n\t        runMigration7,\n\t        setupDone\n\t      ];\n\t\n\t      // run each migration sequentially\n\t      var i = dbVersion;\n\t      var nextMigration = function (tx) {\n\t        tasks[i - 1](tx, nextMigration);\n\t        i++;\n\t      };\n\t      nextMigration(tx);\n\t    }\n\t  }\n\t\n\t  function setup() {\n\t    db.transaction(function (tx) {\n\t      // first check the encoding\n\t      checkEncoding(tx, function () {\n\t        // then get the version\n\t        fetchVersion(tx);\n\t      });\n\t    }, websqlError(callback), dbCreated);\n\t  }\n\t\n\t  function fetchVersion(tx) {\n\t    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n\t    tx.executeSql(sql, [], function (tx, result) {\n\t      if (!result.rows.length) {\n\t        // database hasn't even been created yet (version 0)\n\t        onGetVersion(tx, 0);\n\t      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n\t        // table was created, but without the new db_version column,\n\t        // so add it.\n\t        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n\t          ' ADD COLUMN db_version INTEGER', [], function () {\n\t          // before version 2, this column didn't even exist\n\t          onGetVersion(tx, 1);\n\t        });\n\t      } else { // column exists, we can safely get it\n\t        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n\t          [], function (tx, result) {\n\t          var dbVersion = result.rows.item(0).db_version;\n\t          onGetVersion(tx, dbVersion);\n\t        });\n\t      }\n\t    });\n\t  }\n\t\n\t  setup();\n\t\n\t  function getMaxSeq(tx, callback) {\n\t    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n\t    tx.executeSql(sql, [], function (tx, res) {\n\t      var updateSeq = res.rows.item(0).seq || 0;\n\t      callback(updateSeq);\n\t    });\n\t  }\n\t\n\t  function countDocs(tx, callback) {\n\t    // count the total rows\n\t    var sql = select(\n\t      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n\t      [DOC_STORE$1, BY_SEQ_STORE$1],\n\t      DOC_STORE_AND_BY_SEQ_JOINER,\n\t      BY_SEQ_STORE$1 + '.deleted=0');\n\t\n\t    tx.executeSql(sql, [], function (tx, result) {\n\t      callback(result.rows.item(0).num);\n\t    });\n\t  }\n\t\n\t  api._remote = false;\n\t  api.type = function () {\n\t    return 'websql';\n\t  };\n\t\n\t  api._id = toPromise(function (callback) {\n\t    callback(null, instanceId);\n\t  });\n\t\n\t  api._info = function (callback) {\n\t    var seq;\n\t    var docCount;\n\t    db.readTransaction(function (tx) {\n\t      getMaxSeq(tx, function (theSeq) {\n\t        seq = theSeq;\n\t      });\n\t      countDocs(tx, function (theDocCount) {\n\t        docCount = theDocCount;\n\t      });\n\t    }, websqlError(callback), function () {\n\t      callback(null, {\n\t        doc_count: docCount,\n\t        update_seq: seq,\n\t        websql_encoding: encoding\n\t      });\n\t    });\n\t  };\n\t\n\t  api._bulkDocs = function (req, reqOpts, callback) {\n\t    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n\t  };\n\t\n\t  function latest$$1(tx, id, rev$$1, callback, finish) {\n\t    var sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        DOC_STORE$1 + '.id=?');\n\t    var sqlArgs = [id];\n\t\n\t    tx.executeSql(sql, sqlArgs, function (a, results) {\n\t      if (!results.rows.length) {\n\t        var err = createError(MISSING_DOC, 'missing');\n\t        return finish(err);\n\t      }\n\t      var item = results.rows.item(0);\n\t      var metadata = safeJsonParse(item.metadata);\n\t      callback(latest(rev$$1, metadata));\n\t    });\n\t  }\n\t\n\t  api._get = function (id, opts, callback) {\n\t    var doc;\n\t    var metadata;\n\t    var tx = opts.ctx;\n\t    if (!tx) {\n\t      return db.readTransaction(function (txn) {\n\t        api._get(id, $inject_Object_assign({ctx: txn}, opts), callback);\n\t      });\n\t    }\n\t\n\t    function finish(err) {\n\t      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n\t    }\n\t\n\t    var sql;\n\t    var sqlArgs;\n\t\n\t    if (!opts.rev) {\n\t      sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        DOC_STORE$1 + '.id=?');\n\t      sqlArgs = [id];\n\t    } else if (opts.latest) {\n\t      latest$$1(tx, id, opts.rev, function (latestRev) {\n\t        opts.latest = false;\n\t        opts.rev = latestRev;\n\t        api._get(id, opts, callback);\n\t      }, finish);\n\t      return;\n\t    } else {\n\t      sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n\t        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n\t      sqlArgs = [id, opts.rev];\n\t    }\n\t\n\t    tx.executeSql(sql, sqlArgs, function (a, results) {\n\t      if (!results.rows.length) {\n\t        var missingErr = createError(MISSING_DOC, 'missing');\n\t        return finish(missingErr);\n\t      }\n\t      var item = results.rows.item(0);\n\t      metadata = safeJsonParse(item.metadata);\n\t      if (item.deleted && !opts.rev) {\n\t        var deletedErr = createError(MISSING_DOC, 'deleted');\n\t        return finish(deletedErr);\n\t      }\n\t      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n\t      finish();\n\t    });\n\t  };\n\t\n\t  api._allDocs = function (opts, callback) {\n\t    var results = [];\n\t    var totalRows;\n\t    var updateSeq;\n\t\n\t    var start = 'startkey' in opts ? opts.startkey : false;\n\t    var end = 'endkey' in opts ? opts.endkey : false;\n\t    var key = 'key' in opts ? opts.key : false;\n\t    var keys = 'keys' in opts ? opts.keys : false;\n\t    var descending = 'descending' in opts ? opts.descending : false;\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    var offset = 'skip' in opts ? opts.skip : 0;\n\t    var inclusiveEnd = opts.inclusive_end !== false;\n\t    \n\t    var sqlArgs = [];\n\t    var criteria = [];\n\t\n\t    if (keys) {\n\t      var destinctKeys = [];\n\t      var bindingStr = \"\";\n\t      keys.forEach(function (key) {\n\t        if (destinctKeys.indexOf(key) === -1) {\n\t          destinctKeys.push(key);\n\t          bindingStr += '?,';\n\t        }\n\t      });\n\t      bindingStr = bindingStr.substring(0, bindingStr.length - 1); // keys is never empty\n\t      criteria.push(DOC_STORE$1 + '.id IN (' + bindingStr + ')');\n\t      sqlArgs = sqlArgs.concat(destinctKeys);\n\t    } else if (key !== false) {\n\t      criteria.push(DOC_STORE$1 + '.id = ?');\n\t      sqlArgs.push(key);\n\t    } else if (start !== false || end !== false) {\n\t      if (start !== false) {\n\t        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n\t        sqlArgs.push(start);\n\t      }\n\t      if (end !== false) {\n\t        var comparator = descending ? '>' : '<';\n\t        if (inclusiveEnd) {\n\t          comparator += '=';\n\t        }\n\t        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n\t        sqlArgs.push(end);\n\t      }\n\t      if (key !== false) {\n\t        criteria.push(DOC_STORE$1 + '.id = ?');\n\t        sqlArgs.push(key);\n\t      }\n\t    }\n\t\n\t    if (!keys) {\n\t      // report deleted if keys are specified\n\t      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n\t    }\n\t\n\t    db.readTransaction(function (tx) {\n\t      // count the docs in parallel to other operations\n\t      countDocs(tx, function (docCount) {\n\t        totalRows = docCount;\n\t      });\n\t\n\t      /* istanbul ignore if */\n\t      if (opts.update_seq) {\n\t        // get max sequence in parallel to other operations\n\t        getMaxSeq(tx, function (theSeq) {\n\t          updateSeq = theSeq;\n\t        });\n\t      }\n\t\n\t      if (limit === 0) {\n\t        return;\n\t      }\n\t\n\t      // do a single query to fetch the documents\n\t      var sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        criteria,\n\t        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n\t        );\n\t      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\t\n\t      tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t        for (var i = 0, l = result.rows.length; i < l; i++) {\n\t          var item = result.rows.item(i);\n\t          var metadata = safeJsonParse(item.metadata);\n\t          var id = metadata.id;\n\t          var data = unstringifyDoc(item.data, id, item.rev);\n\t          var winningRev$$1 = data._rev;\n\t          var doc = {\n\t            id: id,\n\t            key: id,\n\t            value: {rev: winningRev$$1}\n\t          };\n\t          if (opts.include_docs) {\n\t            doc.doc = data;\n\t            doc.doc._rev = winningRev$$1;\n\t            if (opts.conflicts) {\n\t              var conflicts = collectConflicts(metadata);\n\t              if (conflicts.length) {\n\t                doc.doc._conflicts = conflicts;\n\t              }\n\t            }\n\t            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n\t          }\n\t          if (item.deleted) {\n\t            if (keys) {\n\t              doc.value.deleted = true;\n\t              doc.doc = null;\n\t            } else {\n\t              // propably should not happen\n\t              continue;\n\t            }\n\t          }\n\t          if (!keys) {\n\t            results.push(doc);\n\t          } else {\n\t            var index = keys.indexOf(id, index);\n\t            do {\n\t              results[index] = doc;\n\t              index = keys.indexOf(id, index + 1);\n\t            } while (index > -1 && index < keys.length);\n\t          }\n\t        }\n\t        if (keys) {\n\t          keys.forEach(function (key, index) {\n\t            if (!results[index]) {\n\t              results[index] = {key: key, error: 'not_found'};\n\t            }\n\t          });\n\t        }\n\t      });\n\t    }, websqlError(callback), function () {\n\t      var returnVal = {\n\t        total_rows: totalRows,\n\t        offset: opts.skip,\n\t        rows: results\n\t      };\n\t\n\t      /* istanbul ignore if */\n\t      if (opts.update_seq) {\n\t        returnVal.update_seq = updateSeq;\n\t      }\n\t      callback(null, returnVal);\n\t    });\n\t  };\n\t\n\t  api._changes = function (opts) {\n\t    opts = clone(opts);\n\t\n\t    if (opts.continuous) {\n\t      var id = api._name + ':' + uuid();\n\t      websqlChanges.addListener(api._name, id, api, opts);\n\t      websqlChanges.notify(api._name);\n\t      return {\n\t        cancel: function () {\n\t          websqlChanges.removeListener(api._name, id);\n\t        }\n\t      };\n\t    }\n\t\n\t    var descending = opts.descending;\n\t\n\t    // Ignore the `since` parameter when `descending` is true\n\t    opts.since = opts.since && !descending ? opts.since : 0;\n\t\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    if (limit === 0) {\n\t      limit = 1; // per CouchDB _changes spec\n\t    }\n\t\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t    var results = [];\n\t    var numResults = 0;\n\t\n\t    function fetchChanges() {\n\t\n\t      var selectStmt =\n\t        DOC_STORE$1 + '.json AS metadata, ' +\n\t        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n\t        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n\t        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\t\n\t      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\t\n\t      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n\t        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\t\n\t      var criteria = ['maxSeq > ?'];\n\t      var sqlArgs = [opts.since];\n\t\n\t      if (opts.doc_ids) {\n\t        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n\t        sqlArgs = sqlArgs.concat(opts.doc_ids);\n\t      }\n\t\n\t      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\t\n\t      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\t\n\t      var filter = filterChange(opts);\n\t      if (!opts.view && !opts.filter) {\n\t        // we can just limit in the query\n\t        sql += ' LIMIT ' + limit;\n\t      }\n\t\n\t      var lastSeq = opts.since || 0;\n\t      db.readTransaction(function (tx) {\n\t        tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t          function reportChange(change) {\n\t            return function () {\n\t              opts.onChange(change);\n\t            };\n\t          }\n\t          for (var i = 0, l = result.rows.length; i < l; i++) {\n\t            var item = result.rows.item(i);\n\t            var metadata = safeJsonParse(item.metadata);\n\t            lastSeq = item.maxSeq;\n\t\n\t            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n\t              item.winningRev);\n\t            var change = opts.processChange(doc, metadata, opts);\n\t            change.seq = item.maxSeq;\n\t\n\t            var filtered = filter(change);\n\t            if (typeof filtered === 'object') {\n\t              return opts.complete(filtered);\n\t            }\n\t\n\t            if (filtered) {\n\t              numResults++;\n\t              if (returnDocs) {\n\t                results.push(change);\n\t              }\n\t              // process the attachment immediately\n\t              // for the benefit of live listeners\n\t              if (opts.attachments && opts.include_docs) {\n\t                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n\t                  reportChange(change));\n\t              } else {\n\t                reportChange(change)();\n\t              }\n\t            }\n\t            if (numResults === limit) {\n\t              break;\n\t            }\n\t          }\n\t        });\n\t      }, websqlError(opts.complete), function () {\n\t        if (!opts.continuous) {\n\t          opts.complete(null, {\n\t            results: results,\n\t            last_seq: lastSeq\n\t          });\n\t        }\n\t      });\n\t    }\n\t\n\t    fetchChanges();\n\t  };\n\t\n\t  api._close = function (callback) {\n\t    //WebSQL databases do not need to be closed\n\t    callback();\n\t  };\n\t\n\t  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n\t    var res;\n\t    var tx = opts.ctx;\n\t    var digest = attachment.digest;\n\t    var type = attachment.content_type;\n\t    var sql = 'SELECT escaped, ' +\n\t      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n\t      ATTACH_STORE$1 + ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      // websql has a bug where \\u0000 causes early truncation in strings\n\t      // and blobs. to work around this, we used to use the hex() function,\n\t      // but that's not performant. after migration 6, we remove \\u0000\n\t      // and add it back in afterwards\n\t      var item = result.rows.item(0);\n\t      var data = item.escaped ? unescapeBlob(item.body) :\n\t        parseHexString(item.body, encoding);\n\t      if (opts.binary) {\n\t        res = binStringToBluffer(data, type);\n\t      } else {\n\t        res = thisBtoa(data);\n\t      }\n\t      callback(null, res);\n\t    });\n\t  };\n\t\n\t  api._getRevisionTree = function (docId, callback) {\n\t    db.readTransaction(function (tx) {\n\t      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n\t      tx.executeSql(sql, [docId], function (tx, result) {\n\t        if (!result.rows.length) {\n\t          callback(createError(MISSING_DOC));\n\t        } else {\n\t          var data = safeJsonParse(result.rows.item(0).metadata);\n\t          callback(null, data.rev_tree);\n\t        }\n\t      });\n\t    });\n\t  };\n\t\n\t  api._doCompaction = function (docId, revs, callback) {\n\t    if (!revs.length) {\n\t      return callback();\n\t    }\n\t    db.transaction(function (tx) {\n\t\n\t      // update doc store\n\t      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n\t      tx.executeSql(sql, [docId], function (tx, result) {\n\t        var metadata = safeJsonParse(result.rows.item(0).metadata);\n\t        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                                           revHash, ctx, opts) {\n\t          var rev$$1 = pos + '-' + revHash;\n\t          if (revs.indexOf(rev$$1) !== -1) {\n\t            opts.status = 'missing';\n\t          }\n\t        });\n\t\n\t        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n\t        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n\t      });\n\t\n\t      compactRevs$1(revs, docId, tx);\n\t    }, websqlError(callback), function () {\n\t      callback();\n\t    });\n\t  };\n\t\n\t  api._getLocal = function (id, callback) {\n\t    db.readTransaction(function (tx) {\n\t      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n\t      tx.executeSql(sql, [id], function (tx, res) {\n\t        if (res.rows.length) {\n\t          var item = res.rows.item(0);\n\t          var doc = unstringifyDoc(item.json, id, item.rev);\n\t          callback(null, doc);\n\t        } else {\n\t          callback(createError(MISSING_DOC));\n\t        }\n\t      });\n\t    });\n\t  };\n\t\n\t  api._putLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    delete doc._revisions; // ignore this, trust the rev\n\t    var oldRev = doc._rev;\n\t    var id = doc._id;\n\t    var newRev;\n\t    if (!oldRev) {\n\t      newRev = doc._rev = '0-1';\n\t    } else {\n\t      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n\t    }\n\t    var json = stringifyDoc(doc);\n\t\n\t    var ret;\n\t    function putLocal(tx) {\n\t      var sql;\n\t      var values;\n\t      if (oldRev) {\n\t        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n\t          'WHERE id=? AND rev=?';\n\t        values = [newRev, json, id, oldRev];\n\t      } else {\n\t        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n\t        values = [id, newRev, json];\n\t      }\n\t      tx.executeSql(sql, values, function (tx, res) {\n\t        if (res.rowsAffected) {\n\t          ret = {ok: true, id: id, rev: newRev};\n\t          if (opts.ctx) { // return immediately\n\t            callback(null, ret);\n\t          }\n\t        } else {\n\t          callback(createError(REV_CONFLICT));\n\t        }\n\t      }, function () {\n\t        callback(createError(REV_CONFLICT));\n\t        return false; // ack that we handled the error\n\t      });\n\t    }\n\t\n\t    if (opts.ctx) {\n\t      putLocal(opts.ctx);\n\t    } else {\n\t      db.transaction(putLocal, websqlError(callback), function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  api._removeLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var ret;\n\t\n\t    function removeLocal(tx) {\n\t      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n\t      var params = [doc._id, doc._rev];\n\t      tx.executeSql(sql, params, function (tx, res) {\n\t        if (!res.rowsAffected) {\n\t          return callback(createError(MISSING_DOC));\n\t        }\n\t        ret = {ok: true, id: doc._id, rev: '0-0'};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t\n\t    if (opts.ctx) {\n\t      removeLocal(opts.ctx);\n\t    } else {\n\t      db.transaction(removeLocal, websqlError(callback), function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  api._destroy = function (opts, callback) {\n\t    websqlChanges.removeAllListeners(api._name);\n\t    db.transaction(function (tx) {\n\t      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n\t        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n\t      stores.forEach(function (store) {\n\t        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n\t      });\n\t    }, websqlError(callback), function () {\n\t      if (hasLocalStorage()) {\n\t        delete window.localStorage['_pouch__websqldb_' + api._name];\n\t        delete window.localStorage[api._name];\n\t      }\n\t      callback(null, {'ok': true});\n\t    });\n\t  };\n\t}\n\t\n\tfunction canOpenTestDB() {\n\t  try {\n\t    openDatabase('_pouch_validate_websql', 1, '', 1);\n\t    return true;\n\t  } catch (err) {\n\t    return false;\n\t  }\n\t}\n\t\n\t// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n\t// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n\t// https://github.com/pouchdb/pouchdb/issues/5079)\n\t// This has been fixed in latest WebKit, so we try to detect it here.\n\tfunction isValidWebSQL() {\n\t  // WKWebView UA:\n\t  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n\t  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n\t  // Chrome for iOS UA:\n\t  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n\t  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n\t  //   Mobile/9B206 Safari/7534.48.3\n\t  // Firefox for iOS UA:\n\t  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n\t  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\t\n\t  // indexedDB is null on some UIWebViews and undefined in others\n\t  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n\t  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n\t      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n\t    // definitely not WKWebView, avoid creating an unnecessary database\n\t    return true;\n\t  }\n\t  // Cache the result in LocalStorage. Reason we do this is because if we\n\t  // call openDatabase() too many times, Safari craps out in SauceLabs and\n\t  // starts throwing DOM Exception 14s.\n\t  var hasLS = hasLocalStorage();\n\t  // Include user agent in the hash, so that if Safari is upgraded, we don't\n\t  // continually think it's broken.\n\t  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n\t  if (hasLS && localStorage[localStorageKey]) {\n\t    return localStorage[localStorageKey] === '1';\n\t  }\n\t  var openedTestDB = canOpenTestDB();\n\t  if (hasLS) {\n\t    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n\t  }\n\t  return openedTestDB;\n\t}\n\t\n\tfunction valid() {\n\t  if (typeof openDatabase !== 'function') {\n\t    return false;\n\t  }\n\t  return isValidWebSQL();\n\t}\n\t\n\tfunction openDB$2(name, version, description, size) {\n\t  // Traditional WebSQL API\n\t  return openDatabase(name, version, description, size);\n\t}\n\t\n\tfunction WebSQLPouch(opts, callback) {\n\t  var msg = 'WebSQL is deprecated and will be removed in future releases of PouchDB. ' +\n\t      'Please migrate to IndexedDB: https://pouchdb.com/2018/01/23/pouchdb-6.4.2.html';\n\t  guardedConsole('warn', msg);\n\t  var _opts = $inject_Object_assign({\n\t    websql: openDB$2\n\t  }, opts);\n\t\n\t  WebSqlPouch.call(this, _opts, callback);\n\t}\n\t\n\tWebSQLPouch.valid = valid;\n\t\n\tWebSQLPouch.use_prefix = true;\n\t\n\tfunction WebSqlPouch$1 (PouchDB) {\n\t  PouchDB.adapter('websql', WebSQLPouch, true);\n\t}\n\t\n\t/* global fetch */\n\t/* global Headers */\n\tfunction wrappedFetch() {\n\t  var wrappedPromise = {};\n\t\n\t  var promise = new PouchPromise(function (resolve, reject) {\n\t    wrappedPromise.resolve = resolve;\n\t    wrappedPromise.reject = reject;\n\t  });\n\t\n\t  var args = new Array(arguments.length);\n\t\n\t  for (var i = 0; i < args.length; i++) {\n\t    args[i] = arguments[i];\n\t  }\n\t\n\t  wrappedPromise.promise = promise;\n\t\n\t  PouchPromise.resolve().then(function () {\n\t    return fetch.apply(null, args);\n\t  }).then(function (response) {\n\t    wrappedPromise.resolve(response);\n\t  }).catch(function (error) {\n\t    wrappedPromise.reject(error);\n\t  });\n\t\n\t  return wrappedPromise;\n\t}\n\t\n\tfunction fetchRequest(options, callback) {\n\t  var wrappedPromise, timer, response;\n\t\n\t  var headers = new Headers();\n\t\n\t  var fetchOptions = {\n\t    method: options.method,\n\t    credentials: 'include',\n\t    headers: headers\n\t  };\n\t\n\t  if (options.json) {\n\t    headers.set('Accept', 'application/json');\n\t    headers.set('Content-Type', options.headers['Content-Type'] ||\n\t      'application/json');\n\t  }\n\t\n\t  if (options.body &&\n\t      options.processData &&\n\t      typeof options.body !== 'string') {\n\t    fetchOptions.body = JSON.stringify(options.body);\n\t  } else if ('body' in options) {\n\t    fetchOptions.body = options.body;\n\t  } else {\n\t    fetchOptions.body = null;\n\t  }\n\t\n\t  Object.keys(options.headers).forEach(function (key) {\n\t    if (options.headers.hasOwnProperty(key)) {\n\t      headers.set(key, options.headers[key]);\n\t    }\n\t  });\n\t\n\t  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\t\n\t  if (options.timeout > 0) {\n\t    timer = setTimeout(function () {\n\t      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n\t        options.url));\n\t    }, options.timeout);\n\t  }\n\t\n\t  wrappedPromise.promise.then(function (fetchResponse) {\n\t    response = {\n\t      statusCode: fetchResponse.status\n\t    };\n\t\n\t    if (options.timeout > 0) {\n\t      clearTimeout(timer);\n\t    }\n\t\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n\t    }\n\t\n\t    return fetchResponse.json();\n\t  }).then(function (result) {\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      callback(null, response, result);\n\t    } else {\n\t      result.status = response.statusCode;\n\t      callback(result);\n\t    }\n\t  }).catch(function (error) {\n\t    if (!error) {\n\t      // this happens when the listener is canceled\n\t      error = new Error('canceled');\n\t    }\n\t    callback(error);\n\t  });\n\t\n\t  return {abort: wrappedPromise.reject};\n\t}\n\t\n\tfunction xhRequest(options, callback) {\n\t\n\t  var xhr, timer;\n\t  var timedout = false;\n\t\n\t  var abortReq = function () {\n\t    xhr.abort();\n\t    cleanUp();\n\t  };\n\t\n\t  var timeoutReq = function () {\n\t    timedout = true;\n\t    xhr.abort();\n\t    cleanUp();\n\t  };\n\t\n\t  var ret = {abort: abortReq};\n\t\n\t  var cleanUp = function () {\n\t    clearTimeout(timer);\n\t    ret.abort = function () {};\n\t    if (xhr) {\n\t      xhr.onprogress = undefined;\n\t      if (xhr.upload) {\n\t        xhr.upload.onprogress = undefined;\n\t      }\n\t      xhr.onreadystatechange = undefined;\n\t      xhr = undefined;\n\t    }\n\t  };\n\t\n\t  if (options.xhr) {\n\t    xhr = new options.xhr();\n\t  } else {\n\t    xhr = new XMLHttpRequest();\n\t  }\n\t\n\t  try {\n\t    xhr.open(options.method, options.url);\n\t  } catch (exception) {\n\t    return callback(new Error(exception.name || 'Url is invalid'));\n\t  }\n\t\n\t  xhr.withCredentials = ('withCredentials' in options) ?\n\t    options.withCredentials : true;\n\t\n\t  if (options.method === 'GET') {\n\t    delete options.headers['Content-Type'];\n\t  } else if (options.json) {\n\t    options.headers.Accept = 'application/json';\n\t    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n\t      'application/json';\n\t    if (options.body &&\n\t        options.processData &&\n\t        typeof options.body !== \"string\") {\n\t      options.body = JSON.stringify(options.body);\n\t    }\n\t  }\n\t\n\t  if (options.binary) {\n\t    xhr.responseType = 'arraybuffer';\n\t  }\n\t\n\t  if (!('body' in options)) {\n\t    options.body = null;\n\t  }\n\t\n\t  for (var key in options.headers) {\n\t    if (options.headers.hasOwnProperty(key)) {\n\t      xhr.setRequestHeader(key, options.headers[key]);\n\t    }\n\t  }\n\t\n\t  if (options.timeout > 0) {\n\t    timer = setTimeout(timeoutReq, options.timeout);\n\t    xhr.onprogress = function () {\n\t      clearTimeout(timer);\n\t      if (xhr.readyState !== 4) {\n\t        timer = setTimeout(timeoutReq, options.timeout);\n\t      }\n\t    };\n\t    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n\t      xhr.upload.onprogress = xhr.onprogress;\n\t    }\n\t  }\n\t\n\t  xhr.onreadystatechange = function () {\n\t    if (xhr.readyState !== 4) {\n\t      return;\n\t    }\n\t\n\t    var response = {\n\t      statusCode: xhr.status\n\t    };\n\t\n\t    if (xhr.status >= 200 && xhr.status < 300) {\n\t      var data;\n\t      if (options.binary) {\n\t        data = createBlob([xhr.response || ''], {\n\t          type: xhr.getResponseHeader('Content-Type')\n\t        });\n\t      } else {\n\t        data = xhr.responseText;\n\t      }\n\t      callback(null, response, data);\n\t    } else {\n\t      var err = {};\n\t      if (timedout) {\n\t        err = new Error('ETIMEDOUT');\n\t        err.code = 'ETIMEDOUT';\n\t      } else if (typeof xhr.response === 'string' && xhr.response !== '') {\n\t        try {\n\t          err = JSON.parse(xhr.response);\n\t        } catch (e) {}\n\t      }\n\t\n\t      err.status = xhr.status;\n\t\n\t      callback(err);\n\t    }\n\t    cleanUp();\n\t  };\n\t\n\t  if (options.body && (options.body instanceof Blob)) {\n\t    readAsArrayBuffer(options.body, function (arrayBuffer) {\n\t      xhr.send(arrayBuffer);\n\t    });\n\t  } else {\n\t    xhr.send(options.body);\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tfunction testXhr() {\n\t  try {\n\t    new XMLHttpRequest();\n\t    return true;\n\t  } catch (err) {\n\t    return false;\n\t  }\n\t}\n\t\n\tvar hasXhr = testXhr();\n\t\n\tfunction ajax(options, callback) {\n\t  if (!false && (hasXhr || options.xhr)) {\n\t    return xhRequest(options, callback);\n\t  } else {\n\t    return fetchRequest(options, callback);\n\t  }\n\t}\n\t\n\t// the blob already has a type; do nothing\n\t\n\tfunction defaultBody() {\n\t  return '';\n\t}\n\t\n\tfunction ajaxCore(options, callback) {\n\t\n\t  options = clone(options);\n\t\n\t  var defaultOptions = {\n\t    method : \"GET\",\n\t    headers: {},\n\t    json: true,\n\t    processData: true,\n\t    timeout: 10000,\n\t    cache: false\n\t  };\n\t\n\t  options = $inject_Object_assign(defaultOptions, options);\n\t\n\t  function onSuccess(obj, resp, cb) {\n\t    if (!options.binary && options.json && typeof obj === 'string') {\n\t      /* istanbul ignore next */\n\t      try {\n\t        obj = JSON.parse(obj);\n\t      } catch (e) {\n\t        // Probably a malformed JSON from server\n\t        return cb(e);\n\t      }\n\t    }\n\t    if (Array.isArray(obj)) {\n\t      obj = obj.map(function (v) {\n\t        if (v.error || v.missing) {\n\t          return generateErrorFromResponse(v);\n\t        } else {\n\t          return v;\n\t        }\n\t      });\n\t    }\n\t    if (options.binary) {\n\t      \n\t    }\n\t    cb(null, obj, resp);\n\t  }\n\t\n\t  if (options.json) {\n\t    if (!options.binary) {\n\t      options.headers.Accept = 'application/json';\n\t    }\n\t    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n\t      'application/json';\n\t  }\n\t\n\t  if (options.binary) {\n\t    options.encoding = null;\n\t    options.json = false;\n\t  }\n\t\n\t  if (!options.processData) {\n\t    options.json = false;\n\t  }\n\t\n\t  return ajax(options, function (err, response, body) {\n\t\n\t    if (err) {\n\t      return callback(generateErrorFromResponse(err));\n\t    }\n\t\n\t    var error;\n\t    var content_type = response.headers && response.headers['content-type'];\n\t    var data = body || defaultBody();\n\t\n\t    // CouchDB doesn't always return the right content-type for JSON data, so\n\t    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n\t    if (!options.binary && (options.json || !options.processData) &&\n\t        typeof data !== 'object' &&\n\t        (/json/.test(content_type) ||\n\t         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n\t      try {\n\t        data = JSON.parse(data.toString());\n\t      } catch (e) {}\n\t    }\n\t\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      onSuccess(data, response, callback);\n\t    } else {\n\t      error = generateErrorFromResponse(data);\n\t      error.status = response.statusCode;\n\t      callback(error);\n\t    }\n\t  });\n\t}\n\t\n\tfunction ajax$1(opts, callback) {\n\t\n\t  // cache-buster, specifically designed to work around IE's aggressive caching\n\t  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n\t  // Also Safari caches POSTs, so we need to cache-bust those too.\n\t  var ua = (navigator && navigator.userAgent) ?\n\t    navigator.userAgent.toLowerCase() : '';\n\t\n\t  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n\t  var isIE = ua.indexOf('msie') !== -1;\n\t  var isTrident = ua.indexOf('trident') !== -1;\n\t  var isEdge = ua.indexOf('edge') !== -1;\n\t\n\t  // it appears the new version of safari also caches GETs,\n\t  // see https://github.com/pouchdb/pouchdb/issues/5010\n\t  var shouldCacheBust = (isSafari ||\n\t    ((isIE || isTrident || isEdge) && opts.method === 'GET'));\n\t\n\t  var cache = 'cache' in opts ? opts.cache : true;\n\t\n\t  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\t\n\t  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n\t    var hasArgs = opts.url.indexOf('?') !== -1;\n\t    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n\t  }\n\t\n\t  return ajaxCore(opts, callback);\n\t}\n\t\n\t// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n\t// but much smaller in code size. limits the number of concurrent promises that are executed\n\t\n\t\n\tfunction pool(promiseFactories, limit) {\n\t  return new PouchPromise(function (resolve, reject) {\n\t    var running = 0;\n\t    var current = 0;\n\t    var done = 0;\n\t    var len = promiseFactories.length;\n\t    var err;\n\t\n\t    function runNext() {\n\t      running++;\n\t      promiseFactories[current++]().then(onSuccess, onError);\n\t    }\n\t\n\t    function doNext() {\n\t      if (++done === len) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          reject(err);\n\t        } else {\n\t          resolve();\n\t        }\n\t      } else {\n\t        runNextBatch();\n\t      }\n\t    }\n\t\n\t    function onSuccess() {\n\t      running--;\n\t      doNext();\n\t    }\n\t\n\t    /* istanbul ignore next */\n\t    function onError(thisErr) {\n\t      running--;\n\t      err = err || thisErr;\n\t      doNext();\n\t    }\n\t\n\t    function runNextBatch() {\n\t      while (running < limit && current < len) {\n\t        runNext();\n\t      }\n\t    }\n\t\n\t    runNextBatch();\n\t  });\n\t}\n\t\n\tvar CHANGES_BATCH_SIZE = 25;\n\tvar MAX_SIMULTANEOUS_REVS = 50;\n\tvar CHANGES_TIMEOUT_BUFFER = 5000;\n\tvar DEFAULT_HEARTBEAT = 10000;\n\t\n\tvar supportsBulkGetMap = {};\n\t\n\tfunction readAttachmentsAsBlobOrBuffer(row) {\n\t  var doc = row.doc || row.ok;\n\t  var atts = doc._attachments;\n\t  if (!atts) {\n\t    return;\n\t  }\n\t  Object.keys(atts).forEach(function (filename) {\n\t    var att = atts[filename];\n\t    att.data = b64ToBluffer(att.data, att.content_type);\n\t  });\n\t}\n\t\n\tfunction encodeDocId(id) {\n\t  if (/^_design/.test(id)) {\n\t    return '_design/' + encodeURIComponent(id.slice(8));\n\t  }\n\t  if (/^_local/.test(id)) {\n\t    return '_local/' + encodeURIComponent(id.slice(7));\n\t  }\n\t  return encodeURIComponent(id);\n\t}\n\t\n\tfunction preprocessAttachments$2(doc) {\n\t  if (!doc._attachments || !Object.keys(doc._attachments)) {\n\t    return PouchPromise.resolve();\n\t  }\n\t\n\t  return PouchPromise.all(Object.keys(doc._attachments).map(function (key) {\n\t    var attachment = doc._attachments[key];\n\t    if (attachment.data && typeof attachment.data !== 'string') {\n\t      return new PouchPromise(function (resolve) {\n\t        blobToBase64(attachment.data, resolve);\n\t      }).then(function (b64) {\n\t        attachment.data = b64;\n\t      });\n\t    }\n\t  }));\n\t}\n\t\n\tfunction hasUrlPrefix(opts) {\n\t  if (!opts.prefix) {\n\t    return false;\n\t  }\n\t\n\t  var protocol = parseUri(opts.prefix).protocol;\n\t\n\t  return protocol === 'http' || protocol === 'https';\n\t}\n\t\n\t// Get all the information you possibly can about the URI given by name and\n\t// return it as a suitable object.\n\tfunction getHost(name, opts) {\n\t\n\t  // encode db name if opts.prefix is a url (#5574)\n\t  if (hasUrlPrefix(opts)) {\n\t    var dbName = opts.name.substr(opts.prefix.length);\n\t    name = opts.prefix + encodeURIComponent(dbName);\n\t  }\n\t\n\t  // Prase the URI into all its little bits\n\t  var uri = parseUri(name);\n\t\n\t  // Store the user and password as a separate auth object\n\t  if (uri.user || uri.password) {\n\t    uri.auth = {username: uri.user, password: uri.password};\n\t  }\n\t\n\t  // Split the path part of the URI into parts using '/' as the delimiter\n\t  // after removing any leading '/' and any trailing '/'\n\t  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\t\n\t  // Store the first part as the database name and remove it from the parts\n\t  // array\n\t  uri.db = parts.pop();\n\t  // Prevent double encoding of URI component\n\t  if (uri.db.indexOf('%') === -1) {\n\t    uri.db = encodeURIComponent(uri.db);\n\t  }\n\t\n\t  // Restore the path by joining all the remaining parts (all the parts\n\t  // except for the database name) with '/'s\n\t  uri.path = parts.join('/');\n\t\n\t  return uri;\n\t}\n\t\n\t// Generate a URL with the host data given by opts and the given path\n\tfunction genDBUrl(opts, path) {\n\t  return genUrl(opts, opts.db + '/' + path);\n\t}\n\t\n\t// Generate a URL with the host data given by opts and the given path\n\tfunction genUrl(opts, path) {\n\t  // If the host already has a path, then we need to have a path delimiter\n\t  // Otherwise, the path delimiter is the empty string\n\t  var pathDel = !opts.path ? '' : '/';\n\t\n\t  // If the host already has a path, then we need to have a path delimiter\n\t  // Otherwise, the path delimiter is the empty string\n\t  return opts.protocol + '://' + opts.host +\n\t         (opts.port ? (':' + opts.port) : '') +\n\t         '/' + opts.path + pathDel + path;\n\t}\n\t\n\tfunction paramsToStr(params) {\n\t  return '?' + Object.keys(params).map(function (k) {\n\t    return k + '=' + encodeURIComponent(params[k]);\n\t  }).join('&');\n\t}\n\t\n\t// Implements the PouchDB API for dealing with CouchDB instances over HTTP\n\tfunction HttpPouch(opts, callback) {\n\t\n\t  // The functions that will be publicly available for HttpPouch\n\t  var api = this;\n\t\n\t  var host = getHost(opts.name, opts);\n\t  var dbUrl = genDBUrl(host, '');\n\t\n\t  opts = clone(opts);\n\t  var ajaxOpts = opts.ajax || {};\n\t\n\t  if (opts.auth || host.auth) {\n\t    var nAuth = opts.auth || host.auth;\n\t    var str = nAuth.username + ':' + nAuth.password;\n\t    var token = thisBtoa(unescape(encodeURIComponent(str)));\n\t    ajaxOpts.headers = ajaxOpts.headers || {};\n\t    ajaxOpts.headers.Authorization = 'Basic ' + token;\n\t  }\n\t\n\t  // Not strictly necessary, but we do this because numerous tests\n\t  // rely on swapping ajax in and out.\n\t  api._ajax = ajax$1;\n\t\n\t  function ajax(userOpts, options, callback) {\n\t    var reqAjax = (userOpts || {}).ajax || {};\n\t    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);\n\t    var defaultHeaders = clone(ajaxOpts.headers || {});\n\t    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers,\n\t      options.headers || {});\n\t    /* istanbul ignore if */\n\t    if (api.constructor.listeners('debug').length) {\n\t      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);\n\t    }\n\t    return api._ajax(reqOpts, callback);\n\t  }\n\t\n\t  function ajaxPromise(userOpts, opts) {\n\t    return new PouchPromise(function (resolve, reject) {\n\t      ajax(userOpts, opts, function (err, res) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  function adapterFun$$1(name, fun) {\n\t    return adapterFun(name, getArguments(function (args) {\n\t      setup().then(function () {\n\t        return fun.apply(this, args);\n\t      }).catch(function (e) {\n\t        var callback = args.pop();\n\t        callback(e);\n\t      });\n\t    }));\n\t  }\n\t\n\t  var setupPromise;\n\t\n\t  function setup() {\n\t    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n\t    if (opts.skipSetup || opts.skip_setup) {\n\t      return PouchPromise.resolve();\n\t    }\n\t\n\t    // If there is a setup in process or previous successful setup\n\t    // done then we will use that\n\t    // If previous setups have been rejected we will try again\n\t    if (setupPromise) {\n\t      return setupPromise;\n\t    }\n\t\n\t    var checkExists = {method: 'GET', url: dbUrl};\n\t    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n\t      if (err && err.status && err.status === 404) {\n\t        // Doesnt exist, create it\n\t        explainError(404, 'PouchDB is just detecting if the remote exists.');\n\t        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n\t      } else {\n\t        return PouchPromise.reject(err);\n\t      }\n\t    }).catch(function (err) {\n\t      // If we try to create a database that already exists, skipped in\n\t      // istanbul since its catching a race condition.\n\t      /* istanbul ignore if */\n\t      if (err && err.status && err.status === 412) {\n\t        return true;\n\t      }\n\t      return PouchPromise.reject(err);\n\t    });\n\t\n\t    setupPromise.catch(function () {\n\t      setupPromise = null;\n\t    });\n\t\n\t    return setupPromise;\n\t  }\n\t\n\t  nextTick(function () {\n\t    callback(null, api);\n\t  });\n\t\n\t  api._remote = true;\n\t  /* istanbul ignore next */\n\t  api.type = function () {\n\t    return 'http';\n\t  };\n\t\n\t  api.id = adapterFun$$1('id', function (callback) {\n\t    ajax({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n\t      var uuid$$1 = (result && result.uuid) ?\n\t        (result.uuid + host.db) : genDBUrl(host, '');\n\t      callback(null, uuid$$1);\n\t    });\n\t  });\n\t\n\t  api.request = adapterFun$$1('request', function (options, callback) {\n\t    options.url = genDBUrl(host, options.url);\n\t    ajax({}, options, callback);\n\t  });\n\t\n\t  // Sends a POST request to the host calling the couchdb _compact function\n\t  //    version: The version of CouchDB it is running\n\t  api.compact = adapterFun$$1('compact', function (opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t    ajax(opts, {\n\t      url: genDBUrl(host, '_compact'),\n\t      method: 'POST'\n\t    }, function () {\n\t      function ping() {\n\t        api.info(function (err, res) {\n\t          // CouchDB may send a \"compact_running:true\" if it's\n\t          // already compacting. PouchDB Server doesn't.\n\t          /* istanbul ignore else */\n\t          if (res && !res.compact_running) {\n\t            callback(null, {ok: true});\n\t          } else {\n\t            setTimeout(ping, opts.interval || 200);\n\t          }\n\t        });\n\t      }\n\t      // Ping the http if it's finished compaction\n\t      ping();\n\t    });\n\t  });\n\t\n\t  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n\t    var self = this;\n\t\n\t    function doBulkGet(cb) {\n\t      var params = {};\n\t      if (opts.revs) {\n\t        params.revs = true;\n\t      }\n\t      if (opts.attachments) {\n\t        /* istanbul ignore next */\n\t        params.attachments = true;\n\t      }\n\t      if (opts.latest) {\n\t        params.latest = true;\n\t      }\n\t      ajax(opts, {\n\t        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n\t        method: 'POST',\n\t        body: { docs: opts.docs}\n\t      }, function (err, result) {\n\t        if (!err && opts.attachments && opts.binary) {\n\t          result.results.forEach(function (res) {\n\t            res.docs.forEach(readAttachmentsAsBlobOrBuffer);\n\t          });\n\t        }\n\t        cb(err, result);\n\t      });\n\t    }\n\t\n\t    /* istanbul ignore next */\n\t    function doBulkGetShim() {\n\t      // avoid \"url too long error\" by splitting up into multiple requests\n\t      var batchSize = MAX_SIMULTANEOUS_REVS;\n\t      var numBatches = Math.ceil(opts.docs.length / batchSize);\n\t      var numDone = 0;\n\t      var results = new Array(numBatches);\n\t\n\t      function onResult(batchNum) {\n\t        return function (err, res) {\n\t          // err is impossible because shim returns a list of errs in that case\n\t          results[batchNum] = res.results;\n\t          if (++numDone === numBatches) {\n\t            callback(null, {results: flatten(results)});\n\t          }\n\t        };\n\t      }\n\t\n\t      for (var i = 0; i < numBatches; i++) {\n\t        var subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);\n\t        subOpts.ajax = ajaxOpts;\n\t        subOpts.docs = opts.docs.slice(i * batchSize,\n\t          Math.min(opts.docs.length, (i + 1) * batchSize));\n\t        bulkGet(self, subOpts, onResult(i));\n\t      }\n\t    }\n\t\n\t    // mark the whole database as either supporting or not supporting _bulk_get\n\t    var dbUrl = genUrl(host, '');\n\t    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\t\n\t    /* istanbul ignore next */\n\t    if (typeof supportsBulkGet !== 'boolean') {\n\t      // check if this database supports _bulk_get\n\t      doBulkGet(function (err, res) {\n\t        if (err) {\n\t          supportsBulkGetMap[dbUrl] = false;\n\t          explainError(\n\t            err.status,\n\t            'PouchDB is just detecting if the remote ' +\n\t            'supports the _bulk_get API.'\n\t          );\n\t          doBulkGetShim();\n\t        } else {\n\t          supportsBulkGetMap[dbUrl] = true;\n\t          callback(null, res);\n\t        }\n\t      });\n\t    } else if (supportsBulkGet) {\n\t      doBulkGet(callback);\n\t    } else {\n\t      doBulkGetShim();\n\t    }\n\t  });\n\t\n\t  // Calls GET on the host, which gets back a JSON string containing\n\t  //    couchdb: A welcome string\n\t  //    version: The version of CouchDB it is running\n\t  api._info = function (callback) {\n\t    setup().then(function () {\n\t      ajax({}, {\n\t        method: 'GET',\n\t        url: genDBUrl(host, '')\n\t      }, function (err, res) {\n\t        /* istanbul ignore next */\n\t        if (err) {\n\t        return callback(err);\n\t        }\n\t        res.host = genDBUrl(host, '');\n\t        callback(null, res);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t  // Get the document with the given id from the database given by host.\n\t  // The id could be solely the _id in the database, or it may be a\n\t  // _design/ID or _local/ID path\n\t  api.get = adapterFun$$1('get', function (id, opts, callback) {\n\t    // If no options were given, set the callback to the second parameter\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t\n\t    // List of parameters to add to the GET request\n\t    var params = {};\n\t\n\t    if (opts.revs) {\n\t      params.revs = true;\n\t    }\n\t\n\t    if (opts.revs_info) {\n\t      params.revs_info = true;\n\t    }\n\t\n\t    if (opts.latest) {\n\t      params.latest = true;\n\t    }\n\t\n\t    if (opts.open_revs) {\n\t      if (opts.open_revs !== \"all\") {\n\t        opts.open_revs = JSON.stringify(opts.open_revs);\n\t      }\n\t      params.open_revs = opts.open_revs;\n\t    }\n\t\n\t    if (opts.rev) {\n\t      params.rev = opts.rev;\n\t    }\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = opts.conflicts;\n\t    }\n\t\n\t    /* istanbul ignore if */\n\t    if (opts.update_seq) {\n\t      params.update_seq = opts.update_seq;\n\t    }\n\t\n\t    id = encodeDocId(id);\n\t\n\t    // Set the options for the ajax call\n\t    var options = {\n\t      method: 'GET',\n\t      url: genDBUrl(host, id + paramsToStr(params))\n\t    };\n\t\n\t    function fetchAttachments(doc) {\n\t      var atts = doc._attachments;\n\t      var filenames = atts && Object.keys(atts);\n\t      if (!atts || !filenames.length) {\n\t        return;\n\t      }\n\t      // we fetch these manually in separate XHRs, because\n\t      // Sync Gateway would normally send it back as multipart/mixed,\n\t      // which we cannot parse. Also, this is more efficient than\n\t      // receiving attachments as base64-encoded strings.\n\t      function fetch(filename) {\n\t        var att = atts[filename];\n\t        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n\t          '?rev=' + doc._rev;\n\t        return ajaxPromise(opts, {\n\t          method: 'GET',\n\t          url: genDBUrl(host, path),\n\t          binary: true\n\t        }).then(function (blob) {\n\t          if (opts.binary) {\n\t            return blob;\n\t          }\n\t          return new PouchPromise(function (resolve) {\n\t            blobToBase64(blob, resolve);\n\t          });\n\t        }).then(function (data) {\n\t          delete att.stub;\n\t          delete att.length;\n\t          att.data = data;\n\t        });\n\t      }\n\t\n\t      var promiseFactories = filenames.map(function (filename) {\n\t        return function () {\n\t          return fetch(filename);\n\t        };\n\t      });\n\t\n\t      // This limits the number of parallel xhr requests to 5 any time\n\t      // to avoid issues with maximum browser request limits\n\t      return pool(promiseFactories, 5);\n\t    }\n\t\n\t    function fetchAllAttachments(docOrDocs) {\n\t      if (Array.isArray(docOrDocs)) {\n\t        return PouchPromise.all(docOrDocs.map(function (doc) {\n\t          if (doc.ok) {\n\t            return fetchAttachments(doc.ok);\n\t          }\n\t        }));\n\t      }\n\t      return fetchAttachments(docOrDocs);\n\t    }\n\t\n\t    ajaxPromise(opts, options).then(function (res) {\n\t      return PouchPromise.resolve().then(function () {\n\t        if (opts.attachments) {\n\t          return fetchAllAttachments(res);\n\t        }\n\t      }).then(function () {\n\t        callback(null, res);\n\t      });\n\t    }).catch(function (e) {\n\t      e.docId = id;\n\t      callback(e);\n\t    });\n\t  });\n\t\n\t  // Delete the document given by doc from the database given by host.\n\t  api.remove = adapterFun$$1('remove',\n\t      function (docOrId, optsOrRev, opts, callback) {\n\t    var doc;\n\t    if (typeof optsOrRev === 'string') {\n\t      // id, rev, opts, callback style\n\t      doc = {\n\t        _id: docOrId,\n\t        _rev: optsOrRev\n\t      };\n\t      if (typeof opts === 'function') {\n\t        callback = opts;\n\t        opts = {};\n\t      }\n\t    } else {\n\t      // doc, opts, callback style\n\t      doc = docOrId;\n\t      if (typeof optsOrRev === 'function') {\n\t        callback = optsOrRev;\n\t        opts = {};\n\t      } else {\n\t        callback = opts;\n\t        opts = optsOrRev;\n\t      }\n\t    }\n\t\n\t    var rev$$1 = (doc._rev || opts.rev);\n\t\n\t    // Delete the document\n\t    ajax(opts, {\n\t      method: 'DELETE',\n\t      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1\n\t    }, callback);\n\t  });\n\t\n\t  function encodeAttachmentId(attachmentId) {\n\t    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n\t  }\n\t\n\t  // Get the attachment\n\t  api.getAttachment =\n\t    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n\t                                                callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n\t    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n\t      encodeAttachmentId(attachmentId) + params;\n\t    ajax(opts, {\n\t      method: 'GET',\n\t      url: url,\n\t      binary: true\n\t    }, callback);\n\t  });\n\t\n\t  // Remove the attachment given by the id and rev\n\t  api.removeAttachment =\n\t    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev$$1,\n\t                                                   callback) {\n\t\n\t    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n\t      encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;\n\t\n\t    ajax({}, {\n\t      method: 'DELETE',\n\t      url: url\n\t    }, callback);\n\t  });\n\t\n\t  // Add the attachment given by blob and its contentType property\n\t  // to the document with the given id, the revision given by rev, and\n\t  // add it to the database given by host.\n\t  api.putAttachment =\n\t    adapterFun$$1('putAttachment', function (docId, attachmentId, rev$$1, blob,\n\t                                                type, callback) {\n\t    if (typeof type === 'function') {\n\t      callback = type;\n\t      type = blob;\n\t      blob = rev$$1;\n\t      rev$$1 = null;\n\t    }\n\t    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n\t    var url = genDBUrl(host, id);\n\t    if (rev$$1) {\n\t      url += '?rev=' + rev$$1;\n\t    }\n\t\n\t    if (typeof blob === 'string') {\n\t      // input is assumed to be a base64 string\n\t      var binary;\n\t      try {\n\t        binary = thisAtob(blob);\n\t      } catch (err) {\n\t        return callback(createError(BAD_ARG,\n\t                        'Attachment is not a valid base64 string'));\n\t      }\n\t      blob = binary ? binStringToBluffer(binary, type) : '';\n\t    }\n\t\n\t    var opts = {\n\t      headers: {'Content-Type': type},\n\t      method: 'PUT',\n\t      url: url,\n\t      processData: false,\n\t      body: blob,\n\t      timeout: ajaxOpts.timeout || 60000\n\t    };\n\t    // Add the attachment\n\t    ajax({}, opts, callback);\n\t  });\n\t\n\t  // Update/create multiple documents given by req in the database\n\t  // given by host.\n\t  api._bulkDocs = function (req, opts, callback) {\n\t    // If new_edits=false then it prevents the database from creating\n\t    // new revision numbers for the documents. Instead it just uses\n\t    // the old ones. This is used in database replication.\n\t    req.new_edits = opts.new_edits;\n\t\n\t    setup().then(function () {\n\t      return PouchPromise.all(req.docs.map(preprocessAttachments$2));\n\t    }).then(function () {\n\t      // Update/create the documents\n\t      ajax(opts, {\n\t        method: 'POST',\n\t        url: genDBUrl(host, '_bulk_docs'),\n\t        timeout: opts.timeout,\n\t        body: req\n\t      }, function (err, results) {\n\t        if (err) {\n\t          return callback(err);\n\t        }\n\t        results.forEach(function (result) {\n\t          result.ok = true; // smooths out cloudant not adding this\n\t        });\n\t        callback(null, results);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t\n\t  // Update/create document\n\t  api._put = function (doc, opts, callback) {\n\t    setup().then(function () {\n\t      return preprocessAttachments$2(doc);\n\t    }).then(function () {\n\t      // Update/create the document\n\t      ajax(opts, {\n\t        method: 'PUT',\n\t        url: genDBUrl(host, encodeDocId(doc._id)),\n\t        body: doc\n\t      }, function (err, result) {\n\t        if (err) {\n\t          err.docId = doc && doc._id;\n\t          return callback(err);\n\t        }\n\t        callback(null, result);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t\n\t  // Get a listing of the documents in the database given\n\t  // by host and ordered by increasing id.\n\t  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t\n\t    // List of parameters to add to the GET request\n\t    var params = {};\n\t    var body;\n\t    var method = 'GET';\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = true;\n\t    }\n\t\n\t    /* istanbul ignore if */\n\t    if (opts.update_seq) {\n\t      params.update_seq = true;\n\t    }\n\t\n\t    if (opts.descending) {\n\t      params.descending = true;\n\t    }\n\t\n\t    if (opts.include_docs) {\n\t      params.include_docs = true;\n\t    }\n\t\n\t    // added in CouchDB 1.6.0\n\t    if (opts.attachments) {\n\t      params.attachments = true;\n\t    }\n\t\n\t    if (opts.key) {\n\t      params.key = JSON.stringify(opts.key);\n\t    }\n\t\n\t    if (opts.start_key) {\n\t      opts.startkey = opts.start_key;\n\t    }\n\t\n\t    if (opts.startkey) {\n\t      params.startkey = JSON.stringify(opts.startkey);\n\t    }\n\t\n\t    if (opts.end_key) {\n\t      opts.endkey = opts.end_key;\n\t    }\n\t\n\t    if (opts.endkey) {\n\t      params.endkey = JSON.stringify(opts.endkey);\n\t    }\n\t\n\t    if (typeof opts.inclusive_end !== 'undefined') {\n\t      params.inclusive_end = !!opts.inclusive_end;\n\t    }\n\t\n\t    if (typeof opts.limit !== 'undefined') {\n\t      params.limit = opts.limit;\n\t    }\n\t\n\t    if (typeof opts.skip !== 'undefined') {\n\t      params.skip = opts.skip;\n\t    }\n\t\n\t    var paramStr = paramsToStr(params);\n\t\n\t    if (typeof opts.keys !== 'undefined') {\n\t      method = 'POST';\n\t      body = {keys: opts.keys};\n\t    }\n\t\n\t    // Get the document listing\n\t    ajaxPromise(opts, {\n\t      method: method,\n\t      url: genDBUrl(host, '_all_docs' + paramStr),\n\t      body: body\n\t    }).then(function (res) {\n\t      if (opts.include_docs && opts.attachments && opts.binary) {\n\t        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n\t      }\n\t      callback(null, res);\n\t    }).catch(callback);\n\t  });\n\t\n\t  // Get a list of changes made to documents in the database given by host.\n\t  // TODO According to the README, there should be two other methods here,\n\t  // api.changes.addListener and api.changes.removeListener.\n\t  api._changes = function (opts) {\n\t\n\t    // We internally page the results of a changes request, this means\n\t    // if there is a large set of changes to be returned we can start\n\t    // processing them quicker instead of waiting on the entire\n\t    // set of changes to return and attempting to process them at once\n\t    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\t\n\t    opts = clone(opts);\n\t\n\t    if (opts.continuous && !('heartbeat' in opts)) {\n\t      opts.heartbeat = DEFAULT_HEARTBEAT;\n\t    }\n\t\n\t    var requestTimeout = ('timeout' in opts) ? opts.timeout :\n\t      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n\t      30 * 1000;\n\t\n\t    // ensure CHANGES_TIMEOUT_BUFFER applies\n\t    if ('timeout' in opts && opts.timeout &&\n\t      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n\t        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n\t    }\n\t\n\t    if ('heartbeat' in opts && opts.heartbeat &&\n\t       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n\t        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n\t    }\n\t\n\t    var params = {};\n\t    if ('timeout' in opts && opts.timeout) {\n\t      params.timeout = opts.timeout;\n\t    }\n\t\n\t    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t    //\n\t    var leftToFetch = limit;\n\t\n\t    if (opts.style) {\n\t      params.style = opts.style;\n\t    }\n\t\n\t    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n\t      params.include_docs = true;\n\t    }\n\t\n\t    if (opts.attachments) {\n\t      params.attachments = true;\n\t    }\n\t\n\t    if (opts.continuous) {\n\t      params.feed = 'longpoll';\n\t    }\n\t\n\t    if (opts.seq_interval) {\n\t      params.seq_interval = opts.seq_interval;\n\t    }\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = true;\n\t    }\n\t\n\t    if (opts.descending) {\n\t      params.descending = true;\n\t    }\n\t    \n\t    /* istanbul ignore if */\n\t    if (opts.update_seq) {\n\t      params.update_seq = true;\n\t    }\n\t\n\t    if ('heartbeat' in opts) {\n\t      // If the heartbeat value is false, it disables the default heartbeat\n\t      if (opts.heartbeat) {\n\t        params.heartbeat = opts.heartbeat;\n\t      }\n\t    }\n\t\n\t    if (opts.filter && typeof opts.filter === 'string') {\n\t      params.filter = opts.filter;\n\t    }\n\t\n\t    if (opts.view && typeof opts.view === 'string') {\n\t      params.filter = '_view';\n\t      params.view = opts.view;\n\t    }\n\t\n\t    // If opts.query_params exists, pass it through to the changes request.\n\t    // These parameters may be used by the filter on the source database.\n\t    if (opts.query_params && typeof opts.query_params === 'object') {\n\t      for (var param_name in opts.query_params) {\n\t        /* istanbul ignore else */\n\t        if (opts.query_params.hasOwnProperty(param_name)) {\n\t          params[param_name] = opts.query_params[param_name];\n\t        }\n\t      }\n\t    }\n\t\n\t    var method = 'GET';\n\t    var body;\n\t\n\t    if (opts.doc_ids) {\n\t      // set this automagically for the user; it's annoying that couchdb\n\t      // requires both a \"filter\" and a \"doc_ids\" param.\n\t      params.filter = '_doc_ids';\n\t      method = 'POST';\n\t      body = {doc_ids: opts.doc_ids };\n\t    }\n\t    /* istanbul ignore next */\n\t    else if (opts.selector) {\n\t      // set this automagically for the user, similar to above\n\t      params.filter = '_selector';\n\t      method = 'POST';\n\t      body = {selector: opts.selector };\n\t    }\n\t\n\t    var xhr;\n\t    var lastFetchedSeq;\n\t\n\t    // Get all the changes starting wtih the one immediately after the\n\t    // sequence number given by since.\n\t    var fetch = function (since, callback) {\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t      params.since = since;\n\t      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n\t      /* istanbul ignore next */\n\t      if (typeof params.since === \"object\") {\n\t        params.since = JSON.stringify(params.since);\n\t      }\n\t\n\t      if (opts.descending) {\n\t        if (limit) {\n\t          params.limit = leftToFetch;\n\t        }\n\t      } else {\n\t        params.limit = (!limit || leftToFetch > batchSize) ?\n\t          batchSize : leftToFetch;\n\t      }\n\t\n\t      // Set the options for the ajax call\n\t      var xhrOpts = {\n\t        method: method,\n\t        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n\t        timeout: requestTimeout,\n\t        body: body\n\t      };\n\t      lastFetchedSeq = since;\n\t\n\t      /* istanbul ignore if */\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t\n\t      // Get the changes\n\t      setup().then(function () {\n\t        xhr = ajax(opts, xhrOpts, callback);\n\t      }).catch(callback);\n\t    };\n\t\n\t    // If opts.since exists, get all the changes from the sequence\n\t    // number given by opts.since. Otherwise, get all the changes\n\t    // from the sequence number 0.\n\t    var results = {results: []};\n\t\n\t    var fetched = function (err, res) {\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t      var raw_results_length = 0;\n\t      // If the result of the ajax call (res) contains changes (res.results)\n\t      if (res && res.results) {\n\t        raw_results_length = res.results.length;\n\t        results.last_seq = res.last_seq;\n\t        var pending = null;\n\t        var lastSeq = null;\n\t        // Attach 'pending' property if server supports it (CouchDB 2.0+)\n\t        /* istanbul ignore if */\n\t        if (typeof res.pending === 'number') {\n\t          pending = res.pending;\n\t        }\n\t        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {\n\t          lastSeq = results.last_seq;\n\t        }\n\t        // For each change\n\t        var req = {};\n\t        req.query = opts.query_params;\n\t        res.results = res.results.filter(function (c) {\n\t          leftToFetch--;\n\t          var ret = filterChange(opts)(c);\n\t          if (ret) {\n\t            if (opts.include_docs && opts.attachments && opts.binary) {\n\t              readAttachmentsAsBlobOrBuffer(c);\n\t            }\n\t            if (returnDocs) {\n\t              results.results.push(c);\n\t            }\n\t            opts.onChange(c, pending, lastSeq);\n\t          }\n\t          return ret;\n\t        });\n\t      } else if (err) {\n\t        // In case of an error, stop listening for changes and call\n\t        // opts.complete\n\t        opts.aborted = true;\n\t        opts.complete(err);\n\t        return;\n\t      }\n\t\n\t      // The changes feed may have timed out with no results\n\t      // if so reuse last update sequence\n\t      if (res && res.last_seq) {\n\t        lastFetchedSeq = res.last_seq;\n\t      }\n\t\n\t      var finished = (limit && leftToFetch <= 0) ||\n\t        (res && raw_results_length < batchSize) ||\n\t        (opts.descending);\n\t\n\t      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n\t        // Queue a call to fetch again with the newest sequence number\n\t        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n\t      } else {\n\t        // We're done, call the callback\n\t        opts.complete(null, results);\n\t      }\n\t    };\n\t\n\t    fetch(opts.since || 0, fetched);\n\t\n\t    // Return a method to cancel this method from processing any more\n\t    return {\n\t      cancel: function () {\n\t        opts.aborted = true;\n\t        if (xhr) {\n\t          xhr.abort();\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  // Given a set of document/revision IDs (given by req), tets the subset of\n\t  // those that do NOT correspond to revisions stored in the database.\n\t  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n\t  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n\t    // If no options were given, set the callback to be the second parameter\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t\n\t    // Get the missing document/revision IDs\n\t    ajax(opts, {\n\t      method: 'POST',\n\t      url: genDBUrl(host, '_revs_diff'),\n\t      body: req\n\t    }, callback);\n\t  });\n\t\n\t  api._close = function (callback) {\n\t    callback();\n\t  };\n\t\n\t  api._destroy = function (options, callback) {\n\t    ajax(options, {\n\t      url: genDBUrl(host, ''),\n\t      method: 'DELETE'\n\t    }, function (err, resp) {\n\t      if (err && err.status && err.status !== 404) {\n\t        return callback(err);\n\t      }\n\t      callback(null, resp);\n\t    });\n\t  };\n\t}\n\t\n\t// HttpPouch is a valid adapter.\n\tHttpPouch.valid = function () {\n\t  return true;\n\t};\n\t\n\tfunction HttpPouch$1 (PouchDB) {\n\t  PouchDB.adapter('http', HttpPouch, false);\n\t  PouchDB.adapter('https', HttpPouch, false);\n\t}\n\t\n\tfunction QueryParseError(message) {\n\t  this.status = 400;\n\t  this.name = 'query_parse_error';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, QueryParseError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(QueryParseError, Error);\n\t\n\tfunction NotFoundError(message) {\n\t  this.status = 404;\n\t  this.name = 'not_found';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, NotFoundError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(NotFoundError, Error);\n\t\n\tfunction BuiltInError(message) {\n\t  this.status = 500;\n\t  this.name = 'invalid_value';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, BuiltInError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(BuiltInError, Error);\n\t\n\tfunction promisedCallback(promise, callback) {\n\t  if (callback) {\n\t    promise.then(function (res) {\n\t      nextTick(function () {\n\t        callback(null, res);\n\t      });\n\t    }, function (reason) {\n\t      nextTick(function () {\n\t        callback(reason);\n\t      });\n\t    });\n\t  }\n\t  return promise;\n\t}\n\t\n\tfunction callbackify(fun) {\n\t  return getArguments(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    if (typeof cb === 'function') {\n\t      promisedCallback(promise, cb);\n\t    }\n\t    return promise;\n\t  });\n\t}\n\t\n\t// Promise finally util similar to Q.finally\n\tfunction fin(promise, finalPromiseFactory) {\n\t  return promise.then(function (res) {\n\t    return finalPromiseFactory().then(function () {\n\t      return res;\n\t    });\n\t  }, function (reason) {\n\t    return finalPromiseFactory().then(function () {\n\t      throw reason;\n\t    });\n\t  });\n\t}\n\t\n\tfunction sequentialize(queue, promiseFactory) {\n\t  return function () {\n\t    var args = arguments;\n\t    var that = this;\n\t    return queue.add(function () {\n\t      return promiseFactory.apply(that, args);\n\t    });\n\t  };\n\t}\n\t\n\t// uniq an array of strings, order not guaranteed\n\t// similar to underscore/lodash _.uniq\n\tfunction uniq(arr) {\n\t  var theSet = new ExportedSet(arr);\n\t  var result = new Array(theSet.size);\n\t  var index = -1;\n\t  theSet.forEach(function (value) {\n\t    result[++index] = value;\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction mapToKeysArray(map) {\n\t  var result = new Array(map.size);\n\t  var index = -1;\n\t  map.forEach(function (value, key) {\n\t    result[++index] = key;\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction createBuiltInError(name) {\n\t  var message = 'builtin ' + name +\n\t    ' function requires map values to be numbers' +\n\t    ' or number arrays';\n\t  return new BuiltInError(message);\n\t}\n\t\n\tfunction sum(values) {\n\t  var result = 0;\n\t  for (var i = 0, len = values.length; i < len; i++) {\n\t    var num = values[i];\n\t    if (typeof num !== 'number') {\n\t      if (Array.isArray(num)) {\n\t        // lists of numbers are also allowed, sum them separately\n\t        result = typeof result === 'number' ? [result] : result;\n\t        for (var j = 0, jLen = num.length; j < jLen; j++) {\n\t          var jNum = num[j];\n\t          if (typeof jNum !== 'number') {\n\t            throw createBuiltInError('_sum');\n\t          } else if (typeof result[j] === 'undefined') {\n\t            result.push(jNum);\n\t          } else {\n\t            result[j] += jNum;\n\t          }\n\t        }\n\t      } else { // not array/number\n\t        throw createBuiltInError('_sum');\n\t      }\n\t    } else if (typeof result === 'number') {\n\t      result += num;\n\t    } else { // add number to array\n\t      result[0] += num;\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tvar log = guardedConsole.bind(null, 'log');\n\tvar isArray = Array.isArray;\n\tvar toJSON = JSON.parse;\n\t\n\tfunction evalFunctionWithEval(func, emit) {\n\t  return scopeEval(\n\t    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n\t    {\n\t      emit: emit,\n\t      sum: sum,\n\t      log: log,\n\t      isArray: isArray,\n\t      toJSON: toJSON\n\t    }\n\t  );\n\t}\n\t\n\t/*\n\t * Simple task queue to sequentialize actions. Assumes\n\t * callbacks will eventually fire (once).\n\t */\n\t\n\t\n\tfunction TaskQueue$2() {\n\t  this.promise = new PouchPromise(function (fulfill) {fulfill(); });\n\t}\n\tTaskQueue$2.prototype.add = function (promiseFactory) {\n\t  this.promise = this.promise.catch(function () {\n\t    // just recover\n\t  }).then(function () {\n\t    return promiseFactory();\n\t  });\n\t  return this.promise;\n\t};\n\tTaskQueue$2.prototype.finish = function () {\n\t  return this.promise;\n\t};\n\t\n\tfunction stringify(input) {\n\t  if (!input) {\n\t    return 'undefined'; // backwards compat for empty reduce\n\t  }\n\t  // for backwards compat with mapreduce, functions/strings are stringified\n\t  // as-is. everything else is JSON-stringified.\n\t  switch (typeof input) {\n\t    case 'function':\n\t      // e.g. a mapreduce map\n\t      return input.toString();\n\t    case 'string':\n\t      // e.g. a mapreduce built-in _reduce function\n\t      return input.toString();\n\t    default:\n\t      // e.g. a JSON object in the case of mango queries\n\t      return JSON.stringify(input);\n\t  }\n\t}\n\t\n\t/* create a string signature for a view so we can cache it and uniq it */\n\tfunction createViewSignature(mapFun, reduceFun) {\n\t  // the \"undefined\" part is for backwards compatibility\n\t  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n\t}\n\t\n\tfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n\t  var viewSignature = createViewSignature(mapFun, reduceFun);\n\t\n\t  var cachedViews;\n\t  if (!temporary) {\n\t    // cache this to ensure we don't try to update the same view twice\n\t    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n\t    if (cachedViews[viewSignature]) {\n\t      return cachedViews[viewSignature];\n\t    }\n\t  }\n\t\n\t  var promiseForView = sourceDB.info().then(function (info) {\n\t\n\t    var depDbName = info.db_name + '-mrview-' +\n\t      (temporary ? 'temp' : stringMd5(viewSignature));\n\t\n\t    // save the view name in the source db so it can be cleaned up if necessary\n\t    // (e.g. when the _design doc is deleted, remove all associated view data)\n\t    function diffFunction(doc) {\n\t      doc.views = doc.views || {};\n\t      var fullViewName = viewName;\n\t      if (fullViewName.indexOf('/') === -1) {\n\t        fullViewName = viewName + '/' + viewName;\n\t      }\n\t      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n\t      /* istanbul ignore if */\n\t      if (depDbs[depDbName]) {\n\t        return; // no update necessary\n\t      }\n\t      depDbs[depDbName] = true;\n\t      return doc;\n\t    }\n\t    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n\t      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n\t        var db = res.db;\n\t        db.auto_compaction = true;\n\t        var view = {\n\t          name: depDbName,\n\t          db: db,\n\t          sourceDB: sourceDB,\n\t          adapter: sourceDB.adapter,\n\t          mapFun: mapFun,\n\t          reduceFun: reduceFun\n\t        };\n\t        return view.db.get('_local/lastSeq').catch(function (err) {\n\t          /* istanbul ignore if */\n\t          if (err.status !== 404) {\n\t            throw err;\n\t          }\n\t        }).then(function (lastSeqDoc) {\n\t          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n\t          if (cachedViews) {\n\t            view.db.once('destroyed', function () {\n\t              delete cachedViews[viewSignature];\n\t            });\n\t          }\n\t          return view;\n\t        });\n\t      });\n\t    });\n\t  });\n\t\n\t  if (cachedViews) {\n\t    cachedViews[viewSignature] = promiseForView;\n\t  }\n\t  return promiseForView;\n\t}\n\t\n\tvar persistentQueues = {};\n\tvar tempViewQueue = new TaskQueue$2();\n\tvar CHANGES_BATCH_SIZE$1 = 50;\n\t\n\tfunction parseViewName(name) {\n\t  // can be either 'ddocname/viewname' or just 'viewname'\n\t  // (where the ddoc name is the same)\n\t  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n\t}\n\t\n\tfunction isGenOne(changes) {\n\t  // only return true if the current change is 1-\n\t  // and there are no other leafs\n\t  return changes.length === 1 && /^1-/.test(changes[0].rev);\n\t}\n\t\n\tfunction emitError(db, e) {\n\t  try {\n\t    db.emit('error', e);\n\t  } catch (err) {\n\t    guardedConsole('error',\n\t      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n\t      'You can debug this error by doing:\\n' +\n\t      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n\t      'Please double-check your map/reduce function.');\n\t    guardedConsole('error', e);\n\t  }\n\t}\n\t\n\t/**\n\t * Returns an \"abstract\" mapreduce object of the form:\n\t *\n\t *   {\n\t *     query: queryFun,\n\t *     viewCleanup: viewCleanupFun\n\t *   }\n\t *\n\t * Arguments are:\n\t *\n\t * localDoc: string\n\t *   This is for the local doc that gets saved in order to track the\n\t *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n\t *   unique, so that indexer plugins don't collide with each other.\n\t * mapper: function (mapFunDef, emit)\n\t *   Returns a map function based on the mapFunDef, which in the case of\n\t *   normal map/reduce is just the de-stringified function, but may be\n\t *   something else, such as an object in the case of pouchdb-find.\n\t * reducer: function (reduceFunDef)\n\t *   Ditto, but for reducing. Modules don't have to support reducing\n\t *   (e.g. pouchdb-find).\n\t * ddocValidator: function (ddoc, viewName)\n\t *   Throws an error if the ddoc or viewName is not valid.\n\t *   This could be a way to communicate to the user that the configuration for the\n\t *   indexer is invalid.\n\t */\n\tfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\t\n\t  function tryMap(db, fun, doc) {\n\t    // emit an event if there was an error thrown by a map function.\n\t    // putting try/catches in a single function also avoids deoptimizations.\n\t    try {\n\t      fun(doc);\n\t    } catch (e) {\n\t      emitError(db, e);\n\t    }\n\t  }\n\t\n\t  function tryReduce(db, fun, keys, values, rereduce) {\n\t    // same as above, but returning the result or an error. there are two separate\n\t    // functions to avoid extra memory allocations since the tryCode() case is used\n\t    // for custom map functions (common) vs this function, which is only used for\n\t    // custom reduce functions (rare)\n\t    try {\n\t      return {output : fun(keys, values, rereduce)};\n\t    } catch (e) {\n\t      emitError(db, e);\n\t      return {error: e};\n\t    }\n\t  }\n\t\n\t  function sortByKeyThenValue(x, y) {\n\t    var keyCompare = collate(x.key, y.key);\n\t    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n\t  }\n\t\n\t  function sliceResults(results, limit, skip) {\n\t    skip = skip || 0;\n\t    if (typeof limit === 'number') {\n\t      return results.slice(skip, limit + skip);\n\t    } else if (skip > 0) {\n\t      return results.slice(skip);\n\t    }\n\t    return results;\n\t  }\n\t\n\t  function rowToDocId(row) {\n\t    var val = row.value;\n\t    // Users can explicitly specify a joined doc _id, or it\n\t    // defaults to the doc _id that emitted the key/value.\n\t    var docId = (val && typeof val === 'object' && val._id) || row.id;\n\t    return docId;\n\t  }\n\t\n\t  function readAttachmentsAsBlobOrBuffer(res) {\n\t    res.rows.forEach(function (row) {\n\t      var atts = row.doc && row.doc._attachments;\n\t      if (!atts) {\n\t        return;\n\t      }\n\t      Object.keys(atts).forEach(function (filename) {\n\t        var att = atts[filename];\n\t        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n\t      });\n\t    });\n\t  }\n\t\n\t  function postprocessAttachments(opts) {\n\t    return function (res) {\n\t      if (opts.include_docs && opts.attachments && opts.binary) {\n\t        readAttachmentsAsBlobOrBuffer(res);\n\t      }\n\t      return res;\n\t    };\n\t  }\n\t\n\t  function addHttpParam(paramName, opts, params, asJson) {\n\t    // add an http param from opts to params, optionally json-encoded\n\t    var val = opts[paramName];\n\t    if (typeof val !== 'undefined') {\n\t      if (asJson) {\n\t        val = encodeURIComponent(JSON.stringify(val));\n\t      }\n\t      params.push(paramName + '=' + val);\n\t    }\n\t  }\n\t\n\t  function coerceInteger(integerCandidate) {\n\t    if (typeof integerCandidate !== 'undefined') {\n\t      var asNumber = Number(integerCandidate);\n\t      // prevents e.g. '1foo' or '1.1' being coerced to 1\n\t      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n\t        return asNumber;\n\t      } else {\n\t        return integerCandidate;\n\t      }\n\t    }\n\t  }\n\t\n\t  function coerceOptions(opts) {\n\t    opts.group_level = coerceInteger(opts.group_level);\n\t    opts.limit = coerceInteger(opts.limit);\n\t    opts.skip = coerceInteger(opts.skip);\n\t    return opts;\n\t  }\n\t\n\t  function checkPositiveInteger(number) {\n\t    if (number) {\n\t      if (typeof number !== 'number') {\n\t        return  new QueryParseError('Invalid value for integer: \"' +\n\t          number + '\"');\n\t      }\n\t      if (number < 0) {\n\t        return new QueryParseError('Invalid value for positive integer: ' +\n\t          '\"' + number + '\"');\n\t      }\n\t    }\n\t  }\n\t\n\t  function checkQueryParseError(options, fun) {\n\t    var startkeyName = options.descending ? 'endkey' : 'startkey';\n\t    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\t\n\t    if (typeof options[startkeyName] !== 'undefined' &&\n\t      typeof options[endkeyName] !== 'undefined' &&\n\t      collate(options[startkeyName], options[endkeyName]) > 0) {\n\t      throw new QueryParseError('No rows can match your key range, ' +\n\t        'reverse your start_key and end_key or set {descending : true}');\n\t    } else if (fun.reduce && options.reduce !== false) {\n\t      if (options.include_docs) {\n\t        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n\t      } else if (options.keys && options.keys.length > 1 &&\n\t        !options.group && !options.group_level) {\n\t        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n\t          '{group: true}');\n\t      }\n\t    }\n\t    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n\t      var error = checkPositiveInteger(options[optionName]);\n\t      if (error) {\n\t        throw error;\n\t      }\n\t    });\n\t  }\n\t\n\t  function httpQuery(db, fun, opts) {\n\t    // List of parameters to add to the PUT request\n\t    var params = [];\n\t    var body;\n\t    var method = 'GET';\n\t\n\t    // If opts.reduce exists and is defined, then add it to the list\n\t    // of parameters.\n\t    // If reduce=false then the results are that of only the map function\n\t    // not the final result of map and reduce.\n\t    addHttpParam('reduce', opts, params);\n\t    addHttpParam('include_docs', opts, params);\n\t    addHttpParam('attachments', opts, params);\n\t    addHttpParam('limit', opts, params);\n\t    addHttpParam('descending', opts, params);\n\t    addHttpParam('group', opts, params);\n\t    addHttpParam('group_level', opts, params);\n\t    addHttpParam('skip', opts, params);\n\t    addHttpParam('stale', opts, params);\n\t    addHttpParam('conflicts', opts, params);\n\t    addHttpParam('startkey', opts, params, true);\n\t    addHttpParam('start_key', opts, params, true);\n\t    addHttpParam('endkey', opts, params, true);\n\t    addHttpParam('end_key', opts, params, true);\n\t    addHttpParam('inclusive_end', opts, params);\n\t    addHttpParam('key', opts, params, true);\n\t    addHttpParam('update_seq', opts, params);\n\t\n\t    // Format the list of parameters into a valid URI query string\n\t    params = params.join('&');\n\t    params = params === '' ? '' : '?' + params;\n\t\n\t    // If keys are supplied, issue a POST to circumvent GET query string limits\n\t    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n\t    if (typeof opts.keys !== 'undefined') {\n\t      var MAX_URL_LENGTH = 2000;\n\t      // according to http://stackoverflow.com/a/417184/680742,\n\t      // the de facto URL length limit is 2000 characters\n\t\n\t      var keysAsString =\n\t        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n\t      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n\t        // If the keys are short enough, do a GET. we do this to work around\n\t        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n\t        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n\t      } else {\n\t        method = 'POST';\n\t        if (typeof fun === 'string') {\n\t          body = {keys: opts.keys};\n\t        } else { // fun is {map : mapfun}, so append to this\n\t          fun.keys = opts.keys;\n\t        }\n\t      }\n\t    }\n\t\n\t    // We are referencing a query defined in the design doc\n\t    if (typeof fun === 'string') {\n\t      var parts = parseViewName(fun);\n\t      return db.request({\n\t        method: method,\n\t        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n\t        body: body\n\t      }).then(\n\t        /* istanbul ignore next */\n\t        function (result) {\n\t          // fail the entire request if the result contains an error\n\t          result.rows.forEach(function (row) {\n\t            if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n\t              throw new Error(row.reason);\n\t            }\n\t          });\n\t\n\t          return result;\n\t      })\n\t      .then(postprocessAttachments(opts));\n\t    }\n\t\n\t    // We are using a temporary view, terrible for performance, good for testing\n\t    body = body || {};\n\t    Object.keys(fun).forEach(function (key) {\n\t      if (Array.isArray(fun[key])) {\n\t        body[key] = fun[key];\n\t      } else {\n\t        body[key] = fun[key].toString();\n\t      }\n\t    });\n\t    return db.request({\n\t      method: 'POST',\n\t      url: '_temp_view' + params,\n\t      body: body\n\t    }).then(postprocessAttachments(opts));\n\t  }\n\t\n\t  // custom adapters can define their own api._query\n\t  // and override the default behavior\n\t  /* istanbul ignore next */\n\t  function customQuery(db, fun, opts) {\n\t    return new PouchPromise(function (resolve, reject) {\n\t      db._query(fun, opts, function (err, res) {\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  // custom adapters can define their own api._viewCleanup\n\t  // and override the default behavior\n\t  /* istanbul ignore next */\n\t  function customViewCleanup(db) {\n\t    return new PouchPromise(function (resolve, reject) {\n\t      db._viewCleanup(function (err, res) {\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  function defaultsTo(value) {\n\t    return function (reason) {\n\t      /* istanbul ignore else */\n\t      if (reason.status === 404) {\n\t        return value;\n\t      } else {\n\t        throw reason;\n\t      }\n\t    };\n\t  }\n\t\n\t  // returns a promise for a list of docs to update, based on the input docId.\n\t  // the order doesn't matter, because post-3.2.0, bulkDocs\n\t  // is an atomic operation in all three adapters.\n\t  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n\t    var metaDocId = '_local/doc_' + docId;\n\t    var defaultMetaDoc = {_id: metaDocId, keys: []};\n\t    var docData = docIdsToChangesAndEmits.get(docId);\n\t    var indexableKeysToKeyValues = docData[0];\n\t    var changes = docData[1];\n\t\n\t    function getMetaDoc() {\n\t      if (isGenOne(changes)) {\n\t        // generation 1, so we can safely assume initial state\n\t        // for performance reasons (avoids unnecessary GETs)\n\t        return PouchPromise.resolve(defaultMetaDoc);\n\t      }\n\t      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n\t    }\n\t\n\t    function getKeyValueDocs(metaDoc) {\n\t      if (!metaDoc.keys.length) {\n\t        // no keys, no need for a lookup\n\t        return PouchPromise.resolve({rows: []});\n\t      }\n\t      return view.db.allDocs({\n\t        keys: metaDoc.keys,\n\t        include_docs: true\n\t      });\n\t    }\n\t\n\t    function processKeyValueDocs(metaDoc, kvDocsRes) {\n\t      var kvDocs = [];\n\t      var oldKeys = new ExportedSet();\n\t\n\t      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n\t        var row = kvDocsRes.rows[i];\n\t        var doc = row.doc;\n\t        if (!doc) { // deleted\n\t          continue;\n\t        }\n\t        kvDocs.push(doc);\n\t        oldKeys.add(doc._id);\n\t        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n\t        if (!doc._deleted) {\n\t          var keyValue = indexableKeysToKeyValues.get(doc._id);\n\t          if ('value' in keyValue) {\n\t            doc.value = keyValue.value;\n\t          }\n\t        }\n\t      }\n\t      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n\t      newKeys.forEach(function (key) {\n\t        if (!oldKeys.has(key)) {\n\t          // new doc\n\t          var kvDoc = {\n\t            _id: key\n\t          };\n\t          var keyValue = indexableKeysToKeyValues.get(key);\n\t          if ('value' in keyValue) {\n\t            kvDoc.value = keyValue.value;\n\t          }\n\t          kvDocs.push(kvDoc);\n\t        }\n\t      });\n\t      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n\t      kvDocs.push(metaDoc);\n\t\n\t      return kvDocs;\n\t    }\n\t\n\t    return getMetaDoc().then(function (metaDoc) {\n\t      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n\t        return processKeyValueDocs(metaDoc, kvDocsRes);\n\t      });\n\t    });\n\t  }\n\t\n\t  // updates all emitted key/value docs and metaDocs in the mrview database\n\t  // for the given batch of documents from the source database\n\t  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n\t    var seqDocId = '_local/lastSeq';\n\t    return view.db.get(seqDocId)\n\t      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n\t      .then(function (lastSeqDoc) {\n\t        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n\t        return PouchPromise.all(docIds.map(function (docId) {\n\t          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n\t        })).then(function (listOfDocsToPersist) {\n\t          var docsToPersist = flatten(listOfDocsToPersist);\n\t          lastSeqDoc.seq = seq;\n\t          docsToPersist.push(lastSeqDoc);\n\t          // write all docs in a single operation, update the seq once\n\t          return view.db.bulkDocs({docs : docsToPersist});\n\t        });\n\t      });\n\t  }\n\t\n\t  function getQueue(view) {\n\t    var viewName = typeof view === 'string' ? view : view.name;\n\t    var queue = persistentQueues[viewName];\n\t    if (!queue) {\n\t      queue = persistentQueues[viewName] = new TaskQueue$2();\n\t    }\n\t    return queue;\n\t  }\n\t\n\t  function updateView(view) {\n\t    return sequentialize(getQueue(view), function () {\n\t      return updateViewInQueue(view);\n\t    })();\n\t  }\n\t\n\t  function updateViewInQueue(view) {\n\t    // bind the emit function once\n\t    var mapResults;\n\t    var doc;\n\t\n\t    function emit(key, value) {\n\t      var output = {id: doc._id, key: normalizeKey(key)};\n\t      // Don't explicitly store the value unless it's defined and non-null.\n\t      // This saves on storage space, because often people don't use it.\n\t      if (typeof value !== 'undefined' && value !== null) {\n\t        output.value = normalizeKey(value);\n\t      }\n\t      mapResults.push(output);\n\t    }\n\t\n\t    var mapFun = mapper(view.mapFun, emit);\n\t\n\t    var currentSeq = view.seq || 0;\n\t\n\t    function processChange(docIdsToChangesAndEmits, seq) {\n\t      return function () {\n\t        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n\t      };\n\t    }\n\t\n\t    var queue = new TaskQueue$2();\n\t\n\t    function processNextBatch() {\n\t      return view.sourceDB.changes({\n\t        conflicts: true,\n\t        include_docs: true,\n\t        style: 'all_docs',\n\t        since: currentSeq,\n\t        limit: CHANGES_BATCH_SIZE$1\n\t      }).then(processBatch);\n\t    }\n\t\n\t    function processBatch(response) {\n\t      var results = response.results;\n\t      if (!results.length) {\n\t        return;\n\t      }\n\t      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n\t      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\t      if (results.length < CHANGES_BATCH_SIZE$1) {\n\t        return;\n\t      }\n\t      return processNextBatch();\n\t    }\n\t\n\t    function createDocIdsToChangesAndEmits(results) {\n\t      var docIdsToChangesAndEmits = new ExportedMap();\n\t      for (var i = 0, len = results.length; i < len; i++) {\n\t        var change = results[i];\n\t        if (change.doc._id[0] !== '_') {\n\t          mapResults = [];\n\t          doc = change.doc;\n\t\n\t          if (!doc._deleted) {\n\t            tryMap(view.sourceDB, mapFun, doc);\n\t          }\n\t          mapResults.sort(sortByKeyThenValue);\n\t\n\t          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n\t          docIdsToChangesAndEmits.set(change.doc._id, [\n\t            indexableKeysToKeyValues,\n\t            change.changes\n\t          ]);\n\t        }\n\t        currentSeq = change.seq;\n\t      }\n\t      return docIdsToChangesAndEmits;\n\t    }\n\t\n\t    function createIndexableKeysToKeyValues(mapResults) {\n\t      var indexableKeysToKeyValues = new ExportedMap();\n\t      var lastKey;\n\t      for (var i = 0, len = mapResults.length; i < len; i++) {\n\t        var emittedKeyValue = mapResults[i];\n\t        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n\t        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n\t          complexKey.push(i); // dup key+id, so make it unique\n\t        }\n\t        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n\t        lastKey = emittedKeyValue.key;\n\t      }\n\t      return indexableKeysToKeyValues;\n\t    }\n\t\n\t    return processNextBatch().then(function () {\n\t      return queue.finish();\n\t    }).then(function () {\n\t      view.seq = currentSeq;\n\t    });\n\t  }\n\t\n\t  function reduceView(view, results, options) {\n\t    if (options.group_level === 0) {\n\t      delete options.group_level;\n\t    }\n\t\n\t    var shouldGroup = options.group || options.group_level;\n\t\n\t    var reduceFun = reducer(view.reduceFun);\n\t\n\t    var groups = [];\n\t    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n\t      options.group_level;\n\t    results.forEach(function (e) {\n\t      var last = groups[groups.length - 1];\n\t      var groupKey = shouldGroup ? e.key : null;\n\t\n\t      // only set group_level for array keys\n\t      if (shouldGroup && Array.isArray(groupKey)) {\n\t        groupKey = groupKey.slice(0, lvl);\n\t      }\n\t\n\t      if (last && collate(last.groupKey, groupKey) === 0) {\n\t        last.keys.push([e.key, e.id]);\n\t        last.values.push(e.value);\n\t        return;\n\t      }\n\t      groups.push({\n\t        keys: [[e.key, e.id]],\n\t        values: [e.value],\n\t        groupKey: groupKey\n\t      });\n\t    });\n\t    results = [];\n\t    for (var i = 0, len = groups.length; i < len; i++) {\n\t      var e = groups[i];\n\t      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n\t      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n\t        // CouchDB returns an error if a built-in errors out\n\t        throw reduceTry.error;\n\t      }\n\t      results.push({\n\t        // CouchDB just sets the value to null if a non-built-in errors out\n\t        value: reduceTry.error ? null : reduceTry.output,\n\t        key: e.groupKey\n\t      });\n\t    }\n\t    // no total_rows/offset when reducing\n\t    return {rows: sliceResults(results, options.limit, options.skip)};\n\t  }\n\t\n\t  function queryView(view, opts) {\n\t    return sequentialize(getQueue(view), function () {\n\t      return queryViewInQueue(view, opts);\n\t    })();\n\t  }\n\t\n\t  function queryViewInQueue(view, opts) {\n\t    var totalRows;\n\t    var shouldReduce = view.reduceFun && opts.reduce !== false;\n\t    var skip = opts.skip || 0;\n\t    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n\t      // equivalent query\n\t      opts.limit = 0;\n\t      delete opts.keys;\n\t    }\n\t\n\t    function fetchFromView(viewOpts) {\n\t      viewOpts.include_docs = true;\n\t      return view.db.allDocs(viewOpts).then(function (res) {\n\t        totalRows = res.total_rows;\n\t        return res.rows.map(function (result) {\n\t\n\t          // implicit migration - in older versions of PouchDB,\n\t          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n\t          // this is tested in a migration test\n\t          /* istanbul ignore next */\n\t          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n\t            result.doc.value !== null) {\n\t            var keys = Object.keys(result.doc.value).sort();\n\t            // this detection method is not perfect, but it's unlikely the user\n\t            // emitted a value which was an object with these 3 exact keys\n\t            var expectedKeys = ['id', 'key', 'value'];\n\t            if (!(keys < expectedKeys || keys > expectedKeys)) {\n\t              return result.doc.value;\n\t            }\n\t          }\n\t\n\t          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n\t          return {\n\t            key: parsedKeyAndDocId[0],\n\t            id: parsedKeyAndDocId[1],\n\t            value: ('value' in result.doc ? result.doc.value : null)\n\t          };\n\t        });\n\t      });\n\t    }\n\t\n\t    function onMapResultsReady(rows) {\n\t      var finalResults;\n\t      if (shouldReduce) {\n\t        finalResults = reduceView(view, rows, opts);\n\t      } else {\n\t        finalResults = {\n\t          total_rows: totalRows,\n\t          offset: skip,\n\t          rows: rows\n\t        };\n\t      }\n\t      /* istanbul ignore if */\n\t      if (opts.update_seq) {\n\t        finalResults.update_seq = view.seq;\n\t      }\n\t      if (opts.include_docs) {\n\t        var docIds = uniq(rows.map(rowToDocId));\n\t\n\t        return view.sourceDB.allDocs({\n\t          keys: docIds,\n\t          include_docs: true,\n\t          conflicts: opts.conflicts,\n\t          attachments: opts.attachments,\n\t          binary: opts.binary\n\t        }).then(function (allDocsRes) {\n\t          var docIdsToDocs = new ExportedMap();\n\t          allDocsRes.rows.forEach(function (row) {\n\t            docIdsToDocs.set(row.id, row.doc);\n\t          });\n\t          rows.forEach(function (row) {\n\t            var docId = rowToDocId(row);\n\t            var doc = docIdsToDocs.get(docId);\n\t            if (doc) {\n\t              row.doc = doc;\n\t            }\n\t          });\n\t          return finalResults;\n\t        });\n\t      } else {\n\t        return finalResults;\n\t      }\n\t    }\n\t\n\t    if (typeof opts.keys !== 'undefined') {\n\t      var keys = opts.keys;\n\t      var fetchPromises = keys.map(function (key) {\n\t        var viewOpts = {\n\t          startkey : toIndexableString([key]),\n\t          endkey   : toIndexableString([key, {}])\n\t        };\n\t        /* istanbul ignore if */\n\t        if (opts.update_seq) {\n\t          viewOpts.update_seq = true;\n\t        }\n\t        return fetchFromView(viewOpts);\n\t      });\n\t      return PouchPromise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n\t    } else { // normal query, no 'keys'\n\t      var viewOpts = {\n\t        descending : opts.descending\n\t      };\n\t      /* istanbul ignore if */\n\t      if (opts.update_seq) {\n\t        viewOpts.update_seq = true;\n\t      }\n\t      var startkey;\n\t      var endkey;\n\t      if ('start_key' in opts) {\n\t        startkey = opts.start_key;\n\t      }\n\t      if ('startkey' in opts) {\n\t        startkey = opts.startkey;\n\t      }\n\t      if ('end_key' in opts) {\n\t        endkey = opts.end_key;\n\t      }\n\t      if ('endkey' in opts) {\n\t        endkey = opts.endkey;\n\t      }\n\t      if (typeof startkey !== 'undefined') {\n\t        viewOpts.startkey = opts.descending ?\n\t          toIndexableString([startkey, {}]) :\n\t          toIndexableString([startkey]);\n\t      }\n\t      if (typeof endkey !== 'undefined') {\n\t        var inclusiveEnd = opts.inclusive_end !== false;\n\t        if (opts.descending) {\n\t          inclusiveEnd = !inclusiveEnd;\n\t        }\n\t\n\t        viewOpts.endkey = toIndexableString(\n\t          inclusiveEnd ? [endkey, {}] : [endkey]);\n\t      }\n\t      if (typeof opts.key !== 'undefined') {\n\t        var keyStart = toIndexableString([opts.key]);\n\t        var keyEnd = toIndexableString([opts.key, {}]);\n\t        if (viewOpts.descending) {\n\t          viewOpts.endkey = keyStart;\n\t          viewOpts.startkey = keyEnd;\n\t        } else {\n\t          viewOpts.startkey = keyStart;\n\t          viewOpts.endkey = keyEnd;\n\t        }\n\t      }\n\t      if (!shouldReduce) {\n\t        if (typeof opts.limit === 'number') {\n\t          viewOpts.limit = opts.limit;\n\t        }\n\t        viewOpts.skip = skip;\n\t      }\n\t      return fetchFromView(viewOpts).then(onMapResultsReady);\n\t    }\n\t  }\n\t\n\t  function httpViewCleanup(db) {\n\t    return db.request({\n\t      method: 'POST',\n\t      url: '_view_cleanup'\n\t    });\n\t  }\n\t\n\t  function localViewCleanup(db) {\n\t    return db.get('_local/' + localDocName).then(function (metaDoc) {\n\t      var docsToViews = new ExportedMap();\n\t      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n\t        var parts = parseViewName(fullViewName);\n\t        var designDocName = '_design/' + parts[0];\n\t        var viewName = parts[1];\n\t        var views = docsToViews.get(designDocName);\n\t        if (!views) {\n\t          views = new ExportedSet();\n\t          docsToViews.set(designDocName, views);\n\t        }\n\t        views.add(viewName);\n\t      });\n\t      var opts = {\n\t        keys : mapToKeysArray(docsToViews),\n\t        include_docs : true\n\t      };\n\t      return db.allDocs(opts).then(function (res) {\n\t        var viewsToStatus = {};\n\t        res.rows.forEach(function (row) {\n\t          var ddocName = row.key.substring(8); // cuts off '_design/'\n\t          docsToViews.get(row.key).forEach(function (viewName) {\n\t            var fullViewName = ddocName + '/' + viewName;\n\t            /* istanbul ignore if */\n\t            if (!metaDoc.views[fullViewName]) {\n\t              // new format, without slashes, to support PouchDB 2.2.0\n\t              // migration test in pouchdb's browser.migration.js verifies this\n\t              fullViewName = viewName;\n\t            }\n\t            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n\t            // design doc deleted, or view function nonexistent\n\t            var statusIsGood = row.doc && row.doc.views &&\n\t              row.doc.views[viewName];\n\t            viewDBNames.forEach(function (viewDBName) {\n\t              viewsToStatus[viewDBName] =\n\t                viewsToStatus[viewDBName] || statusIsGood;\n\t            });\n\t          });\n\t        });\n\t        var dbsToDelete = Object.keys(viewsToStatus).filter(\n\t          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n\t        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n\t          return sequentialize(getQueue(viewDBName), function () {\n\t            return new db.constructor(viewDBName, db.__opts).destroy();\n\t          })();\n\t        });\n\t        return PouchPromise.all(destroyPromises).then(function () {\n\t          return {ok: true};\n\t        });\n\t      });\n\t    }, defaultsTo({ok: true}));\n\t  }\n\t\n\t  function queryPromised(db, fun, opts) {\n\t    /* istanbul ignore next */\n\t    if (typeof db._query === 'function') {\n\t      return customQuery(db, fun, opts);\n\t    }\n\t    if (isRemote(db)) {\n\t      return httpQuery(db, fun, opts);\n\t    }\n\t    \n\t    if (typeof fun !== 'string') {\n\t      // temp_view\n\t      checkQueryParseError(opts, fun);\n\t\n\t      tempViewQueue.add(function () {\n\t        var createViewPromise = createView(\n\t          /* sourceDB */ db,\n\t          /* viewName */ 'temp_view/temp_view',\n\t          /* mapFun */ fun.map,\n\t          /* reduceFun */ fun.reduce,\n\t          /* temporary */ true,\n\t          /* localDocName */ localDocName);\n\t        return createViewPromise.then(function (view) {\n\t          return fin(updateView(view).then(function () {\n\t            return queryView(view, opts);\n\t          }), function () {\n\t            return view.db.destroy();\n\t          });\n\t        });\n\t      });\n\t      return tempViewQueue.finish();\n\t    } else {\n\t      // persistent view\n\t      var fullViewName = fun;\n\t      var parts = parseViewName(fullViewName);\n\t      var designDocName = parts[0];\n\t      var viewName = parts[1];\n\t      return db.get('_design/' + designDocName).then(function (doc) {\n\t        var fun = doc.views && doc.views[viewName];\n\t\n\t        if (!fun) {\n\t          // basic validator; it's assumed that every subclass would want this\n\t          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n\t            viewName);\n\t        }\n\t\n\t        ddocValidator(doc, viewName);\n\t        checkQueryParseError(opts, fun);\n\t\n\t        var createViewPromise = createView(\n\t          /* sourceDB */ db,\n\t          /* viewName */ fullViewName,\n\t          /* mapFun */ fun.map,\n\t          /* reduceFun */ fun.reduce,\n\t          /* temporary */ false,\n\t          /* localDocName */ localDocName);\n\t        return createViewPromise.then(function (view) {\n\t          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n\t            if (opts.stale === 'update_after') {\n\t              nextTick(function () {\n\t                updateView(view);\n\t              });\n\t            }\n\t            return queryView(view, opts);\n\t          } else { // stale not ok\n\t            return updateView(view).then(function () {\n\t              return queryView(view, opts);\n\t            });\n\t          }\n\t        });\n\t      });\n\t    }\n\t  }\n\t\n\t  function abstractQuery(fun, opts, callback) {\n\t    var db = this;\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = opts ? coerceOptions(opts) : {};\n\t\n\t    if (typeof fun === 'function') {\n\t      fun = {map : fun};\n\t    }\n\t\n\t    var promise = PouchPromise.resolve().then(function () {\n\t      return queryPromised(db, fun, opts);\n\t    });\n\t    promisedCallback(promise, callback);\n\t    return promise;\n\t  }\n\t\n\t  var abstractViewCleanup = callbackify(function () {\n\t    var db = this;\n\t    /* istanbul ignore next */\n\t    if (typeof db._viewCleanup === 'function') {\n\t      return customViewCleanup(db);\n\t    }\n\t    if (isRemote(db)) {\n\t      return httpViewCleanup(db);\n\t    }\n\t    return localViewCleanup(db);\n\t  });\n\t\n\t  return {\n\t    query: abstractQuery,\n\t    viewCleanup: abstractViewCleanup\n\t  };\n\t}\n\t\n\tvar builtInReduce = {\n\t  _sum: function (keys, values) {\n\t    return sum(values);\n\t  },\n\t\n\t  _count: function (keys, values) {\n\t    return values.length;\n\t  },\n\t\n\t  _stats: function (keys, values) {\n\t    // no need to implement rereduce=true, because Pouch\n\t    // will never call it\n\t    function sumsqr(values) {\n\t      var _sumsqr = 0;\n\t      for (var i = 0, len = values.length; i < len; i++) {\n\t        var num = values[i];\n\t        _sumsqr += (num * num);\n\t      }\n\t      return _sumsqr;\n\t    }\n\t    return {\n\t      sum     : sum(values),\n\t      min     : Math.min.apply(null, values),\n\t      max     : Math.max.apply(null, values),\n\t      count   : values.length,\n\t      sumsqr : sumsqr(values)\n\t    };\n\t  }\n\t};\n\t\n\tfunction getBuiltIn(reduceFunString) {\n\t  if (/^_sum/.test(reduceFunString)) {\n\t    return builtInReduce._sum;\n\t  } else if (/^_count/.test(reduceFunString)) {\n\t    return builtInReduce._count;\n\t  } else if (/^_stats/.test(reduceFunString)) {\n\t    return builtInReduce._stats;\n\t  } else if (/^_/.test(reduceFunString)) {\n\t    throw new Error(reduceFunString + ' is not a supported reduce function.');\n\t  }\n\t}\n\t\n\tfunction mapper(mapFun, emit) {\n\t  // for temp_views one can use emit(doc, emit), see #38\n\t  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n\t    var origMap = mapFun;\n\t    return function (doc) {\n\t      return origMap(doc, emit);\n\t    };\n\t  } else {\n\t    return evalFunctionWithEval(mapFun.toString(), emit);\n\t  }\n\t}\n\t\n\tfunction reducer(reduceFun) {\n\t  var reduceFunString = reduceFun.toString();\n\t  var builtIn = getBuiltIn(reduceFunString);\n\t  if (builtIn) {\n\t    return builtIn;\n\t  } else {\n\t    return evalFunctionWithEval(reduceFunString);\n\t  }\n\t}\n\t\n\tfunction ddocValidator(ddoc, viewName) {\n\t  var fun = ddoc.views && ddoc.views[viewName];\n\t  if (typeof fun.map !== 'string') {\n\t    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n\t      viewName + ', instead found object of type: ' + typeof fun.map);\n\t  }\n\t}\n\t\n\tvar localDocName = 'mrviews';\n\tvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\t\n\tfunction query(fun, opts, callback) {\n\t  return abstract.query.call(this, fun, opts, callback);\n\t}\n\t\n\tfunction viewCleanup(callback) {\n\t  return abstract.viewCleanup.call(this, callback);\n\t}\n\t\n\tvar mapreduce = {\n\t  query: query,\n\t  viewCleanup: viewCleanup\n\t};\n\t\n\tfunction isGenOne$1(rev$$1) {\n\t  return /^1-/.test(rev$$1);\n\t}\n\t\n\tfunction fileHasChanged(localDoc, remoteDoc, filename) {\n\t  return !localDoc._attachments ||\n\t         !localDoc._attachments[filename] ||\n\t         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n\t}\n\t\n\tfunction getDocAttachments(db, doc) {\n\t  var filenames = Object.keys(doc._attachments);\n\t  return PouchPromise.all(filenames.map(function (filename) {\n\t    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n\t  }));\n\t}\n\t\n\tfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n\t  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n\t  var filenames = Object.keys(doc._attachments);\n\t\n\t  if (!doCheckForLocalAttachments) {\n\t    return getDocAttachments(src, doc);\n\t  }\n\t\n\t  return target.get(doc._id).then(function (localDoc) {\n\t    return PouchPromise.all(filenames.map(function (filename) {\n\t      if (fileHasChanged(localDoc, doc, filename)) {\n\t        return src.getAttachment(doc._id, filename);\n\t      }\n\t\n\t      return target.getAttachment(localDoc._id, filename);\n\t    }));\n\t  }).catch(function (error) {\n\t    /* istanbul ignore if */\n\t    if (error.status !== 404) {\n\t      throw error;\n\t    }\n\t\n\t    return getDocAttachments(src, doc);\n\t  });\n\t}\n\t\n\tfunction createBulkGetOpts(diffs) {\n\t  var requests = [];\n\t  Object.keys(diffs).forEach(function (id) {\n\t    var missingRevs = diffs[id].missing;\n\t    missingRevs.forEach(function (missingRev) {\n\t      requests.push({\n\t        id: id,\n\t        rev: missingRev\n\t      });\n\t    });\n\t  });\n\t\n\t  return {\n\t    docs: requests,\n\t    revs: true,\n\t    latest: true\n\t  };\n\t}\n\t\n\t//\n\t// Fetch all the documents from the src as described in the \"diffs\",\n\t// which is a mapping of docs IDs to revisions. If the state ever\n\t// changes to \"cancelled\", then the returned promise will be rejected.\n\t// Else it will be resolved with a list of fetched documents.\n\t//\n\tfunction getDocs(src, target, diffs, state) {\n\t  diffs = clone(diffs); // we do not need to modify this\n\t\n\t  var resultDocs = [],\n\t      ok = true;\n\t\n\t  function getAllDocs() {\n\t\n\t    var bulkGetOpts = createBulkGetOpts(diffs);\n\t\n\t    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n\t      return;\n\t    }\n\t\n\t    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n\t      /* istanbul ignore if */\n\t      if (state.cancelled) {\n\t        throw new Error('cancelled');\n\t      }\n\t      return PouchPromise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n\t        return PouchPromise.all(bulkGetInfo.docs.map(function (doc) {\n\t          var remoteDoc = doc.ok;\n\t\n\t          if (doc.error) {\n\t            // when AUTO_COMPACTION is set, docs can be returned which look\n\t            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n\t            ok = false;\n\t          }\n\t\n\t          if (!remoteDoc || !remoteDoc._attachments) {\n\t            return remoteDoc;\n\t          }\n\t\n\t          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n\t                   .then(function (attachments) {\n\t                           var filenames = Object.keys(remoteDoc._attachments);\n\t                           attachments\n\t                             .forEach(function (attachment, i) {\n\t                                        var att = remoteDoc._attachments[filenames[i]];\n\t                                        delete att.stub;\n\t                                        delete att.length;\n\t                                        att.data = attachment;\n\t                                      });\n\t\n\t                                      return remoteDoc;\n\t                                    });\n\t        }));\n\t      }))\n\t\n\t      .then(function (results) {\n\t        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n\t      });\n\t    });\n\t  }\n\t\n\t  function hasAttachments(doc) {\n\t    return doc._attachments && Object.keys(doc._attachments).length > 0;\n\t  }\n\t\n\t  function hasConflicts(doc) {\n\t    return doc._conflicts && doc._conflicts.length > 0;\n\t  }\n\t\n\t  function fetchRevisionOneDocs(ids) {\n\t    // Optimization: fetch gen-1 docs and attachments in\n\t    // a single request using _all_docs\n\t    return src.allDocs({\n\t      keys: ids,\n\t      include_docs: true,\n\t      conflicts: true\n\t    }).then(function (res) {\n\t      if (state.cancelled) {\n\t        throw new Error('cancelled');\n\t      }\n\t      res.rows.forEach(function (row) {\n\t        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n\t            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n\t          // if any of these conditions apply, we need to fetch using get()\n\t          return;\n\t        }\n\t\n\t        // strip _conflicts array to appease CSG (#5793)\n\t        /* istanbul ignore if */\n\t        if (row.doc._conflicts) {\n\t          delete row.doc._conflicts;\n\t        }\n\t\n\t        // the doc we got back from allDocs() is sufficient\n\t        resultDocs.push(row.doc);\n\t        delete diffs[row.id];\n\t      });\n\t    });\n\t  }\n\t\n\t  function getRevisionOneDocs() {\n\t    // filter out the generation 1 docs and get them\n\t    // leaving the non-generation one docs to be got otherwise\n\t    var ids = Object.keys(diffs).filter(function (id) {\n\t      var missing = diffs[id].missing;\n\t      return missing.length === 1 && isGenOne$1(missing[0]);\n\t    });\n\t    if (ids.length > 0) {\n\t      return fetchRevisionOneDocs(ids);\n\t    }\n\t  }\n\t\n\t  function returnResult() {\n\t    return { ok:ok, docs:resultDocs };\n\t  }\n\t\n\t  return PouchPromise.resolve()\n\t    .then(getRevisionOneDocs)\n\t    .then(getAllDocs)\n\t    .then(returnResult);\n\t}\n\t\n\tvar CHECKPOINT_VERSION = 1;\n\tvar REPLICATOR = \"pouchdb\";\n\t// This is an arbitrary number to limit the\n\t// amount of replication history we save in the checkpoint.\n\t// If we save too much, the checkpoing docs will become very big,\n\t// if we save fewer, we'll run a greater risk of having to\n\t// read all the changes from 0 when checkpoint PUTs fail\n\t// CouchDB 2.0 has a more involved history pruning,\n\t// but let's go for the simple version for now.\n\tvar CHECKPOINT_HISTORY_SIZE = 5;\n\tvar LOWEST_SEQ = 0;\n\t\n\tfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n\t  return db.get(id).catch(function (err) {\n\t    if (err.status === 404) {\n\t      if (db.adapter === 'http' || db.adapter === 'https') {\n\t        explainError(\n\t          404, 'PouchDB is just checking if a remote checkpoint exists.'\n\t        );\n\t      }\n\t      return {\n\t        session_id: session,\n\t        _id: id,\n\t        history: [],\n\t        replicator: REPLICATOR,\n\t        version: CHECKPOINT_VERSION\n\t      };\n\t    }\n\t    throw err;\n\t  }).then(function (doc) {\n\t    if (returnValue.cancelled) {\n\t      return;\n\t    }\n\t\n\t    // if the checkpoint has not changed, do not update\n\t    if (doc.last_seq === checkpoint) {\n\t      return;\n\t    }\n\t\n\t    // Filter out current entry for this replication\n\t    doc.history = (doc.history || []).filter(function (item) {\n\t      return item.session_id !== session;\n\t    });\n\t\n\t    // Add the latest checkpoint to history\n\t    doc.history.unshift({\n\t      last_seq: checkpoint,\n\t      session_id: session\n\t    });\n\t\n\t    // Just take the last pieces in history, to\n\t    // avoid really big checkpoint docs.\n\t    // see comment on history size above\n\t    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\t\n\t    doc.version = CHECKPOINT_VERSION;\n\t    doc.replicator = REPLICATOR;\n\t\n\t    doc.session_id = session;\n\t    doc.last_seq = checkpoint;\n\t\n\t    return db.put(doc).catch(function (err) {\n\t      if (err.status === 409) {\n\t        // retry; someone is trying to write a checkpoint simultaneously\n\t        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n\t      }\n\t      throw err;\n\t    });\n\t  });\n\t}\n\t\n\tfunction Checkpointer(src, target, id, returnValue, opts) {\n\t  this.src = src;\n\t  this.target = target;\n\t  this.id = id;\n\t  this.returnValue = returnValue;\n\t  this.opts = opts || {};\n\t}\n\t\n\tCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n\t  var self = this;\n\t  return this.updateTarget(checkpoint, session).then(function () {\n\t    return self.updateSource(checkpoint, session);\n\t  });\n\t};\n\t\n\tCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n\t  if (this.opts.writeTargetCheckpoint) {\n\t    return updateCheckpoint(this.target, this.id, checkpoint,\n\t      session, this.returnValue);\n\t  } else {\n\t    return PouchPromise.resolve(true);\n\t  }\n\t};\n\t\n\tCheckpointer.prototype.updateSource = function (checkpoint, session) {\n\t  if (this.opts.writeSourceCheckpoint) {\n\t    var self = this;\n\t    return updateCheckpoint(this.src, this.id, checkpoint,\n\t      session, this.returnValue)\n\t      .catch(function (err) {\n\t        if (isForbiddenError(err)) {\n\t          self.opts.writeSourceCheckpoint = false;\n\t          return true;\n\t        }\n\t        throw err;\n\t      });\n\t  } else {\n\t    return PouchPromise.resolve(true);\n\t  }\n\t};\n\t\n\tvar comparisons = {\n\t  \"undefined\": function (targetDoc, sourceDoc) {\n\t    // This is the previous comparison function\n\t    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n\t      return sourceDoc.last_seq;\n\t    }\n\t    /* istanbul ignore next */\n\t    return 0;\n\t  },\n\t  \"1\": function (targetDoc, sourceDoc) {\n\t    // This is the comparison function ported from CouchDB\n\t    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n\t  }\n\t};\n\t\n\tCheckpointer.prototype.getCheckpoint = function () {\n\t  var self = this;\n\t\n\t  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {\n\t    return self.src.get(self.id).then(function (sourceDoc) {\n\t      return sourceDoc.last_seq || LOWEST_SEQ;\n\t    }).catch(function (err) {\n\t      /* istanbul ignore if */\n\t      if (err.status !== 404) {\n\t        throw err;\n\t      }\n\t      return LOWEST_SEQ;\n\t    });\n\t  }\n\t\n\t  return self.target.get(self.id).then(function (targetDoc) {\n\t    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {\n\t      return targetDoc.last_seq || LOWEST_SEQ;\n\t    }\n\t\n\t    return self.src.get(self.id).then(function (sourceDoc) {\n\t      // Since we can't migrate an old version doc to a new one\n\t      // (no session id), we just go with the lowest seq in this case\n\t      /* istanbul ignore if */\n\t      if (targetDoc.version !== sourceDoc.version) {\n\t        return LOWEST_SEQ;\n\t      }\n\t\n\t      var version;\n\t      if (targetDoc.version) {\n\t        version = targetDoc.version.toString();\n\t      } else {\n\t        version = \"undefined\";\n\t      }\n\t\n\t      if (version in comparisons) {\n\t        return comparisons[version](targetDoc, sourceDoc);\n\t      }\n\t      /* istanbul ignore next */\n\t      return LOWEST_SEQ;\n\t    }, function (err) {\n\t      if (err.status === 404 && targetDoc.last_seq) {\n\t        return self.src.put({\n\t          _id: self.id,\n\t          last_seq: LOWEST_SEQ\n\t        }).then(function () {\n\t          return LOWEST_SEQ;\n\t        }, function (err) {\n\t          if (isForbiddenError(err)) {\n\t            self.opts.writeSourceCheckpoint = false;\n\t            return targetDoc.last_seq;\n\t          }\n\t          /* istanbul ignore next */\n\t          return LOWEST_SEQ;\n\t        });\n\t      }\n\t      throw err;\n\t    });\n\t  }).catch(function (err) {\n\t    if (err.status !== 404) {\n\t      throw err;\n\t    }\n\t    return LOWEST_SEQ;\n\t  });\n\t};\n\t// This checkpoint comparison is ported from CouchDBs source\n\t// they come from here:\n\t// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\t\n\tfunction compareReplicationLogs(srcDoc, tgtDoc) {\n\t  if (srcDoc.session_id === tgtDoc.session_id) {\n\t    return {\n\t      last_seq: srcDoc.last_seq,\n\t      history: srcDoc.history\n\t    };\n\t  }\n\t\n\t  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n\t}\n\t\n\tfunction compareReplicationHistory(sourceHistory, targetHistory) {\n\t  // the erlang loop via function arguments is not so easy to repeat in JS\n\t  // therefore, doing this as recursion\n\t  var S = sourceHistory[0];\n\t  var sourceRest = sourceHistory.slice(1);\n\t  var T = targetHistory[0];\n\t  var targetRest = targetHistory.slice(1);\n\t\n\t  if (!S || targetHistory.length === 0) {\n\t    return {\n\t      last_seq: LOWEST_SEQ,\n\t      history: []\n\t    };\n\t  }\n\t\n\t  var sourceId = S.session_id;\n\t  /* istanbul ignore if */\n\t  if (hasSessionId(sourceId, targetHistory)) {\n\t    return {\n\t      last_seq: S.last_seq,\n\t      history: sourceHistory\n\t    };\n\t  }\n\t\n\t  var targetId = T.session_id;\n\t  if (hasSessionId(targetId, sourceRest)) {\n\t    return {\n\t      last_seq: T.last_seq,\n\t      history: targetRest\n\t    };\n\t  }\n\t\n\t  return compareReplicationHistory(sourceRest, targetRest);\n\t}\n\t\n\tfunction hasSessionId(sessionId, history) {\n\t  var props = history[0];\n\t  var rest = history.slice(1);\n\t\n\t  if (!sessionId || history.length === 0) {\n\t    return false;\n\t  }\n\t\n\t  if (sessionId === props.session_id) {\n\t    return true;\n\t  }\n\t\n\t  return hasSessionId(sessionId, rest);\n\t}\n\t\n\tfunction isForbiddenError(err) {\n\t  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n\t}\n\t\n\tvar STARTING_BACK_OFF = 0;\n\t\n\tfunction backOff(opts, returnValue, error, callback) {\n\t  if (opts.retry === false) {\n\t    returnValue.emit('error', error);\n\t    returnValue.removeAllListeners();\n\t    return;\n\t  }\n\t  if (typeof opts.back_off_function !== 'function') {\n\t    opts.back_off_function = defaultBackOff;\n\t  }\n\t  returnValue.emit('requestError', error);\n\t  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n\t    returnValue.emit('paused', error);\n\t    returnValue.state = 'stopped';\n\t    var backOffSet = function backoffTimeSet() {\n\t      opts.current_back_off = STARTING_BACK_OFF;\n\t    };\n\t    var removeBackOffSetter = function removeBackOffTimeSet() {\n\t      returnValue.removeListener('active', backOffSet);\n\t    };\n\t    returnValue.once('paused', removeBackOffSetter);\n\t    returnValue.once('active', backOffSet);\n\t  }\n\t\n\t  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n\t  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n\t  setTimeout(callback, opts.current_back_off);\n\t}\n\t\n\tfunction sortObjectPropertiesByKey(queryParams) {\n\t  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n\t    result[key] = queryParams[key];\n\t    return result;\n\t  }, {});\n\t}\n\t\n\t// Generate a unique id particular to this replication.\n\t// Not guaranteed to align perfectly with CouchDB's rep ids.\n\tfunction generateReplicationId(src, target, opts) {\n\t  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n\t  var filterFun = opts.filter ? opts.filter.toString() : '';\n\t  var queryParams = '';\n\t  var filterViewName =  '';\n\t  var selector = '';\n\t\n\t  // possibility for checkpoints to be lost here as behaviour of\n\t  // JSON.stringify is not stable (see #6226)\n\t  /* istanbul ignore if */\n\t  if (opts.selector) {\n\t    selector = JSON.stringify(opts.selector);\n\t  }\n\t\n\t  if (opts.filter && opts.query_params) {\n\t    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n\t  }\n\t\n\t  if (opts.filter && opts.filter === '_view') {\n\t    filterViewName = opts.view.toString();\n\t  }\n\t\n\t  return PouchPromise.all([src.id(), target.id()]).then(function (res) {\n\t    var queryData = res[0] + res[1] + filterFun + filterViewName +\n\t      queryParams + docIds + selector;\n\t    return new PouchPromise(function (resolve) {\n\t      binaryMd5(queryData, resolve);\n\t    });\n\t  }).then(function (md5sum) {\n\t    // can't use straight-up md5 alphabet, because\n\t    // the char '/' is interpreted as being for attachments,\n\t    // and + is also not url-safe\n\t    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n\t    return '_local/' + md5sum;\n\t  });\n\t}\n\t\n\tfunction replicate(src, target, opts, returnValue, result) {\n\t  var batches = [];               // list of batches to be processed\n\t  var currentBatch;               // the batch currently being processed\n\t  var pendingBatch = {\n\t    seq: 0,\n\t    changes: [],\n\t    docs: []\n\t  }; // next batch, not yet ready to be processed\n\t  var writingCheckpoint = false;  // true while checkpoint is being written\n\t  var changesCompleted = false;   // true when all changes received\n\t  var replicationCompleted = false; // true when replication has completed\n\t  var last_seq = 0;\n\t  var continuous = opts.continuous || opts.live || false;\n\t  var batch_size = opts.batch_size || 100;\n\t  var batches_limit = opts.batches_limit || 10;\n\t  var changesPending = false;     // true while src.changes is running\n\t  var doc_ids = opts.doc_ids;\n\t  var selector = opts.selector;\n\t  var repId;\n\t  var checkpointer;\n\t  var changedDocs = [];\n\t  // Like couchdb, every replication gets a unique session id\n\t  var session = uuid();\n\t  var seq_interval = opts.seq_interval;\n\t\n\t  result = result || {\n\t    ok: true,\n\t    start_time: new Date(),\n\t    docs_read: 0,\n\t    docs_written: 0,\n\t    doc_write_failures: 0,\n\t    errors: []\n\t  };\n\t\n\t  var changesOpts = {};\n\t  returnValue.ready(src, target);\n\t\n\t  function initCheckpointer() {\n\t    if (checkpointer) {\n\t      return PouchPromise.resolve();\n\t    }\n\t    return generateReplicationId(src, target, opts).then(function (res) {\n\t      repId = res;\n\t\n\t      var checkpointOpts = {};\n\t      if (opts.checkpoint === false) {\n\t        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n\t      } else if (opts.checkpoint === 'source') {\n\t        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n\t      } else if (opts.checkpoint === 'target') {\n\t        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n\t      } else {\n\t        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n\t      }\n\t\n\t      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n\t    });\n\t  }\n\t\n\t  function writeDocs() {\n\t    changedDocs = [];\n\t\n\t    if (currentBatch.docs.length === 0) {\n\t      return;\n\t    }\n\t    var docs = currentBatch.docs;\n\t    var bulkOpts = {timeout: opts.timeout};\n\t    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t\n\t      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n\t      // (id -> error), and check for errors while iterating over `docs`\n\t      var errorsById = Object.create(null);\n\t      res.forEach(function (res) {\n\t        if (res.error) {\n\t          errorsById[res.id] = res;\n\t        }\n\t      });\n\t\n\t      var errorsNo = Object.keys(errorsById).length;\n\t      result.doc_write_failures += errorsNo;\n\t      result.docs_written += docs.length - errorsNo;\n\t\n\t      docs.forEach(function (doc) {\n\t        var error = errorsById[doc._id];\n\t        if (error) {\n\t          result.errors.push(error);\n\t          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n\t          var errorName = (error.name || '').toLowerCase();\n\t          if (errorName === 'unauthorized' || errorName === 'forbidden') {\n\t            returnValue.emit('denied', clone(error));\n\t          } else {\n\t            throw error;\n\t          }\n\t        } else {\n\t          changedDocs.push(doc);\n\t        }\n\t      });\n\t\n\t    }, function (err) {\n\t      result.doc_write_failures += docs.length;\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  function finishBatch() {\n\t    if (currentBatch.error) {\n\t      throw new Error('There was a problem getting docs.');\n\t    }\n\t    result.last_seq = last_seq = currentBatch.seq;\n\t    var outResult = clone(result);\n\t    if (changedDocs.length) {\n\t      outResult.docs = changedDocs;\n\t      // Attach 'pending' property if server supports it (CouchDB 2.0+)\n\t      /* istanbul ignore if */\n\t      if (typeof currentBatch.pending === 'number') {\n\t        outResult.pending = currentBatch.pending;\n\t        delete currentBatch.pending;\n\t      }\n\t      returnValue.emit('change', outResult);\n\t    }\n\t    writingCheckpoint = true;\n\t    return checkpointer.writeCheckpoint(currentBatch.seq,\n\t        session).then(function () {\n\t      writingCheckpoint = false;\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      currentBatch = undefined;\n\t      getChanges();\n\t    }).catch(function (err) {\n\t      onCheckpointError(err);\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  function getDiffs() {\n\t    var diff = {};\n\t    currentBatch.changes.forEach(function (change) {\n\t      // Couchbase Sync Gateway emits these, but we can ignore them\n\t      /* istanbul ignore if */\n\t      if (change.id === \"_user/\") {\n\t        return;\n\t      }\n\t      diff[change.id] = change.changes.map(function (x) {\n\t        return x.rev;\n\t      });\n\t    });\n\t    return target.revsDiff(diff).then(function (diffs) {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      // currentBatch.diffs elements are deleted as the documents are written\n\t      currentBatch.diffs = diffs;\n\t    });\n\t  }\n\t\n\t  function getBatchDocs() {\n\t    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n\t      currentBatch.error = !got.ok;\n\t      got.docs.forEach(function (doc) {\n\t        delete currentBatch.diffs[doc._id];\n\t        result.docs_read++;\n\t        currentBatch.docs.push(doc);\n\t      });\n\t    });\n\t  }\n\t\n\t  function startNextBatch() {\n\t    if (returnValue.cancelled || currentBatch) {\n\t      return;\n\t    }\n\t    if (batches.length === 0) {\n\t      processPendingBatch(true);\n\t      return;\n\t    }\n\t    currentBatch = batches.shift();\n\t    getDiffs()\n\t      .then(getBatchDocs)\n\t      .then(writeDocs)\n\t      .then(finishBatch)\n\t      .then(startNextBatch)\n\t      .catch(function (err) {\n\t        abortReplication('batch processing terminated with error', err);\n\t      });\n\t  }\n\t\n\t\n\t  function processPendingBatch(immediate) {\n\t    if (pendingBatch.changes.length === 0) {\n\t      if (batches.length === 0 && !currentBatch) {\n\t        if ((continuous && changesOpts.live) || changesCompleted) {\n\t          returnValue.state = 'pending';\n\t          returnValue.emit('paused');\n\t        }\n\t        if (changesCompleted) {\n\t          completeReplication();\n\t        }\n\t      }\n\t      return;\n\t    }\n\t    if (\n\t      immediate ||\n\t      changesCompleted ||\n\t      pendingBatch.changes.length >= batch_size\n\t    ) {\n\t      batches.push(pendingBatch);\n\t      pendingBatch = {\n\t        seq: 0,\n\t        changes: [],\n\t        docs: []\n\t      };\n\t      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n\t        returnValue.state = 'active';\n\t        returnValue.emit('active');\n\t      }\n\t      startNextBatch();\n\t    }\n\t  }\n\t\n\t\n\t  function abortReplication(reason, err) {\n\t    if (replicationCompleted) {\n\t      return;\n\t    }\n\t    if (!err.message) {\n\t      err.message = reason;\n\t    }\n\t    result.ok = false;\n\t    result.status = 'aborting';\n\t    batches = [];\n\t    pendingBatch = {\n\t      seq: 0,\n\t      changes: [],\n\t      docs: []\n\t    };\n\t    completeReplication(err);\n\t  }\n\t\n\t\n\t  function completeReplication(fatalError) {\n\t    if (replicationCompleted) {\n\t      return;\n\t    }\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      result.status = 'cancelled';\n\t      if (writingCheckpoint) {\n\t        return;\n\t      }\n\t    }\n\t    result.status = result.status || 'complete';\n\t    result.end_time = new Date();\n\t    result.last_seq = last_seq;\n\t    replicationCompleted = true;\n\t\n\t    if (fatalError) {\n\t      // need to extend the error because Firefox considers \".result\" read-only\n\t      fatalError = createError(fatalError);\n\t      fatalError.result = result;\n\t\n\t      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n\t      var errorName = (fatalError.name || '').toLowerCase();\n\t      if (errorName === 'unauthorized' || errorName === 'forbidden') {\n\t        returnValue.emit('error', fatalError);\n\t        returnValue.removeAllListeners();\n\t      } else {\n\t        backOff(opts, returnValue, fatalError, function () {\n\t          replicate(src, target, opts, returnValue);\n\t        });\n\t      }\n\t    } else {\n\t      returnValue.emit('complete', result);\n\t      returnValue.removeAllListeners();\n\t    }\n\t  }\n\t\n\t\n\t  function onChange(change, pending, lastSeq) {\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t    // Attach 'pending' property if server supports it (CouchDB 2.0+)\n\t    /* istanbul ignore if */\n\t    if (typeof pending === 'number') {\n\t      pendingBatch.pending = pending;\n\t    }\n\t\n\t    var filter = filterChange(opts)(change);\n\t    if (!filter) {\n\t      return;\n\t    }\n\t    pendingBatch.seq = change.seq || lastSeq;\n\t    pendingBatch.changes.push(change);\n\t    processPendingBatch(batches.length === 0 && changesOpts.live);\n\t  }\n\t\n\t\n\t  function onChangesComplete(changes) {\n\t    changesPending = false;\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t\n\t    // if no results were returned then we're done,\n\t    // else fetch more\n\t    if (changes.results.length > 0) {\n\t      changesOpts.since = changes.last_seq;\n\t      getChanges();\n\t      processPendingBatch(true);\n\t    } else {\n\t\n\t      var complete = function () {\n\t        if (continuous) {\n\t          changesOpts.live = true;\n\t          getChanges();\n\t        } else {\n\t          changesCompleted = true;\n\t        }\n\t        processPendingBatch(true);\n\t      };\n\t\n\t      // update the checkpoint so we start from the right seq next time\n\t      if (!currentBatch && changes.results.length === 0) {\n\t        writingCheckpoint = true;\n\t        checkpointer.writeCheckpoint(changes.last_seq,\n\t            session).then(function () {\n\t          writingCheckpoint = false;\n\t          result.last_seq = last_seq = changes.last_seq;\n\t          complete();\n\t        })\n\t        .catch(onCheckpointError);\n\t      } else {\n\t        complete();\n\t      }\n\t    }\n\t  }\n\t\n\t\n\t  function onChangesError(err) {\n\t    changesPending = false;\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t    abortReplication('changes rejected', err);\n\t  }\n\t\n\t\n\t  function getChanges() {\n\t    if (!(\n\t      !changesPending &&\n\t      !changesCompleted &&\n\t      batches.length < batches_limit\n\t      )) {\n\t      return;\n\t    }\n\t    changesPending = true;\n\t    function abortChanges() {\n\t      changes.cancel();\n\t    }\n\t    function removeListener() {\n\t      returnValue.removeListener('cancel', abortChanges);\n\t    }\n\t\n\t    if (returnValue._changes) { // remove old changes() and listeners\n\t      returnValue.removeListener('cancel', returnValue._abortChanges);\n\t      returnValue._changes.cancel();\n\t    }\n\t    returnValue.once('cancel', abortChanges);\n\t\n\t    var changes = src.changes(changesOpts)\n\t      .on('change', onChange);\n\t    changes.then(removeListener, removeListener);\n\t    changes.then(onChangesComplete)\n\t      .catch(onChangesError);\n\t\n\t    if (opts.retry) {\n\t      // save for later so we can cancel if necessary\n\t      returnValue._changes = changes;\n\t      returnValue._abortChanges = abortChanges;\n\t    }\n\t  }\n\t\n\t\n\t  function startChanges() {\n\t    initCheckpointer().then(function () {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        return;\n\t      }\n\t      return checkpointer.getCheckpoint().then(function (checkpoint) {\n\t        last_seq = checkpoint;\n\t        changesOpts = {\n\t          since: last_seq,\n\t          limit: batch_size,\n\t          batch_size: batch_size,\n\t          style: 'all_docs',\n\t          doc_ids: doc_ids,\n\t          selector: selector,\n\t          return_docs: true // required so we know when we're done\n\t        };\n\t        if (seq_interval !== false) {\n\t          changesOpts.seq_interval = seq_interval || batch_size;\n\t        }\n\t        if (opts.filter) {\n\t          if (typeof opts.filter !== 'string') {\n\t            // required for the client-side filter in onChange\n\t            changesOpts.include_docs = true;\n\t          } else { // ddoc filter\n\t            changesOpts.filter = opts.filter;\n\t          }\n\t        }\n\t        if ('heartbeat' in opts) {\n\t          changesOpts.heartbeat = opts.heartbeat;\n\t        }\n\t        if ('timeout' in opts) {\n\t          changesOpts.timeout = opts.timeout;\n\t        }\n\t        if (opts.query_params) {\n\t          changesOpts.query_params = opts.query_params;\n\t        }\n\t        if (opts.view) {\n\t          changesOpts.view = opts.view;\n\t        }\n\t        getChanges();\n\t      });\n\t    }).catch(function (err) {\n\t      abortReplication('getCheckpoint rejected with ', err);\n\t    });\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  function onCheckpointError(err) {\n\t    writingCheckpoint = false;\n\t    abortReplication('writeCheckpoint completed with error', err);\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (returnValue.cancelled) { // cancelled immediately\n\t    completeReplication();\n\t    return;\n\t  }\n\t\n\t  if (!returnValue._addedListeners) {\n\t    returnValue.once('cancel', completeReplication);\n\t\n\t    if (typeof opts.complete === 'function') {\n\t      returnValue.once('error', opts.complete);\n\t      returnValue.once('complete', function (result) {\n\t        opts.complete(null, result);\n\t      });\n\t    }\n\t    returnValue._addedListeners = true;\n\t  }\n\t\n\t  if (typeof opts.since === 'undefined') {\n\t    startChanges();\n\t  } else {\n\t    initCheckpointer().then(function () {\n\t      writingCheckpoint = true;\n\t      return checkpointer.writeCheckpoint(opts.since, session);\n\t    }).then(function () {\n\t      writingCheckpoint = false;\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        return;\n\t      }\n\t      last_seq = opts.since;\n\t      startChanges();\n\t    }).catch(onCheckpointError);\n\t  }\n\t}\n\t\n\t// We create a basic promise so the caller can cancel the replication possibly\n\t// before we have actually started listening to changes etc\n\tinherits(Replication, events.EventEmitter);\n\tfunction Replication() {\n\t  events.EventEmitter.call(this);\n\t  this.cancelled = false;\n\t  this.state = 'pending';\n\t  var self = this;\n\t  var promise = new PouchPromise(function (fulfill, reject) {\n\t    self.once('complete', fulfill);\n\t    self.once('error', reject);\n\t  });\n\t  self.then = function (resolve, reject) {\n\t    return promise.then(resolve, reject);\n\t  };\n\t  self.catch = function (reject) {\n\t    return promise.catch(reject);\n\t  };\n\t  // As we allow error handling via \"error\" event as well,\n\t  // put a stub in here so that rejecting never throws UnhandledError.\n\t  self.catch(function () {});\n\t}\n\t\n\tReplication.prototype.cancel = function () {\n\t  this.cancelled = true;\n\t  this.state = 'cancelled';\n\t  this.emit('cancel');\n\t};\n\t\n\tReplication.prototype.ready = function (src, target) {\n\t  var self = this;\n\t  if (self._readyCalled) {\n\t    return;\n\t  }\n\t  self._readyCalled = true;\n\t\n\t  function onDestroy() {\n\t    self.cancel();\n\t  }\n\t  src.once('destroyed', onDestroy);\n\t  target.once('destroyed', onDestroy);\n\t  function cleanup() {\n\t    src.removeListener('destroyed', onDestroy);\n\t    target.removeListener('destroyed', onDestroy);\n\t  }\n\t  self.once('complete', cleanup);\n\t};\n\t\n\tfunction toPouch(db, opts) {\n\t  var PouchConstructor = opts.PouchConstructor;\n\t  if (typeof db === 'string') {\n\t    return new PouchConstructor(db, opts);\n\t  } else {\n\t    return db;\n\t  }\n\t}\n\t\n\tfunction replicateWrapper(src, target, opts, callback) {\n\t\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof opts === 'undefined') {\n\t    opts = {};\n\t  }\n\t\n\t  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n\t    throw createError(BAD_REQUEST,\n\t                       \"`doc_ids` filter parameter is not a list.\");\n\t  }\n\t\n\t  opts.complete = callback;\n\t  opts = clone(opts);\n\t  opts.continuous = opts.continuous || opts.live;\n\t  opts.retry = ('retry' in opts) ? opts.retry : false;\n\t  /*jshint validthis:true */\n\t  opts.PouchConstructor = opts.PouchConstructor || this;\n\t  var replicateRet = new Replication(opts);\n\t  var srcPouch = toPouch(src, opts);\n\t  var targetPouch = toPouch(target, opts);\n\t  replicate(srcPouch, targetPouch, opts, replicateRet);\n\t  return replicateRet;\n\t}\n\t\n\tinherits(Sync, events.EventEmitter);\n\tfunction sync$1(src, target, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof opts === 'undefined') {\n\t    opts = {};\n\t  }\n\t  opts = clone(opts);\n\t  /*jshint validthis:true */\n\t  opts.PouchConstructor = opts.PouchConstructor || this;\n\t  src = toPouch(src, opts);\n\t  target = toPouch(target, opts);\n\t  return new Sync(src, target, opts, callback);\n\t}\n\t\n\tfunction Sync(src, target, opts, callback) {\n\t  var self = this;\n\t  this.canceled = false;\n\t\n\t  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n\t  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\t\n\t  this.push = replicateWrapper(src, target, optsPush);\n\t  this.pull = replicateWrapper(target, src, optsPull);\n\t\n\t  this.pushPaused = true;\n\t  this.pullPaused = true;\n\t\n\t  function pullChange(change) {\n\t    self.emit('change', {\n\t      direction: 'pull',\n\t      change: change\n\t    });\n\t  }\n\t  function pushChange(change) {\n\t    self.emit('change', {\n\t      direction: 'push',\n\t      change: change\n\t    });\n\t  }\n\t  function pushDenied(doc) {\n\t    self.emit('denied', {\n\t      direction: 'push',\n\t      doc: doc\n\t    });\n\t  }\n\t  function pullDenied(doc) {\n\t    self.emit('denied', {\n\t      direction: 'pull',\n\t      doc: doc\n\t    });\n\t  }\n\t  function pushPaused() {\n\t    self.pushPaused = true;\n\t    /* istanbul ignore if */\n\t    if (self.pullPaused) {\n\t      self.emit('paused');\n\t    }\n\t  }\n\t  function pullPaused() {\n\t    self.pullPaused = true;\n\t    /* istanbul ignore if */\n\t    if (self.pushPaused) {\n\t      self.emit('paused');\n\t    }\n\t  }\n\t  function pushActive() {\n\t    self.pushPaused = false;\n\t    /* istanbul ignore if */\n\t    if (self.pullPaused) {\n\t      self.emit('active', {\n\t        direction: 'push'\n\t      });\n\t    }\n\t  }\n\t  function pullActive() {\n\t    self.pullPaused = false;\n\t    /* istanbul ignore if */\n\t    if (self.pushPaused) {\n\t      self.emit('active', {\n\t        direction: 'pull'\n\t      });\n\t    }\n\t  }\n\t\n\t  var removed = {};\n\t\n\t  function removeAll(type) { // type is 'push' or 'pull'\n\t    return function (event, func) {\n\t      var isChange = event === 'change' &&\n\t        (func === pullChange || func === pushChange);\n\t      var isDenied = event === 'denied' &&\n\t        (func === pullDenied || func === pushDenied);\n\t      var isPaused = event === 'paused' &&\n\t        (func === pullPaused || func === pushPaused);\n\t      var isActive = event === 'active' &&\n\t        (func === pullActive || func === pushActive);\n\t\n\t      if (isChange || isDenied || isPaused || isActive) {\n\t        if (!(event in removed)) {\n\t          removed[event] = {};\n\t        }\n\t        removed[event][type] = true;\n\t        if (Object.keys(removed[event]).length === 2) {\n\t          // both push and pull have asked to be removed\n\t          self.removeAllListeners(event);\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  if (opts.live) {\n\t    this.push.on('complete', self.pull.cancel.bind(self.pull));\n\t    this.pull.on('complete', self.push.cancel.bind(self.push));\n\t  }\n\t\n\t  function addOneListener(ee, event, listener) {\n\t    if (ee.listeners(event).indexOf(listener) == -1) {\n\t      ee.on(event, listener);\n\t    }\n\t  }\n\t\n\t  this.on('newListener', function (event) {\n\t    if (event === 'change') {\n\t      addOneListener(self.pull, 'change', pullChange);\n\t      addOneListener(self.push, 'change', pushChange);\n\t    } else if (event === 'denied') {\n\t      addOneListener(self.pull, 'denied', pullDenied);\n\t      addOneListener(self.push, 'denied', pushDenied);\n\t    } else if (event === 'active') {\n\t      addOneListener(self.pull, 'active', pullActive);\n\t      addOneListener(self.push, 'active', pushActive);\n\t    } else if (event === 'paused') {\n\t      addOneListener(self.pull, 'paused', pullPaused);\n\t      addOneListener(self.push, 'paused', pushPaused);\n\t    }\n\t  });\n\t\n\t  this.on('removeListener', function (event) {\n\t    if (event === 'change') {\n\t      self.pull.removeListener('change', pullChange);\n\t      self.push.removeListener('change', pushChange);\n\t    } else if (event === 'denied') {\n\t      self.pull.removeListener('denied', pullDenied);\n\t      self.push.removeListener('denied', pushDenied);\n\t    } else if (event === 'active') {\n\t      self.pull.removeListener('active', pullActive);\n\t      self.push.removeListener('active', pushActive);\n\t    } else if (event === 'paused') {\n\t      self.pull.removeListener('paused', pullPaused);\n\t      self.push.removeListener('paused', pushPaused);\n\t    }\n\t  });\n\t\n\t  this.pull.on('removeListener', removeAll('pull'));\n\t  this.push.on('removeListener', removeAll('push'));\n\t\n\t  var promise = PouchPromise.all([\n\t    this.push,\n\t    this.pull\n\t  ]).then(function (resp) {\n\t    var out = {\n\t      push: resp[0],\n\t      pull: resp[1]\n\t    };\n\t    self.emit('complete', out);\n\t    if (callback) {\n\t      callback(null, out);\n\t    }\n\t    self.removeAllListeners();\n\t    return out;\n\t  }, function (err) {\n\t    self.cancel();\n\t    if (callback) {\n\t      // if there's a callback, then the callback can receive\n\t      // the error event\n\t      callback(err);\n\t    } else {\n\t      // if there's no callback, then we're safe to emit an error\n\t      // event, which would otherwise throw an unhandled error\n\t      // due to 'error' being a special event in EventEmitters\n\t      self.emit('error', err);\n\t    }\n\t    self.removeAllListeners();\n\t    if (callback) {\n\t      // no sense throwing if we're already emitting an 'error' event\n\t      throw err;\n\t    }\n\t  });\n\t\n\t  this.then = function (success, err) {\n\t    return promise.then(success, err);\n\t  };\n\t\n\t  this.catch = function (err) {\n\t    return promise.catch(err);\n\t  };\n\t}\n\t\n\tSync.prototype.cancel = function () {\n\t  if (!this.canceled) {\n\t    this.canceled = true;\n\t    this.push.cancel();\n\t    this.pull.cancel();\n\t  }\n\t};\n\t\n\tfunction replication(PouchDB) {\n\t  PouchDB.replicate = replicateWrapper;\n\t  PouchDB.sync = sync$1;\n\t\n\t  Object.defineProperty(PouchDB.prototype, 'replicate', {\n\t    get: function () {\n\t      var self = this;\n\t      if (typeof this.replicateMethods === 'undefined') {\n\t        this.replicateMethods = {\n\t          from: function (other, opts, callback) {\n\t            return self.constructor.replicate(other, self, opts, callback);\n\t          },\n\t          to: function (other, opts, callback) {\n\t            return self.constructor.replicate(self, other, opts, callback);\n\t          }\n\t        };\n\t      }\n\t      return this.replicateMethods;\n\t    }\n\t  });\n\t\n\t  PouchDB.prototype.sync = function (dbName, opts, callback) {\n\t    return this.constructor.sync(this, dbName, opts, callback);\n\t  };\n\t}\n\t\n\tPouchDB.plugin(IDBPouch)\n\t  .plugin(WebSqlPouch$1)\n\t  .plugin(HttpPouch$1)\n\t  .plugin(mapreduce)\n\t  .plugin(replication);\n\t\n\t// Pull from src because pouchdb-node/pouchdb-browser themselves\n\t// are aggressively optimized and jsnext:main would normally give us this\n\t// aggressive bundle.\n\t\n\tmodule.exports = PouchDB;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(84);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n\t  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n\t  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n\t  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n\t  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n\t  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n\t  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n\t  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n\t  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n\t  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n\t  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // NB: In an Electron preload script, document will be defined but not fully\n\t  // initialized. Since we know we're in Chrome, we'll just detect this case\n\t  // explicitly\n\t  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n\t    return true;\n\t  }\n\t\n\t  // Internet Explorer and Edge do not support colors.\n\t  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n\t    return false;\n\t  }\n\t\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t    // double check webkit in userAgent just in case we are in a worker\n\t    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  try {\n\t    return JSON.stringify(v);\n\t  } catch (err) {\n\t    return '[UnexpectedJSONParseError]: ' + err.message;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs(args) {\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args.splice(1, 0, c, 'color: inherit')\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  var r;\n\t  try {\n\t    r = exports.storage.debug;\n\t  } catch(e) {}\n\t\n\t  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\t  if (!r && typeof process !== 'undefined' && 'env' in process) {\n\t    r = process.env.DEBUG;\n\t  }\n\t\n\t  return r;\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage() {\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32)))\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(85);\n\t\n\t/**\n\t * Active `debug` instances.\n\t */\n\texports.instances = [];\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Select a color.\n\t * @param {String} namespace\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor(namespace) {\n\t  var hash = 0, i;\n\t\n\t  for (i in namespace) {\n\t    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t    hash |= 0; // Convert to 32bit integer\n\t  }\n\t\n\t  return exports.colors[Math.abs(hash) % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction createDebug(namespace) {\n\t\n\t  var prevTime;\n\t\n\t  function debug() {\n\t    // disabled?\n\t    if (!debug.enabled) return;\n\t\n\t    var self = debug;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // turn the `arguments` into a proper Array\n\t    var args = new Array(arguments.length);\n\t    for (var i = 0; i < args.length; i++) {\n\t      args[i] = arguments[i];\n\t    }\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %O\n\t      args.unshift('%O');\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    // apply env-specific formatting (colors, etc.)\n\t    exports.formatArgs.call(self, args);\n\t\n\t    var logFn = debug.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t\n\t  debug.namespace = namespace;\n\t  debug.enabled = exports.enabled(namespace);\n\t  debug.useColors = exports.useColors();\n\t  debug.color = selectColor(namespace);\n\t  debug.destroy = destroy;\n\t\n\t  // env-specific initialization logic for debug instances\n\t  if ('function' === typeof exports.init) {\n\t    exports.init(debug);\n\t  }\n\t\n\t  exports.instances.push(debug);\n\t\n\t  return debug;\n\t}\n\t\n\tfunction destroy () {\n\t  var index = exports.instances.indexOf(this);\n\t  if (index !== -1) {\n\t    exports.instances.splice(index, 1);\n\t    return true;\n\t  } else {\n\t    return false;\n\t  }\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  exports.names = [];\n\t  exports.skips = [];\n\t\n\t  var i;\n\t  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t\n\t  for (i = 0; i < exports.instances.length; i++) {\n\t    var instance = exports.instances[i];\n\t    instance.enabled = exports.enabled(instance.namespace);\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  if (name[name.length - 1] === '*') {\n\t    return true;\n\t  }\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 85 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000;\n\tvar m = s * 60;\n\tvar h = m * 60;\n\tvar d = h * 24;\n\tvar y = d * 365.25;\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} [options]\n\t * @throws {Error} throw an error if val is not a non-empty string or a number\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function(val, options) {\n\t  options = options || {};\n\t  var type = typeof val;\n\t  if (type === 'string' && val.length > 0) {\n\t    return parse(val);\n\t  } else if (type === 'number' && isNaN(val) === false) {\n\t    return options.long ? fmtLong(val) : fmtShort(val);\n\t  }\n\t  throw new Error(\n\t    'val is not a non-empty string or a valid number. val=' +\n\t      JSON.stringify(val)\n\t  );\n\t};\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = String(str);\n\t  if (str.length > 100) {\n\t    return;\n\t  }\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n\t    str\n\t  );\n\t  if (!match) {\n\t    return;\n\t  }\n\t  var n = parseFloat(match[1]);\n\t  var type = (match[2] || 'ms').toLowerCase();\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y;\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d;\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h;\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m;\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s;\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n;\n\t    default:\n\t      return undefined;\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction fmtShort(ms) {\n\t  if (ms >= d) {\n\t    return Math.round(ms / d) + 'd';\n\t  }\n\t  if (ms >= h) {\n\t    return Math.round(ms / h) + 'h';\n\t  }\n\t  if (ms >= m) {\n\t    return Math.round(ms / m) + 'm';\n\t  }\n\t  if (ms >= s) {\n\t    return Math.round(ms / s) + 's';\n\t  }\n\t  return ms + 'ms';\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction fmtLong(ms) {\n\t  return plural(ms, d, 'day') ||\n\t    plural(ms, h, 'hour') ||\n\t    plural(ms, m, 'minute') ||\n\t    plural(ms, s, 'second') ||\n\t    ms + ' ms';\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) {\n\t    return;\n\t  }\n\t  if (ms < n * 1.5) {\n\t    return Math.floor(ms / n) + ' ' + name;\n\t  }\n\t  return Math.ceil(ms / n) + ' ' + name + 's';\n\t}\n\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(36);\n\tvar bytesToUuid = __webpack_require__(35);\n\t\n\t// **`v1()` - Generate time-based UUID**\n\t//\n\t// Inspired by https://github.com/LiosK/UUID.js\n\t// and http://docs.python.org/library/uuid.html\n\t\n\tvar _nodeId;\n\tvar _clockseq;\n\t\n\t// Previous uuid creation time\n\tvar _lastMSecs = 0;\n\tvar _lastNSecs = 0;\n\t\n\t// See https://github.com/broofa/node-uuid for API details\n\tfunction v1(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t  var b = buf || [];\n\t\n\t  options = options || {};\n\t  var node = options.node || _nodeId;\n\t  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\t\n\t  // node and clockseq need to be initialized to random values if they're not\n\t  // specified.  We do this lazily to minimize issues related to insufficient\n\t  // system entropy.  See #189\n\t  if (node == null || clockseq == null) {\n\t    var seedBytes = rng();\n\t    if (node == null) {\n\t      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n\t      node = _nodeId = [\n\t        seedBytes[0] | 0x01,\n\t        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n\t      ];\n\t    }\n\t    if (clockseq == null) {\n\t      // Per 4.2.2, randomize (14 bit) clockseq\n\t      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n\t    }\n\t  }\n\t\n\t  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n\t  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n\t  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n\t  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\t  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\t\n\t  // Per 4.2.1.2, use count of uuid's generated during the current clock\n\t  // cycle to simulate higher resolution clock\n\t  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\t\n\t  // Time since last uuid creation (in msecs)\n\t  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\t\n\t  // Per 4.2.1.2, Bump clockseq on clock regression\n\t  if (dt < 0 && options.clockseq === undefined) {\n\t    clockseq = clockseq + 1 & 0x3fff;\n\t  }\n\t\n\t  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n\t  // time interval\n\t  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n\t    nsecs = 0;\n\t  }\n\t\n\t  // Per 4.2.1.2 Throw error if too many uuids are requested\n\t  if (nsecs >= 10000) {\n\t    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n\t  }\n\t\n\t  _lastMSecs = msecs;\n\t  _lastNSecs = nsecs;\n\t  _clockseq = clockseq;\n\t\n\t  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\t  msecs += 12219292800000;\n\t\n\t  // `time_low`\n\t  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n\t  b[i++] = tl >>> 24 & 0xff;\n\t  b[i++] = tl >>> 16 & 0xff;\n\t  b[i++] = tl >>> 8 & 0xff;\n\t  b[i++] = tl & 0xff;\n\t\n\t  // `time_mid`\n\t  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n\t  b[i++] = tmh >>> 8 & 0xff;\n\t  b[i++] = tmh & 0xff;\n\t\n\t  // `time_high_and_version`\n\t  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\t  b[i++] = tmh >>> 16 & 0xff;\n\t\n\t  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\t  b[i++] = clockseq >>> 8 | 0x80;\n\t\n\t  // `clock_seq_low`\n\t  b[i++] = clockseq & 0xff;\n\t\n\t  // `node`\n\t  for (var n = 0; n < 6; ++n) {\n\t    b[i + n] = node[n];\n\t  }\n\t\n\t  return buf ? buf : bytesToUuid(b);\n\t}\n\t\n\tmodule.exports = v1;\n\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar rng = __webpack_require__(36);\n\tvar bytesToUuid = __webpack_require__(35);\n\t\n\tfunction v4(options, buf, offset) {\n\t  var i = buf && offset || 0;\n\t\n\t  if (typeof(options) == 'string') {\n\t    buf = options === 'binary' ? new Array(16) : null;\n\t    options = null;\n\t  }\n\t  options = options || {};\n\t\n\t  var rnds = options.random || (options.rng || rng)();\n\t\n\t  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\t  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n\t  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\t\n\t  // Copy bytes to buffer, if provided\n\t  if (buf) {\n\t    for (var ii = 0; ii < 16; ++ii) {\n\t      buf[i + ii] = rnds[ii];\n\t    }\n\t  }\n\t\n\t  return buf || bytesToUuid(rnds);\n\t}\n\t\n\tmodule.exports = v4;\n\n\n/***/ },\n/* 88 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Stringify/parse functions that don't operate\n\t * recursively, so they avoid call stack exceeded\n\t * errors.\n\t */\n\texports.stringify = function stringify(input) {\n\t  var queue = [];\n\t  queue.push({obj: input});\n\t\n\t  var res = '';\n\t  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n\t  while ((next = queue.pop())) {\n\t    obj = next.obj;\n\t    prefix = next.prefix || '';\n\t    val = next.val || '';\n\t    res += prefix;\n\t    if (val) {\n\t      res += val;\n\t    } else if (typeof obj !== 'object') {\n\t      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n\t    } else if (obj === null) {\n\t      res += 'null';\n\t    } else if (Array.isArray(obj)) {\n\t      queue.push({val: ']'});\n\t      for (i = obj.length - 1; i >= 0; i--) {\n\t        arrayPrefix = i === 0 ? '' : ',';\n\t        queue.push({obj: obj[i], prefix: arrayPrefix});\n\t      }\n\t      queue.push({val: '['});\n\t    } else { // object\n\t      keys = [];\n\t      for (k in obj) {\n\t        if (obj.hasOwnProperty(k)) {\n\t          keys.push(k);\n\t        }\n\t      }\n\t      queue.push({val: '}'});\n\t      for (i = keys.length - 1; i >= 0; i--) {\n\t        key = keys[i];\n\t        value = obj[key];\n\t        objPrefix = (i > 0 ? ',' : '');\n\t        objPrefix += JSON.stringify(key) + ':';\n\t        queue.push({obj: value, prefix: objPrefix});\n\t      }\n\t      queue.push({val: '{'});\n\t    }\n\t  }\n\t  return res;\n\t};\n\t\n\t// Convenience function for the parse function.\n\t// This pop function is basically copied from\n\t// pouchCollate.parseIndexableString\n\tfunction pop(obj, stack, metaStack) {\n\t  var lastMetaElement = metaStack[metaStack.length - 1];\n\t  if (obj === lastMetaElement.element) {\n\t    // popping a meta-element, e.g. an object whose value is another object\n\t    metaStack.pop();\n\t    lastMetaElement = metaStack[metaStack.length - 1];\n\t  }\n\t  var element = lastMetaElement.element;\n\t  var lastElementIndex = lastMetaElement.index;\n\t  if (Array.isArray(element)) {\n\t    element.push(obj);\n\t  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t    var key = stack.pop();\n\t    element[key] = obj;\n\t  } else {\n\t    stack.push(obj); // obj with key only\n\t  }\n\t}\n\t\n\texports.parse = function (str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t  var collationIndex,parsedNum,numChar;\n\t  var parsedString,lastCh,numConsecutiveSlashes,ch;\n\t  var arrayElement, objElement;\n\t  while (true) {\n\t    collationIndex = str[i++];\n\t    if (collationIndex === '}' ||\n\t        collationIndex === ']' ||\n\t        typeof collationIndex === 'undefined') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack.pop(), stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case ' ':\n\t      case '\\t':\n\t      case '\\n':\n\t      case ':':\n\t      case ',':\n\t        break;\n\t      case 'n':\n\t        i += 3; // 'ull'\n\t        pop(null, stack, metaStack);\n\t        break;\n\t      case 't':\n\t        i += 3; // 'rue'\n\t        pop(true, stack, metaStack);\n\t        break;\n\t      case 'f':\n\t        i += 4; // 'alse'\n\t        pop(false, stack, metaStack);\n\t        break;\n\t      case '0':\n\t      case '1':\n\t      case '2':\n\t      case '3':\n\t      case '4':\n\t      case '5':\n\t      case '6':\n\t      case '7':\n\t      case '8':\n\t      case '9':\n\t      case '-':\n\t        parsedNum = '';\n\t        i--;\n\t        while (true) {\n\t          numChar = str[i++];\n\t          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n\t            parsedNum += numChar;\n\t          } else {\n\t            i--;\n\t            break;\n\t          }\n\t        }\n\t        pop(parseFloat(parsedNum), stack, metaStack);\n\t        break;\n\t      case '\"':\n\t        parsedString = '';\n\t        lastCh = void 0;\n\t        numConsecutiveSlashes = 0;\n\t        while (true) {\n\t          ch = str[i++];\n\t          if (ch !== '\"' || (lastCh === '\\\\' &&\n\t              numConsecutiveSlashes % 2 === 1)) {\n\t            parsedString += ch;\n\t            lastCh = ch;\n\t            if (lastCh === '\\\\') {\n\t              numConsecutiveSlashes++;\n\t            } else {\n\t              numConsecutiveSlashes = 0;\n\t            }\n\t          } else {\n\t            break;\n\t          }\n\t        }\n\t        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n\t        break;\n\t      case '[':\n\t        arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '{':\n\t        objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      default:\n\t        throw new Error(\n\t          'unexpectedly reached end of input: ' + collationIndex);\n\t    }\n\t  }\n\t};\n\n\n/***/ },\n/* 89 */\n/***/ function(module, exports) {\n\n\t(function(self) {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  var support = {\n\t    searchParams: 'URLSearchParams' in self,\n\t    iterable: 'Symbol' in self && 'iterator' in Symbol,\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob()\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  if (support.arrayBuffer) {\n\t    var viewClasses = [\n\t      '[object Int8Array]',\n\t      '[object Uint8Array]',\n\t      '[object Uint8ClampedArray]',\n\t      '[object Int16Array]',\n\t      '[object Uint16Array]',\n\t      '[object Int32Array]',\n\t      '[object Uint32Array]',\n\t      '[object Float32Array]',\n\t      '[object Float64Array]'\n\t    ]\n\t\n\t    var isDataView = function(obj) {\n\t      return obj && DataView.prototype.isPrototypeOf(obj)\n\t    }\n\t\n\t    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n\t      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n\t    }\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  // Build a destructive iterator for the value list\n\t  function iteratorFor(items) {\n\t    var iterator = {\n\t      next: function() {\n\t        var value = items.shift()\n\t        return {done: value === undefined, value: value}\n\t      }\n\t    }\n\t\n\t    if (support.iterable) {\n\t      iterator[Symbol.iterator] = function() {\n\t        return iterator\n\t      }\n\t    }\n\t\n\t    return iterator\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t    } else if (Array.isArray(headers)) {\n\t      headers.forEach(function(header) {\n\t        this.append(header[0], header[1])\n\t      }, this)\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var oldValue = this.map[name]\n\t    this.map[name] = oldValue ? oldValue+','+value : value\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    name = normalizeName(name)\n\t    return this.has(name) ? this.map[name] : null\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = normalizeValue(value)\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    for (var name in this.map) {\n\t      if (this.map.hasOwnProperty(name)) {\n\t        callback.call(thisArg, this.map[name], name, this)\n\t      }\n\t    }\n\t  }\n\t\n\t  Headers.prototype.keys = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push(name) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.values = function() {\n\t    var items = []\n\t    this.forEach(function(value) { items.push(value) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.entries = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push([name, value]) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  if (support.iterable) {\n\t    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    var promise = fileReaderReady(reader)\n\t    reader.readAsArrayBuffer(blob)\n\t    return promise\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    var promise = fileReaderReady(reader)\n\t    reader.readAsText(blob)\n\t    return promise\n\t  }\n\t\n\t  function readArrayBufferAsText(buf) {\n\t    var view = new Uint8Array(buf)\n\t    var chars = new Array(view.length)\n\t\n\t    for (var i = 0; i < view.length; i++) {\n\t      chars[i] = String.fromCharCode(view[i])\n\t    }\n\t    return chars.join('')\n\t  }\n\t\n\t  function bufferClone(buf) {\n\t    if (buf.slice) {\n\t      return buf.slice(0)\n\t    } else {\n\t      var view = new Uint8Array(buf.byteLength)\n\t      view.set(new Uint8Array(buf))\n\t      return view.buffer\n\t    }\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (!body) {\n\t        this._bodyText = ''\n\t      } else if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t        this._bodyText = body.toString()\n\t      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n\t        this._bodyArrayBuffer = bufferClone(body.buffer)\n\t        // IE 10-11 can't handle a DataView body.\n\t        this._bodyInit = new Blob([this._bodyArrayBuffer])\n\t      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n\t        this._bodyArrayBuffer = bufferClone(body)\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t\n\t      if (!this.headers.get('content-type')) {\n\t        if (typeof body === 'string') {\n\t          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n\t        } else if (this._bodyBlob && this._bodyBlob.type) {\n\t          this.headers.set('content-type', this._bodyBlob.type)\n\t        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n\t        }\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyArrayBuffer) {\n\t          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        if (this._bodyArrayBuffer) {\n\t          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n\t        } else {\n\t          return this.blob().then(readBlobAsArrayBuffer)\n\t        }\n\t      }\n\t    }\n\t\n\t    this.text = function() {\n\t      var rejected = consumed(this)\n\t      if (rejected) {\n\t        return rejected\n\t      }\n\t\n\t      if (this._bodyBlob) {\n\t        return readBlobAsText(this._bodyBlob)\n\t      } else if (this._bodyArrayBuffer) {\n\t        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n\t      } else if (this._bodyFormData) {\n\t        throw new Error('could not read FormData body as text')\n\t      } else {\n\t        return Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t\n\t    if (input instanceof Request) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body && input._bodyInit != null) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = String(input)\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this, { body: this._bodyInit })\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function parseHeaders(rawHeaders) {\n\t    var headers = new Headers()\n\t    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n\t    // https://tools.ietf.org/html/rfc7230#section-3.2\n\t    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n\t    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n\t      var parts = line.split(':')\n\t      var key = parts.shift().trim()\n\t      if (key) {\n\t        var value = parts.join(':').trim()\n\t        headers.append(key, value)\n\t      }\n\t    })\n\t    return headers\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this.type = 'default'\n\t    this.status = options.status === undefined ? 200 : options.status\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n\t    this.headers = new Headers(options.headers)\n\t    this.url = options.url || ''\n\t    this._initBody(bodyInit)\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers\n\t  self.Request = Request\n\t  self.Response = Response\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request = new Request(input, init)\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      xhr.onload = function() {\n\t        var options = {\n\t          status: xhr.status,\n\t          statusText: xhr.statusText,\n\t          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n\t        }\n\t        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.ontimeout = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      } else if (request.credentials === 'omit') {\n\t        xhr.withCredentials = false\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// cozy-client.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap f8e327ef45269f91f28d","/* global fetch */\nimport { refreshToken, AccessToken } from './auth_v3'\nimport { retry, encodeQuery } from './utils'\nimport jsonapi from './jsonapi'\n\nexport function cozyFetch(cozy, path, options = {}) {\n  return cozy.fullpath(path).then(fullpath => {\n    let resp\n    if (options.disableAuth) {\n      resp = fetch(fullpath, options)\n    } else if (options.manualAuthCredentials) {\n      resp = cozyFetchWithAuth(\n        cozy,\n        fullpath,\n        options,\n        options.manualAuthCredentials\n      )\n    } else {\n      resp = cozy\n        .authorize()\n        .then(credentials =>\n          cozyFetchWithAuth(cozy, fullpath, options, credentials)\n        )\n    }\n    return resp.then(res => handleResponse(res, cozy._invalidTokenErrorHandler))\n  })\n}\n\nfunction cozyFetchWithAuth(cozy, fullpath, options, credentials) {\n  if (credentials) {\n    options.headers = options.headers || {}\n    options.headers['Authorization'] = credentials.token.toAuthHeader()\n  }\n\n  // the option credentials:include tells fetch to include the cookies in the\n  // request even for cross-origin requests\n  options.credentials = 'include'\n\n  return Promise.all([cozy.isV2(), fetch(fullpath, options)]).then(\n    ([isV2, res]) => {\n      if (\n        (res.status !== 400 && res.status !== 401) ||\n        isV2 ||\n        !credentials ||\n        options.dontRetry\n      ) {\n        return res\n      }\n      // we try to refresh the token only for OAuth, ie, the client defined\n      // and the token is an instance of AccessToken.\n      const { client, token } = credentials\n      if (!client || !(token instanceof AccessToken)) {\n        return res\n      }\n      options.dontRetry = true\n      return retry(() => refreshToken(cozy, client, token), 3)()\n        .then(newToken => cozy.saveCredentials(client, newToken))\n        .then(credentials =>\n          cozyFetchWithAuth(cozy, fullpath, options, credentials)\n        )\n    }\n  )\n}\n\nexport function cozyFetchJSON(cozy, method, path, body, options = {}) {\n  const processJSONAPI =\n    typeof options.processJSONAPI === 'undefined' || options.processJSONAPI\n  return fetchJSON(cozy, method, path, body, options).then(response =>\n    handleJSONResponse(response, processJSONAPI)\n  )\n}\n\nexport function cozyFetchRawJSON(cozy, method, path, body, options = {}) {\n  return fetchJSON(cozy, method, path, body, options).then(response =>\n    handleJSONResponse(response, false)\n  )\n}\n\nfunction fetchJSON(cozy, method, path, body, options = {}) {\n  options.method = method\n\n  const headers = (options.headers = options.headers || {})\n\n  headers['Accept'] = 'application/json'\n\n  if (method !== 'GET' && method !== 'HEAD' && body !== undefined) {\n    if (headers['Content-Type']) {\n      options.body = body\n    } else {\n      headers['Content-Type'] = 'application/json'\n      options.body = JSON.stringify(body)\n    }\n  }\n\n  return cozyFetch(cozy, path, options)\n}\n\nfunction handleResponse(res, invalidTokenErrorHandler) {\n  if (res.ok) {\n    return res\n  }\n  let data\n  const contentType = res.headers.get('content-type')\n  if (contentType && contentType.indexOf('json') >= 0) {\n    data = res.json()\n  } else {\n    data = res.text()\n  }\n  return data.then(err => {\n    const error = new FetchError(res, err)\n    if (FetchError.isInvalidToken(error) && invalidTokenErrorHandler) {\n      invalidTokenErrorHandler(error)\n    }\n    throw error\n  })\n}\n\nfunction handleJSONResponse(res, processJSONAPI = true) {\n  const contentType = res.headers.get('content-type')\n  if (!contentType || contentType.indexOf('json') < 0) {\n    return res.text(data => {\n      throw new FetchError(res, new Error('Response is not JSON: ' + data))\n    })\n  }\n\n  const json = res.json()\n  if (contentType.indexOf('application/vnd.api+json') === 0 && processJSONAPI) {\n    return json.then(jsonapi)\n  } else {\n    return json\n  }\n}\n\nexport function handleInvalidTokenError(error) {\n  try {\n    const currentOrigin = window.location.origin\n    const requestUrl = error.url\n\n    if (\n      requestUrl.indexOf(\n        currentOrigin.replace(/^(https?:\\/\\/\\w+)-\\w+\\./, '$1.')\n      ) === 0\n    ) {\n      const redirectURL = `${currentOrigin}?${encodeQuery({ disconnect: 1 })}`\n      window.location = redirectURL\n    }\n  } catch (e) {\n    console.warn('Unable to handle invalid token error', e, error)\n  }\n}\n\nexport class FetchError extends Error {\n  constructor(res, reason) {\n    super()\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n    // XXX We have to hardcode this because babel doesn't play nice when extending Error\n    this.name = 'FetchError'\n    this.response = res\n    this.url = res.url\n    this.status = res.status\n    this.reason = reason\n\n    Object.defineProperty(this, 'message', {\n      value:\n        reason.message ||\n        (typeof reason === 'string' ? reason : JSON.stringify(reason))\n    })\n  }\n}\n\nFetchError.isUnauthorized = function(err) {\n  // XXX We can't use err instanceof FetchError because of the caveats of babel\n  return err.name === 'FetchError' && err.status === 401\n}\n\nFetchError.isNotFound = function(err) {\n  // XXX We can't use err instanceof FetchError because of the caveats of babel\n  return err.name === 'FetchError' && err.status === 404\n}\n\nFetchError.isInvalidToken = function(err) {\n  // XXX We can't use err instanceof FetchError because of the caveats of babel\n  return (\n    err.name === 'FetchError' &&\n    err.status === 400 &&\n    err.reason &&\n    (err.reason.error === 'Invalid JWT token' ||\n      err.reason.error === 'Expired token')\n  )\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/fetch.js","/* global navigator */\nconst FuzzFactor = 0.3\n\nexport function unpromiser(fn) {\n  return function(...args) {\n    const value = fn.apply(this, args)\n    if (!isPromise(value)) {\n      return value\n    }\n    const l = args.length\n    if (l === 0 || typeof args[l - 1] !== 'function') {\n      return\n    }\n    const cb = args[l - 1]\n    value.then(res => cb(null, res), err => cb(err, null))\n  }\n}\n\nexport function isPromise(value) {\n  return !!value && typeof value.then === 'function'\n}\n\nexport function isOnline() {\n  return typeof navigator !== 'undefined' ? navigator.onLine : true\n}\n\nexport function isOffline() {\n  return !isOnline()\n}\n\nexport function sleep(time, args) {\n  return new Promise(resolve => {\n    setTimeout(resolve, time, args)\n  })\n}\n\nexport function retry(fn, count, delay = 300) {\n  return function doTry(...args) {\n    return fn(...args).catch(err => {\n      if (--count < 0) {\n        throw err\n      }\n      return sleep(getBackedoffDelay(delay, count)).then(() => doTry(...args))\n    })\n  }\n}\n\nexport function getFuzzedDelay(retryDelay) {\n  const fuzzingFactor = (Math.random() * 2 - 1) * FuzzFactor\n  return retryDelay * (1.0 + fuzzingFactor)\n}\n\nexport function getBackedoffDelay(retryDelay, retryCount = 1) {\n  return getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1))\n}\n\nexport function createPath(cozy, isV2, doctype, id = '', query = null) {\n  let route = '/data/'\n  if (!isV2) {\n    route += `${encodeURIComponent(doctype)}/`\n  }\n  if (id !== '') {\n    route += encodeURIComponent(id)\n  }\n  const q = encodeQuery(query)\n  if (q !== '') {\n    route += '?' + q\n  }\n  return route\n}\n\nexport function encodeQuery(query) {\n  if (!query) {\n    return ''\n  }\n  let q = ''\n  for (const qname in query) {\n    if (q !== '') {\n      q += '&'\n    }\n    q += `${encodeURIComponent(qname)}=${encodeURIComponent(query[qname])}`\n  }\n  return q\n}\n\nexport function decodeQuery(url) {\n  let queryIndex = url.indexOf('?')\n  if (queryIndex < 0) {\n    queryIndex = url.length\n  }\n  const queries = {}\n  let fragIndex = url.indexOf('#')\n  if (fragIndex < 0) {\n    fragIndex = url.length\n  }\n  if (fragIndex < queryIndex) {\n    return queries\n  }\n  const queryStr = url.slice(queryIndex + 1, fragIndex)\n  if (queryStr === '') {\n    return queries\n  }\n  const parts = queryStr.split('&')\n  for (let i = 0; i < parts.length; i++) {\n    let pair = parts[i].split('=')\n    if (pair.length === 0 || pair[0] === '') {\n      continue\n    }\n    const qname = decodeURIComponent(pair[0])\n    if (queries.hasOwnProperty(qname)) {\n      continue\n    }\n    if (pair.length === 1) {\n      queries[qname] = true\n    } else if (pair.length === 2) {\n      queries[qname] = decodeURIComponent(pair[1])\n    } else {\n      throw new Error('Malformed URL')\n    }\n  }\n  return queries\n}\n\nconst warned = []\nexport function warn(text) {\n  if (warned.indexOf(text) === -1) {\n    warned.push(text)\n    console.warn('cozy-client-js', text)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","import { warn } from './utils'\n\nexport const DOCTYPE_FILES = 'io.cozy.files'\n\nconst KNOWN_DOCTYPES = {\n  files: DOCTYPE_FILES,\n  folder: DOCTYPE_FILES,\n  contact: 'io.cozy.contacts',\n  event: 'io.cozy.events',\n  track: 'io.cozy.labs.music.track',\n  playlist: 'io.cozy.labs.music.playlist'\n}\n\nconst REVERSE_KNOWN = {}\nObject.keys(KNOWN_DOCTYPES).forEach(k => {\n  REVERSE_KNOWN[KNOWN_DOCTYPES[k]] = k\n})\n\nexport function normalizeDoctype(cozy, isV2, doctype) {\n  let isQualified = doctype.indexOf('.') !== -1\n  if (isV2 && isQualified) {\n    let known = REVERSE_KNOWN[doctype]\n    if (known) return known\n    return doctype.replace(/\\./g, '-')\n  }\n  if (!isV2 && !isQualified) {\n    let known = KNOWN_DOCTYPES[doctype]\n    if (known) {\n      warn(\n        'you are using a non-qualified doctype ' +\n          doctype +\n          ' assumed to be ' +\n          known\n      )\n      return known\n    }\n    throw new Error('Doctype ' + doctype + ' should be qualified.')\n  }\n  return doctype\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/doctypes.js","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_global.js\n// module id = 4\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inherits/inherits_browser.js\n// module id = 5\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar getArguments = _interopDefault(require('argsarray'));\nvar Promise = _interopDefault(require('pouchdb-promise'));\nvar pouchdbCollections = require('pouchdb-collections');\nvar immediate = _interopDefault(require('immediate'));\nvar events = require('events');\nvar inherits = _interopDefault(require('inherits'));\nvar pouchdbErrors = require('pouchdb-errors');\nvar uuidV4 = _interopDefault(require('uuid'));\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new Promise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return Promise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return Promise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new Promise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new pouchdbCollections.Map();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\ninherits(Changes, events.EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  events.EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        immediate(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  events.EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar assign$1 = assign;\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return pouchdbErrors.createError(pouchdbErrors.BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function (fun) {\n    return fun.name;\n  };\n} else {\n  res = function (fun) {\n    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n  };\n}\n\nvar res$1 = res;\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = pouchdbErrors.createError(pouchdbErrors.MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = pouchdbErrors.createError(pouchdbErrors.INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = pouchdbErrors.createError(pouchdbErrors.RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\nfunction isCordova() {\n  return (typeof cordova !== \"undefined\" ||\n  typeof PhoneGap !== \"undefined\" ||\n  typeof phonegap !== \"undefined\");\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 events.EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new Promise(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nfunction rev() {\n  return uuidV4.v4().replace(/-/g, '').toLowerCase();\n}\n\nvar uuid = uuidV4.v4;\n\nexports.adapterFun = adapterFun;\nexports.assign = assign$1;\nexports.bulkGetShim = bulkGet;\nexports.changesHandler = Changes;\nexports.clone = clone;\nexports.defaultBackOff = defaultBackOff;\nexports.explainError = explainError;\nexports.filterChange = filterChange;\nexports.flatten = flatten;\nexports.functionName = res$1;\nexports.guardedConsole = guardedConsole;\nexports.hasLocalStorage = hasLocalStorage;\nexports.invalidIdError = invalidIdError;\nexports.isChromeApp = isChromeApp;\nexports.isCordova = isCordova;\nexports.isRemote = isRemote;\nexports.listenerCount = listenerCount;\nexports.nextTick = immediate;\nexports.normalizeDdocFunctionName = normalizeDesignDocFunctionName;\nexports.once = once;\nexports.parseDdocFunctionName = parseDesignDocFunctionName;\nexports.parseUri = parseUri;\nexports.pick = pick;\nexports.rev = rev;\nexports.scopeEval = scopeEval;\nexports.toPromise = toPromise;\nexports.upsert = upsert;\nexports.uuid = uuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-utils/lib/index-browser.js\n// module id = 6\n// module chunks = 0","'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/argsarray/index.js\n// module id = 7\n// module chunks = 0","/* global btoa */\nimport { encodeQuery, decodeQuery, isOffline } from './utils'\nimport { cozyFetchJSON, FetchError } from './fetch'\n\nconst StateSize = 16\n\nexport const CredsKey = 'creds'\nexport const StateKey = 'state'\n\nexport class Client {\n  constructor(opts) {\n    this.clientID = opts.clientID || opts.client_id || ''\n    this.clientSecret = opts.clientSecret || opts.client_secret || ''\n    this.registrationAccessToken =\n      opts.registrationAccessToken || opts.registration_access_token || ''\n\n    if (opts.redirect_uris) {\n      this.redirectURI = opts.redirect_uris[0] || ''\n    } else {\n      this.redirectURI = opts.redirectURI || ''\n    }\n\n    this.softwareID = opts.softwareID || opts.software_id || ''\n    this.softwareVersion = opts.softwareVersion || opts.software_version || ''\n    this.clientName = opts.clientName || opts.client_name || ''\n    this.clientKind = opts.clientKind || opts.client_kind || ''\n    this.clientURI = opts.clientURI || opts.client_uri || ''\n\n    this.logoURI = opts.logoURI || opts.logo_uri || ''\n    this.policyURI = opts.policyURI || opts.policy_uri || ''\n\n    this.notificationPlatform =\n      opts.notificationPlatform || opts.notification_platform || ''\n    this.notificationDeviceToken =\n      opts.notificationDeviceToken || opts.notification_device_token || ''\n\n    if (!this.registrationAccessToken) {\n      if (this.redirectURI === '') {\n        throw new Error('Missing redirectURI field')\n      }\n      if (this.softwareID === '') {\n        throw new Error('Missing softwareID field')\n      }\n      if (this.clientName === '') {\n        throw new Error('Missing clientName field')\n      }\n    }\n  }\n\n  isRegistered() {\n    return this.clientID !== ''\n  }\n\n  toRegisterJSON() {\n    return {\n      redirect_uris: [this.redirectURI],\n      software_id: this.softwareID,\n      software_version: this.softwareVersion,\n      client_name: this.clientName,\n      client_kind: this.clientKind,\n      client_uri: this.clientURI,\n      logo_uri: this.logoURI,\n      policy_uri: this.policyURI,\n      notification_platform: this.notificationPlatform,\n      notification_device_token: this.notificationDeviceToken\n    }\n  }\n\n  toAuthHeader() {\n    return 'Bearer ' + this.registrationAccessToken\n  }\n}\n\nexport class AccessToken {\n  constructor(opts) {\n    this.tokenType = opts.tokenType || opts.token_type\n    this.accessToken = opts.accessToken || opts.access_token\n    this.refreshToken = opts.refreshToken || opts.refresh_token\n    this.scope = opts.scope\n  }\n\n  toAuthHeader() {\n    return 'Bearer ' + this.accessToken\n  }\n\n  toBasicAuth() {\n    return `user:${this.accessToken}@`\n  }\n}\n\nexport class AppToken {\n  constructor(opts) {\n    this.token = opts.token || ''\n  }\n\n  toAuthHeader() {\n    return 'Bearer ' + this.token\n  }\n\n  toBasicAuth() {\n    return `user:${this.token}@`\n  }\n}\n\nexport function client(cozy, clientParams) {\n  if (!clientParams) {\n    clientParams = cozy._clientParams\n  }\n  if (clientParams instanceof Client) {\n    return clientParams\n  }\n  return new Client(clientParams)\n}\n\nexport function registerClient(cozy, clientParams) {\n  const cli = client(cozy, clientParams)\n  if (cli.isRegistered()) {\n    return Promise.reject(new Error('Client already registered'))\n  }\n  return cozyFetchJSON(cozy, 'POST', '/auth/register', cli.toRegisterJSON(), {\n    disableAuth: true\n  }).then(data => new Client(data))\n}\n\nexport function updateClient(cozy, clientParams, resetSecret = false) {\n  const cli = client(cozy, clientParams)\n  if (!cli.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  let data = cli.toRegisterJSON()\n  data.client_id = cli.clientID\n  if (resetSecret) data.client_secret = cli.clientSecret\n\n  return cozyFetchJSON(cozy, 'PUT', `/auth/register/${cli.clientID}`, data, {\n    manualAuthCredentials: {\n      token: cli\n    }\n  }).then(data => createClient(data, cli))\n}\n\nexport function unregisterClient(cozy, clientParams) {\n  const cli = client(cozy, clientParams)\n  if (!cli.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  return cozyFetchJSON(cozy, 'DELETE', `/auth/register/${cli.clientID}`, null, {\n    manualAuthCredentials: {\n      token: cli\n    }\n  })\n}\n\n// getClient will retrive the registered client informations from the server.\nexport function getClient(cozy, clientParams) {\n  const cli = client(cozy, clientParams)\n  if (!cli.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  if (isOffline()) {\n    return Promise.resolve(cli)\n  }\n  return cozyFetchJSON(cozy, 'GET', `/auth/register/${cli.clientID}`, null, {\n    manualAuthCredentials: {\n      token: cli\n    }\n  })\n    .then(data => createClient(data, cli))\n    .catch(err => {\n      // If we fall into an error while fetching the client (because of a\n      // bad connectivity for instance), we do not bail the whole process\n      // since the client should be able to continue with the persisted\n      // client and token.\n      //\n      // If it is an explicit Unauthorized error though, we bail, clear th\n      // cache and retry.\n      if (FetchError.isUnauthorized(err) || FetchError.isNotFound(err)) {\n        throw new Error('Client has been revoked')\n      }\n      throw err\n    })\n}\n\n// createClient returns a new Client instance given on object containing the\n// data of the client, from the API, and an old instance of the client.\nfunction createClient(data, oldClient) {\n  const newClient = new Client(data)\n  // we need to keep track of the registrationAccessToken since it is send\n  // only on registration. The GET /auth/register/:client-id endpoint does\n  // not return this token.\n  const shouldPassRegistration =\n    !!oldClient &&\n    oldClient.registrationAccessToken !== '' &&\n    newClient.registrationAccessToken === ''\n  if (shouldPassRegistration) {\n    newClient.registrationAccessToken = oldClient.registrationAccessToken\n  }\n  return newClient\n}\n\n// getAuthCodeURL returns a pair {authURL,state} given a registered client. The\n// state should be stored in order to be checked against on the user validation\n// phase.\nexport function getAuthCodeURL(cozy, client, scopes = []) {\n  if (!(client instanceof Client)) {\n    client = new Client(client)\n  }\n  if (!client.isRegistered()) {\n    throw new Error('Client not registered')\n  }\n  const state = generateRandomState()\n  const query = {\n    client_id: client.clientID,\n    redirect_uri: client.redirectURI,\n    state: state,\n    response_type: 'code',\n    scope: scopes.join(' ')\n  }\n  return {\n    url: cozy._url + `/auth/authorize?${encodeQuery(query)}`,\n    state: state\n  }\n}\n\n// getAccessToken perform a request on the access_token entrypoint with the\n// authorization_code grant type in order to generate a new access token for a\n// newly registered client.\n//\n// This method extracts the access code and state from the given URL. By\n// default it uses window.location.href. Also, it checks the given state with\n// the one specified in the URL query parameter to prevent CSRF attacks.\nexport function getAccessToken(cozy, client, state, pageURL = '') {\n  if (!state) {\n    return Promise.reject(new Error('Missing state value'))\n  }\n  const grantQueries = getGrantCodeFromPageURL(pageURL)\n  if (grantQueries === null) {\n    return Promise.reject(new Error('Missing states from current URL'))\n  }\n  if (state !== grantQueries.state) {\n    return Promise.reject(\n      new Error('Given state does not match url query state')\n    )\n  }\n  return retrieveToken(cozy, client, null, {\n    grant_type: 'authorization_code',\n    code: grantQueries.code\n  })\n}\n\n// refreshToken perform a request on the access_token entrypoint with the\n// refresh_token grant type in order to refresh the given token.\nexport function refreshToken(cozy, client, token) {\n  return retrieveToken(cozy, client, token, {\n    grant_type: 'refresh_token',\n    refresh_token: token.refreshToken\n  })\n}\n\n// oauthFlow performs the stateful registration and access granting of an OAuth\n// client.\nexport function oauthFlow(\n  cozy,\n  storage,\n  clientParams,\n  onRegistered,\n  ignoreCachedCredentials = false\n) {\n  if (ignoreCachedCredentials) {\n    return storage\n      .clear()\n      .then(() => oauthFlow(cozy, storage, clientParams, onRegistered, false))\n  }\n\n  let tryCount = 0\n\n  function clearAndRetry(err) {\n    if (tryCount++ > 0) {\n      throw err\n    }\n    return storage\n      .clear()\n      .then(() => oauthFlow(cozy, storage, clientParams, onRegistered))\n  }\n\n  function registerNewClient() {\n    return storage\n      .clear()\n      .then(() => registerClient(cozy, clientParams))\n      .then(client => {\n        const { url, state } = getAuthCodeURL(cozy, client, clientParams.scopes)\n        return storage.save(StateKey, { client, url, state })\n      })\n  }\n\n  return Promise.all([storage.load(CredsKey), storage.load(StateKey)])\n    .then(([credentials, storedState]) => {\n      // If credentials are cached we re-fetch the registered client with the\n      // said token. Fetching the client, if the token is outdated we should try\n      // the token is refreshed.\n      if (credentials) {\n        let oldClient, token\n        try {\n          oldClient = new Client(credentials.client)\n          token = new AccessToken(credentials.token)\n        } catch (err) {\n          // bad cache, we should clear and retry the process\n          return clearAndRetry(err)\n        }\n        return getClient(cozy, oldClient)\n          .then(client => ({ client, token }))\n          .catch(err => {\n            // If we fall into an error while fetching the client (because of a\n            // bad connectivity for instance), we do not bail the whole process\n            // since the client should be able to continue with the persisted\n            // client and token.\n            //\n            // If it is an explicit Unauthorized error though, we bail, clear th\n            // cache and retry.\n            if (FetchError.isUnauthorized(err) || FetchError.isNotFound(err)) {\n              throw new Error('Client has been revoked')\n            }\n            return { client: oldClient, token }\n          })\n      }\n\n      // Otherwise register a new client if necessary (ie. no client is stored)\n      // and call the onRegistered callback to wait for the user to grant the\n      // access. Finally fetches to access token on success.\n      let statePromise\n      if (!storedState) {\n        statePromise = registerNewClient()\n      } else {\n        statePromise = Promise.resolve(storedState)\n      }\n\n      let client, state, token\n      return statePromise\n        .then(data => {\n          client = data.client\n          state = data.state\n          return Promise.resolve(onRegistered(client, data.url))\n        })\n        .then(pageURL => getAccessToken(cozy, client, state, pageURL))\n        .then(t => {\n          token = t\n        })\n        .then(() => storage.delete(StateKey))\n        .then(() => ({ client, token }))\n    })\n    .then(\n      creds => storage.save(CredsKey, creds),\n      err => {\n        if (FetchError.isUnauthorized(err)) {\n          return clearAndRetry(err)\n        } else {\n          throw err\n        }\n      }\n    )\n}\n\n// retrieveToken perform a request on the access_token entrypoint in order to\n// fetch a token.\nfunction retrieveToken(cozy, client, token, query) {\n  if (!(client instanceof Client)) {\n    client = new Client(client)\n  }\n  if (!client.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  const body = encodeQuery(\n    Object.assign({}, query, {\n      client_id: client.clientID,\n      client_secret: client.clientSecret\n    })\n  )\n  return cozyFetchJSON(cozy, 'POST', '/auth/access_token', body, {\n    disableAuth: token === null,\n    dontRetry: true,\n    manualAuthCredentials: { client, token },\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n  }).then(data => {\n    data.refreshToken = data.refreshToken || query.refresh_token\n    return new AccessToken(data)\n  })\n}\n\n// getGrantCodeFromPageURL extract the state and code query parameters from the\n// given url\nfunction getGrantCodeFromPageURL(pageURL = '') {\n  if (pageURL === '' && typeof window !== 'undefined') {\n    pageURL = window.location.href\n  }\n  const queries = decodeQuery(pageURL)\n  if (!queries.hasOwnProperty('state')) {\n    return null\n  }\n  return {\n    state: queries['state'],\n    code: queries['code']\n  }\n}\n\n// generateRandomState will try to generate a 128bits random value from a secure\n// pseudo random generator. It will fallback on Math.random if it cannot find\n// such generator.\nfunction generateRandomState() {\n  let buffer\n  if (\n    typeof window !== 'undefined' &&\n    typeof window.crypto !== 'undefined' &&\n    typeof window.crypto.getRandomValues === 'function'\n  ) {\n    buffer = new Uint8Array(StateSize)\n    window.crypto.getRandomValues(buffer)\n  } else {\n    try {\n      buffer = require('crypto').randomBytes(StateSize)\n    } catch (e) {\n      buffer = null\n    }\n  }\n  if (!buffer) {\n    buffer = new Array(StateSize)\n    for (let i = 0; i < buffer.length; i++) {\n      buffer[i] = Math.floor(Math.random() * 255)\n    }\n  }\n  return btoa(String.fromCharCode.apply(null, buffer))\n    .replace(/=+$/, '')\n    .replace(/\\//g, '_')\n    .replace(/\\+/g, '-')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/auth_v3.js","// helper to serialize/deserialize an error for/from postMessage\nexport const errorSerializer = (() => {\n  function mapErrorProperties(from, to) {\n    const result = Object.assign(to, from)\n    const nativeProperties = ['name', 'message']\n    return nativeProperties.reduce((result, property) => {\n      if (from[property]) {\n        to[property] = from[property]\n      }\n      return result\n    }, result)\n  }\n  return {\n    serialize: error => mapErrorProperties(error, {}),\n    deserialize: data => mapErrorProperties(data, new Error(data.message))\n  }\n})()\n\nconst first = arr => arr && arr[0]\n// In a far future, the user will have to pick the desired service from a list.\n// For now it's our job, an easy job as we arbitrary pick the first service of\n// the list.\nexport function pickService(intent, filterServices) {\n  const services = intent.attributes.services\n  const filteredServices = filterServices\n    ? (services || []).filter(filterServices)\n    : services\n  return first(filteredServices)\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/intents/helpers.js","var core = module.exports = { version: '2.5.7' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_core.js\n// module id = 10\n// module chunks = 0","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_descriptors.js\n// module id = 11\n// module chunks = 0","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_fails.js\n// module id = 12\n// module chunks = 0","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_is-object.js\n// module id = 13\n// module chunks = 0","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/immediate/lib/browser.js\n// module id = 14\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\nexports.collate = collate;\nexports.normalizeKey = normalizeKey;\nexports.toIndexableString = toIndexableString;\nexports.parseIndexableString = parseIndexableString;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-collate/lib/index.js\n// module id = 15\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    exports.Set = Set;\n    exports.Map = Map;\n  } else { // fall back to our polyfill\n    exports.Set = Set$1;\n    exports.Map = Map$1;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-collections/lib/index.js\n// module id = 16\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(require('lie'));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nmodule.exports = PouchPromise;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-promise/lib/index.js\n// module id = 17\n// module chunks = 0","import { cozyFetchJSON } from '../fetch'\nimport { pickService } from './helpers'\nimport * as client from './client'\nimport * as service from './service'\n\nexport function create(cozy, action, type, data = {}, permissions = []) {\n  if (!action)\n    throw new Error(`Misformed intent, \"action\" property must be provided`)\n  if (!type)\n    throw new Error(`Misformed intent, \"type\" property must be provided`)\n\n  const createPromise = cozyFetchJSON(cozy, 'POST', '/intents', {\n    data: {\n      type: 'io.cozy.intents',\n      attributes: {\n        action: action,\n        type: type,\n        data: data,\n        permissions: permissions\n      }\n    }\n  })\n\n  createPromise.start = (element, onReadyCallback) => {\n    const options = {\n      filteredServices: data.filteredServices,\n      onReadyCallback: onReadyCallback\n    }\n\n    delete data.filteredServices\n\n    return createPromise.then(intent =>\n      client.start(cozy, intent, element, data, options)\n    )\n  }\n\n  return createPromise\n}\n\n// returns a service to communicate with intent client\nexport function createService(cozy, intentId, serviceWindow) {\n  return service.start(cozy, intentId, serviceWindow)\n}\n\nfunction removeQueryString(url) {\n  return url.replace(/\\?[^/#]*/, '')\n}\n\n// Redirect to an app able to handle the doctype\n// Redirections are more or less a hack of the intent API to retrieve an URL for\n// accessing a given doctype or a given document.\n// It needs to use a special action `REDIRECT`\nexport async function getRedirectionURL(cozy, type, data) {\n  if (!type && !data)\n    throw new Error(\n      `Cannot retrieve redirection, at least type or doc must be provided`\n    )\n\n  const intent = await create(cozy, 'REDIRECT', type, data)\n\n  const service = pickService(intent)\n  if (!service) throw new Error('Unable to find a service')\n\n  // Intents cannot be deleted now\n  // await deleteIntent(cozy, intent)\n\n  const baseURL = removeQueryString(service.href)\n  return data ? buildRedirectionURL(baseURL, data) : baseURL\n}\n\nfunction isSerializable(value) {\n  return !['object', 'function'].includes(typeof value)\n}\n\nfunction buildRedirectionURL(url, data) {\n  const parameterStrings = Object.keys(data)\n    .filter(key => isSerializable(data[key]))\n    .map(key => `${key}=${data[key]}`)\n\n  return parameterStrings.length ? `${url}?${parameterStrings.join('&')}` : url\n}\n\nexport async function redirect(cozy, type, doc, redirectFn) {\n  if (!window)\n    throw new Error('redirect() method can only be called in a browser')\n  const redirectionURL = await getRedirectionURL(cozy, type, doc)\n  if (redirectFn && typeof redirectFn === 'function') {\n    return redirectFn(redirectionURL)\n  }\n\n  window.location.href = redirectionURL\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/intents/index.js","function indexKey(doc) {\n  return doc.type + '/' + doc.id\n}\n\nfunction findByRef(resources, ref) {\n  return resources[indexKey(ref)]\n}\n\nfunction handleResource(rawResource, resources, links) {\n  let resource = {\n    _id: rawResource.id,\n    _type: rawResource.type,\n    _rev: rawResource.meta && rawResource.meta.rev,\n    links: Object.assign({}, rawResource.links, links),\n    attributes: rawResource.attributes,\n    relations: name => {\n      let rels = rawResource.relationships[name]\n      if (rels === undefined || rels.data === undefined) return undefined\n      if (rels.data === null) return null\n      if (!Array.isArray(rels.data)) return findByRef(resources, rels.data)\n      return rels.data.map(ref => findByRef(resources, ref))\n    }\n  }\n  if (rawResource.relationships) {\n    resource.relationships = rawResource.relationships\n  }\n\n  resources[indexKey(rawResource)] = resource\n\n  return resource\n}\n\nfunction handleTopLevel(doc, resources = {}) {\n  // build an index of included resource by Type & ID\n  const included = doc.included\n\n  if (Array.isArray(included)) {\n    included.forEach(r => handleResource(r, resources, doc.links))\n  }\n\n  if (Array.isArray(doc.data)) {\n    return doc.data.map(r => handleResource(r, resources, doc.links))\n  } else {\n    return handleResource(doc.data, resources, doc.links)\n  }\n}\n\nexport default handleTopLevel\n\n\n\n// WEBPACK FOOTER //\n// ./src/jsonapi.js","module.exports = require(\"regenerator-runtime\");\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/regenerator/index.js\n// module id = 20\n// module chunks = 0","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_defined.js\n// module id = 21\n// module chunks = 0","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_has.js\n// module id = 22\n// module chunks = 0","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_hide.js\n// module id = 23\n// module chunks = 0","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_iobject.js\n// module id = 24\n// module chunks = 0","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-integer.js\n// module id = 25\n// module chunks = 0","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-iobject.js\n// module id = 26\n// module chunks = 0","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_uid.js\n// module id = 27\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 28\n// module chunks = 0","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && (typeof obj === 'object' || typeof obj === 'function') && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lie/lib/browser.js\n// module id = 29\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\nfunction typedBuffer() {\n}\n\nexports.atob = thisAtob;\nexports.btoa = thisBtoa;\nexports.base64StringToBlobOrBuffer = b64ToBluffer;\nexports.binaryStringToArrayBuffer = binaryStringToArrayBuffer;\nexports.binaryStringToBlobOrBuffer = binStringToBluffer;\nexports.blob = createBlob;\nexports.blobOrBufferToBase64 = blobToBase64;\nexports.blobOrBufferToBinaryString = blobToBinaryString;\nexports.readAsArrayBuffer = readAsArrayBuffer;\nexports.readAsBinaryString = readAsBinaryString;\nexports.typedBuffer = typedBuffer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-binary-utils/lib/index-browser.js\n// module id = 30\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar pouchdbBinaryUtils = require('pouchdb-binary-utils');\nvar Md5 = _interopDefault(require('spark-md5'));\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return pouchdbBinaryUtils.btoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  pouchdbBinaryUtils.readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nexports.binaryMd5 = binaryMd5;\nexports.stringMd5 = stringMd5;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-md5/lib/index-browser.js\n// module id = 31\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 32\n// module chunks = 0","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/spark-md5/spark-md5.js\n// module id = 33\n// module chunks = 0","var v1 = require('./v1');\nvar v4 = require('./v4');\n\nvar uuid = v4;\nuuid.v1 = v1;\nuuid.v4 = v4;\n\nmodule.exports = uuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/index.js\n// module id = 34\n// module chunks = 0","/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).substr(1);\n}\n\nfunction bytesToUuid(buf, offset) {\n  var i = offset || 0;\n  var bth = byteToHex;\n  return bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] + '-' +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]] +\n          bth[buf[i++]] + bth[buf[i++]];\n}\n\nmodule.exports = bytesToUuid;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/bytesToUuid.js\n// module id = 35\n// module chunks = 0","// Unique ID creation requires a high quality random # generator.  In the\n// browser this is a little complicated due to unknown quality of Math.random()\n// and inconsistent support for the `crypto` API.  We do the best we can via\n// feature-detection\n\n// getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\nvar getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues.bind(crypto)) ||\n                      (typeof(msCrypto) != 'undefined' && msCrypto.getRandomValues.bind(msCrypto));\nif (getRandomValues) {\n  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto\n  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef\n\n  module.exports = function whatwgRNG() {\n    getRandomValues(rnds8);\n    return rnds8;\n  };\n} else {\n  // Math.random()-based (RNG)\n  //\n  // If all else fails, use Math.random().  It's fast, but is of unspecified\n  // quality.\n  var rnds = new Array(16);\n\n  module.exports = function mathRNG() {\n    for (var i = 0, r; i < 16; i++) {\n      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;\n      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;\n    }\n\n    return rnds;\n  };\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/lib/rng-browser.js\n// module id = 36\n// module chunks = 0","export class LocalStorage {\n  constructor(storage, prefix) {\n    if (!storage && typeof window !== 'undefined') {\n      storage = window.localStorage\n    }\n    this.storage = storage\n    this.prefix = prefix || 'cozy:oauth:'\n  }\n\n  save(key, value) {\n    return new Promise(resolve => {\n      this.storage.setItem(this.prefix + key, JSON.stringify(value))\n      resolve(value)\n    })\n  }\n\n  load(key) {\n    return new Promise(resolve => {\n      const item = this.storage.getItem(this.prefix + key)\n      if (!item) {\n        resolve()\n      } else {\n        resolve(JSON.parse(item))\n      }\n    })\n  }\n\n  delete(key) {\n    return new Promise(resolve =>\n      resolve(this.storage.removeItem(this.prefix + key))\n    )\n  }\n\n  clear() {\n    return new Promise(resolve => {\n      const storage = this.storage\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i)\n        if (key.indexOf(this.prefix) === 0) {\n          storage.removeItem(key)\n        }\n      }\n      resolve()\n    })\n  }\n}\n\nexport class MemoryStorage {\n  constructor() {\n    this.hash = Object.create(null)\n  }\n\n  save(key, value) {\n    this.hash[key] = value\n    return Promise.resolve(value)\n  }\n\n  load(key) {\n    return Promise.resolve(this.hash[key])\n  }\n\n  delete(key) {\n    const deleted = delete this.hash[key]\n    return Promise.resolve(deleted)\n  }\n\n  clear() {\n    this.hash = Object.create(null)\n    return Promise.resolve()\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/auth_storage.js","/* global btoa */\nconst V2TOKEN_ABORT_TIMEOUT = 3000\n\nexport function getAppToken() {\n  return new Promise(function(resolve, reject) {\n    if (typeof window === 'undefined') {\n      return reject(new Error('getV2Token should be used in browser'))\n    } else if (!window.parent) {\n      return reject(new Error('getV2Token should be used in iframe'))\n    } else if (!window.parent.postMessage) {\n      return reject(new Error('getV2Token should be used in modern browser'))\n    }\n    const origin = window.location.origin\n    const intent = { action: 'getToken' }\n    let timeout = null\n    const receiver = function(event) {\n      let token\n      try {\n        token = new AppToken({\n          appName: event.data.appName,\n          token: event.data.token\n        })\n      } catch (e) {\n        reject(e)\n        return\n      }\n      window.removeEventListener('message', receiver)\n      clearTimeout(timeout)\n      resolve({ client: null, token })\n    }\n    window.addEventListener('message', receiver, false)\n    window.parent.postMessage(intent, origin)\n    timeout = setTimeout(() => {\n      reject(new Error('No response from parent iframe after 3s'))\n    }, V2TOKEN_ABORT_TIMEOUT)\n  })\n}\n\nexport class AppToken {\n  constructor(opts) {\n    this.appName = opts.appName || ''\n    this.token = opts.token || ''\n  }\n\n  toAuthHeader() {\n    return 'Basic ' + btoa(`${this.appName}:${this.token}`)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/auth_v2.js","import { createPath } from './utils'\nimport { normalizeDoctype } from './doctypes'\nimport { cozyFetchJSON } from './fetch'\n\nconst NOREV = 'stack-v2-no-rev'\n\nexport function create(cozy, doctype, attributes) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    if (isV2) {\n      attributes.docType = doctype\n    }\n    const path = createPath(cozy, isV2, doctype, attributes._id)\n    const httpVerb = attributes._id ? 'PUT' : 'POST'\n    delete attributes._id\n    return cozyFetchJSON(cozy, httpVerb, path, attributes).then(resp => {\n      if (isV2) {\n        return find(cozy, doctype, resp._id)\n      } else {\n        return resp.data\n      }\n    })\n  })\n}\n\nexport function find(cozy, doctype, id) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n\n    if (!id) {\n      return Promise.reject(new Error('Missing id parameter'))\n    }\n\n    const path = createPath(cozy, isV2, doctype, id)\n    return cozyFetchJSON(cozy, 'GET', path).then(resp => {\n      if (isV2) {\n        return Object.assign(resp, { _rev: NOREV })\n      } else {\n        return resp\n      }\n    })\n  })\n}\n\nexport function findMany(cozy, doctype, ids) {\n  if (!(ids instanceof Array)) {\n    return Promise.reject(new Error('Parameter ids must be a non-empty array'))\n  }\n  if (ids.length === 0) {\n    // So users don't need to be defensive regarding the array content.\n    // This should not hide issues in user code since the result will be an\n    // empty object anyway.\n    return Promise.resolve({})\n  }\n\n  return cozy.isV2().then(isV2 => {\n    if (isV2) {\n      return Promise.reject(new Error('findMany is not available on v2'))\n    }\n\n    const path = createPath(cozy, isV2, doctype, '_all_docs', {\n      include_docs: true\n    })\n\n    return cozyFetchJSON(cozy, 'POST', path, { keys: ids })\n      .then(resp => {\n        const docs = {}\n\n        for (const row of resp.rows) {\n          const { key, doc, error } = row\n          docs[key] = error ? { error } : { doc }\n        }\n\n        return docs\n      })\n      .catch(error => {\n        if (error.status !== 404) return Promise.reject(error)\n\n        // When no doc was ever created and the database does not exist yet,\n        // the response will be a 404 error.\n        const docs = {}\n\n        for (const id of ids) {\n          docs[id] = { error }\n        }\n\n        return docs\n      })\n  })\n}\n\nexport function findAll(cozy, doctype) {\n  return cozy.isV2().then(isV2 => {\n    if (isV2) {\n      return Promise.reject(new Error('findAll is not available on v2'))\n    }\n\n    const path = createPath(cozy, isV2, doctype, '_all_docs', {\n      include_docs: true\n    })\n\n    return cozyFetchJSON(cozy, 'POST', path, {})\n      .then(resp => {\n        const docs = []\n\n        for (const row of resp.rows) {\n          const { doc } = row\n          // if not couchDB indexes\n          if (!doc._id.match(/_design\\//)) docs.push(doc)\n        }\n        return docs\n      })\n      .catch(error => {\n        // the _all_docs endpoint returns a 404 error if no document with the given\n        // doctype exists.\n        if (error.status === 404) return []\n        throw error\n      })\n  })\n}\n\nexport function changesFeed(cozy, doctype, options) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    const path = createPath(cozy, isV2, doctype, '_changes', options)\n    return cozyFetchJSON(cozy, 'GET', path)\n  })\n}\n\nexport function update(cozy, doctype, doc, changes) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    const { _id, _rev } = doc\n\n    if (!_id) {\n      return Promise.reject(new Error('Missing _id field in passed document'))\n    }\n\n    if (!isV2 && !_rev) {\n      return Promise.reject(new Error('Missing _rev field in passed document'))\n    }\n\n    if (isV2) {\n      changes = Object.assign({ _id }, changes)\n    } else {\n      changes = Object.assign({ _id, _rev }, changes)\n    }\n\n    const path = createPath(cozy, isV2, doctype, _id)\n    return cozyFetchJSON(cozy, 'PUT', path, changes).then(resp => {\n      if (isV2) {\n        return find(cozy, doctype, _id)\n      } else {\n        return resp.data\n      }\n    })\n  })\n}\n\nexport function updateAttributes(cozy, doctype, _id, changes, tries = 3) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    return find(cozy, doctype, _id)\n      .then(doc => {\n        return update(cozy, doctype, doc, Object.assign({ _id }, doc, changes))\n      })\n      .catch(err => {\n        if (tries > 0) {\n          return updateAttributes(cozy, doctype, _id, changes, tries - 1)\n        } else {\n          throw err\n        }\n      })\n  })\n}\n\nexport function _delete(cozy, doctype, doc) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    const { _id, _rev } = doc\n\n    if (!_id) {\n      return Promise.reject(new Error('Missing _id field in passed document'))\n    }\n\n    if (!isV2 && !_rev) {\n      return Promise.reject(new Error('Missing _rev field in passed document'))\n    }\n\n    const query = isV2 ? null : { rev: _rev }\n    const path = createPath(cozy, isV2, doctype, _id, query)\n    return cozyFetchJSON(cozy, 'DELETE', path).then(resp => {\n      if (isV2) {\n        return { id: _id, rev: NOREV }\n      } else {\n        return resp\n      }\n    })\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/data.js","/* global Blob, File */\nimport { cozyFetch, cozyFetchJSON } from './fetch'\nimport jsonapi from './jsonapi'\nimport { DOCTYPE_FILES } from './doctypes'\n\n// global variables\nexport const ROOT_DIR_ID = 'io.cozy.files.root-dir'\nexport const TRASH_DIR_ID = 'io.cozy.files.trash-dir'\n\nconst contentTypeOctetStream = 'application/octet-stream'\n\nfunction sanitizeFileName(name) {\n  return name && name.trim()\n}\n\nfunction getFileTypeFromName(name) {\n  if (/\\.heic$/i.test(name)) return 'image/heic'\n  else if (/\\.heif$/i.test(name)) return 'image/heif'\n  else return null\n}\n\nfunction doUpload(cozy, data, method, path, options) {\n  if (!data) {\n    throw new Error('missing data argument')\n  }\n\n  // transform any ArrayBufferView to ArrayBuffer\n  if (data.buffer && data.buffer instanceof ArrayBuffer) {\n    data = data.buffer\n  }\n\n  const isBuffer =\n    typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer\n  const isFile = typeof File !== 'undefined' && data instanceof File\n  const isBlob = typeof Blob !== 'undefined' && data instanceof Blob\n  const isStream = data.readable === true && typeof data.pipe === 'function'\n  const isString = typeof data === 'string'\n\n  if (!isBuffer && !isFile && !isBlob && !isStream && !isString) {\n    throw new Error('invalid data type')\n  }\n\n  let { contentType, contentLength, checksum, lastModifiedDate, ifMatch } =\n    options || {}\n  if (!contentType) {\n    if (isBuffer) {\n      contentType = contentTypeOctetStream\n    } else if (isFile) {\n      contentType =\n        data.type ||\n        getFileTypeFromName(data.name.toLowerCase()) ||\n        contentTypeOctetStream\n      if (!lastModifiedDate) {\n        lastModifiedDate = data.lastModifiedDate\n      }\n    } else if (isBlob) {\n      contentType = data.type || contentTypeOctetStream\n    } else if (isStream) {\n      contentType = contentTypeOctetStream\n    } else if (typeof data === 'string') {\n      contentType = 'text/plain'\n    }\n  }\n\n  if (lastModifiedDate && typeof lastModifiedDate === 'string') {\n    lastModifiedDate = new Date(lastModifiedDate)\n  }\n\n  const headers = {\n    'Content-Type': contentType\n  }\n  if (contentLength) headers['Content-Length'] = String(contentLength)\n  if (checksum) headers['Content-MD5'] = checksum\n  if (lastModifiedDate) headers['Date'] = lastModifiedDate.toGMTString()\n  if (ifMatch) headers['If-Match'] = ifMatch\n\n  return cozyFetch(cozy, path, {\n    method: method,\n    headers: headers,\n    body: data\n  }).then(res => {\n    const json = res.json()\n    if (!res.ok) {\n      return json.then(err => {\n        throw err\n      })\n    } else {\n      return json.then(jsonapi)\n    }\n  })\n}\n\nexport function create(cozy, data, options) {\n  let { name, dirID, executable } = options || {}\n\n  // handle case where data is a file and contains the name\n  if (!name && typeof data.name === 'string') {\n    name = data.name\n  }\n\n  name = sanitizeFileName(name)\n\n  if (typeof name !== 'string' || name === '') {\n    throw new Error('missing name argument')\n  }\n\n  if (executable === undefined) {\n    executable = false\n  }\n\n  const path = `/files/${encodeURIComponent(dirID || '')}`\n  const query = `?Name=${encodeURIComponent(\n    name\n  )}&Type=file&Executable=${executable}`\n  return doUpload(cozy, data, 'POST', `${path}${query}`, options)\n}\n\nexport function createDirectory(cozy, options) {\n  let { name, dirID, lastModifiedDate } = options || {}\n\n  name = sanitizeFileName(name)\n\n  if (typeof name !== 'string' || name === '') {\n    throw new Error('missing name argument')\n  }\n\n  if (lastModifiedDate && typeof lastModifiedDate === 'string') {\n    lastModifiedDate = new Date(lastModifiedDate)\n  }\n\n  const path = `/files/${encodeURIComponent(dirID || '')}`\n  const query = `?Name=${encodeURIComponent(name)}&Type=directory`\n  return cozyFetchJSON(cozy, 'POST', `${path}${query}`, undefined, {\n    headers: {\n      Date: lastModifiedDate ? lastModifiedDate.toGMTString() : ''\n    }\n  })\n}\n\nfunction getDirectoryOrCreate(cozy, name, parentDirectory) {\n  if (parentDirectory && !parentDirectory.attributes)\n    throw new Error('Malformed parent directory')\n\n  name = sanitizeFileName(name)\n\n  const path = `${\n    parentDirectory._id === ROOT_DIR_ID ? '' : parentDirectory.attributes.path\n  }/${name}`\n\n  return cozy.files.statByPath(path || '/').catch(error => {\n    const parsedError = JSON.parse(error.message)\n    const errors = parsedError.errors\n    if (errors && errors.length && errors[0].status === '404') {\n      return cozy.files.createDirectory({\n        name: name,\n        dirID: parentDirectory && parentDirectory._id\n      })\n    }\n\n    throw errors\n  })\n}\n\nexport function createDirectoryByPath(cozy, path, offline) {\n  const parts = path.split('/').filter(part => part !== '')\n\n  const rootDirectoryPromise = cozy.files.statById(ROOT_DIR_ID, offline)\n\n  return parts.length\n    ? parts.reduce((parentDirectoryPromise, part) => {\n        return parentDirectoryPromise.then(parentDirectory =>\n          getDirectoryOrCreate(cozy, part, parentDirectory)\n        )\n      }, rootDirectoryPromise)\n    : rootDirectoryPromise\n}\n\nexport function updateById(cozy, id, data, options) {\n  return doUpload(\n    cozy,\n    data,\n    'PUT',\n    `/files/${encodeURIComponent(id)}`,\n    options\n  )\n}\n\nfunction doUpdateAttributes(cozy, attrs, path, options) {\n  if (!attrs || typeof attrs !== 'object') {\n    throw new Error('missing attrs argument')\n  }\n\n  const { ifMatch } = options || {}\n  const body = {\n    data: {\n      attributes: Object.assign({}, attrs, {\n        name: sanitizeFileName(attrs.name)\n      })\n    }\n  }\n  return cozyFetchJSON(cozy, 'PATCH', path, body, {\n    headers: {\n      'If-Match': ifMatch || ''\n    }\n  })\n}\n\nexport function updateAttributesById(cozy, id, attrs, options) {\n  return doUpdateAttributes(\n    cozy,\n    attrs,\n    `/files/${encodeURIComponent(id)}`,\n    options\n  )\n}\n\nexport function updateAttributesByPath(cozy, path, attrs, options) {\n  return doUpdateAttributes(\n    cozy,\n    attrs,\n    `/files/metadata?Path=${encodeURIComponent(path)}`,\n    options\n  )\n}\n\nexport function trashById(cozy, id, options) {\n  if (typeof id !== 'string' || id === '') {\n    throw new Error('missing id argument')\n  }\n  const { ifMatch } = options || {}\n  return cozyFetchJSON(\n    cozy,\n    'DELETE',\n    `/files/${encodeURIComponent(id)}`,\n    undefined,\n    {\n      headers: {\n        'If-Match': ifMatch || ''\n      }\n    }\n  )\n}\n\nexport function statById(cozy, id, offline = true, options = {}) {\n  if (offline && cozy.offline.hasDatabase(DOCTYPE_FILES)) {\n    let db = cozy.offline.getDatabase(DOCTYPE_FILES)\n    return Promise.all([\n      db.get(id),\n      db.find(Object.assign({ selector: { dir_id: id } }, options))\n    ]).then(([doc, children]) => {\n      if (id === ROOT_DIR_ID) {\n        children.docs = children.docs.filter(doc => doc._id !== TRASH_DIR_ID)\n      }\n      children = sortFiles(\n        children.docs.map(doc => addIsDir(toJsonApi(cozy, doc)))\n      )\n      return addIsDir(toJsonApi(cozy, doc, children))\n    })\n  }\n  const query =\n    Object.keys(options).length === 0 ? '' : `?${encodePageOptions(options)}`\n  return cozyFetchJSON(\n    cozy,\n    'GET',\n    `/files/${encodeURIComponent(id)}${query}`\n  ).then(addIsDir)\n}\n\nexport function statByPath(cozy, path) {\n  return cozyFetchJSON(\n    cozy,\n    'GET',\n    `/files/metadata?Path=${encodeURIComponent(path)}`\n  ).then(addIsDir)\n}\n\nexport function downloadById(cozy, id) {\n  return cozyFetch(cozy, `/files/download/${encodeURIComponent(id)}`)\n}\n\nexport function downloadByPath(cozy, path) {\n  return cozyFetch(cozy, `/files/download?Path=${encodeURIComponent(path)}`)\n}\n\nfunction extractResponseLinkRelated(res) {\n  let href = res.links && res.links.related\n  if (!href) throw new Error('No related link in server response')\n  return href\n}\n\nexport function getDownloadLinkByPath(cozy, path) {\n  return cozyFetchJSON(\n    cozy,\n    'POST',\n    `/files/downloads?Path=${encodeURIComponent(path)}`\n  ).then(extractResponseLinkRelated)\n}\n\nexport function getDownloadLinkById(cozy, id) {\n  return cozyFetchJSON(\n    cozy,\n    'POST',\n    `/files/downloads?Id=${encodeURIComponent(id)}`\n  ).then(extractResponseLinkRelated)\n}\n\nexport function getFilePath(cozy, file = {}, folder) {\n  if (!folder || !folder.attributes) {\n    throw Error('Folder should be valid with an attributes.path property')\n  }\n\n  const folderPath = folder.attributes.path.endsWith('/')\n    ? folder.attributes.path\n    : `${folder.attributes.path}/`\n\n  return `${folderPath}${file.name}`\n}\n\nexport function getCollectionShareLink(cozy, id, collectionType) {\n  if (!id) {\n    return Promise.reject(\n      Error('An id should be provided to create a share link')\n    )\n  }\n  return cozyFetchJSON(cozy, 'POST', `/permissions?codes=email`, {\n    data: {\n      type: 'io.cozy.permissions',\n      attributes: {\n        permissions: {\n          files: {\n            type: 'io.cozy.files',\n            verbs: ['GET'],\n            values: [id],\n            selector: 'referenced_by'\n          },\n          collection: {\n            type: collectionType,\n            verbs: ['GET'],\n            values: [id]\n          }\n        }\n      }\n    }\n  }).then(data => ({\n    sharecode: `sharecode=${data.attributes.codes.email}`,\n    id: `id=${id}`\n  }))\n}\n\nexport function getArchiveLinkByPaths(cozy, paths, name = 'files') {\n  const archive = {\n    type: 'io.cozy.archives',\n    attributes: {\n      name: name,\n      files: paths\n    }\n  }\n  return cozyFetchJSON(cozy, 'POST', `/files/archive`, { data: archive }).then(\n    extractResponseLinkRelated\n  )\n}\n\nexport function getArchiveLinkByIds(cozy, ids, name = 'files') {\n  const archive = {\n    type: 'io.cozy.archives',\n    attributes: {\n      name: name,\n      ids: ids\n    }\n  }\n  return cozyFetchJSON(cozy, 'POST', `/files/archive`, { data: archive }).then(\n    extractResponseLinkRelated\n  )\n}\n\nexport function listTrash(cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/files/trash`)\n}\n\nexport function clearTrash(cozy) {\n  return cozyFetchJSON(cozy, 'DELETE', `/files/trash`)\n}\n\nexport function restoreById(cozy, id) {\n  return cozyFetchJSON(cozy, 'POST', `/files/trash/${encodeURIComponent(id)}`)\n}\n\nexport function destroyById(cozy, id, options) {\n  const { ifMatch } = options || {}\n  return cozyFetchJSON(\n    cozy,\n    'DELETE',\n    `/files/trash/${encodeURIComponent(id)}`,\n    undefined,\n    {\n      headers: {\n        'If-Match': ifMatch || ''\n      }\n    }\n  )\n}\n\nfunction addIsDir(obj) {\n  obj.isDir = obj.attributes.type === 'directory'\n  return obj\n}\n\nfunction encodePageOptions(options) {\n  let opts = []\n  for (const name in options) {\n    opts.push(\n      `page[${encodeURIComponent(name)}]=${encodeURIComponent(options[name])}`\n    )\n  }\n  return opts.join('&')\n}\n\nfunction toJsonApi(cozy, doc, contents = []) {\n  let clone = JSON.parse(JSON.stringify(doc))\n  delete clone._id\n  delete clone._rev\n  return {\n    _id: doc._id,\n    _rev: doc._rev,\n    _type: DOCTYPE_FILES,\n    attributes: clone,\n    relationships: {\n      contents: {\n        data: contents,\n        meta: {\n          count: contents.length\n        }\n      }\n    },\n    relations: name => {\n      if (name === 'contents') {\n        return contents\n      }\n    }\n  }\n}\n\nfunction sortFiles(allFiles) {\n  const folders = allFiles.filter(f => f.attributes.type === 'directory')\n  const files = allFiles.filter(f => f.attributes.type !== 'directory')\n  const sort = files =>\n    files.sort((a, b) => a.attributes.name.localeCompare(b.attributes.name))\n  return sort(folders).concat(sort(files))\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/files.js","/* global fetch URL */\nimport 'core-js/modules/es6.object.assign'\nimport { unpromiser, retry, warn } from './utils'\nimport { LocalStorage, MemoryStorage } from './auth_storage'\nimport { AppToken as AppTokenV2, getAppToken as getAppTokenV2 } from './auth_v2'\nimport * as auth from './auth_v3'\nimport * as data from './data'\nimport * as cozyFetch from './fetch'\nimport * as mango from './mango'\nimport * as files from './files'\nimport * as intents from './intents/'\nimport * as jobs from './jobs'\nimport * as offline from './offline'\nimport * as settings from './settings'\nimport * as relations from './relations'\n\nconst {\n  AppToken: AppTokenV3,\n  AccessToken: AccessTokenV3,\n  Client: ClientV3\n} = auth\n\nconst AuthNone = 0\nconst AuthRunning = 1\nconst AuthError = 2\nconst AuthOK = 3\n\nconst defaultClientParams = {\n  softwareID: 'github.com/cozy/cozy-client-js'\n}\n\nconst dataProto = {\n  create: data.create,\n  find: data.find,\n  findMany: data.findMany,\n  findAll: data.findAll,\n  update: data.update,\n  delete: data._delete,\n  updateAttributes: data.updateAttributes,\n  changesFeed: data.changesFeed,\n  defineIndex: mango.defineIndex,\n  query: mango.query,\n  addReferencedFiles: relations.addReferencedFiles,\n  removeReferencedFiles: relations.removeReferencedFiles,\n  listReferencedFiles: relations.listReferencedFiles,\n  fetchReferencedFiles: relations.fetchReferencedFiles,\n  destroy: function(...args) {\n    warn('destroy is deprecated, use cozy.data.delete instead.')\n    return data._delete(...args)\n  }\n}\n\nconst authProto = {\n  client: auth.client,\n  registerClient: auth.registerClient,\n  updateClient: auth.updateClient,\n  unregisterClient: auth.unregisterClient,\n  getClient: auth.getClient,\n  getAuthCodeURL: auth.getAuthCodeURL,\n  getAccessToken: auth.getAccessToken,\n  refreshToken: auth.refreshToken\n}\n\nconst filesProto = {\n  create: files.create,\n  createDirectory: files.createDirectory,\n  createDirectoryByPath: files.createDirectoryByPath,\n  updateById: files.updateById,\n  updateAttributesById: files.updateAttributesById,\n  updateAttributesByPath: files.updateAttributesByPath,\n  trashById: files.trashById,\n  statById: files.statById,\n  statByPath: files.statByPath,\n  downloadById: files.downloadById,\n  downloadByPath: files.downloadByPath,\n  getDownloadLinkById: files.getDownloadLinkById,\n  getDownloadLink: files.getDownloadLinkByPath, // DEPRECATED, should be removed very soon\n  getDownloadLinkByPath: files.getDownloadLinkByPath,\n  getArchiveLink: function(...args) {\n    warn(\n      'getArchiveLink is deprecated, use cozy.files.getArchiveLinkByPaths instead.'\n    )\n    return files.getArchiveLinkByPaths(...args)\n  },\n  getArchiveLinkByPaths: files.getArchiveLinkByPaths,\n  getArchiveLinkByIds: files.getArchiveLinkByIds,\n  getFilePath: files.getFilePath,\n  getCollectionShareLink: files.getCollectionShareLink,\n  query: mango.queryFiles,\n  listTrash: files.listTrash,\n  clearTrash: files.clearTrash,\n  restoreById: files.restoreById,\n  destroyById: files.destroyById\n}\n\nconst intentsProto = {\n  create: intents.create,\n  createService: intents.createService,\n  getRedirectionURL: intents.getRedirectionURL,\n  redirect: intents.redirect\n}\n\nconst jobsProto = {\n  create: jobs.create,\n  count: jobs.count,\n  queued: jobs.queued\n}\n\nconst offlineProto = {\n  init: offline.init,\n  getDoctypes: offline.getDoctypes,\n  // database\n  hasDatabase: offline.hasDatabase,\n  getDatabase: offline.getDatabase,\n  createDatabase: offline.createDatabase,\n  destroyDatabase: offline.destroyDatabase,\n  destroyAllDatabase: offline.destroyAllDatabase,\n  // replication\n  hasReplication: offline.hasReplication,\n  replicateFromCozy: offline.replicateFromCozy,\n  stopReplication: offline.stopReplication,\n  stopAllReplication: offline.stopAllReplication,\n  // repeated replication\n  hasRepeatedReplication: offline.hasRepeatedReplication,\n  startRepeatedReplication: offline.startRepeatedReplication,\n  stopRepeatedReplication: offline.stopRepeatedReplication,\n  stopAllRepeatedReplication: offline.stopAllRepeatedReplication\n}\n\nconst settingsProto = {\n  diskUsage: settings.diskUsage,\n  changePassphrase: settings.changePassphrase,\n  getInstance: settings.getInstance,\n  updateInstance: settings.updateInstance,\n  getClients: settings.getClients,\n  deleteClientById: settings.deleteClientById,\n  updateLastSync: settings.updateLastSync\n}\n\nconst ensureHasReconnectParam = _url => {\n  const url = new URL(_url)\n  if (url.searchParams && !url.searchParams.has('reconnect')) {\n    url.searchParams.append('reconnect', 1)\n  } else if (!url.search || url.search.indexOf('reconnect') === -1) {\n    // Some old navigators do not have the searchParams API\n    // and it is not polyfilled by babel-polyfill\n    url.search = url.search + '&reconnect=1'\n  }\n  return url.toString()\n}\n\nclass Client {\n  constructor(options) {\n    this.data = {}\n    this.files = {}\n    this.intents = {}\n    this.jobs = {}\n    this.offline = {}\n    this.settings = {}\n    this.auth = {\n      Client: ClientV3,\n      AccessToken: AccessTokenV3,\n      AppToken: AppTokenV3,\n      AppTokenV2: AppTokenV2,\n      LocalStorage: LocalStorage,\n      MemoryStorage: MemoryStorage\n    }\n    this._inited = false\n    if (options) {\n      this.init(options)\n    }\n  }\n\n  init(options = {}) {\n    this._inited = true\n    this._oauth = false // is oauth activated or not\n    this._token = null // application token\n    this._authstate = AuthNone\n    this._authcreds = null\n    this._storage = null\n    this._version = options.version || null\n    this._offline = null\n\n    const token = options.token\n    const oauth = options.oauth\n    if (token && oauth) {\n      throw new Error(\n        'Cannot specify an application token with a oauth activated'\n      )\n    }\n\n    if (token) {\n      this._token = new AppTokenV3({ token })\n    } else if (oauth) {\n      this._oauth = true\n      this._storage = oauth.storage\n      this._clientParams = Object.assign(\n        {},\n        defaultClientParams,\n        oauth.clientParams\n      )\n      this._onRegistered = oauth.onRegistered || nopOnRegistered\n    }\n\n    let url = options.cozyURL || ''\n    while (url[url.length - 1] === '/') {\n      url = url.slice(0, -1)\n    }\n\n    this._url = url\n\n    this._invalidTokenErrorHandler =\n      options.onInvalidTokenError !== undefined\n        ? options.onInvalidTokenError\n        : cozyFetch.handleInvalidTokenError\n\n    const disablePromises = !!options.disablePromises\n    addToProto(this, this.data, dataProto, disablePromises)\n    addToProto(this, this.auth, authProto, disablePromises)\n    addToProto(this, this.files, filesProto, disablePromises)\n    addToProto(this, this.intents, intentsProto, disablePromises)\n    addToProto(this, this.jobs, jobsProto, disablePromises)\n    addToProto(this, this.offline, offlineProto, disablePromises)\n    addToProto(this, this.settings, settingsProto, disablePromises)\n\n    if (options.offline) {\n      this.offline.init(options.offline)\n    }\n\n    // Exposing cozyFetchJSON to make some development easier. Should be temporary.\n    this.fetchJSON = function _fetchJSON() {\n      const args = [this].concat(Array.prototype.slice.call(arguments))\n      return cozyFetch.cozyFetchJSON.apply(this, args)\n    }\n  }\n\n  authorize(forceTokenRefresh = false) {\n    const state = this._authstate\n    if (state === AuthOK || state === AuthRunning) {\n      return this._authcreds\n    }\n\n    this._authstate = AuthRunning\n    this._authcreds = this.isV2().then(isV2 => {\n      if (isV2 && this._oauth) {\n        throw new Error('OAuth is not supported on the V2 stack')\n      }\n      if (this._oauth) {\n        if (forceTokenRefresh && this._clientParams.redirectURI) {\n          this._clientParams.redirectURI = ensureHasReconnectParam(\n            this._clientParams.redirectURI\n          )\n        }\n        return auth.oauthFlow(\n          this,\n          this._storage,\n          this._clientParams,\n          this._onRegistered,\n          forceTokenRefresh\n        )\n      }\n      // we expect to be on a client side application running in a browser\n      // with cookie-based authentication.\n      if (isV2) {\n        return getAppTokenV2()\n      } else if (this._token) {\n        return Promise.resolve({ client: null, token: this._token })\n      } else {\n        throw new Error('Missing application token')\n      }\n    })\n\n    this._authcreds.then(\n      () => {\n        this._authstate = AuthOK\n      },\n      () => {\n        this._authstate = AuthError\n      }\n    )\n\n    return this._authcreds\n  }\n\n  saveCredentials(client, token) {\n    const creds = { client, token }\n    if (!this._storage || this._authstate === AuthRunning) {\n      return Promise.resolve(creds)\n    }\n    this._storage.save(auth.CredsKey, creds)\n    this._authcreds = Promise.resolve(creds)\n    return this._authcreds\n  }\n\n  fullpath(path) {\n    return this.isV2().then(isV2 => {\n      const pathprefix = isV2 ? '/ds-api' : ''\n      return this._url + pathprefix + path\n    })\n  }\n\n  isV2() {\n    if (!this._version) {\n      return retry(() => fetch(`${this._url}/status/`), 3)()\n        .then(res => {\n          if (!res.ok) {\n            throw new Error('Could not fetch cozy status')\n          } else {\n            return res.json()\n          }\n        })\n        .then(status => {\n          this._version = status.datasystem !== undefined ? 2 : 3\n          return this.isV2()\n        })\n    }\n    return Promise.resolve(this._version === 2)\n  }\n}\n\nfunction nopOnRegistered() {\n  throw new Error('Missing onRegistered callback')\n}\n\nfunction protoify(context, fn) {\n  return function prototyped(...args) {\n    return fn(context, ...args)\n  }\n}\n\nfunction addToProto(ctx, obj, proto, disablePromises) {\n  for (const attr in proto) {\n    let fn = protoify(ctx, proto[attr])\n    if (disablePromises) {\n      fn = unpromiser(fn)\n    }\n    obj[attr] = fn\n  }\n}\n\nmodule.exports = new Client()\nObject.assign(module.exports, { Client, LocalStorage, MemoryStorage })\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import { errorSerializer, pickService } from './helpers'\nimport { create as createIntent } from './'\n\nconst intentClass = 'coz-intent'\n\nfunction hideIntentIframe(iframe) {\n  iframe.style.display = 'none'\n}\n\nfunction showIntentFrame(iframe) {\n  iframe.style.display = 'block'\n}\n\nfunction buildIntentIframe(intent, element, url) {\n  const document = element.ownerDocument\n  if (!document)\n    return Promise.reject(\n      new Error('Cannot retrieve document object from given element')\n    )\n\n  const iframe = document.createElement('iframe')\n  // TODO: implement 'title' attribute\n  iframe.setAttribute('id', `intent-${intent._id}`)\n  iframe.setAttribute('src', url)\n  iframe.classList.add(intentClass)\n  return iframe\n}\n\nfunction injectIntentIframe(intent, element, url, options) {\n  const { onReadyCallback } = options\n  const iframe = buildIntentIframe(\n    intent,\n    element,\n    url,\n    options.onReadyCallback\n  )\n  // if callback provided for when iframe is loaded\n  if (typeof onReadyCallback === 'function') iframe.onload = onReadyCallback\n  element.appendChild(iframe)\n  iframe.focus()\n  return iframe\n}\n\n// inject iframe for service in given element\nfunction connectIntentIframe(cozy, iframe, element, intent, data) {\n  const document = element.ownerDocument\n  if (!document)\n    return Promise.reject(\n      new Error('Cannot retrieve document object from given element')\n    )\n\n  const window = document.defaultView\n  if (!window)\n    return Promise.reject(\n      new Error('Cannot retrieve window object from document')\n    )\n\n  // Keeps only http://domain:port/\n  const serviceOrigin = iframe.src.split('/', 3).join('/')\n\n  async function compose(cozy, action, doctype, data) {\n    const intent = await createIntent(cozy, action, doctype, data)\n    hideIntentIframe(iframe)\n    const doc = await start(cozy, intent, element, {\n      ...data,\n      exposeIntentFrameRemoval: false\n    })\n    showIntentFrame(iframe)\n    return doc\n  }\n\n  return new Promise((resolve, reject) => {\n    let handshaken = false\n    const messageHandler = async event => {\n      if (event.origin !== serviceOrigin) return\n\n      const eventType = event.data.type\n      if (eventType === 'load') {\n        // Safari 9.1 (At least) send a MessageEvent when the iframe loads,\n        // making the handshake fails.\n        console.warn &&\n          console.warn(\n            'Cozy Client ignored MessageEvent having data.type `load`.'\n          )\n        return\n      }\n\n      if (eventType === `intent-${intent._id}:ready`) {\n        handshaken = true\n        return event.source.postMessage(data, event.origin)\n      }\n\n      if (handshaken && eventType === `intent-${intent._id}:resize`) {\n        ;['width', 'height', 'maxWidth', 'maxHeight'].forEach(prop => {\n          if (event.data.transition)\n            element.style.transition = event.data.transition\n          if (event.data.dimensions[prop])\n            element.style[prop] = `${event.data.dimensions[prop]}px`\n        })\n\n        return true\n      }\n\n      if (handshaken && eventType === `intent-${intent._id}:compose`) {\n        // Let start to name `type` as `doctype`, as `event.data` already have a `type` attribute.\n        const { action, doctype, data } = event.data\n        const doc = await compose(cozy, action, doctype, data)\n        return event.source.postMessage(doc, event.origin)\n      }\n\n      window.removeEventListener('message', messageHandler)\n      const removeIntentFrame = () => {\n        // check if the parent node has not been already removed from the DOM\n        iframe.parentNode && iframe.parentNode.removeChild(iframe)\n      }\n\n      if (\n        handshaken &&\n        eventType === `intent-${intent._id}:exposeFrameRemoval`\n      ) {\n        return resolve({ removeIntentFrame, doc: event.data.document })\n      }\n\n      removeIntentFrame()\n\n      if (eventType === `intent-${intent._id}:error`) {\n        return reject(errorSerializer.deserialize(event.data.error))\n      }\n\n      if (handshaken && eventType === `intent-${intent._id}:cancel`) {\n        return resolve(null)\n      }\n\n      if (handshaken && eventType === `intent-${intent._id}:done`) {\n        return resolve(event.data.document)\n      }\n\n      if (!handshaken) {\n        return reject(\n          new Error('Unexpected handshake message from intent service')\n        )\n      }\n\n      // We may be in a state where the messageHandler is still attached to then\n      // window, but will not be needed anymore. For example, the service failed\n      // before adding the `unload` listener, so no `intent:cancel` message has\n      // never been sent.\n      // So we simply ignore other messages, and this listener will stay here,\n      // waiting for a message which will never come, forever (almost).\n    }\n\n    window.addEventListener('message', messageHandler)\n  })\n}\n\nexport function start(cozy, intent, element, data = {}, options = {}) {\n  const service = pickService(intent, options.filterServices)\n\n  if (!service) {\n    throw new Error('Unable to find a service')\n  }\n\n  const iframe = injectIntentIframe(intent, element, service.href, options)\n\n  return connectIntentIframe(\n    cozy,\n    iframe,\n    element,\n    intent,\n    data,\n    options.onReadyCallback\n  )\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/intents/client.js","import { cozyFetchJSON } from '../fetch'\nimport { errorSerializer } from './helpers'\n\nfunction listenClientData(intent, window) {\n  return new Promise(resolve => {\n    const messageEventListener = event => {\n      if (event.origin !== intent.attributes.client) return\n\n      window.removeEventListener('message', messageEventListener)\n      resolve(event.data)\n    }\n\n    window.addEventListener('message', messageEventListener)\n    window.parent.postMessage(\n      {\n        type: `intent-${intent._id}:ready`\n      },\n      intent.attributes.client\n    )\n  })\n}\n\n// maximize the height of an element\nfunction maximize(element) {\n  if (element && element.style) {\n    element.style.height = '100%'\n  }\n}\n\nexport function start(cozy, intentId, serviceWindow) {\n  serviceWindow = serviceWindow || (typeof window !== 'undefined' && window)\n  if (!serviceWindow || !serviceWindow.document) {\n    return Promise.reject(new Error('Intent service should be used in browser'))\n  }\n\n  // Maximize document, the whole iframe is handled by intents, clients and\n  // services\n  serviceWindow.addEventListener('load', () => {\n    const { document } = serviceWindow\n    ;[document.documentElement, document.body].forEach(maximize)\n  })\n\n  intentId = intentId || serviceWindow.location.search.split('=')[1]\n  if (!intentId)\n    return Promise.reject(new Error('Cannot retrieve intent from URL'))\n\n  return cozyFetchJSON(cozy, 'GET', `/intents/${intentId}`).then(intent => {\n    let terminated = false\n\n    const sendMessage = message => {\n      if (terminated)\n        throw new Error('Intent service has already been terminated')\n      serviceWindow.parent.postMessage(message, intent.attributes.client)\n    }\n\n    const compose = (action, doctype, data) =>\n      new Promise(resolve => {\n        const composeEventListener = event => {\n          if (event.origin !== intent.attributes.client) return\n          serviceWindow.removeEventListener('message', composeEventListener)\n          return resolve(event.data)\n        }\n\n        serviceWindow.addEventListener('message', composeEventListener)\n\n        sendMessage({\n          type: `intent-${intent._id}:compose`,\n          action,\n          doctype,\n          data\n        })\n      })\n\n    const terminate = message => {\n      sendMessage(message)\n      terminated = true\n    }\n\n    const resizeClient = (dimensions, transitionProperty) => {\n      if (terminated) throw new Error('Intent service has been terminated')\n\n      sendMessage({\n        type: `intent-${intent._id}:resize`,\n        // if a dom element is passed, calculate its size\n        dimensions: dimensions.element\n          ? Object.assign({}, dimensions, {\n              maxHeight: dimensions.element.clientHeight,\n              maxWidth: dimensions.element.clientWidth\n            })\n          : dimensions,\n        transition: transitionProperty\n      })\n    }\n\n    const cancel = () => {\n      terminate({ type: `intent-${intent._id}:cancel` })\n    }\n\n    // Prevent unfulfilled client promises when this window unloads for a\n    // reason or another.\n    serviceWindow.addEventListener('unload', () => {\n      if (!terminated) cancel()\n    })\n\n    return listenClientData(intent, serviceWindow).then(data => {\n      return {\n        compose: compose,\n        getData: () => data,\n        getIntent: () => intent,\n        terminate: doc => {\n          const eventName =\n            data && data.exposeIntentFrameRemoval\n              ? 'exposeFrameRemoval'\n              : 'done'\n          return terminate({\n            type: `intent-${intent._id}:${eventName}`,\n            document: doc\n          })\n        },\n        throw: error =>\n          terminate({\n            type: `intent-${intent._id}:error`,\n            error: errorSerializer.serialize(error)\n          }),\n        resizeClient: resizeClient,\n        cancel: cancel\n      }\n    })\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/intents/service.js","import { cozyFetchJSON } from './fetch'\n\nexport function count(cozy, workerType) {\n  return cozyFetchJSON(cozy, 'GET', `/jobs/queue/${workerType}`).then(\n    data => data.length\n  )\n}\n\nexport function queued(cozy, workerType) {\n  return cozyFetchJSON(cozy, 'GET', `/jobs/queue/${workerType}`)\n}\n\nexport function create(cozy, workerType, args, options) {\n  return cozyFetchJSON(cozy, 'POST', `/jobs/queue/${workerType}`, {\n    data: {\n      type: 'io.cozy.jobs',\n      attributes: {\n        arguments: args || {},\n        options: options || {}\n      }\n    }\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/jobs.js","import { warn, createPath, sleep } from './utils'\nimport { normalizeDoctype } from './doctypes'\nimport { cozyFetchJSON, cozyFetchRawJSON } from './fetch'\n\nexport function defineIndex(cozy, doctype, fields) {\n  return cozy.isV2().then(isV2 => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    if (!Array.isArray(fields) || fields.length === 0) {\n      throw new Error('defineIndex fields should be a non-empty array')\n    }\n    if (isV2) {\n      return defineIndexV2(cozy, doctype, fields)\n    } else {\n      return defineIndexV3(cozy, doctype, fields)\n    }\n  })\n}\n\nexport function query(cozy, indexRef, options) {\n  return cozy.isV2().then(isV2 => {\n    if (!indexRef) {\n      throw new Error('query should be passed the indexRef')\n    }\n    if (isV2) {\n      return queryV2(cozy, indexRef, options)\n    } else {\n      return queryV3(cozy, indexRef, options)\n    }\n  })\n}\n\nexport function queryFiles(cozy, indexRef, options) {\n  const opts = getV3Options(indexRef, options)\n  return cozyFetchRawJSON(cozy, 'POST', '/files/_find', opts).then(\n    response => (options.wholeResponse ? response : response.docs)\n  )\n}\n\n// Internals\n\nconst VALUEOPERATORS = ['$eq', '$gt', '$gte', '$lt', '$lte']\nconst LOGICOPERATORS = ['$or', '$and', '$not']\n\n/* eslint-disable */\nconst MAP_TEMPLATE = function(doc) {\n  if (doc.docType.toLowerCase() === 'DOCTYPEPLACEHOLDER') {\n    emit(FIELDSPLACEHOLDER, doc)\n  }\n}\n  .toString()\n  .replace(/ /g, '')\n  .replace(/\\n/g, '')\nconst COUCHDB_INFINITY = { '\\uFFFF': '\\uFFFF' }\nconst COUCHDB_LOWEST = null\n/* eslint-enable */\n\n// defineIndexV2 is equivalent to defineIndex but only works for V2.\n// It transforms the index fields into a map reduce view.\nfunction defineIndexV2(cozy, doctype, fields) {\n  let indexName = 'by' + fields.map(capitalize).join('')\n  let indexDefinition = {\n    map: makeMapFunction(doctype, fields),\n    reduce: '_count'\n  }\n  let path = `/request/${doctype}/${indexName}/`\n  return cozyFetchJSON(cozy, 'PUT', path, indexDefinition).then(() => ({\n    doctype: doctype,\n    type: 'mapreduce',\n    name: indexName,\n    fields: fields\n  }))\n}\n\nfunction defineIndexV3(cozy, doctype, fields) {\n  let path = createPath(cozy, false, doctype, '_index')\n  let indexDefinition = { index: { fields } }\n  return cozyFetchJSON(cozy, 'POST', path, indexDefinition).then(response => {\n    const indexResult = {\n      doctype: doctype,\n      type: 'mango',\n      name: response.id,\n      fields\n    }\n\n    if (response.result === 'exists') return indexResult\n\n    // indexes might not be usable right after being created; so we delay the resolving until they are\n    const selector = {}\n    selector[fields[0]] = { $gt: null }\n\n    const opts = getV3Options(indexResult, { selector: selector })\n    let path = createPath(cozy, false, indexResult.doctype, '_find')\n    return cozyFetchJSON(cozy, 'POST', path, opts)\n      .then(() => indexResult)\n      .catch(() => {\n        // one retry\n        return sleep(1000)\n          .then(() => cozyFetchJSON(cozy, 'POST', path, opts))\n          .then(() => indexResult)\n          .catch(() => {\n            return sleep(500).then(() => indexResult)\n          })\n      })\n  })\n}\n\n// queryV2 is equivalent to query but only works for V2.\n// It transforms the query into a _views call using makeMapReduceQuery\nfunction queryV2(cozy, indexRef, options) {\n  if (indexRef.type !== 'mapreduce') {\n    throw new Error(\n      'query indexRef should be the return value of defineIndexV2'\n    )\n  }\n  if (options.fields) {\n    warn('query fields will be ignored on v2')\n  }\n\n  let path = `/request/${indexRef.doctype}/${indexRef.name}/`\n  let opts = makeMapReduceQuery(indexRef, options)\n  return cozyFetchJSON(cozy, 'POST', path, opts).then(response =>\n    response.map(r => r.value)\n  )\n}\n\n// queryV3 is equivalent to query but only works for V3\nfunction queryV3(cozy, indexRef, options) {\n  const opts = getV3Options(indexRef, options)\n\n  let path = createPath(cozy, false, indexRef.doctype, '_find')\n  return cozyFetchJSON(cozy, 'POST', path, opts).then(\n    response => (options.wholeResponse ? response : response.docs)\n  )\n}\n\nfunction getV3Options(indexRef, options) {\n  if (indexRef.type !== 'mango') {\n    throw new Error('indexRef should be the return value of defineIndexV3')\n  }\n\n  let opts = {\n    use_index: indexRef.name,\n    fields: options.fields,\n    selector: options.selector,\n    limit: options.limit,\n    skip: options.skip,\n    since: options.since,\n    sort: options.sort\n  }\n\n  if (options.descending) {\n    opts.sort = indexRef.fields.map(f => ({ [f]: 'desc' }))\n  }\n\n  return opts\n}\n\n// misc\nfunction capitalize(name) {\n  return name.charAt(0).toUpperCase() + name.slice(1)\n}\n\nfunction makeMapFunction(doctype, fields) {\n  fields = '[' + fields.map(name => 'doc.' + name).join(',') + ']'\n\n  return MAP_TEMPLATE.replace(\n    'DOCTYPEPLACEHOLDER',\n    doctype.toLowerCase()\n  ).replace('FIELDSPLACEHOLDER', fields)\n}\n\n// parseSelector takes a mango selector and returns it as an array of filter\n// a filter is [path, operator, value] array\n// a path is an array of field names\n// This function is only exported so it can be unit tested.\n// Example :\n// parseSelector({\"test\":{\"deep\": {\"$gt\": 3}}})\n// [[['test', 'deep'], '$gt', 3 ]]\nexport function parseSelector(selector, path = [], operator = '$eq') {\n  if (typeof selector !== 'object') {\n    return [[path, operator, selector]]\n  }\n\n  let keys = Object.keys(selector)\n  if (keys.length === 0) {\n    throw new Error('empty selector')\n  } else {\n    return keys.reduce(function(acc, k) {\n      if (LOGICOPERATORS.indexOf(k) !== -1) {\n        throw new Error('cozy-client-js does not support mango logic ops')\n      } else if (VALUEOPERATORS.indexOf(k) !== -1) {\n        return acc.concat(parseSelector(selector[k], path, k))\n      } else {\n        return acc.concat(parseSelector(selector[k], path.concat(k), '$eq'))\n      }\n    }, [])\n  }\n}\n\n// normalizeSelector takes a mango selector and returns it as an object\n// normalized.\n// This function is only exported so it can be unit tested.\n// Example :\n// parseSelector({\"test\":{\"deep\": {\"$gt\": 3}}})\n// {\"test.deep\": {\"$gt\": 3}}\nexport function normalizeSelector(selector) {\n  var filters = parseSelector(selector)\n  return filters.reduce(function(acc, filter) {\n    let [path, op, value] = filter\n    let field = path.join('.')\n    acc[field] = acc[field] || {}\n    acc[field][op] = value\n    return acc\n  }, {})\n}\n\n// applySelector takes the normalized selector for the current field\n// and append the proper values to opts.startkey, opts.endkey\nfunction applySelector(selector, opts) {\n  let value = selector['$eq']\n  let lower = COUCHDB_LOWEST\n  let upper = COUCHDB_INFINITY\n  let inclusiveEnd\n\n  if (value) {\n    opts.startkey.push(value)\n    opts.endkey.push(value)\n    return false\n  }\n\n  value = selector['$gt']\n  if (value) {\n    throw new Error('operator $gt (strict greater than) not supported')\n  }\n\n  value = selector['$gte']\n  if (value) {\n    lower = value\n  }\n\n  value = selector['$lte']\n  if (value) {\n    upper = value\n    inclusiveEnd = true\n  }\n\n  value = selector['$lt']\n  if (value) {\n    upper = value\n    inclusiveEnd = false\n  }\n\n  opts.startkey.push(lower)\n  opts.endkey.push(upper)\n  if (inclusiveEnd !== undefined) opts.inclusive_end = inclusiveEnd\n  return true\n}\n\n// makeMapReduceQuery takes a mango query and generate _views call parameters\n// to obtain same results depending on fields in the passed indexRef.\nexport function makeMapReduceQuery(indexRef, query) {\n  let mrquery = {\n    startkey: [],\n    endkey: [],\n    reduce: false\n  }\n  let firstFreeValueField = null\n  let normalizedSelector = normalizeSelector(query.selector)\n\n  indexRef.fields.forEach(function(field) {\n    let selector = normalizedSelector[field]\n\n    if (selector && firstFreeValueField != null) {\n      throw new Error(\n        'Selector on field ' +\n          field +\n          ', but not on ' +\n          firstFreeValueField +\n          ' which is higher in index fields.'\n      )\n    } else if (selector) {\n      selector.used = true\n      let isFreeValue = applySelector(selector, mrquery)\n      if (isFreeValue) firstFreeValueField = field\n    } else if (firstFreeValueField == null) {\n      firstFreeValueField = field\n      mrquery.endkey.push(COUCHDB_INFINITY)\n    }\n  })\n\n  Object.keys(normalizedSelector).forEach(function(field) {\n    if (!normalizedSelector[field].used) {\n      throw new Error(\n        'Cant apply selector on ' + field + ', it is not in index'\n      )\n    }\n  })\n\n  if (query.descending) {\n    mrquery = {\n      descending: true,\n      reduce: false,\n      startkey: mrquery.endkey,\n      endkey: mrquery.startkey,\n      inclusive_end: mrquery.inclusive_end\n    }\n  }\n\n  return mrquery\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/mango.js","/* global pouchdbAdapterCordovaSqlite */\nimport { DOCTYPE_FILES } from './doctypes'\nimport { refreshToken } from './auth_v3'\nimport { isOffline } from './utils'\nimport PouchDB from 'pouchdb'\nimport pouchdbFind from 'pouchdb-find'\n\nexport const replicationOfflineError =\n  'Replication abort, your device is actually offline.'\n\nlet pluginLoaded = false\n\n/*\n  For each doctype we have some parameters:\n  cozy._offline[doctype] = {\n    database: pouchdb database\n    replication: the pouchdb replication\n    replicationPromise: promise of replication\n    interval: repeated replication interval\n  }\n*/\n\nexport function init(cozy, { options = {}, doctypes = [] }) {\n  for (let doctype of doctypes) {\n    createDatabase(cozy, doctype, options)\n  }\n}\n\n// helper\n\nfunction getInfo(cozy, doctype) {\n  cozy._offline = cozy._offline || []\n  cozy._offline[doctype] = cozy._offline[doctype] || {}\n  return cozy._offline[doctype]\n}\n\nexport function getDoctypes(cozy) {\n  cozy._offline = cozy._offline || []\n  return Object.keys(cozy._offline)\n}\n\n//\n// DATABASE\n//\n\nexport function hasDatabase(cozy, doctype) {\n  return getDatabase(cozy, doctype) !== undefined\n}\n\nexport function getDatabase(cozy, doctype) {\n  return getInfo(cozy, doctype).database\n}\n\nexport function setDatabase(cozy, doctype, database) {\n  cozy._offline[doctype].database = database\n  return getDatabase(cozy, doctype)\n}\n\nexport function createDatabase(cozy, doctype, options = {}) {\n  if (!pluginLoaded) {\n    PouchDB.plugin(pouchdbFind)\n    if (typeof pouchdbAdapterCordovaSqlite !== 'undefined')\n      PouchDB.plugin(pouchdbAdapterCordovaSqlite)\n    pluginLoaded = true\n  }\n\n  if (hasDatabase(cozy, doctype)) {\n    return Promise.resolve(getDatabase(cozy, doctype))\n  }\n\n  setDatabase(cozy, doctype, new PouchDB(doctype, options))\n  return createIndexes(cozy, doctype).then(() => getDatabase(cozy, doctype))\n}\n\nexport function destroyDatabase(cozy, doctype) {\n  if (!hasDatabase(cozy, doctype)) {\n    return Promise.resolve(false)\n  }\n\n  return stopRepeatedReplication(cozy, doctype)\n    .then(() => stopReplication(cozy, doctype))\n    .then(() => getDatabase(cozy, doctype).destroy())\n    .then(response => {\n      setDatabase(cozy, doctype, undefined)\n      return response\n    })\n}\n\nexport function destroyAllDatabase(cozy) {\n  const doctypes = getDoctypes(cozy)\n  const destroy = doctype => destroyDatabase(cozy, doctype)\n  return Promise.all(doctypes.map(destroy))\n}\n\nfunction createIndexes(cozy, doctype) {\n  if (doctype === DOCTYPE_FILES) {\n    return getDatabase(cozy, doctype).createIndex({\n      index: { fields: ['dir_id'] }\n    })\n  }\n  return Promise.resolve()\n}\n\n//\n// REPLICATION\n//\n\nexport function hasReplication(cozy, doctype) {\n  return getReplication(cozy, doctype) !== undefined\n}\n\nfunction getReplication(cozy, doctype) {\n  return getInfo(cozy, doctype).replication\n}\n\nfunction setReplication(cozy, doctype, replication) {\n  cozy._offline[doctype].replication = replication\n  return getReplication(cozy, doctype)\n}\n\nfunction getReplicationUrl(cozy, doctype) {\n  return cozy.authorize().then(credentials => {\n    const basic = credentials.token.toBasicAuth()\n    return (cozy._url + '/data/' + doctype).replace('//', `//${basic}`)\n  })\n}\n\nfunction getReplicationPromise(cozy, doctype) {\n  return getInfo(cozy, doctype).replicationPromise\n}\n\nfunction setReplicationPromise(cozy, doctype, promise) {\n  cozy._offline[doctype].replicationPromise = promise\n  return getReplicationPromise(cozy, doctype)\n}\n\nexport function replicateFromCozy(cozy, doctype, options = {}) {\n  return setReplicationPromise(\n    cozy,\n    doctype,\n    new Promise((resolve, reject) => {\n      if (!hasDatabase(cozy, doctype)) {\n        createDatabase(cozy, doctype)\n      }\n      if (options.live === true) {\n        return reject(\n          new Error(\"You can't use `live` option with Cozy couchdb.\")\n        )\n      }\n\n      if (isOffline()) {\n        reject(replicationOfflineError)\n        options.onError && options.onError(replicationOfflineError)\n        return\n      }\n\n      getReplicationUrl(cozy, doctype).then(url =>\n        setReplication(\n          cozy,\n          doctype,\n          getDatabase(cozy, doctype)\n            .replicate.from(url, options)\n            .on('complete', info => {\n              setReplication(cozy, doctype, undefined)\n              resolve(info)\n              options.onComplete && options.onComplete(info)\n            })\n            .on('error', err => {\n              if (err.error === 'code=400, message=Expired token') {\n                cozy.authorize().then(({ client, token }) => {\n                  refreshToken(cozy, client, token)\n                    .then(newToken => cozy.saveCredentials(client, newToken))\n                    .then(() => replicateFromCozy(cozy, doctype, options))\n                })\n              } else {\n                console.warn(`ReplicateFromCozy '${doctype}' Error:`)\n                console.warn(err)\n                setReplication(cozy, doctype, undefined)\n                reject(err)\n                options.onError && options.onError(err)\n              }\n            })\n        )\n      )\n    })\n  )\n}\n\nexport function stopReplication(cozy, doctype) {\n  if (!getDatabase(cozy, doctype) || !hasReplication(cozy, doctype)) {\n    return Promise.resolve()\n  }\n\n  return new Promise(resolve => {\n    try {\n      getReplicationPromise(cozy, doctype).then(() => {\n        resolve()\n      })\n      getReplication(cozy, doctype).cancel()\n      // replication is set to undefined by complete replication\n    } catch (e) {\n      resolve()\n    }\n  })\n}\n\nexport function stopAllReplication(cozy) {\n  const doctypes = getDoctypes(cozy)\n  const stop = doctype => stopReplication(cozy, doctype)\n  return Promise.all(doctypes.map(stop))\n}\n\n//\n// REPEATED REPLICATION\n//\n\nfunction getRepeatedReplication(cozy, doctype) {\n  return getInfo(cozy, doctype).interval\n}\n\nfunction setRepeatedReplication(cozy, doctype, interval) {\n  cozy._offline[doctype].interval = interval\n}\n\nexport function hasRepeatedReplication(cozy, doctype) {\n  return getRepeatedReplication(cozy, doctype) !== undefined\n}\n\nexport function startRepeatedReplication(cozy, doctype, timer, options = {}) {\n  // TODO: add timer limitation for not flooding Gozy\n  if (hasRepeatedReplication(cozy, doctype)) {\n    return getRepeatedReplication(cozy, doctype)\n  }\n\n  return setRepeatedReplication(\n    cozy,\n    doctype,\n    setInterval(() => {\n      if (isOffline()) {\n        // network is offline, replication cannot be launched\n        console.info(replicationOfflineError)\n        return\n      }\n      if (!hasReplication(cozy, doctype)) {\n        replicateFromCozy(cozy, doctype, options)\n        // TODO: add replicationToCozy\n      }\n    }, timer * 1000)\n  )\n}\n\nexport function stopRepeatedReplication(cozy, doctype) {\n  if (hasRepeatedReplication(cozy, doctype)) {\n    clearInterval(getRepeatedReplication(cozy, doctype))\n    setRepeatedReplication(cozy, doctype, undefined)\n  }\n  if (hasReplication(cozy, doctype)) {\n    return stopReplication(cozy, doctype)\n  }\n\n  return Promise.resolve()\n}\n\nexport function stopAllRepeatedReplication(cozy) {\n  const doctypes = getDoctypes(cozy)\n  const stop = doctype => stopRepeatedReplication(cozy, doctype)\n  return Promise.all(doctypes.map(stop))\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/offline.js","import { cozyFetchJSON, cozyFetchRawJSON } from './fetch'\nimport { DOCTYPE_FILES } from './doctypes'\n\nfunction updateRelations(verb) {\n  return function(cozy, doc, ids) {\n    if (!doc) throw new Error('missing doc argument')\n    if (!Array.isArray(ids)) ids = [ids]\n\n    const refs = ids.map(id => ({ type: DOCTYPE_FILES, id }))\n\n    return cozyFetchJSON(cozy, verb, makeReferencesPath(doc), { data: refs })\n  }\n}\n\nexport const addReferencedFiles = updateRelations('POST')\nexport const removeReferencedFiles = updateRelations('DELETE')\n\nexport function listReferencedFiles(cozy, doc) {\n  if (!doc) throw new Error('missing doc argument')\n  return cozyFetchJSON(cozy, 'GET', makeReferencesPath(doc)).then(files =>\n    files.map(file => file._id)\n  )\n}\n\nexport function fetchReferencedFiles(cozy, doc, options) {\n  if (!doc) throw new Error('missing doc argument')\n  const params = Object.keys(options)\n    .map(key => `&page[${key}]=${options[key]}`)\n    .join('')\n  // As datetime is the only sort option available, I see no reason to not have it by default\n  return cozyFetchRawJSON(\n    cozy,\n    'GET',\n    `${makeReferencesPath(doc)}?include=files&sort=datetime${params}`\n  )\n}\n\nfunction makeReferencesPath(doc) {\n  const type = encodeURIComponent(doc._type)\n  const id = encodeURIComponent(doc._id)\n  return `/data/${type}/${id}/relationships/references`\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/relations.js","import { cozyFetchJSON } from './fetch'\n\nexport function diskUsage(cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/settings/disk-usage`)\n}\n\nexport function changePassphrase(cozy, currentPassPhrase, newPassPhrase) {\n  return cozyFetchJSON(cozy, 'PUT', `/settings/passphrase`, {\n    current_passphrase: currentPassPhrase,\n    new_passphrase: newPassPhrase\n  })\n}\n\nexport function getInstance(cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/settings/instance`)\n}\n\nexport function updateInstance(cozy, instance) {\n  return cozyFetchJSON(cozy, 'PUT', `/settings/instance`, instance)\n}\n\nexport function getClients(cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/settings/clients`)\n}\n\nexport function deleteClientById(cozy, id) {\n  return cozyFetchJSON(cozy, 'DELETE', `/settings/clients/${id}`)\n}\n\nexport function updateLastSync(cozy) {\n  return cozyFetchJSON(cozy, 'POST', '/settings/synchronized')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/settings.js","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n// This method of obtaining a reference to the global object needs to be\n// kept identical to the way it is obtained in runtime.js\nvar g = (function() { return this })() || Function(\"return this\")();\n\n// Use `getOwnPropertyNames` because not all browsers support calling\n// `hasOwnProperty` on the global `self` object in a worker. See #183.\nvar hadRuntime = g.regeneratorRuntime &&\n  Object.getOwnPropertyNames(g).indexOf(\"regeneratorRuntime\") >= 0;\n\n// Save the old regeneratorRuntime in case it needs to be restored later.\nvar oldRuntime = hadRuntime && g.regeneratorRuntime;\n\n// Force reevalutation of runtime.js.\ng.regeneratorRuntime = undefined;\n\nmodule.exports = require(\"./runtime\");\n\nif (hadRuntime) {\n  // Restore the original runtime.\n  g.regeneratorRuntime = oldRuntime;\n} else {\n  // Remove the global property added by runtime.js.\n  try {\n    delete g.regeneratorRuntime;\n  } catch(e) {\n    g.regeneratorRuntime = undefined;\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/~/regenerator-runtime/runtime-module.js\n// module id = 49\n// module chunks = 0","/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  AsyncIterator.prototype[asyncIteratorSymbol] = function () {\n    return this;\n  };\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // In sloppy mode, unbound `this` refers to the global object, fallback to\n  // Function constructor if we're in global strict mode. That is sadly a form\n  // of indirect eval which violates Content Security Policy.\n  (function() { return this })() || Function(\"return this\")()\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/babel-runtime/~/regenerator-runtime/runtime.js\n// module id = 50\n// module chunks = 0","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_a-function.js\n// module id = 51\n// module chunks = 0","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_an-object.js\n// module id = 52\n// module chunks = 0","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_array-includes.js\n// module id = 53\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_cof.js\n// module id = 54\n// module chunks = 0","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_ctx.js\n// module id = 55\n// module chunks = 0","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_dom-create.js\n// module id = 56\n// module chunks = 0","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_enum-bug-keys.js\n// module id = 57\n// module chunks = 0","var global = require('./_global');\nvar core = require('./_core');\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar ctx = require('./_ctx');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_export.js\n// module id = 58\n// module chunks = 0","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_ie8-dom-define.js\n// module id = 59\n// module chunks = 0","module.exports = false;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_library.js\n// module id = 60\n// module chunks = 0","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nvar toObject = require('./_to-object');\nvar IObject = require('./_iobject');\nvar $assign = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function () {\n  var A = {};\n  var B = {};\n  // eslint-disable-next-line no-undef\n  var S = Symbol();\n  var K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function (k) { B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source) { // eslint-disable-line no-unused-vars\n  var T = toObject(target);\n  var aLen = arguments.length;\n  var index = 1;\n  var getSymbols = gOPS.f;\n  var isEnum = pIE.f;\n  while (aLen > index) {\n    var S = IObject(arguments[index++]);\n    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);\n    var length = keys.length;\n    var j = 0;\n    var key;\n    while (length > j) if (isEnum.call(S, key = keys[j++])) T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-assign.js\n// module id = 61\n// module chunks = 0","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-dp.js\n// module id = 62\n// module chunks = 0","exports.f = Object.getOwnPropertySymbols;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-gops.js\n// module id = 63\n// module chunks = 0","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-keys-internal.js\n// module id = 64\n// module chunks = 0","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-keys.js\n// module id = 65\n// module chunks = 0","exports.f = {}.propertyIsEnumerable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-pie.js\n// module id = 66\n// module chunks = 0","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_property-desc.js\n// module id = 67\n// module chunks = 0","var global = require('./_global');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar SRC = require('./_uid')('src');\nvar TO_STRING = 'toString';\nvar $toString = Function[TO_STRING];\nvar TPL = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_redefine.js\n// module id = 68\n// module chunks = 0","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_shared-key.js\n// module id = 69\n// module chunks = 0","var core = require('./_core');\nvar global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: require('./_library') ? 'pure' : 'global',\n  copyright: 'Â© 2018 Denis Pushkarev (zloirock.ru)'\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_shared.js\n// module id = 70\n// module chunks = 0","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-absolute-index.js\n// module id = 71\n// module chunks = 0","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-length.js\n// module id = 72\n// module chunks = 0","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-object.js\n// module id = 73\n// module chunks = 0","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-primitive.js\n// module id = 74\n// module chunks = 0","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', { assign: require('./_object-assign') });\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.object.assign.js\n// module id = 75\n// module chunks = 0","// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\nrequire('whatwg-fetch');\nmodule.exports = self.fetch.bind(self);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isomorphic-fetch/fetch-npm-browserify.js\n// module id = 76\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar Promise = _interopDefault(require('pouchdb-promise'));\nvar pouchdbUtils = require('pouchdb-utils');\nvar pouchdbMd5 = require('pouchdb-md5');\nvar pouchdbCollections = require('pouchdb-collections');\nvar pouchdbBinaryUtils = require('pouchdb-binary-utils');\nvar pouchdbCollate = require('pouchdb-collate');\nvar pouchdbMapreduceUtils = require('pouchdb-mapreduce-utils');\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue() {\n  this.promise = new Promise(function (fulfill) {fulfill(); });\n}\nTaskQueue.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : pouchdbMd5.stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return pouchdbUtils.upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    pouchdbUtils.guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    pouchdbUtils.guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = pouchdbCollate.collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : pouchdbCollate.collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = pouchdbBinaryUtils.base64StringToBlobOrBuffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new pouchdbMapreduceUtils.QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new pouchdbMapreduceUtils.QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      pouchdbCollate.collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new pouchdbMapreduceUtils.QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new pouchdbMapreduceUtils.QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new pouchdbMapreduceUtils.QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(\n        /* istanbul ignore next */\n        function (result) {\n          // fail the entire request if the result contains an error\n          result.rows.forEach(function (row) {\n            if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n              throw new Error(row.reason);\n            }\n          });\n\n          return result;\n      })\n      .then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new Promise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new Promise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new pouchdbCollections.Set();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = pouchdbMapreduceUtils.mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = pouchdbMapreduceUtils.uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = pouchdbMapreduceUtils.mapToKeysArray(docIdsToChangesAndEmits);\n        return Promise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = pouchdbUtils.flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return pouchdbMapreduceUtils.sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: pouchdbCollate.normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = pouchdbCollate.normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new pouchdbCollections.Map();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new pouchdbCollections.Map();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && pouchdbCollate.collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(pouchdbCollate.toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && pouchdbCollate.collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof pouchdbMapreduceUtils.BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return pouchdbMapreduceUtils.sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = pouchdbCollate.parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        var docIds = pouchdbMapreduceUtils.uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new pouchdbCollections.Map();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : pouchdbCollate.toIndexableString([key]),\n          endkey   : pouchdbCollate.toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(pouchdbUtils.flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          pouchdbCollate.toIndexableString([startkey, {}]) :\n          pouchdbCollate.toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = pouchdbCollate.toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = pouchdbCollate.toIndexableString([opts.key]);\n        var keyEnd = pouchdbCollate.toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new pouchdbCollections.Map();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new pouchdbCollections.Set();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : pouchdbMapreduceUtils.mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return pouchdbMapreduceUtils.sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (pouchdbUtils.isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n    \n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return pouchdbMapreduceUtils.fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new pouchdbMapreduceUtils.NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              pouchdbUtils.nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    pouchdbMapreduceUtils.promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = pouchdbMapreduceUtils.callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (pouchdbUtils.isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nmodule.exports = createAbstractMapReduce;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-abstract-mapreduce/lib/index.js\n// module id = 77\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar pouchdbUtils = require('pouchdb-utils');\nvar Promise = _interopDefault(require('pouchdb-promise'));\nvar pouchdbSelectorCore = require('pouchdb-selector-core');\nvar abstractMapReduce = _interopDefault(require('pouchdb-abstract-mapreduce'));\nvar pouchdbCollate = require('pouchdb-collate');\nvar pouchdbMd5 = require('pouchdb-md5');\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nfunction massageCreateIndexRequest(requestDef) {\n  requestDef = pouchdbUtils.clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n}\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n\n  db.request({\n    method: 'POST',\n    url: '_index',\n    body: requestDef\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  db.request({\n    method: 'POST',\n    url: '_find',\n    body: requestDef\n  }, callback);\n}\n\nfunction explain(db, requestDef, callback) {\n  db.request({\n    method: 'POST',\n    url: '_explain',\n    body: requestDef\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  db.request({\n    method: 'GET',\n    url: '_index'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n\n\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\n  db.request({\n    method: 'DELETE',\n    url: url\n  }, callback);\n}\n\nfunction getArguments(fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n}\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    promisedCallback(promise, cb);\n    return promise;\n  });\n}\n\nfunction promisedCallback(promise, callback) {\n  promise.then(function (res) {\n    process.nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    process.nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n}\n\nvar flatten = getArguments(function (args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n});\n\nfunction mergeObjects(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = pouchdbUtils.assign(res, arr[i]);\n  }\n  return res;\n}\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = pouchdbSelectorCore.parseField(arr[i]);\n    var value = pouchdbSelectorCore.getFieldFromDoc(obj, parsedField);\n    if (typeof value !== 'undefined') {\n      pouchdbSelectorCore.setFieldInDoc(res, parsedField, value);\n    }\n  }\n  return res;\n}\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nfunction oneArrayIsSubArrayOfOther(left, right) {\n\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nfunction oneArrayIsStrictSubArrayOfOther(left, right) {\n\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return oneArrayIsSubArrayOfOther(left, right);\n}\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nfunction oneSetIsSubArrayOfOther(left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n}\n\nfunction arrayToObject(arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n}\n\nfunction max(arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n}\n\nfunction arrayEquals(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction uniq(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n}\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = pouchdbSelectorCore.parseField(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (typeof value === 'undefined') {\n          return; // don't emit\n        }\n      }\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit) {\n  var parsedField = pouchdbSelectorCore.parseField(field);\n  return function (doc) {\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (typeof value === 'undefined') {\n        return; // do nothing\n      }\n    }\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit) {\n  return function (doc) {\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createMapper(fields, emit) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit);\n    } else { // multi\n      return createShallowMultiMapper(fields, emit);\n    }\n  } else { // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit);\n    } else { // multi\n      return createDeepMultiMapper(fields, emit);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  var fields = Object.keys(mapFunDef.fields);\n\n  return createMapper(fields, emit);\n}\n\n/* istanbul ignore next */\nfunction reducer(/*reduceFunDef*/) {\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n      ' doesn\\'t have map.fields defined. ' +\n      'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce(\n  /* localDocName */ 'indexes',\n  mapper,\n  reducer,\n  ddocValidator\n);\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nfunction massageUseIndex(useIndex) {\n  var cleanedUseIndex = [];\n  if (typeof useIndex === 'string') {\n    cleanedUseIndex.push(useIndex);\n  } else {\n    cleanedUseIndex = useIndex;\n  }\n\n  return cleanedUseIndex.map(function (name) {\n    return name.replace('_design/', '');\n  });\n}\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = pouchdbSelectorCore.getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else { // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(pouchdbCollate.collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = pouchdbUtils.clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return pouchdbSelectorCore.getValue(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort(requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n      '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort? sort.map(pouchdbSelectorCore.getKey) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n\n  return {\n    fields: userFields,\n    sortOrder: sort.map(pouchdbSelectorCore.getKey)\n  };\n}\n\nfunction createIndex$1(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = pouchdbUtils.clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n\n  validateIndex(requestDef.index);\n\n  // calculating md5 is expensive - memoize and only\n  // run if required\n  var md5;\n  function getMd5() {\n    return md5 || (md5 = pouchdbMd5.stringMd5(JSON.stringify(requestDef)));\n  }\n\n  var viewName = requestDef.name || ('idx-' + getMd5());\n\n  var ddocName = requestDef.ddoc || ('idx-' + getMd5());\n  var ddocId = '_design/' + ddocName;\n\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n\n    return doc;\n  }\n\n  db.constructor.emit('debug', ['find', 'creating index', ddocId]);\n\n  return pouchdbUtils.upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' +\n      ddocId +\n      '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper.query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nfunction getIndexes$1(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uffff',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{_id: 'asc'}]\n        }\n      }]\n    };\n\n    res.indexes = flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return pouchdbSelectorCore.compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = {\"\\uffff\": {}};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(pouchdbSelectorCore.getKey);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = pouchdbSelectorCore.getKey(matcher);\n\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(pouchdbSelectorCore.getKey);\n\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return pouchdbSelectorCore.compare(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = flatten(\n    // in-memory fields reported as necessary by the query planner\n    coreInMemoryFields,\n    // combine with another pass that checks for any we may have missed\n    getBasicInMemoryFields(index, selector, userFields),\n    // combine with another pass that checks for $ne's\n    getInMemoryFieldsFromNe(selector)\n  );\n\n  return sortFieldsByIndex(uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = oneArrayIsSubArrayOfOther(fields, indexFields);\n\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher(matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  if (typeof matcher === 'undefined') {\n    /* istanbul ignore next */\n    return true;\n  }\n\n  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n    return !(isNonLogicalMatcher(matcherKey));\n  });\n\n  if (!hasLogicalOperator) {\n    return false;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 &&\n    pouchdbSelectorCore.getKey(matcher) === '$ne';\n\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\n  var indexFields = index.def.fields.map(pouchdbSelectorCore.getKey);\n\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n\n  return indexes.reduce(function (res, index) {\n    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n    if (indexMatches) {\n      res.push(index);\n    }\n    return res;\n  }, []);\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes, useIndex) {\n\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    if (useIndex) {\n      throw {\n        error: \"no_usable_index\",\n        message: \"There is no index available for this selector.\"\n      };\n    }\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1 && !useIndex) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(pouchdbSelectorCore.getKey);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n\n  if (useIndex) {\n    var useIndexDdoc = '_design/' + useIndex[0];\n    var useIndexName = useIndex.length === 2 ? useIndex[1] : false;\n    var index = matchingIndexes.find(function (index) {\n      if (useIndexName && index.ddoc === useIndexDdoc && useIndexName === index.name) {\n        return true;\n      }\n\n      if (index.ddoc === useIndexDdoc) {\n        /* istanbul ignore next */\n        return true;\n      }\n\n      return false;\n    });\n\n    if (!index) {\n      throw {\n        error: \"unknown_error\",\n        message: \"Could not find that index or could not use that index for the query\"\n      };\n    }\n    return index;\n  }\n\n  return max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {key: userValue};\n    case '$lte':\n      return {endkey: userValue};\n    case '$gte':\n      return {startkey: userValue};\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = pouchdbSelectorCore.getKey(index.def.fields[0]);\n  //ignoring this because the test to exercise the branch is skipped at the moment\n  /* istanbul ignore next */\n  var matcher = selector[field] || {};\n  var inMemoryFields = [];\n\n  var userOperators = Object.keys(matcher);\n\n  var combinedOpts;\n\n  userOperators.forEach(function (userOperator) {\n\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n      return;\n    }\n\n    var userValue = matcher[userOperator];\n\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n\n  var indexFields = index.def.fields.map(pouchdbSelectorCore.getKey);\n\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n\n  function finish(i) {\n\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    var matcher = selector[indexField];\n\n    if (!matcher || !Object.keys(matcher).length) { // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (i > 0) {\n      if (Object.keys(matcher).some(isNonLogicalMatcher)) { // non-logical are ignored\n        finish(i);\n        break;\n      }\n      var usingGtlt = (\n        '$gt' in matcher || '$gte' in matcher ||\n        '$lt' in matcher || '$lte' in matcher);\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getDefaultQueryPlan(selector) {\n  //using default index, so all fields need to be done in memory\n  return {\n    queryOpts: {startkey: null},\n    inMemoryFields: [Object.keys(selector)]\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n\n  var selector = request.selector;\n  var sort = request.sort;\n\n  var userFieldsRes = getUserFields(selector, sort);\n\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes, request.use_index);\n\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  return res;\n}\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = pouchdbUtils.clone(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  return db.allDocs(opts)\n  .then(function (res) {\n    // filter out any design docs that _all_docs might return\n    res.rows = res.rows.filter(function (row) {\n      return !/^_design\\//.test(row.id);\n    });\n    return res;\n  });\n}\n\nfunction find$1(db, requestDef, explain) {\n  if (requestDef.selector) {\n    requestDef.selector = pouchdbSelectorCore.massageSelector(requestDef.selector);\n  }\n\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  if (requestDef.use_index) {\n    requestDef.use_index = massageUseIndex(requestDef.use_index);\n  }\n\n  validateFindRequest(requestDef);\n\n  return getIndexes$1(db).then(function (getIndexesRes) {\n\n    db.constructor.emit('debug', ['find', 'planning query', requestDef]);\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n    db.constructor.emit('debug', ['find', 'query plan', queryPlan]);\n\n    var indexToUse = queryPlan.index;\n\n    validateSort(requestDef, indexToUse);\n\n    var opts = pouchdbUtils.assign({\n      include_docs: true,\n      reduce: false\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts &&\n        pouchdbCollate.collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      /* istanbul ignore next */\n      return {docs: []};\n    }\n\n    var isDescending = requestDef.sort &&\n      typeof requestDef.sort[0] !== 'string' &&\n      pouchdbSelectorCore.getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    if (explain) {\n      return Promise.resolve(queryPlan, opts);\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper.query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = pouchdbSelectorCore.filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'no matching index found, create an index to optimize query time';\n      }\n\n      return resp;\n    });\n  });\n}\n\nfunction explain$1(db, requestDef) {\n  return find$1(db, requestDef, true)\n  .then(function (queryPlan) {\n    return {\n      dbname: db.name,\n      index: queryPlan.index,\n      selector: requestDef.selector,\n      range: {\n        start_key: queryPlan.queryOpts.startkey,\n        end_key: queryPlan.queryOpts.endkey,\n      },\n      opts: {\n        use_index: requestDef.use_index || [],\n        bookmark: \"nil\", //hardcoded to match CouchDB since its not supported,\n        limit: requestDef.limit,\n        skip: requestDef.skip,\n        sort: requestDef.sort || {},\n        fields: requestDef.fields,\n        conflicts: false, //hardcoded to match CouchDB since its not supported,\n        r: [49], // hardcoded to match CouchDB since its not support\n      },\n      limit: requestDef.limit,\n      skip: requestDef.skip || 0,\n      fields: requestDef.fields,\n    };\n  });\n}\n\nfunction deleteIndex$1(db, index) {\n\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun(doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {_id: docId, _deleted: true};\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return pouchdbUtils.upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper.viewCleanup.apply(db);\n  }).then(function () {\n    return {ok: true};\n  });\n}\n\nvar createIndexAsCallback = callbackify(createIndex$1);\nvar findAsCallback = callbackify(find$1);\nvar explainAsCallback = callbackify(explain$1);\nvar getIndexesAsCallback = callbackify(getIndexes$1);\nvar deleteIndexAsCallback = callbackify(deleteIndex$1);\n\nvar plugin = {};\nplugin.createIndex = pouchdbUtils.toPromise(function (requestDef, callback) {\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var createIndex$$1 = pouchdbUtils.isRemote(this) ?\n    createIndex : createIndexAsCallback;\n  createIndex$$1(this, requestDef, callback);\n});\n\nplugin.find = pouchdbUtils.toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var find$$1 = pouchdbUtils.isRemote(this) ? find : findAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.explain = pouchdbUtils.toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to explain()'));\n  }\n\n  var find$$1 = pouchdbUtils.isRemote(this) ? explain : explainAsCallback;\n  find$$1(this, requestDef, callback);\n});\n\nplugin.getIndexes = pouchdbUtils.toPromise(function (callback) {\n\n  var getIndexes$$1 = pouchdbUtils.isRemote(this) ? getIndexes : getIndexesAsCallback;\n  getIndexes$$1(this, callback);\n});\n\nplugin.deleteIndex = pouchdbUtils.toPromise(function (indexDef, callback) {\n\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var deleteIndex$$1 = pouchdbUtils.isRemote(this) ?\n    deleteIndex : deleteIndexAsCallback;\n  deleteIndex$$1(this, indexDef, callback);\n});\n\nmodule.exports = plugin;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/index-browser.js\n// module id = 78\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar inherits = _interopDefault(require('inherits'));\nvar pouchdbCollections = require('pouchdb-collections');\nvar argsarray = _interopDefault(require('argsarray'));\nvar pouchdbUtils = require('pouchdb-utils');\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      pouchdbUtils.nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      pouchdbUtils.nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return argsarray(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new pouchdbCollections.Set(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nexports.uniq = uniq;\nexports.sequentialize = sequentialize;\nexports.fin = fin;\nexports.callbackify = callbackify;\nexports.promisedCallback = promisedCallback;\nexports.mapToKeysArray = mapToKeysArray;\nexports.QueryParseError = QueryParseError;\nexports.NotFoundError = NotFoundError;\nexports.BuiltInError = BuiltInError;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-mapreduce-utils/lib/index.js\n// module id = 79\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar pouchdbUtils = require('pouchdb-utils');\nvar pouchdbCollate = require('pouchdb-collate');\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction setFieldInDoc(doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = {};\n  }\n  doc[parsedField[len-1]] = value;\n}\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = pouchdbUtils.clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = pouchdbCollate.collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && pouchdbCollate.collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && pouchdbCollate.collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && pouchdbCollate.collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && pouchdbCollate.collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && pouchdbCollate.collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return pouchdbCollate.collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nexports.massageSelector = massageSelector;\nexports.matchesSelector = matchesSelector;\nexports.filterInMemoryFields = filterInMemoryFields;\nexports.createFieldSorter = createFieldSorter;\nexports.rowFilter = rowFilter;\nexports.isCombinationalField = isCombinationalField;\nexports.getKey = getKey;\nexports.getValue = getValue;\nexports.getFieldFromDoc = getFieldFromDoc;\nexports.setFieldInDoc = setFieldInDoc;\nexports.compare = compare;\nexports.parseField = parseField;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-selector-core/lib/index.js\n// module id = 80\n// module chunks = 0","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar inherits = _interopDefault(require('inherits'));\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nexports.UNAUTHORIZED = UNAUTHORIZED;\nexports.MISSING_BULK_DOCS = MISSING_BULK_DOCS;\nexports.MISSING_DOC = MISSING_DOC;\nexports.REV_CONFLICT = REV_CONFLICT;\nexports.INVALID_ID = INVALID_ID;\nexports.MISSING_ID = MISSING_ID;\nexports.RESERVED_ID = RESERVED_ID;\nexports.NOT_OPEN = NOT_OPEN;\nexports.UNKNOWN_ERROR = UNKNOWN_ERROR;\nexports.BAD_ARG = BAD_ARG;\nexports.INVALID_REQUEST = INVALID_REQUEST;\nexports.QUERY_PARSE_ERROR = QUERY_PARSE_ERROR;\nexports.DOC_VALIDATION = DOC_VALIDATION;\nexports.BAD_REQUEST = BAD_REQUEST;\nexports.NOT_AN_OBJECT = NOT_AN_OBJECT;\nexports.DB_MISSING = DB_MISSING;\nexports.WSQ_ERROR = WSQ_ERROR;\nexports.LDB_ERROR = LDB_ERROR;\nexports.FORBIDDEN = FORBIDDEN;\nexports.INVALID_REV = INVALID_REV;\nexports.FILE_EXISTS = FILE_EXISTS;\nexports.MISSING_STUB = MISSING_STUB;\nexports.IDB_ERROR = IDB_ERROR;\nexports.INVALID_URL = INVALID_URL;\nexports.createError = createError;\nexports.generateErrorFromResponse = generateErrorFromResponse;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-utils/~/pouchdb-errors/lib/index.js\n// module id = 81\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(require('lie'));\nvar getArguments = _interopDefault(require('argsarray'));\nvar nextTick = _interopDefault(require('immediate'));\nvar events = require('events');\nvar inherits = _interopDefault(require('inherits'));\nvar uuidV4 = _interopDefault(require('uuid'));\nvar debug = _interopDefault(require('debug'));\nvar Md5 = _interopDefault(require('spark-md5'));\nvar vuvuzela = _interopDefault(require('vuvuzela'));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new PouchPromise(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nfunction logApiCall(self, name, args) {\n  /* istanbul ignore if */\n  if (self.constructor.listeners('debug').length) {\n    var logArgs = ['api', self.name, name];\n    for (var i = 0; i < args.length - 1; i++) {\n      logArgs.push(args[i]);\n    }\n    self.constructor.emit('debug', logArgs);\n\n    // override the callback itself to log the response\n    var origCallback = args[args.length - 1];\n    args[args.length - 1] = function (err, res) {\n      var responseArgs = ['api', self.name, name];\n      responseArgs = responseArgs.concat(\n        err ? ['error', err] : ['success', res]\n      );\n      self.constructor.emit('debug', responseArgs);\n      origCallback(err, res);\n    };\n  }\n}\n\nfunction adapterFun(name, callback) {\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return PouchPromise.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\ninherits(Changes, events.EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  events.EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        nextTick(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  events.EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (typeof console !== 'undefined' && typeof console[method] === 'function') {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if (max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar $inject_Object_assign = assign;\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\n// Checks if a PouchDB object is \"remote\" or not. This is\n// designed to opt-in to certain optimizations, such as\n// avoiding checks for \"dependentDbs\" and other things that\n// we know only apply to local databases. In general, \"remote\"\n// should be true for the http adapter, and for third-party\n// adapters with similar expensive boundaries to cross for\n// every API call, such as socket-pouch and worker-pouch.\n// Previously, this was handled via db.type() === 'http'\n// which is now deprecated.\n\nfunction isRemote(db) {\n  if (typeof db._remote === 'boolean') {\n    return db._remote;\n  }\n  /* istanbul ignore next */\n  if (typeof db.type === 'function') {\n    guardedConsole('warn',\n      'db.type() is deprecated and will be removed in ' +\n      'a future version of PouchDB');\n    return db.type() === 'http';\n  }\n  /* istanbul ignore next */\n  return false;\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 events.EventEmitter.listenerCount(ee, type);\n}\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* eslint maxlen: 0, no-useless-escape: 0 */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// Based on https://github.com/alexdavid/scope-eval v0.0.3\n// (source: https://unpkg.com/scope-eval@0.0.3/scope_eval.js)\n// This is basically just a wrapper around new Function()\n\nfunction scopeEval(source, scope) {\n  var keys = [];\n  var values = [];\n  for (var key in scope) {\n    if (scope.hasOwnProperty(key)) {\n      keys.push(key);\n      values.push(scope[key]);\n    }\n  }\n  keys.push(source);\n  return Function.apply(null, keys).apply(null, values);\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\nfunction rev() {\n  return uuidV4.v4().replace(/-/g, '').toLowerCase();\n}\n\nvar uuid = uuidV4.v4;\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var stemmedRevs;\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var node;\n    if (stemmed.length > depth) {\n      // only do the stemming work if we actually need to stem\n      if (!stemmedRevs) {\n        stemmedRevs = {}; // avoid allocating this object unnecessarily\n      }\n      var numStemmed = stemmed.length - depth;\n      node = {\n        pos: path.pos + numStemmed,\n        ids: pathToTree(stemmed, numStemmed)\n      };\n\n      for (var s = 0; s < numStemmed; s++) {\n        var rev = (path.pos + s) + '-' + stemmed[s].id;\n        stemmedRevs[rev] = true;\n      }\n    } else { // no need to actually stem\n      node = {\n        pos: path.pos,\n        ids: pathToTree(stemmed, 0)\n      };\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, node, true).tree;\n    } else {\n      result = [node];\n    }\n  }\n\n  // this is memory-heavy per Chrome profiler, avoid unless we actually stemmed\n  if (stemmedRevs) {\n    traverseRevTree(result, function (isLeaf, pos, revHash) {\n      // some revisions may have been removed in a branch but not in another\n      delete stemmedRevs[pos + '-' + revHash];\n    });\n  }\n\n  return {\n    tree: result,\n    revs: stemmedRevs ? Object.keys(stemmedRevs) : []\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\ninherits(Changes$2, events.EventEmitter);\n\nfunction tryCatchInChangeListener(self, change, pending, lastSeq) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change, pending, lastSeq);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$2(db, opts, callback) {\n  events.EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change, pending, lastSeq);\n  };\n\n  var promise = new PouchPromise(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.validateChanges(opts);\n      }\n    });\n  } else {\n    self.validateChanges(opts);\n  }\n}\nChanges$2.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$2.prototype.validateChanges = function (opts) {\n  var callback = opts.complete;\n  var self = this;\n\n  /* istanbul ignore else */\n  if (PouchDB._changesFilterPlugin) {\n    PouchDB._changesFilterPlugin.validate(opts, function (err) {\n      if (err) {\n        return callback(err);\n      }\n      self.doChanges(opts);\n    });\n  } else {\n    self.doChanges(opts);\n  }\n};\n\nChanges$2.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n  /* istanbul ignore else */\n  if (PouchDB._changesFilterPlugin) {\n    PouchDB._changesFilterPlugin.normalize(opts);\n    if (PouchDB._changesFilterPlugin.shouldFilter(this, opts)) {\n      return PouchDB._changesFilterPlugin.filter(this, opts);\n    }\n  } else {\n    ['doc_ids', 'filter', 'selector', 'view'].forEach(function (key) {\n      if (key in opts) {\n        guardedConsole('warn',\n          'The \"' + key + '\" option was passed in to changes/replicate, ' +\n          'but pouchdb-changes-filter plugin is not installed, so it ' +\n          'was ignored. Please install the plugin to enable filtering.'\n        );\n      }\n    });\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback, docId) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      err = err || results[0];\n      err.docId = docId;\n      callback(err);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev$$1 = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev$$1] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev$$1});\n    }\n    return rev$$1;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysParse(opts) {\n  var keys =  ('limit' in opts) ?\n    opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n    (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  opts.keys = keys;\n  opts.skip = 0;\n  delete opts.limit;\n  if (opts.descending) {\n    keys.reverse();\n    opts.descending = false;\n  }\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + ' is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, events.EventEmitter);\n\nfunction AbstractPouchDB() {\n  events.EventEmitter.call(this);\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback, doc._id));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  var self = this;\n  if (opts.force && doc._rev) {\n    transformForceOptionToNewEditsOption();\n    putDoc(function (err) {\n      var result = err ? null : {ok: true, id: doc._id, rev: doc._rev};\n      cb(err, result);\n    });\n  } else {\n    putDoc(cb);\n  }\n\n  function transformForceOptionToNewEditsOption() {\n    var parts = doc._rev.split('-');\n    var oldRevId = parts[1];\n    var oldRevNum = parseInt(parts[0], 10);\n\n    var newRevNum = oldRevNum + 1;\n    var newRevId = rev();\n\n    doc._revisions = {\n      start: newRevNum,\n      ids: [newRevId, oldRevId]\n    };\n    doc._rev = newRevNum + '-' + newRevId;\n    opts.new_edits = false;\n  }\n  function putDoc(next) {\n    if (typeof self._put === 'function' && opts.new_edits !== false) {\n      self._put(doc, opts, next);\n    } else {\n      self.bulkDocs({docs: [doc]}, opts, yankError(next, doc._id));\n    }\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev$$1,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev$$1;\n    rev$$1 = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev$$1) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev$$1,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev$$1) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback, newDoc._id));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev$$1 = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev$$1);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev$$1);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev$$1) {\n      addToMissing(id, rev$$1);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev$$1) {\n      if (height[rev$$1] > maxHeight) {\n        candidates.push(rev$$1);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev$$1 = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev$$1) !== -1) {\n        revs.push(rev$$1);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    }).catch(callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments,\n        binary: opts.binary\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ok: doc});\n          }\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      err.docId = id;\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo       = parseInt(splittedRev[0], 10);\n      var revHash     = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n          .indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) { return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev$$1) {\n            return rev$$1.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev$$1) {\n          pos--;\n          return {\n            rev: pos + '-' + rev$$1.id,\n            status: rev$$1.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (!isRemote(this)) {\n      allDocsKeysParse(opts);\n      if (opts.keys.length === 0) {\n        return this._allDocs({limit: 0}, callback);\n      }\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes$2(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && !isRemote(self));\n    info.adapter = self.adapter;\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && !isRemote(adapter)) {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (!isRemote(adapter)) {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (isRemote(self)) {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue$1() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue$1.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue$1.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue$1.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue$1.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB.adapters;\n  var preferredAdapters = PouchDB.preferredAdapters;\n  var prefix = PouchDB.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  function onDestroyed(from_constructor) {\n    self.removeListener('closed', onClosed);\n    if (!from_constructor) {\n      self.constructor.emit('destroyed', self.name);\n    }\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.constructor.emit('unref', self);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n  self.constructor.emit('ref', self);\n}\n\ninherits(PouchDB, AbstractPouchDB);\nfunction PouchDB(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB)) {\n    return new PouchDB(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  PouchDB.emit('debug', ['adapter', 'Picked adapter: ', opts.adapter]);\n\n  if (!PouchDB.adapters[opts.adapter] ||\n      !PouchDB.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue$1();\n\n  self.adapter = opts.adapter;\n\n  PouchDB.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\nPouchDB.adapters = {};\nPouchDB.preferredAdapters = [];\n\nPouchDB.prefix = '_pouch_';\n\nvar eventEmitter = new events.EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n    if (typeof events.EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\n  Pouch.on('ref', function onConstructorRef(db) {\n    if (!destructListeners.has(db.name)) {\n      destructListeners.set(db.name, []);\n    }\n    destructListeners.get(db.name).push(db);\n  });\n\n  Pouch.on('unref', function onConstructorUnref(db) {\n    if (!destructListeners.has(db.name)) {\n      return;\n    }\n    var dbList = destructListeners.get(db.name);\n    var pos = dbList.indexOf(db);\n    if (pos < 0) {\n      /* istanbul ignore next */\n      return;\n    }\n    dbList.splice(pos, 1);\n    if (dbList.length > 1) {\n      /* istanbul ignore next */\n      destructListeners.set(db.name, dbList);\n    } else {\n      destructListeners.delete(db.name);\n    }\n  });\n\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    if (!destructListeners.has(name)) {\n      return;\n    }\n    var dbList = destructListeners.get(name);\n    destructListeners.delete(name);\n    dbList.forEach(function (db) {\n      db.emit('destroyed',true);\n    });\n  });\n}\n\nsetUpEventEmitter(PouchDB);\n\nPouchDB.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0) {\n    throw new Error('Invalid plugin: got \"' + obj + '\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB.prototype[id] = obj[id];\n    });\n  }\n  if (this.__defaults) {\n    PouchDB.__defaults = $inject_Object_assign({}, this.__defaults);\n  }\n  return PouchDB;\n};\n\nPouchDB.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = $inject_Object_assign({}, PouchAlt.__defaults, opts);\n    PouchDB.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB);\n\n  PouchAlt.preferredAdapters = PouchDB.preferredAdapters.slice();\n  Object.keys(PouchDB).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = $inject_Object_assign({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\n// managed automatically by set-version.js\nvar version = \"6.4.3\";\n\nfunction debugPouch(PouchDB) {\n  PouchDB.debug = debug;\n  var logs = {};\n  /* istanbul ignore next */\n  PouchDB.on('debug', function (args) {\n    // first argument is log identifier\n    var logId = args[0];\n    // rest should be passed verbatim to debug module\n    var logArgs = args.slice(1);\n    if (!logs[logId]) {\n      logs[logId] = debug('pouchdb:' + logId);\n    }\n    logs[logId].apply(null, logArgs);\n  });\n}\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nfunction getFieldFromDoc(doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n}\n\nfunction compare$1(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nfunction parseField(fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField(field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  ['$or', '$nor'].forEach(function (orOrNor) {\n    if (orOrNor in result) {\n      // message each individual selector\n      // e.g. {foo: 'bar'} becomes {foo: {$eq: 'bar'}}\n      result[orOrNor].forEach(function (subSelector) {\n        var fields = Object.keys(subSelector);\n        for (var i = 0; i < fields.length; i++) {\n          var field = fields[i];\n          var matcher = subSelector[field];\n          if (typeof matcher !== 'object' || matcher === null) {\n            subSelector[field] = {$eq: matcher};\n          }\n        }\n      });\n    }\n  });\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return compare$1(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields(rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter(doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector(matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector(field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type, $allMatch or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField(docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue(docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues(docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize(docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof (docFieldValue) === 'boolean';\n    case 'number':\n      return typeof (docFieldValue) === 'number';\n    case 'string':\n      return typeof (docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$allMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!Array.isArray(docFieldValue)) {\n      return false;\n    }\n\n    /* istanbul ignore next */\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.every(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.every(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return Array.isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\n// return true if the given doc matches the supplied selector\nfunction matchesSelector(doc, selector) {\n  /* istanbul ignore if */\n  if (typeof selector !== 'object') {\n    // match the CouchDB error message\n    throw new Error('Selector error: expected a JSON object');\n  }\n\n  selector = massageSelector(selector);\n  var row = {\n    'doc': doc\n  };\n\n  var rowsMatched = filterInMemoryFields([row], { 'selector': selector }, Object.keys(selector));\n  return rowsMatched && rowsMatched.length === 1;\n}\n\nfunction evalFilter(input) {\n  return scopeEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopeEval(code, {});\n}\n\nfunction validate(opts, callback) {\n  if (opts.selector) {\n    if (opts.filter && opts.filter !== '_selector') {\n      var filterName = typeof opts.filter === 'string' ?\n        opts.filter : 'function';\n      return callback(new Error('selector invalid for filter \"' + filterName + '\"'));\n    }\n  }\n  callback();\n}\n\nfunction normalize(opts) {\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.selector && !opts.filter) {\n    opts.filter = '_selector';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n  }\n}\n\nfunction shouldFilter(changesHandler, opts) {\n  return opts.filter && typeof opts.filter === 'string' &&\n    !opts.doc_ids && !isRemote(changesHandler.db);\n}\n\nfunction filter(changesHandler, opts) {\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    changesHandler.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      changesHandler.doChanges(opts);\n    });\n  } else if (opts.selector) {\n    opts.filter = function (doc) {\n      return matchesSelector(doc, opts.selector);\n    };\n    changesHandler.doChanges(opts);\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    changesHandler.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (changesHandler.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      changesHandler.doChanges(opts);\n    });\n  }\n}\n\nfunction applyChangesFilterPlugin(PouchDB) {\n  PouchDB._changesFilterPlugin = {\n    validate: validate,\n    normalize: normalize,\n    shouldFilter: shouldFilter,\n    filter: filter\n  };\n}\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB.plugin(debugPouch);\n\n// TODO: remove from pouchdb-core (breaking)\nPouchDB.plugin(applyChangesFilterPlugin);\n\nPouchDB.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev$$1) {\n  if (!/^\\d+-./.test(rev$$1)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev$$1.indexOf('-');\n  var left = rev$$1.substring(0, idx);\n  var right = rev$$1.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = rev();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob, start, end) {\n  if (blob.webkitSlice) {\n    return blob.webkitSlice(start, end);\n  }\n  return blob.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob, start, end, callback) {\n  if (start > 0 || end < blob.size) {\n    // only slice blob if we really need to\n    blob = sliceBlob(blob, start, end);\n  }\n  readAsArrayBuffer(blob, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && ((\n    (previouslyDeleted && deleted && merged.conflicts !== 'new_leaf') ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = $inject_Object_assign(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev$$1) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev$$1;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler$$1 = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler$$1.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n  //    perhaps they are filtering on a per-doc basis)\n  // 3) descending â no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction allDocsKeys(keys, docStore, onBatch) {\n  // It's not guaranted to be returned in right order  \n  var valuesBatch = [];\n  var count = 0;\n  keys.forEach(function (key, index) {\n    docStore.get(key).onsuccess = function (event) {\n      if (event.target.result) {\n        valuesBatch[index] = event.target.result;\n      } else {\n        valuesBatch[index] = {key: key, error: 'not_found'};\n      }\n      count++;\n      if (count === keys.length) {\n        onBatch(keys, valuesBatch, {});\n      }\n    };\n  });\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var keys = 'keys' in opts ? opts.keys : false; \n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange; \n  var keyRangeError;\n  if (!keys) {\n    keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n    keyRangeError = keyRange && keyRange.error;\n    if (keyRangeError && \n      !(keyRangeError.name === \"DataError\" && keyRangeError.code === 0)) {\n      // DataError with error code 0 indicates start is less than end, so\n      // can just do an empty query. Else need to throw\n      return callback(createError(IDB_ERROR,\n        keyRangeError.name, keyRangeError.message));\n    }\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n  var updateSeq;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  /* istanbul ignore if */\n  if (opts.update_seq) {\n    getMaxUpdateSeq(seqStore, function (e) { \n      if (e.target.result && e.target.result.length > 0) {\n        updateSeq = e.target.result[0];\n      }\n    });\n  }\n\n  function getMaxUpdateSeq(objectStore, onSuccess) {\n    function onCursor(e) {\n      var cursor = e.target.result;\n      var maxKey = undefined;\n      if (cursor && cursor.key) {\n        maxKey = cursor.key;\n      } \n      return onSuccess({\n        target: {\n          result: [maxKey]\n        }\n      });\n    }\n    objectStore.openCursor(null, 'prev').onsuccess = onCursor;\n  }\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (deleted) {\n      if (keys) {\n        results.push(row);\n        // deleted docs are okay with \"keys\" requests\n        row.value.deleted = true;\n        row.doc = null;\n      }\n    } else if (skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      if (batchValue.error && keys) {\n        // key was not found with \"keys\" requests\n        results.push(batchValue);\n        continue;\n      }\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    var returnVal = {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    };\n    \n    /* istanbul ignore if */\n    if (opts.update_seq && updateSeq !== undefined) {\n      returnVal.update_seq = updateSeq;\n    }\n    callback(null, returnVal);\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (keys) {\n    return allDocsKeys(opts.keys, docStore, onBatch);\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise(function (resolve) {\n    var blob$$1 = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n// before calling the next one. This works around IE/Edge race conditions in IDB.\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler$$1.addListener(dbName, id, api, opts);\n    changesHandler$$1.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler$$1.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n  var returnDocs;\n  if ('return_docs' in opts) {\n    returnDocs = opts.return_docs;\n  } else if ('returnDocs' in opts) {\n    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n    returnDocs = opts.returnDocs;\n  } else {\n    returnDocs = true;\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return opts.complete(filtered);\n      }\n\n      if (filtered) {\n        numResults++;\n        if (returnDocs) {\n          results.push(change);\n        }\n        // process the attachment immediately\n        // for the benefit of live listeners\n        if (opts.attachments && opts.include_docs) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              opts.onChange(change);\n            });\n          });\n        } else {\n          opts.onChange(change);\n        }\n      }\n    }\n\n    function onBatchDone() {\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        processMetadataAndWinningDoc(metadata, winningDoc);\n      }\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev$$1 = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev$$1;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev$$1;\n      if (!opts.rev) {\n        rev$$1 = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev$$1 = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev$$1;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    return changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev$$1 = pos + '-' + revHash;\n        if (revs.indexOf(rev$$1) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler$$1.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n    txn.onabort = idbError(callback);\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' &&\n    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n    !/Chrome/.test(navigator.userAgent) &&\n    !/BlackBerry/.test(navigator.platform);\n\n  // Safari <10.1 does not meet our requirements for IDB support (#5572)\n  // since Safari 10.1 shipped with fetch, we can use that to detect it\n  var hasFetch = typeof fetch === 'function' &&\n    fetch.toString().indexOf('[native code') !== -1;\n\n  // On Firefox SecurityError is thrown while referencing indexedDB if cookies\n  // are not allowed. `typeof indexedDB` also triggers the error.\n  try {\n    // some outdated implementations of IDB that appear on Samsung\n    // and HTC Android devices <4.4 are missing IDBKeyRange\n    return (!isSafari || hasFetch) && typeof indexedDB !== 'undefined' &&\n      typeof IDBKeyRange !== 'undefined';\n  } catch (e) {\n    return false;\n  }\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try { // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch (err) {\n      return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\nfunction IDBPouch (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n}\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n}\n\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start++)) << 4) |\n        hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n        (hexToInt(str.charCodeAt(start)) << 4) |\n        hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str\n    .replace(/\\u0002/g, '\\u0002\\u0002')\n    .replace(/\\u0001/g, '\\u0001\\u0002')\n    .replace(/\\u0000/g, '\\u0001\\u0001');\n}\n\nfunction unescapeBlob(str) {\n  return str\n    .replace(/\\u0001\\u0001/g, '\\u0000')\n    .replace(/\\u0001\\u0002/g, '\\u0001')\n    .replace(/\\u0002\\u0002/g, '\\u0002');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev$$1) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev$$1;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' +\n    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n    (joiner ? (' ON ' + joiner) : '') +\n    (where ? (' WHERE ' +\n    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n    (orderBy ? (' ORDER BY ' + orderBy) : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) { // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n        ' WHERE seq IN (' +\n        seqs.map(function () { return '?'; }).join(',') +\n        ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n          ' WHERE digest IN (' +\n          digestsToCheck.map(function () { return '?'; }).join(',') +\n          ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new ExportedSet();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n              [digest]);\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev$$1) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev$$1], function (tx, res) {\n      if (!res.rows.length) { // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql(\n        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    guardedConsole('error', 'WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString()\n        .match(/function ([^(]+)/);\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' &&\n    /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n      ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n            ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n          'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n\n      var revsToCompact = docInfo.stemmedRevs || [];\n      if (isUpdate && api.auto_compaction) {\n        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n      }\n      if (revsToCompact.length) {\n        compactRevs$1(revsToCompact, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      var rev = docInfo.metadata.rev;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ?\n      'UPDATE ' + DOC_STORE$1 +\n      ' SET json=?, max_seq=?, winningseq=' +\n      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n        : 'INSERT INTO ' + DOC_STORE$1 +\n      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ?\n        [metadataStr, seq, winningRev$$1, id] :\n        [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: rev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n                results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n      ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) { // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n      ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar cachedDatabases = new ExportedMap();\n\n// openDatabase passed in through opts (e.g. for node-websql)\nfunction openDatabaseWithOpts(opts) {\n  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n}\n\nfunction openDBSafely(opts) {\n  try {\n    return {\n      db: openDatabaseWithOpts(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction openDB(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    cachedResult = openDBSafely(opts);\n    cachedDatabases.set(opts.name, cachedResult);\n  }\n  return cachedResult;\n}\n\nvar websqlChanges = new Changes();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = {binary: opts.binary, ctx: txn};\n    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n      doc._attachments[att] = $inject_Object_assign(\n        pick(attObj, ['digest', 'content_type']),\n        { data: data }\n      );\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n  BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n    BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n  DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n  BY_SEQ_STORE$1 + '.json AS data, ' +\n  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n  DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._name = opts.name;\n\n  // extend the options here, because sqlite plugin has a ton of options\n  // and they are constantly changing, so it's more prudent to allow anything\n  var websqlOpts = $inject_Object_assign({}, opts, {\n    version: POUCH_VERSION,\n    description: opts.name,\n    size: size\n  });\n  var openDBResult = openDB(websqlOpts);\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n          DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n            qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n              ' SET deleted = 1 WHERE seq IN ' +\n              qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n      ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n        BY_SEQ_STORE$1 + '.json AS data ' +\n        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n        DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev$$1 = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n              ' (id, rev, json) VALUES (?,?,?)',\n              [row.id, rev$$1, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n                [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n                  [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev$$1 = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev$$1, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(\n            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n            [DOC_STORE$1, BY_SEQ_STORE$1],\n            DOC_STORE_AND_BY_SEQ_JOINER,\n            null,\n            DOC_STORE$1 + '.id '\n          );\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n                ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(\n        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n          tx.executeSql(\n            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n            migrateAttsAndSeqs);\n        });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n      ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql =\n          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n          DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n        var hex = res.rows.item(0).hex;\n        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n        cb();\n      }\n    );\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n        ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n        'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n        ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n              ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else { // version > 0\n\n      var setupDone = function () {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n            ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [\n        runMigration2,\n        runMigration3,\n        runMigration4,\n        runMigration5,\n        runMigration6,\n        runMigration7,\n        setupDone\n      ];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function (tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n          ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else { // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n          [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  function getMaxSeq(tx, callback) {\n    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n    tx.executeSql(sql, [], function (tx, res) {\n      var updateSeq = res.rows.item(0).seq || 0;\n      callback(updateSeq);\n    });\n  }\n\n  function countDocs(tx, callback) {\n    // count the total rows\n    var sql = select(\n      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n      [DOC_STORE$1, BY_SEQ_STORE$1],\n      DOC_STORE_AND_BY_SEQ_JOINER,\n      BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      callback(result.rows.item(0).num);\n    });\n  }\n\n  api._remote = false;\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    var seq;\n    var docCount;\n    db.readTransaction(function (tx) {\n      getMaxSeq(tx, function (theSeq) {\n        seq = theSeq;\n      });\n      countDocs(tx, function (theDocCount) {\n        docCount = theDocCount;\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: seq,\n        websql_encoding: encoding\n      });\n    });\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  function latest$$1(tx, id, rev$$1, callback, finish) {\n    var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n    var sqlArgs = [id];\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var err = createError(MISSING_DOC, 'missing');\n        return finish(err);\n      }\n      var item = results.rows.item(0);\n      var metadata = safeJsonParse(item.metadata);\n      callback(latest(rev$$1, metadata));\n    });\n  }\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, $inject_Object_assign({ctx: txn}, opts), callback);\n      });\n    }\n\n    function finish(err) {\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql;\n    var sqlArgs;\n\n    if (!opts.rev) {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    } else if (opts.latest) {\n      latest$$1(tx, id, opts.rev, function (latestRev) {\n        opts.latest = false;\n        opts.rev = latestRev;\n        api._get(id, opts, callback);\n      }, finish);\n      return;\n    } else {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    }\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var missingErr = createError(MISSING_DOC, 'missing');\n        return finish(missingErr);\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        var deletedErr = createError(MISSING_DOC, 'deleted');\n        return finish(deletedErr);\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n    var updateSeq;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var keys = 'keys' in opts ? opts.keys : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n    \n    var sqlArgs = [];\n    var criteria = [];\n\n    if (keys) {\n      var destinctKeys = [];\n      var bindingStr = \"\";\n      keys.forEach(function (key) {\n        if (destinctKeys.indexOf(key) === -1) {\n          destinctKeys.push(key);\n          bindingStr += '?,';\n        }\n      });\n      bindingStr = bindingStr.substring(0, bindingStr.length - 1); // keys is never empty\n      criteria.push(DOC_STORE$1 + '.id IN (' + bindingStr + ')');\n      sqlArgs = sqlArgs.concat(destinctKeys);\n    } else if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (!keys) {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n      // count the docs in parallel to other operations\n      countDocs(tx, function (docCount) {\n        totalRows = docCount;\n      });\n\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        // get max sequence in parallel to other operations\n        getMaxSeq(tx, function (theSeq) {\n          updateSeq = theSeq;\n        });\n      }\n\n      if (limit === 0) {\n        return;\n      }\n\n      // do a single query to fetch the documents\n      var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        criteria,\n        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n        );\n      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++) {\n          var item = result.rows.item(i);\n          var metadata = safeJsonParse(item.metadata);\n          var id = metadata.id;\n          var data = unstringifyDoc(item.data, id, item.rev);\n          var winningRev$$1 = data._rev;\n          var doc = {\n            id: id,\n            key: id,\n            value: {rev: winningRev$$1}\n          };\n          if (opts.include_docs) {\n            doc.doc = data;\n            doc.doc._rev = winningRev$$1;\n            if (opts.conflicts) {\n              var conflicts = collectConflicts(metadata);\n              if (conflicts.length) {\n                doc.doc._conflicts = conflicts;\n              }\n            }\n            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n          }\n          if (item.deleted) {\n            if (keys) {\n              doc.value.deleted = true;\n              doc.doc = null;\n            } else {\n              // propably should not happen\n              continue;\n            }\n          }\n          if (!keys) {\n            results.push(doc);\n          } else {\n            var index = keys.indexOf(id, index);\n            do {\n              results[index] = doc;\n              index = keys.indexOf(id, index + 1);\n            } while (index > -1 && index < keys.length);\n          }\n        }\n        if (keys) {\n          keys.forEach(function (key, index) {\n            if (!results[index]) {\n              results[index] = {key: key, error: 'not_found'};\n            }\n          });\n        }\n      });\n    }, websqlError(callback), function () {\n      var returnVal = {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      };\n\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        returnVal.update_seq = updateSeq;\n      }\n      callback(null, returnVal);\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function () {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt =\n        DOC_STORE$1 + '.json AS metadata, ' +\n        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n              item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n                  reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' +\n      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n      ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) :\n        parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = thisBtoa(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                           revHash, ctx, opts) {\n          var rev$$1 = pos + '-' + revHash;\n          if (revs.indexOf(rev$$1) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n          'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = {ok: true, id: id, rev: newRev};\n          if (opts.ctx) { // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = {ok: true, id: doc._id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, {'ok': true});\n    });\n  };\n}\n\nfunction canOpenTestDB() {\n  try {\n    openDatabase('_pouch_validate_websql', 1, '', 1);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n// https://github.com/pouchdb/pouchdb/issues/5079)\n// This has been fixed in latest WebKit, so we try to detect it here.\nfunction isValidWebSQL() {\n  // WKWebView UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n  // Chrome for iOS UA:\n  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n  //   Mobile/9B206 Safari/7534.48.3\n  // Firefox for iOS UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\n  // indexedDB is null on some UIWebViews and undefined in others\n  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n    // definitely not WKWebView, avoid creating an unnecessary database\n    return true;\n  }\n  // Cache the result in LocalStorage. Reason we do this is because if we\n  // call openDatabase() too many times, Safari craps out in SauceLabs and\n  // starts throwing DOM Exception 14s.\n  var hasLS = hasLocalStorage();\n  // Include user agent in the hash, so that if Safari is upgraded, we don't\n  // continually think it's broken.\n  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n  if (hasLS && localStorage[localStorageKey]) {\n    return localStorage[localStorageKey] === '1';\n  }\n  var openedTestDB = canOpenTestDB();\n  if (hasLS) {\n    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n  }\n  return openedTestDB;\n}\n\nfunction valid() {\n  if (typeof openDatabase !== 'function') {\n    return false;\n  }\n  return isValidWebSQL();\n}\n\nfunction openDB$2(name, version, description, size) {\n  // Traditional WebSQL API\n  return openDatabase(name, version, description, size);\n}\n\nfunction WebSQLPouch(opts, callback) {\n  var msg = 'WebSQL is deprecated and will be removed in future releases of PouchDB. ' +\n      'Please migrate to IndexedDB: https://pouchdb.com/2018/01/23/pouchdb-6.4.2.html';\n  guardedConsole('warn', msg);\n  var _opts = $inject_Object_assign({\n    websql: openDB$2\n  }, opts);\n\n  WebSqlPouch.call(this, _opts, callback);\n}\n\nWebSQLPouch.valid = valid;\n\nWebSQLPouch.use_prefix = true;\n\nfunction WebSqlPouch$1 (PouchDB) {\n  PouchDB.adapter('websql', WebSQLPouch, true);\n}\n\n/* global fetch */\n/* global Headers */\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise(function (resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function (response) {\n    wrappedPromise.resolve(response);\n  }).catch(function (error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] ||\n      'application/json');\n  }\n\n  if (options.body &&\n      options.processData &&\n      typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function (key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function () {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n        options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function (fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function (result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      result.status = response.statusCode;\n      callback(result);\n    }\n  }).catch(function (error) {\n    if (!error) {\n      // this happens when the listener is canceled\n      error = new Error('canceled');\n    }\n    callback(error);\n  });\n\n  return {abort: wrappedPromise.reject};\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n  var timedout = false;\n\n  var abortReq = function () {\n    xhr.abort();\n    cleanUp();\n  };\n\n  var timeoutReq = function () {\n    timedout = true;\n    xhr.abort();\n    cleanUp();\n  };\n\n  var ret = {abort: abortReq};\n\n  var cleanUp = function () {\n    clearTimeout(timer);\n    ret.abort = function () {};\n    if (xhr) {\n      xhr.onprogress = undefined;\n      if (xhr.upload) {\n        xhr.upload.onprogress = undefined;\n      }\n      xhr.onreadystatechange = undefined;\n      xhr = undefined;\n    }\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n    return callback(new Error(exception.name || 'Url is invalid'));\n  }\n\n  xhr.withCredentials = ('withCredentials' in options) ?\n    options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n    if (options.body &&\n        options.processData &&\n        typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(timeoutReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      if (xhr.readyState !== 4) {\n        timer = setTimeout(timeoutReq, options.timeout);\n      }\n    };\n    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      if (timedout) {\n        err = new Error('ETIMEDOUT');\n        err.code = 'ETIMEDOUT';\n      } else if (typeof xhr.response === 'string' && xhr.response !== '') {\n        try {\n          err = JSON.parse(xhr.response);\n        } catch (e) {}\n      }\n\n      err.status = xhr.status;\n\n      callback(err);\n    }\n    cleanUp();\n  };\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return ret;\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax(options, callback) {\n  if (!false && (hasXhr || options.xhr)) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = $inject_Object_assign(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      /* istanbul ignore next */\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      \n    }\n    cb(null, obj, resp);\n  }\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax(options, function (err, response, body) {\n\n    if (err) {\n      return callback(generateErrorFromResponse(err));\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) &&\n        typeof data !== 'object' &&\n        (/json/.test(content_type) ||\n         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax$1(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = (navigator && navigator.userAgent) ?\n    navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isTrident = ua.indexOf('trident') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  // it appears the new version of safari also caches GETs,\n  // see https://github.com/pouchdb/pouchdb/issues/5010\n  var shouldCacheBust = (isSafari ||\n    ((isIE || isTrident || isEdge) && opts.method === 'GET'));\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\n  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore(opts, callback);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\n\nfunction pool(promiseFactories, limit) {\n  return new PouchPromise(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\nvar CHANGES_TIMEOUT_BUFFER = 5000;\nvar DEFAULT_HEARTBEAT = 10000;\n\nvar supportsBulkGetMap = {};\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var doc = row.doc || row.ok;\n  var atts = doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$2(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise.resolve();\n  }\n\n  return PouchPromise.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new PouchPromise(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n\n  var protocol = parseUri(opts.prefix).protocol;\n\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    name = opts.prefix + encodeURIComponent(dbName);\n  }\n\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = thisBtoa(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  // Not strictly necessary, but we do this because numerous tests\n  // rely on swapping ajax in and out.\n  api._ajax = ajax$1;\n\n  function ajax(userOpts, options, callback) {\n    var reqAjax = (userOpts || {}).ajax || {};\n    var reqOpts = $inject_Object_assign(clone(ajaxOpts), reqAjax, options);\n    var defaultHeaders = clone(ajaxOpts.headers || {});\n    reqOpts.headers = $inject_Object_assign(defaultHeaders, reqAjax.headers,\n      options.headers || {});\n    /* istanbul ignore if */\n    if (api.constructor.listeners('debug').length) {\n      api.constructor.emit('debug', ['http', reqOpts.method, reqOpts.url]);\n    }\n    return api._ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise(function (resolve, reject) {\n      ajax(userOpts, opts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = {method: 'GET', url: dbUrl};\n    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n      } else {\n        return PouchPromise.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  nextTick(function () {\n    callback(null, api);\n  });\n\n  api._remote = true;\n  /* istanbul ignore next */\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ajax({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n      var uuid$$1 = (result && result.uuid) ?\n        (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    });\n  });\n\n  api.request = adapterFun$$1('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          // CouchDB may send a \"compact_running:true\" if it's\n          // already compacting. PouchDB Server doesn't.\n          /* istanbul ignore else */\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      ajax(opts, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs}\n      }, function (err, result) {\n        if (!err && opts.attachments && opts.binary) {\n          result.results.forEach(function (res) {\n            res.docs.forEach(readAttachmentsAsBlobOrBuffer);\n          });\n        }\n        cb(err, result);\n      });\n    }\n\n    /* istanbul ignore next */\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'binary', 'latest']);\n        subOpts.ajax = ajaxOpts;\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    /* istanbul ignore next */\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      ajax({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n        return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    }).catch(callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = opts.update_seq;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetch(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n          '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob) {\n          if (opts.binary) {\n            return blob;\n          }\n          return new PouchPromise(function (resolve) {\n            blobToBase64(blob, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetch(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    }).catch(function (e) {\n      e.docId = id;\n      callback(e);\n    });\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove',\n      function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev$$1 = (doc._rev || opts.rev);\n\n    // Delete the document\n    ajax(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev$$1\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment =\n    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n                                                callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n      encodeAttachmentId(attachmentId) + params;\n    ajax(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =\n    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev$$1,\n                                                   callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n      encodeAttachmentId(attachmentId)) + '?rev=' + rev$$1;\n\n    ajax({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment =\n    adapterFun$$1('putAttachment', function (docId, attachmentId, rev$$1, blob,\n                                                type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob;\n      blob = rev$$1;\n      rev$$1 = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev$$1) {\n      url += '?rev=' + rev$$1;\n    }\n\n    if (typeof blob === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: {'Content-Type': type},\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise.all(req.docs.map(preprocessAttachments$2));\n    }).then(function () {\n      // Update/create the documents\n      ajax(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        timeout: opts.timeout,\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    }).catch(callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$2(doc);\n    }).then(function () {\n      // Update/create the document\n      ajax(opts, {\n        method: 'PUT',\n        url: genDBUrl(host, encodeDocId(doc._id)),\n        body: doc\n      }, function (err, result) {\n        if (err) {\n          err.docId = doc && doc._id;\n          return callback(err);\n        }\n        callback(null, result);\n      });\n    }).catch(callback);\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n\n    if (opts.continuous && !('heartbeat' in opts)) {\n      opts.heartbeat = DEFAULT_HEARTBEAT;\n    }\n\n    var requestTimeout = ('timeout' in opts) ? opts.timeout :\n      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n      30 * 1000;\n\n    // ensure CHANGES_TIMEOUT_BUFFER applies\n    if ('timeout' in opts && opts.timeout &&\n      (requestTimeout - opts.timeout) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.timeout + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    if ('heartbeat' in opts && opts.heartbeat &&\n       (requestTimeout - opts.heartbeat) < CHANGES_TIMEOUT_BUFFER) {\n        requestTimeout = opts.heartbeat + CHANGES_TIMEOUT_BUFFER;\n    }\n\n    var params = {};\n    if ('timeout' in opts && opts.timeout) {\n      params.timeout = opts.timeout;\n    }\n\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.seq_interval) {\n      params.seq_interval = opts.seq_interval;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n    \n    /* istanbul ignore if */\n    if (opts.update_seq) {\n      params.update_seq = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n    /* istanbul ignore next */\n    else if (opts.selector) {\n      // set this automagically for the user, similar to above\n      params.filter = '_selector';\n      method = 'POST';\n      body = {selector: opts.selector };\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: requestTimeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        xhr = ajax(opts, xhrOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        var pending = null;\n        var lastSeq = null;\n        // Attach 'pending' property if server supports it (CouchDB 2.0+)\n        /* istanbul ignore if */\n        if (typeof res.pending === 'number') {\n          pending = res.pending;\n        }\n        if (typeof results.last_seq === 'string' || typeof results.last_seq === 'number') {\n          lastSeq = results.last_seq;\n        }\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c, pending, lastSeq);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nfunction HttpPouch$1 (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n}\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopeEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\n\nfunction TaskQueue$2() {\n  this.promise = new PouchPromise(function (fulfill) {fulfill(); });\n}\nTaskQueue$2.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$2.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\n/* create a string signature for a view so we can cache it and uniq it */\nfunction createViewSignature(mapFun, reduceFun) {\n  // the \"undefined\" part is for backwards compatibility\n  return stringify(mapFun) + stringify(reduceFun) + 'undefined';\n}\n\nfunction createView(sourceDB, viewName, mapFun, reduceFun, temporary, localDocName) {\n  var viewSignature = createViewSignature(mapFun, reduceFun);\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + localDocName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$2();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\n\n/**\n * Returns an \"abstract\" mapreduce object of the form:\n *\n *   {\n *     query: queryFun,\n *     viewCleanup: viewCleanupFun\n *   }\n *\n * Arguments are:\n *\n * localDoc: string\n *   This is for the local doc that gets saved in order to track the\n *   \"dependent\" DBs and clean them up for viewCleanup. It should be\n *   unique, so that indexer plugins don't collide with each other.\n * mapper: function (mapFunDef, emit)\n *   Returns a map function based on the mapFunDef, which in the case of\n *   normal map/reduce is just the de-stringified function, but may be\n *   something else, such as an object in the case of pouchdb-find.\n * reducer: function (reduceFunDef)\n *   Ditto, but for reducing. Modules don't have to support reducing\n *   (e.g. pouchdb-find).\n * ddocValidator: function (ddoc, viewName)\n *   Throws an error if the ddoc or viewName is not valid.\n *   This could be a way to communicate to the user that the configuration for the\n *   indexer is invalid.\n */\nfunction createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator) {\n\n  function tryMap(db, fun, doc) {\n    // emit an event if there was an error thrown by a map function.\n    // putting try/catches in a single function also avoids deoptimizations.\n    try {\n      fun(doc);\n    } catch (e) {\n      emitError(db, e);\n    }\n  }\n\n  function tryReduce(db, fun, keys, values, rereduce) {\n    // same as above, but returning the result or an error. there are two separate\n    // functions to avoid extra memory allocations since the tryCode() case is used\n    // for custom map functions (common) vs this function, which is only used for\n    // custom reduce functions (rare)\n    try {\n      return {output : fun(keys, values, rereduce)};\n    } catch (e) {\n      emitError(db, e);\n      return {error: e};\n    }\n  }\n\n  function sortByKeyThenValue(x, y) {\n    var keyCompare = collate(x.key, y.key);\n    return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n  }\n\n  function sliceResults(results, limit, skip) {\n    skip = skip || 0;\n    if (typeof limit === 'number') {\n      return results.slice(skip, limit + skip);\n    } else if (skip > 0) {\n      return results.slice(skip);\n    }\n    return results;\n  }\n\n  function rowToDocId(row) {\n    var val = row.value;\n    // Users can explicitly specify a joined doc _id, or it\n    // defaults to the doc _id that emitted the key/value.\n    var docId = (val && typeof val === 'object' && val._id) || row.id;\n    return docId;\n  }\n\n  function readAttachmentsAsBlobOrBuffer(res) {\n    res.rows.forEach(function (row) {\n      var atts = row.doc && row.doc._attachments;\n      if (!atts) {\n        return;\n      }\n      Object.keys(atts).forEach(function (filename) {\n        var att = atts[filename];\n        atts[filename].data = b64ToBluffer(att.data, att.content_type);\n      });\n    });\n  }\n\n  function postprocessAttachments(opts) {\n    return function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        readAttachmentsAsBlobOrBuffer(res);\n      }\n      return res;\n    };\n  }\n\n  function addHttpParam(paramName, opts, params, asJson) {\n    // add an http param from opts to params, optionally json-encoded\n    var val = opts[paramName];\n    if (typeof val !== 'undefined') {\n      if (asJson) {\n        val = encodeURIComponent(JSON.stringify(val));\n      }\n      params.push(paramName + '=' + val);\n    }\n  }\n\n  function coerceInteger(integerCandidate) {\n    if (typeof integerCandidate !== 'undefined') {\n      var asNumber = Number(integerCandidate);\n      // prevents e.g. '1foo' or '1.1' being coerced to 1\n      if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n        return asNumber;\n      } else {\n        return integerCandidate;\n      }\n    }\n  }\n\n  function coerceOptions(opts) {\n    opts.group_level = coerceInteger(opts.group_level);\n    opts.limit = coerceInteger(opts.limit);\n    opts.skip = coerceInteger(opts.skip);\n    return opts;\n  }\n\n  function checkPositiveInteger(number) {\n    if (number) {\n      if (typeof number !== 'number') {\n        return  new QueryParseError('Invalid value for integer: \"' +\n          number + '\"');\n      }\n      if (number < 0) {\n        return new QueryParseError('Invalid value for positive integer: ' +\n          '\"' + number + '\"');\n      }\n    }\n  }\n\n  function checkQueryParseError(options, fun) {\n    var startkeyName = options.descending ? 'endkey' : 'startkey';\n    var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n    if (typeof options[startkeyName] !== 'undefined' &&\n      typeof options[endkeyName] !== 'undefined' &&\n      collate(options[startkeyName], options[endkeyName]) > 0) {\n      throw new QueryParseError('No rows can match your key range, ' +\n        'reverse your start_key and end_key or set {descending : true}');\n    } else if (fun.reduce && options.reduce !== false) {\n      if (options.include_docs) {\n        throw new QueryParseError('{include_docs:true} is invalid for reduce');\n      } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n        throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n          '{group: true}');\n      }\n    }\n    ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n      var error = checkPositiveInteger(options[optionName]);\n      if (error) {\n        throw error;\n      }\n    });\n  }\n\n  function httpQuery(db, fun, opts) {\n    // List of parameters to add to the PUT request\n    var params = [];\n    var body;\n    var method = 'GET';\n\n    // If opts.reduce exists and is defined, then add it to the list\n    // of parameters.\n    // If reduce=false then the results are that of only the map function\n    // not the final result of map and reduce.\n    addHttpParam('reduce', opts, params);\n    addHttpParam('include_docs', opts, params);\n    addHttpParam('attachments', opts, params);\n    addHttpParam('limit', opts, params);\n    addHttpParam('descending', opts, params);\n    addHttpParam('group', opts, params);\n    addHttpParam('group_level', opts, params);\n    addHttpParam('skip', opts, params);\n    addHttpParam('stale', opts, params);\n    addHttpParam('conflicts', opts, params);\n    addHttpParam('startkey', opts, params, true);\n    addHttpParam('start_key', opts, params, true);\n    addHttpParam('endkey', opts, params, true);\n    addHttpParam('end_key', opts, params, true);\n    addHttpParam('inclusive_end', opts, params);\n    addHttpParam('key', opts, params, true);\n    addHttpParam('update_seq', opts, params);\n\n    // Format the list of parameters into a valid URI query string\n    params = params.join('&');\n    params = params === '' ? '' : '?' + params;\n\n    // If keys are supplied, issue a POST to circumvent GET query string limits\n    // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n    if (typeof opts.keys !== 'undefined') {\n      var MAX_URL_LENGTH = 2000;\n      // according to http://stackoverflow.com/a/417184/680742,\n      // the de facto URL length limit is 2000 characters\n\n      var keysAsString =\n        'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n      if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n        // If the keys are short enough, do a GET. we do this to work around\n        // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n        params += (params[0] === '?' ? '&' : '?') + keysAsString;\n      } else {\n        method = 'POST';\n        if (typeof fun === 'string') {\n          body = {keys: opts.keys};\n        } else { // fun is {map : mapfun}, so append to this\n          fun.keys = opts.keys;\n        }\n      }\n    }\n\n    // We are referencing a query defined in the design doc\n    if (typeof fun === 'string') {\n      var parts = parseViewName(fun);\n      return db.request({\n        method: method,\n        url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n        body: body\n      }).then(\n        /* istanbul ignore next */\n        function (result) {\n          // fail the entire request if the result contains an error\n          result.rows.forEach(function (row) {\n            if (row.value && row.value.error && row.value.error === \"builtin_reduce_error\") {\n              throw new Error(row.reason);\n            }\n          });\n\n          return result;\n      })\n      .then(postprocessAttachments(opts));\n    }\n\n    // We are using a temporary view, terrible for performance, good for testing\n    body = body || {};\n    Object.keys(fun).forEach(function (key) {\n      if (Array.isArray(fun[key])) {\n        body[key] = fun[key];\n      } else {\n        body[key] = fun[key].toString();\n      }\n    });\n    return db.request({\n      method: 'POST',\n      url: '_temp_view' + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // custom adapters can define their own api._query\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customQuery(db, fun, opts) {\n    return new PouchPromise(function (resolve, reject) {\n      db._query(fun, opts, function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  // custom adapters can define their own api._viewCleanup\n  // and override the default behavior\n  /* istanbul ignore next */\n  function customViewCleanup(db) {\n    return new PouchPromise(function (resolve, reject) {\n      db._viewCleanup(function (err, res) {\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function defaultsTo(value) {\n    return function (reason) {\n      /* istanbul ignore else */\n      if (reason.status === 404) {\n        return value;\n      } else {\n        throw reason;\n      }\n    };\n  }\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits.get(docId);\n    var indexableKeysToKeyValues = docData[0];\n    var changes = docData[1];\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return PouchPromise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return PouchPromise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKeyValueDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeys = new ExportedSet();\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeys.add(doc._id);\n        doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues.get(doc._id);\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n      var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeys.has(key)) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues.get(key);\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKeyValueDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n      .catch(defaultsTo({_id: seqDocId, seq: 0}))\n      .then(function (lastSeqDoc) {\n        var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n        return PouchPromise.all(docIds.map(function (docId) {\n          return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n        })).then(function (listOfDocsToPersist) {\n          var docsToPersist = flatten(listOfDocsToPersist);\n          lastSeqDoc.seq = seq;\n          docsToPersist.push(lastSeqDoc);\n          // write all docs in a single operation, update the seq once\n          return view.db.bulkDocs({docs : docsToPersist});\n        });\n      });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue$2();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue$2();\n\n    function processNextBatch() {\n      return view.sourceDB.changes({\n        conflicts: true,\n        include_docs: true,\n        style: 'all_docs',\n        since: currentSeq,\n        limit: CHANGES_BATCH_SIZE$1\n      }).then(processBatch);\n    }\n\n    function processBatch(response) {\n      var results = response.results;\n      if (!results.length) {\n        return;\n      }\n      var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n      queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n      if (results.length < CHANGES_BATCH_SIZE$1) {\n        return;\n      }\n      return processNextBatch();\n    }\n\n    function createDocIdsToChangesAndEmits(results) {\n      var docIdsToChangesAndEmits = new ExportedMap();\n      for (var i = 0, len = results.length; i < len; i++) {\n        var change = results[i];\n        if (change.doc._id[0] !== '_') {\n          mapResults = [];\n          doc = change.doc;\n\n          if (!doc._deleted) {\n            tryMap(view.sourceDB, mapFun, doc);\n          }\n          mapResults.sort(sortByKeyThenValue);\n\n          var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n          docIdsToChangesAndEmits.set(change.doc._id, [\n            indexableKeysToKeyValues,\n            change.changes\n          ]);\n        }\n        currentSeq = change.seq;\n      }\n      return docIdsToChangesAndEmits;\n    }\n\n    function createIndexableKeysToKeyValues(mapResults) {\n      var indexableKeysToKeyValues = new ExportedMap();\n      var lastKey;\n      for (var i = 0, len = mapResults.length; i < len; i++) {\n        var emittedKeyValue = mapResults[i];\n        var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n        if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n          complexKey.push(i); // dup key+id, so make it unique\n        }\n        indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n        lastKey = emittedKeyValue.key;\n      }\n      return indexableKeysToKeyValues;\n    }\n\n    return processNextBatch().then(function () {\n      return queue.finish();\n    }).then(function () {\n      view.seq = currentSeq;\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n      options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var groupKey = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(groupKey)) {\n        groupKey = groupKey.slice(0, lvl);\n      }\n\n      if (last && collate(last.groupKey, groupKey) === 0) {\n        last.keys.push([e.key, e.id]);\n        last.values.push(e.value);\n        return;\n      }\n      groups.push({\n        keys: [[e.key, e.id]],\n        values: [e.value],\n        groupKey: groupKey\n      });\n    });\n    results = [];\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n      if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      results.push({\n        // CouchDB just sets the value to null if a non-built-in errors out\n        value: reduceTry.error ? null : reduceTry.output,\n        key: e.groupKey\n      });\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(results, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        finalResults.update_seq = view.seq;\n      }\n      if (opts.include_docs) {\n        var docIds = uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = new ExportedMap();\n          allDocsRes.rows.forEach(function (row) {\n            docIdsToDocs.set(row.id, row.doc);\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs.get(docId);\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        /* istanbul ignore if */\n        if (opts.update_seq) {\n          viewOpts.update_seq = true;\n        }\n        return fetchFromView(viewOpts);\n      });\n      return PouchPromise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      /* istanbul ignore if */\n      if (opts.update_seq) {\n        viewOpts.update_seq = true;\n      }\n      var startkey;\n      var endkey;\n      if ('start_key' in opts) {\n        startkey = opts.start_key;\n      }\n      if ('startkey' in opts) {\n        startkey = opts.startkey;\n      }\n      if ('end_key' in opts) {\n        endkey = opts.end_key;\n      }\n      if ('endkey' in opts) {\n        endkey = opts.endkey;\n      }\n      if (typeof startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([startkey, {}]) :\n          toIndexableString([startkey]);\n      }\n      if (typeof endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(\n          inclusiveEnd ? [endkey, {}] : [endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function httpViewCleanup(db) {\n    return db.request({\n      method: 'POST',\n      url: '_view_cleanup'\n    });\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + localDocName).then(function (metaDoc) {\n      var docsToViews = new ExportedMap();\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        var views = docsToViews.get(designDocName);\n        if (!views) {\n          views = new ExportedSet();\n          docsToViews.set(designDocName, views);\n        }\n        views.add(viewName);\n      });\n      var opts = {\n        keys : mapToKeysArray(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8); // cuts off '_design/'\n          docsToViews.get(row.key).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views &&\n              row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] =\n                viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(\n          function (viewDBName) { return !viewsToStatus[viewDBName]; });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return PouchPromise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    /* istanbul ignore next */\n    if (typeof db._query === 'function') {\n      return customQuery(db, fun, opts);\n    }\n    if (isRemote(db)) {\n      return httpQuery(db, fun, opts);\n    }\n    \n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      tempViewQueue.add(function () {\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ 'temp_view/temp_view',\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ true,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          return fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), function () {\n            return view.db.destroy();\n          });\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewPromise = createView(\n          /* sourceDB */ db,\n          /* viewName */ fullViewName,\n          /* mapFun */ fun.map,\n          /* reduceFun */ fun.reduce,\n          /* temporary */ false,\n          /* localDocName */ localDocName);\n        return createViewPromise.then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  function abstractQuery(fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = opts ? coerceOptions(opts) : {};\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = PouchPromise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    promisedCallback(promise, callback);\n    return promise;\n  }\n\n  var abstractViewCleanup = callbackify(function () {\n    var db = this;\n    /* istanbul ignore next */\n    if (typeof db._viewCleanup === 'function') {\n      return customViewCleanup(db);\n    }\n    if (isRemote(db)) {\n      return httpViewCleanup(db);\n    }\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: abstractQuery,\n    viewCleanup: abstractViewCleanup\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction getBuiltIn(reduceFunString) {\n  if (/^_sum/.test(reduceFunString)) {\n    return builtInReduce._sum;\n  } else if (/^_count/.test(reduceFunString)) {\n    return builtInReduce._count;\n  } else if (/^_stats/.test(reduceFunString)) {\n    return builtInReduce._stats;\n  } else if (/^_/.test(reduceFunString)) {\n    throw new Error(reduceFunString + ' is not a supported reduce function.');\n  }\n}\n\nfunction mapper(mapFun, emit) {\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof mapFun === \"function\" && mapFun.length === 2) {\n    var origMap = mapFun;\n    return function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    return evalFunctionWithEval(mapFun.toString(), emit);\n  }\n}\n\nfunction reducer(reduceFun) {\n  var reduceFunString = reduceFun.toString();\n  var builtIn = getBuiltIn(reduceFunString);\n  if (builtIn) {\n    return builtIn;\n  } else {\n    return evalFunctionWithEval(reduceFunString);\n  }\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var fun = ddoc.views && ddoc.views[viewName];\n  if (typeof fun.map !== 'string') {\n    throw new NotFoundError('ddoc ' + ddoc._id + ' has no string view named ' +\n      viewName + ', instead found object of type: ' + typeof fun.map);\n  }\n}\n\nvar localDocName = 'mrviews';\nvar abstract = createAbstractMapReduce(localDocName, mapper, reducer, ddocValidator);\n\nfunction query(fun, opts, callback) {\n  return abstract.query.call(this, fun, opts, callback);\n}\n\nfunction viewCleanup(callback) {\n  return abstract.viewCleanup.call(this, callback);\n}\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev$$1) {\n  return /^1-/.test(rev$$1);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return PouchPromise.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = isRemote(src) && !isRemote(target);\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return PouchPromise.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return PouchPromise.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return PouchPromise.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc)\n                   .then(function (attachments) {\n                           var filenames = Object.keys(remoteDoc._attachments);\n                           attachments\n                             .forEach(function (attachment, i) {\n                                        var att = remoteDoc._attachments[filenames[i]];\n                                        delete att.stub;\n                                        delete att.length;\n                                        att.data = attachment;\n                                      });\n\n                                      return remoteDoc;\n                                    });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return PouchPromise.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.adapter === 'http' || db.adapter === 'https') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue, opts) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n  this.opts = opts || {};\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  if (this.opts.writeTargetCheckpoint) {\n    return updateCheckpoint(this.target, this.id, checkpoint,\n      session, this.returnValue);\n  } else {\n    return PouchPromise.resolve(true);\n  }\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  if (this.opts.writeSourceCheckpoint) {\n    var self = this;\n    return updateCheckpoint(this.src, this.id, checkpoint,\n      session, this.returnValue)\n      .catch(function (err) {\n        if (isForbiddenError(err)) {\n          self.opts.writeSourceCheckpoint = false;\n          return true;\n        }\n        throw err;\n      });\n  } else {\n    return PouchPromise.resolve(true);\n  }\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n\n  if (self.opts && self.opts.writeSourceCheckpoint && !self.opts.writeTargetCheckpoint) {\n    return self.src.get(self.id).then(function (sourceDoc) {\n      return sourceDoc.last_seq || LOWEST_SEQ;\n    }).catch(function (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        throw err;\n      }\n      return LOWEST_SEQ;\n    });\n  }\n\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.opts && self.opts.writeTargetCheckpoint && !self.opts.writeSourceCheckpoint) {\n      return targetDoc.last_seq || LOWEST_SEQ;\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.opts.writeSourceCheckpoint = false;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n  var selector = '';\n\n  // possibility for checkpoints to be lost here as behaviour of\n  // JSON.stringify is not stable (see #6226)\n  /* istanbul ignore if */\n  if (opts.selector) {\n    selector = JSON.stringify(opts.selector);\n  }\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds + selector;\n    return new PouchPromise(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var selector = opts.selector;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n  var seq_interval = opts.seq_interval;\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n\n      var checkpointOpts = {};\n      if (opts.checkpoint === false) {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'source') {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: false };\n      } else if (opts.checkpoint === 'target') {\n        checkpointOpts = { writeSourceCheckpoint: false, writeTargetCheckpoint: true };\n      } else {\n        checkpointOpts = { writeSourceCheckpoint: true, writeTargetCheckpoint: true };\n      }\n\n      checkpointer = new Checkpointer(src, target, repId, returnValue, checkpointOpts);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n          var errorName = (error.name || '').toLowerCase();\n          if (errorName === 'unauthorized' || errorName === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      // Attach 'pending' property if server supports it (CouchDB 2.0+)\n      /* istanbul ignore if */\n      if (typeof currentBatch.pending === 'number') {\n        outResult.pending = currentBatch.pending;\n        delete currentBatch.pending;\n      }\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      // need to extend the error because Firefox considers \".result\" read-only\n      fatalError = createError(fatalError);\n      fatalError.result = result;\n\n      // Normalize error name. i.e. 'Unauthorized' -> 'unauthorized' (eg Sync Gateway)\n      var errorName = (fatalError.name || '').toLowerCase();\n      if (errorName === 'unauthorized' || errorName === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change, pending, lastSeq) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    // Attach 'pending' property if server supports it (CouchDB 2.0+)\n    /* istanbul ignore if */\n    if (typeof pending === 'number') {\n      pendingBatch.pending = pending;\n    }\n\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq || lastSeq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(batches.length === 0 && changesOpts.live);\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          selector: selector,\n          return_docs: true // required so we know when we're done\n        };\n        if (seq_interval !== false) {\n          changesOpts.seq_interval = seq_interval || batch_size;\n        }\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, events.EventEmitter);\nfunction Replication() {\n  events.EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, events.EventEmitter);\nfunction sync$1(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? $inject_Object_assign({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? $inject_Object_assign({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync$1;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      if (typeof this.replicateMethods === 'undefined') {\n        this.replicateMethods = {\n          from: function (other, opts, callback) {\n            return self.constructor.replicate(other, self, opts, callback);\n          },\n          to: function (other, opts, callback) {\n            return self.constructor.replicate(self, other, opts, callback);\n          }\n        };\n      }\n      return this.replicateMethods;\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB.plugin(IDBPouch)\n  .plugin(WebSqlPouch$1)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n// are aggressively optimized and jsnext:main would normally give us this\n// aggressive bundle.\n\nmodule.exports = PouchDB;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb/lib/index-browser.js\n// module id = 82\n// module chunks = 0","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb/~/debug/src/browser.js\n// module id = 83\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb/~/debug/src/debug.js\n// module id = 84\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb/~/ms/index.js\n// module id = 85\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\nvar _clockseq;\n\n// Previous uuid creation time\nvar _lastMSecs = 0;\nvar _lastNSecs = 0;\n\n// See https://github.com/broofa/node-uuid for API details\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || [];\n\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;\n\n  // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n  if (node == null || clockseq == null) {\n    var seedBytes = rng();\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [\n        seedBytes[0] | 0x01,\n        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]\n      ];\n    }\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  }\n\n  // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();\n\n  // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;\n\n  // Time since last uuid creation (in msecs)\n  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;\n\n  // Per 4.2.1.2, Bump clockseq on clock regression\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  }\n\n  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  }\n\n  // Per 4.2.1.2 Throw error if too many uuids are requested\n  if (nsecs >= 10000) {\n    throw new Error('uuid.v1(): Can\\'t create more than 10M uuids/sec');\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq;\n\n  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n  msecs += 12219292800000;\n\n  // `time_low`\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff;\n\n  // `time_mid`\n  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff;\n\n  // `time_high_and_version`\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n  b[i++] = tmh >>> 16 & 0xff;\n\n  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n  b[i++] = clockseq >>> 8 | 0x80;\n\n  // `clock_seq_low`\n  b[i++] = clockseq & 0xff;\n\n  // `node`\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf ? buf : bytesToUuid(b);\n}\n\nmodule.exports = v1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v1.js\n// module id = 86\n// module chunks = 0","var rng = require('./lib/rng');\nvar bytesToUuid = require('./lib/bytesToUuid');\n\nfunction v4(options, buf, offset) {\n  var i = buf && offset || 0;\n\n  if (typeof(options) == 'string') {\n    buf = options === 'binary' ? new Array(16) : null;\n    options = null;\n  }\n  options = options || {};\n\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = (rnds[6] & 0x0f) | 0x40;\n  rnds[8] = (rnds[8] & 0x3f) | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    for (var ii = 0; ii < 16; ++ii) {\n      buf[i + ii] = rnds[ii];\n    }\n  }\n\n  return buf || bytesToUuid(rnds);\n}\n\nmodule.exports = v4;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/uuid/v4.js\n// module id = 87\n// module chunks = 0","'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vuvuzela/index.js\n// module id = 88\n// module chunks = 0","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ')\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = options.status === undefined ? 200 : options.status\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/whatwg-fetch/fetch.js\n// module id = 89\n// module chunks = 0"],"sourceRoot":""}