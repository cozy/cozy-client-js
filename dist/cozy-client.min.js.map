{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///cozy-client.min.js","webpack:///webpack/bootstrap df176c5bf46a37c88d76","webpack:///./~/core-js/modules/_export.js","webpack:///./~/core-js/modules/_global.js","webpack:///./~/core-js/modules/_an-object.js","webpack:///./~/core-js/modules/_wks.js","webpack:///./~/core-js/modules/_is-object.js","webpack:///./~/core-js/modules/_fails.js","webpack:///./~/core-js/modules/_object-dp.js","webpack:///./~/core-js/modules/_has.js","webpack:///./~/core-js/modules/_descriptors.js","webpack:///./~/core-js/modules/_to-length.js","webpack:///./~/core-js/modules/_hide.js","webpack:///./~/core-js/modules/_to-iobject.js","webpack:///./src/fetch.js","webpack:///./~/core-js/modules/_ctx.js","webpack:///./~/core-js/modules/_typed-array.js","webpack:///./~/pouchdb-find/lib/utils.js","webpack:///./~/core-js/modules/_defined.js","webpack:///./~/core-js/modules/_object-gopd.js","webpack:///./~/core-js/modules/_property-desc.js","webpack:///./~/core-js/modules/_redefine.js","webpack:///./~/process/browser.js","webpack:///./src/utils.js","webpack:///./~/core-js/modules/_a-function.js","webpack:///./~/core-js/modules/_to-object.js","webpack:///./~/core-js/modules/_uid.js","webpack:///./~/core-js/modules/_add-to-unscopables.js","webpack:///./~/core-js/modules/_an-instance.js","webpack:///./~/core-js/modules/_cof.js","webpack:///./~/core-js/modules/_iterators.js","webpack:///./~/core-js/modules/_library.js","webpack:///./~/core-js/modules/_object-keys.js","webpack:///./~/core-js/modules/_redefine-all.js","webpack:///./~/core-js/modules/_set-to-string-tag.js","webpack:///./~/core-js/modules/_to-integer.js","webpack:///./~/pouchdb-find/lib/adapters/local/utils.js","webpack:///./src/doctypes.js","webpack:///./~/core-js/modules/_array-methods.js","webpack:///./~/core-js/modules/_core.js","webpack:///./~/core-js/modules/_meta.js","webpack:///./~/core-js/modules/_object-create.js","webpack:///./~/core-js/modules/_object-gopn.js","webpack:///./~/core-js/modules/_object-gpo.js","webpack:///./~/core-js/modules/_object-pie.js","webpack:///./~/core-js/modules/_to-index.js","webpack:///./~/core-js/modules/_to-primitive.js","webpack:///./~/core-js/modules/_collection.js","webpack:///./~/core-js/modules/_fix-re-wks.js","webpack:///./~/core-js/modules/_for-of.js","webpack:///./~/core-js/modules/_invoke.js","webpack:///./~/core-js/modules/_iter-detect.js","webpack:///./~/core-js/modules/_object-gops.js","webpack:///./~/immediate/lib/browser.js","webpack:///./~/pouchdb-collate/lib/index.js","webpack:///./src/auth_v3.js","webpack:///./~/core-js/modules/_array-fill.js","webpack:///./~/core-js/modules/_array-includes.js","webpack:///./~/core-js/modules/_classof.js","webpack:///./~/core-js/modules/_create-property.js","webpack:///./~/core-js/modules/_dom-create.js","webpack:///./~/core-js/modules/_enum-bug-keys.js","webpack:///./~/core-js/modules/_fails-is-regexp.js","webpack:///./~/core-js/modules/_iobject.js","webpack:///./~/core-js/modules/_is-array-iter.js","webpack:///./~/core-js/modules/_math-expm1.js","webpack:///./~/core-js/modules/_math-sign.js","webpack:///./~/core-js/modules/_set-proto.js","webpack:///./~/core-js/modules/_set-species.js","webpack:///./~/core-js/modules/_shared-key.js","webpack:///./~/core-js/modules/_shared.js","webpack:///./~/core-js/modules/_string-context.js","webpack:///./~/core-js/modules/_task.js","webpack:///./~/core-js/modules/_typed.js","webpack:///./~/core-js/modules/core.get-iterator-method.js","webpack:///./~/core-js/modules/es6.array.iterator.js","webpack:///./~/inherits/inherits_browser.js","webpack:///./~/pouchdb-find/lib/abstract-mapreduce/utils.js","webpack:///./~/pouchdb-find/lib/adapters/local/abstract-mapper.js","webpack:///./~/argsarray/index.js","webpack:///./src/jsonapi.js","webpack:///./~/core-js/modules/_array-copy-within.js","webpack:///./~/core-js/modules/_collection-strong.js","webpack:///./~/core-js/modules/_collection-weak.js","webpack:///./~/core-js/modules/_html.js","webpack:///./~/core-js/modules/_ie8-dom-define.js","webpack:///./~/core-js/modules/_is-array.js","webpack:///./~/core-js/modules/_is-integer.js","webpack:///./~/core-js/modules/_is-regexp.js","webpack:///./~/core-js/modules/_iter-call.js","webpack:///./~/core-js/modules/_iter-define.js","webpack:///./~/core-js/modules/_iter-step.js","webpack:///./~/core-js/modules/_math-log1p.js","webpack:///./~/core-js/modules/_object-assign.js","webpack:///./~/core-js/modules/_object-keys-internal.js","webpack:///./~/core-js/modules/_object-to-array.js","webpack:///./~/core-js/modules/_own-keys.js","webpack:///./~/core-js/modules/_same-value.js","webpack:///./~/core-js/modules/_species-constructor.js","webpack:///./~/core-js/modules/_string-pad.js","webpack:///./~/core-js/modules/_string-repeat.js","webpack:///./~/core-js/modules/_typed-buffer.js","webpack:///./~/core-js/modules/_wks-ext.js","webpack:///./~/pouchdb-extend/index.js","webpack:///./~/pouchdb-find/lib/abstract-mapreduce/upsert.js","webpack:///./~/pouchdb-find/lib/adapters/local/get-indexes/index.js","webpack:///./~/pouchdb-find/lib/massageCreateIndexRequest.js","webpack:///./~/pouchdb-upsert/index.js","webpack:///./~/spark-md5/spark-md5.js","webpack:///./src/auth_storage.js","webpack:///./src/auth_v2.js","webpack:///./src/data.js","webpack:///./src/files.js","webpack:///./src/index.js","webpack:///./src/intents.js","webpack:///./src/jobs.js","webpack:///./src/mango.js","webpack:///./src/offline.js","webpack:///./src/relations.js","webpack:///./src/settings.js","webpack:///./~/core-js/modules/_array-species-constructor.js","webpack:///./~/core-js/modules/_array-species-create.js","webpack:///./~/core-js/modules/_bind.js","webpack:///./~/core-js/modules/_enum-keys.js","webpack:///./~/core-js/modules/_flags.js","webpack:///./~/core-js/modules/_inherit-if-required.js","webpack:///./~/core-js/modules/_iter-create.js","webpack:///./~/core-js/modules/_keyof.js","webpack:///./~/core-js/modules/_microtask.js","webpack:///./~/core-js/modules/_object-dps.js","webpack:///./~/core-js/modules/_object-gopn-ext.js","webpack:///./~/core-js/modules/_partial.js","webpack:///./~/core-js/modules/_path.js","webpack:///./~/core-js/modules/_string-at.js","webpack:///./~/core-js/modules/_wks-define.js","webpack:///./~/core-js/modules/es6.array.copy-within.js","webpack:///./~/core-js/modules/es6.array.fill.js","webpack:///./~/core-js/modules/es6.array.find-index.js","webpack:///./~/core-js/modules/es6.array.find.js","webpack:///./~/core-js/modules/es6.array.from.js","webpack:///./~/core-js/modules/es6.array.of.js","webpack:///./~/core-js/modules/es6.function.name.js","webpack:///./~/core-js/modules/es6.map.js","webpack:///./~/core-js/modules/es6.math.acosh.js","webpack:///./~/core-js/modules/es6.math.asinh.js","webpack:///./~/core-js/modules/es6.math.atanh.js","webpack:///./~/core-js/modules/es6.math.cbrt.js","webpack:///./~/core-js/modules/es6.math.clz32.js","webpack:///./~/core-js/modules/es6.math.cosh.js","webpack:///./~/core-js/modules/es6.math.expm1.js","webpack:///./~/core-js/modules/es6.math.fround.js","webpack:///./~/core-js/modules/es6.math.hypot.js","webpack:///./~/core-js/modules/es6.math.imul.js","webpack:///./~/core-js/modules/es6.math.log10.js","webpack:///./~/core-js/modules/es6.math.log1p.js","webpack:///./~/core-js/modules/es6.math.log2.js","webpack:///./~/core-js/modules/es6.math.sign.js","webpack:///./~/core-js/modules/es6.math.sinh.js","webpack:///./~/core-js/modules/es6.math.tanh.js","webpack:///./~/core-js/modules/es6.math.trunc.js","webpack:///./~/core-js/modules/es6.number.epsilon.js","webpack:///./~/core-js/modules/es6.number.is-finite.js","webpack:///./~/core-js/modules/es6.number.is-integer.js","webpack:///./~/core-js/modules/es6.number.is-nan.js","webpack:///./~/core-js/modules/es6.number.is-safe-integer.js","webpack:///./~/core-js/modules/es6.number.max-safe-integer.js","webpack:///./~/core-js/modules/es6.number.min-safe-integer.js","webpack:///./~/core-js/modules/es6.object.assign.js","webpack:///./~/core-js/modules/es6.object.is.js","webpack:///./~/core-js/modules/es6.object.set-prototype-of.js","webpack:///./~/core-js/modules/es6.promise.js","webpack:///./~/core-js/modules/es6.reflect.apply.js","webpack:///./~/core-js/modules/es6.reflect.construct.js","webpack:///./~/core-js/modules/es6.reflect.define-property.js","webpack:///./~/core-js/modules/es6.reflect.delete-property.js","webpack:///./~/core-js/modules/es6.reflect.get-own-property-descriptor.js","webpack:///./~/core-js/modules/es6.reflect.get-prototype-of.js","webpack:///./~/core-js/modules/es6.reflect.get.js","webpack:///./~/core-js/modules/es6.reflect.has.js","webpack:///./~/core-js/modules/es6.reflect.is-extensible.js","webpack:///./~/core-js/modules/es6.reflect.own-keys.js","webpack:///./~/core-js/modules/es6.reflect.prevent-extensions.js","webpack:///./~/core-js/modules/es6.reflect.set-prototype-of.js","webpack:///./~/core-js/modules/es6.reflect.set.js","webpack:///./~/core-js/modules/es6.regexp.flags.js","webpack:///./~/core-js/modules/es6.regexp.match.js","webpack:///./~/core-js/modules/es6.regexp.replace.js","webpack:///./~/core-js/modules/es6.regexp.search.js","webpack:///./~/core-js/modules/es6.regexp.split.js","webpack:///./~/core-js/modules/es6.set.js","webpack:///./~/core-js/modules/es6.string.code-point-at.js","webpack:///./~/core-js/modules/es6.string.ends-with.js","webpack:///./~/core-js/modules/es6.string.from-code-point.js","webpack:///./~/core-js/modules/es6.string.includes.js","webpack:///./~/core-js/modules/es6.string.raw.js","webpack:///./~/core-js/modules/es6.string.repeat.js","webpack:///./~/core-js/modules/es6.string.starts-with.js","webpack:///./~/core-js/modules/es6.symbol.js","webpack:///./~/core-js/modules/es6.typed.data-view.js","webpack:///./~/core-js/modules/es6.typed.float32-array.js","webpack:///./~/core-js/modules/es6.typed.float64-array.js","webpack:///./~/core-js/modules/es6.typed.int16-array.js","webpack:///./~/core-js/modules/es6.typed.int32-array.js","webpack:///./~/core-js/modules/es6.typed.int8-array.js","webpack:///./~/core-js/modules/es6.typed.uint16-array.js","webpack:///./~/core-js/modules/es6.typed.uint32-array.js","webpack:///./~/core-js/modules/es6.typed.uint8-array.js","webpack:///./~/core-js/modules/es6.typed.uint8-clamped-array.js","webpack:///./~/core-js/modules/es6.weak-map.js","webpack:///./~/core-js/modules/es6.weak-set.js","webpack:///./~/core-js/modules/es7.array.includes.js","webpack:///./~/core-js/modules/es7.object.entries.js","webpack:///./~/core-js/modules/es7.object.get-own-property-descriptors.js","webpack:///./~/core-js/modules/es7.object.values.js","webpack:///./~/core-js/modules/es7.string.pad-end.js","webpack:///./~/core-js/modules/es7.string.pad-start.js","webpack:///./~/core-js/modules/web.dom.iterable.js","webpack:///./~/core-js/modules/web.immediate.js","webpack:///./~/core-js/modules/web.timers.js","webpack:///./~/events/events.js","webpack:///./~/is-array/index.js","webpack:///./~/isomorphic-fetch/fetch-npm-browserify.js","webpack:///./~/lie/lib/browser.js","webpack:///./~/pouchdb-collate/lib/utils.js","webpack:///./~/pouchdb-find/lib/abstract-mapreduce/create-view.js","webpack:///./~/pouchdb-find/lib/abstract-mapreduce/index.js","webpack:///./~/pouchdb-find/lib/abstract-mapreduce/taskqueue.js","webpack:///./~/pouchdb-find/lib/adapters/http/index.js","webpack:///./~/pouchdb-find/lib/adapters/local/create-index/index.js","webpack:///./~/pouchdb-find/lib/adapters/local/delete-index/index.js","webpack:///./~/pouchdb-find/lib/adapters/local/find/in-memory-filter.js","webpack:///./~/pouchdb-find/lib/adapters/local/find/index.js","webpack:///./~/pouchdb-find/lib/adapters/local/find/query-planner.js","webpack:///./~/pouchdb-find/lib/adapters/local/index.js","webpack:///./~/pouchdb-find/lib/index.js","webpack:///./~/pouchdb-find/~/debug/src/debug.js","webpack:///./~/pouchdb-find/~/ms/index.js","webpack:///./~/pouchdb-promise/~/lie/lib/index.js","webpack:///./~/pouchdb/lib/index-browser.js","webpack:///./~/pouchdb/~/debug/src/debug.js","webpack:///./~/pouchdb/~/spark-md5/spark-md5.js","webpack:///./~/regenerator-runtime/runtime.js","webpack:///./~/scope-eval/scope_eval.js","webpack:///./~/vuvuzela/index.js","webpack:///./~/whatwg-fetch/fetch.js","webpack:///./~/pouchdb/~/debug/src/browser.js","webpack:///./~/pouchdb-promise/lib/index.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","i","Object","prototype","hasOwnProperty","_m","args","slice","fn","a","b","apply","concat","global","core","hide","redefine","ctx","PROTOTYPE","$export","type","name","source","key","own","out","exp","IS_FORCED","F","IS_GLOBAL","G","IS_STATIC","S","IS_PROTO","P","IS_BIND","B","target","expProto","undefined","Function","U","W","R","window","Math","self","__g","isObject","it","TypeError","store","uid","Symbol","USE_SYMBOL","$exports","exec","e","anObject","IE8_DOM_DEFINE","toPrimitive","dP","defineProperty","f","O","Attributes","value","get","toInteger","min","createDesc","object","IObject","defined","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","_possibleConstructorReturn","ReferenceError","_inherits","subClass","superClass","create","constructor","enumerable","writable","configurable","setPrototypeOf","__proto__","cozyFetch","cozy","path","options","arguments","length","fullpath","then","resp","disableAuth","fetch","manualAuthCredentials","cozyFetchWithAuth","authorize","credentials","handleResponse","headers","token","toAuthHeader","Promise","all","isV2","_ref","_ref2","_slicedToArray","res","status","dontRetry","client","_utils","retry","_auth_v","refreshToken","newToken","saveCredentials","cozyFetchJSON","method","body","processJSONAPI","fetchJSON","response","handleJSONResponse","cozyFetchRawJSON","JSON","stringify","ok","data","contentType","indexOf","json","text","err","FetchError","Error","_jsonapi2","sliceIterator","arr","_arr","_n","_d","_e","_s","_i","iterator","next","done","push","Array","isArray","_jsonapi","_Error","reason","_this","getPrototypeOf","captureStackTrace","url","message","isUnauthorized","isNotFound","aFunction","that","LIBRARY","fails","$typed","$buffer","anInstance","propertyDesc","redefineAll","toLength","toIndex","has","same","classof","toObject","isArrayIter","gOPN","getIterFn","wks","createArrayMethod","createArrayIncludes","speciesConstructor","ArrayIterators","Iterators","$iterDetect","setSpecies","arrayFill","arrayCopyWithin","$DP","$GOPD","gOPD","RangeError","Uint8Array","ARRAY_BUFFER","SHARED_BUFFER","BYTES_PER_ELEMENT","ArrayProto","$ArrayBuffer","ArrayBuffer","$DataView","DataView","arrayForEach","arrayFilter","arraySome","arrayEvery","arrayFind","arrayFindIndex","arrayIncludes","arrayIndexOf","arrayValues","values","arrayKeys","keys","arrayEntries","entries","arrayLastIndexOf","lastIndexOf","arrayReduce","reduce","arrayReduceRight","reduceRight","arrayJoin","join","arraySort","sort","arraySlice","arrayToString","toString","arrayToLocaleString","toLocaleString","ITERATOR","TAG","TYPED_CONSTRUCTOR","DEF_CONSTRUCTOR","ALL_CONSTRUCTORS","CONSTR","TYPED_ARRAY","TYPED","VIEW","WRONG_LENGTH","$map","allocate","LITTLE_ENDIAN","Uint16Array","buffer","FORCED_SET","set","strictToLength","SAME","number","toOffset","BYTES","offset","validate","C","speciesFromList","list","fromList","index","result","addGetter","internal","$from","step","aLen","mapfn","mapping","iterFn","$of","TO_LOCALE_BUG","$toLocaleString","proto","copyWithin","start","every","callbackfn","fill","filter","find","predicate","findIndex","forEach","searchElement","includes","separator","map","reverse","middle","floor","some","comparefn","subarray","begin","end","$begin","byteOffset","$slice","$set","arrayLike","src","len","$iterators","isTAIndex","String","$getDesc","$setDesc","desc","getOwnPropertyDescriptor","$TypedArrayPrototype$","KEY","wrapper","CLAMPED","NAME","ISNT_UINT8","GETTER","SETTER","TypedArray","Base","TAC","FORCED","ABV","TypedArrayPrototype","getter","v","o","setter","round","addElement","$offset","$length","byteLength","klass","$len","l","iter","$nativeIterator","CORRECT_ITER_NAME","$iterator","from","of","process","once","fun","called","getArguments","console","trace","toPromise","func","usedCB","tempCB","pop","nextTick","promise","fulfill","reject","callback","mesg","cancel","inherits","clone","extend","callbackify","cb","promisedCallback","crypto","Md5","MD5","string","browser","hash","createHash","update","digest","flatten","subArr","mergeObjects","getFieldFromDoc","doc","parsedField","setFieldInDoc","elem","parseField","fieldName","fields","current","ch","substring","pick","oneArrayIsSubArrayOfOther","left","right","oneArrayIsStrictSubArrayOfOther","oneSetIsSubArrayOfOther","field","leftIdx","splice","compare","arrayToObject","max","maxScore","element","score","arrayEquals","arr1","arr2","uniq","log","pIE","toIObject","bitmap","SRC","TO_STRING","$toString","TPL","split","inspectSource","val","safe","isFunction","defaultSetTimout","defaultClearTimeout","runTimeout","cachedSetTimeout","setTimeout","runClearTimeout","marker","cachedClearTimeout","clearTimeout","cleanUpNextTick","draining","currentQueue","queue","queueIndex","drainQueue","timeout","run","Item","array","noop","title","env","argv","version","versions","on","addListener","off","removeListener","removeAllListeners","emit","binding","cwd","chdir","dir","umask","unpromiser","_len","_key","isPromise","isOnline","navigator","onLine","isOffline","sleep","time","resolve","count","delay","doTry","_len2","_key2","catch","getBackedoffDelay","getFuzzedDelay","retryDelay","fuzzingFactor","random","FuzzFactor","retryCount","pow","createPath","doctype","query","route","encodeURIComponent","q","encodeQuery","qname","decodeQuery","queryIndex","queries","fragIndex","queryStr","parts","pair","decodeURIComponent","warn","warned","px","UNSCOPABLES","forbiddenField","$keys","enumBugKeys","def","tag","stat","ceil","isNaN","getKey","getValue","massageSort","sorting","isCombinationalField","combinationFields","mergeGtGte","operator","fieldMatchers","$eq","$gte","$gt","mergeLtLte","$lte","$lt","mergeNe","$ne","mergeEq","mergeAndedSelectors","selectors","selector","matcher","massageSelector","input","utils","wasAnded","massageIndexDef","indexDef","getKeyFromDoc","filterInclusiveStart","rows","targetValue","indexFields","row","docKey","abs","collate","reverseOptions","opts","newOpts","startkey","endkey","inclusive_start","inclusive_end","validateIndex","ascFields","validateSort","requestDef","defaultUsed","noneIdSorts","sortItem","validateFindRequest","getUserFields","userFields","selectorFields","sortFields","Number","MAX_VALUE","rightIdx","sortOrder","normalizeDoctype","isQualified","known","REVERSE_KNOWN","replace","KNOWN_DOCTYPES","DOCTYPE_FILES","files","folder","contact","event","track","playlist","k","asc","TYPE","$create","IS_MAP","IS_FILTER","IS_SOME","IS_EVERY","IS_FIND_INDEX","NO_HOLES","$this","__e","META","setDesc","isExtensible","FREEZE","preventExtensions","setMeta","w","fastKey","getWeak","onFreeze","meta","NEED","dPs","IE_PROTO","Empty","createDict","iframeDocument","iframe","lt","gt","style","display","appendChild","contentWindow","document","open","write","close","Properties","hiddenKeys","getOwnPropertyNames","ObjectProto","propertyIsEnumerable","valueOf","forOf","setToStringTag","inheritIfRequired","methods","common","IS_WEAK","ADDER","fixMethod","HASNT_CHAINING","THROWS_ON_PRIMITIVES","ACCEPT_ITERABLES","BUGGY_ZERO","$instance","iterable","clear","getConstructor","setStrong","SYMBOL","fns","strfn","rxfn","RegExp","arg","BREAK","RETURN","un","SAFE_CLOSING","riter","skipClosing","getOwnPropertySymbols","oldQueue","immediate","task","scheduleDrain","Mutation","MutationObserver","WebKitMutationObserver","observer","createTextNode","observe","characterData","setImmediate","MessageChannel","createElement","scriptEl","onreadystatechange","parentNode","removeChild","documentElement","channel","port1","onmessage","port2","postMessage","indexify","numToIndexableString","toIndexableString","objKey","parseNumber","str","num","originalIdx","zero","neg","numAsString","magAsString","MAGNITUDE_DIGITS","magnitude","parseInt","MIN_MAGNITUDE","parseFloat","stack","metaStack","lastMetaElement","lastElementIndex","arrayCollate","stringCollate","objectCollate","ak","bk","collationIndex","x","idx","expFormat","toExponential","magForComparison","magString","padLeft","SEP","factor","factorStr","toFixed","normalizeKey","ai","bi","Infinity","origKey","Date","toJSON","parseIndexableString","parsedNum","parsedStr","arrayElement","objElement","clientParams","_clientParams","Client","registerClient","cli","isRegistered","_fetch","toRegisterJSON","updateClient","resetSecret","client_id","clientID","client_secret","clientSecret","createClient","unregisterClient","getClient","oldClient","newClient","shouldPassRegistration","registrationAccessToken","getAuthCodeURL","scopes","state","generateRandomState","redirect_uri","redirectURI","response_type","scope","_url","getAccessToken","pageURL","grantQueries","getGrantCodeFromPageURL","retrieveToken","grant_type","code","refresh_token","oauthFlow","storage","onRegistered","clearAndRetry","tryCount","registerNewClient","_getAuthCodeURL","save","StateKey","ignoreCachedCredentials","load","CredsKey","storedState","AccessToken","statePromise","t","delete","creds","assign","Content-Type","location","href","getRandomValues","StateSize","randomBytes","btoa","fromCharCode","AppToken","_createClass","defineProperties","props","descriptor","protoProps","staticProps","registration_access_token","redirect_uris","softwareID","software_id","softwareVersion","software_version","clientName","client_name","clientKind","client_kind","clientURI","client_uri","logoURI","logo_uri","policyURI","policy_uri","tokenType","token_type","accessToken","access_token","endPos","IS_INCLUDES","el","fromIndex","cof","ARG","tryGet","T","callee","$defineProperty","is","MATCH","re","$expm1","expm1","sign","check","test","buggy","DESCRIPTORS","SPECIES","shared","SHARED","isRegExp","searchString","defer","port","invoke","html","cel","setTask","clearTask","clearImmediate","counter","ONREADYSTATECHANGE","listener","addEventListener","importScripts","Typed","TypedArrayConstructors","getIteratorMethod","addToUnscopables","iterated","kind","_t","_k","Arguments","ctor","superCtor","super_","TempCtor","argsarray","fin","promise2","sequentialize","promiseFactory","add","arrs","output","createDeepMultiMapper","toEmit","iLen","j","jLen","createDeepSingleMapper","createShallowSingleMapper","createShallowMultiMapper","checkShallow","createMapper","isShallow","isSingle","mapper","mapFunDef","reducer","ddocValidator","ddoc","viewName","view","views","_id","localUtils","abstractMapReduce","abstractMapper","argsArray","indexKey","findByRef","resources","ref","handleResource","rawResource","links","resource","_type","_rev","rev","attributes","relations","rels","relationships","handleTopLevel","included","r","to","inc","$iterDefine","SIZE","getEntry","entry","_f","n","_l","prev","$has","uncaughtFrozenStore","UncaughtFrozenStore","findUncaughtFrozen","ufstore","isFinite","ret","$iterCreate","BUGGY","FF_ITERATOR","KEYS","VALUES","returnThis","DEFAULT","IS_SET","IteratorPrototype","getMethod","DEF_VALUES","VALUES_BUG","$native","$default","$entries","$anyNative","log1p","getKeys","gOPS","$assign","A","K","getSymbols","isEnum","names","isEntries","Reflect","ownKeys","y","D","repeat","maxLength","fillString","stringLength","fillStr","intMaxLength","fillLen","stringFiller","DATA_VIEW","WRONG_INDEX","BaseBuffer","LN2","BUFFER","BYTE_LENGTH","BYTE_OFFSET","$BUFFER","$LENGTH","$OFFSET","packIEEE754","mLen","nBytes","eLen","eMax","eBias","rt","s","unpackIEEE754","nBits","NaN","unpackI32","bytes","packI8","packI16","packI32","packF64","packF32","isLittleEndian","numIndex","intIndex","_b","pack","conversion","validateArrayBufferArguments","numberLength","ArrayBufferProto","$setInt8","setInt8","getInt8","setUint8","bufferLength","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","getFloat64","setInt16","setUint16","setInt32","setUint32","setFloat32","setFloat64","class2type","core_toString","isWindow","isPlainObject","nodeType","core_hasOwn","container","extendInner","copy","copyIsArray","optionsIsArray","deep","numericStringRegex","types","typename","toLowerCase","upsert","db","diffFun","getIndexes","allDocs","include_docs","allDocsRes","indexes","language","viewNames","total_rows","upsertInner","docId","PouchPromise","docRev","newDoc","tryAndPut","updated","put","putIfNotExists","existingDoc","PouchDB","plugin","add32","cmn","ff","d","gg","hh","ii","md5cycle","md5blk","md5blks","charCodeAt","md5blk_array","md51","tail","tmp","lo","hi","match","md51_array","hex_chr","rhex","hex","md5","SparkMD5","reset","lsw","msw","append","unescape","appendBinary","contents","_buff","_length","_state","substr","raw","buff","_finish","destroy","hashBinary","content","_concatArrayBuffer","first","second","firstLength","LocalStorage","prefix","localStorage","setItem","_this2","item","getItem","parse","_this3","removeItem","_this4","MemoryStorage","deleted","getAppToken","parent","origin","intent","action","receiver","appName","removeEventListener","V2TOKEN_ABORT_TIMEOUT","_doctypes","docType","httpVerb","NOREV","findMany","ids","docs","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","error","return","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","findAll","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","changesFeed","changes","updateAttributes","tries","_delete","doUpload","isBuffer","isFile","File","isBlob","Blob","isStream","readable","pipe","isString","checksum","lastModifiedDate","ifMatch","contentTypeOctetStream","Content-MD5","toGMTString","If-Match","dirID","executable","createDirectory","_ref3","getDirectoryOrCreate","parentDirectory","ROOT_DIR_ID","statByPath","parsedError","errors","createDirectoryByPath","part","rootDirectoryPromise","statById","parentDirectoryPromise","updateById","doUpdateAttributes","attrs","_typeof","_ref4","updateAttributesById","updateAttributesByPath","trashById","_ref5","offline","hasDatabase","getDatabase","dir_id","_ref6","_ref7","children","TRASH_DIR_ID","sortFiles","addIsDir","toJsonApi","encodePageOptions","downloadById","downloadByPath","extractResponseLinkRelated","related","getDownloadLinkByPath","getDownloadLinkById","getFilePath","file","folderPath","endsWith","getCollectionShareLink","collectionType","permissions","verbs","collection","sharecode","codes","email","getArchiveLinkByPaths","paths","archive","getArchiveLinkByIds","listTrash","clearTrash","restoreById","destroyById","_ref8","isDir","allFiles","folders","localeCompare","_interopRequireWildcard","newObj","nopOnRegistered","protoify","context","addToProto","disablePromises","attr","_auth_storage","_auth_v2","auth","_data","_mango","mango","_files","_intents","intents","_jobs","jobs","_offline","_settings","settings","_relations","AppTokenV3","AccessTokenV3","ClientV3","AuthNone","AuthRunning","AuthError","AuthOK","defaultClientParams","dataProto","defineIndex","addReferencedFiles","removeReferencedFiles","listReferencedFiles","fetchReferencedFiles","authProto","filesProto","getDownloadLink","getArchiveLink","queryFiles","intentsProto","createService","jobsProto","queued","offlineProto","init","getDoctypes","createDatabase","destroyDatabase","destroyAllDatabase","hasReplication","replicateFromCozy","stopReplication","stopAllReplication","hasRepeatedReplication","startRepeatedReplication","stopRepeatedReplication","stopAllRepeatedReplication","settingsProto","diskUsage","changePassphrase","getInstance","updateInstance","getClients","deleteClientById","updateLastSync","AppTokenV2","_inited","_oauth","_token","_authstate","_authcreds","_storage","_version","oauth","_onRegistered","cozyURL","forceTokenRefresh","URL","searchParams","pathprefix","datasystem","injectService","onReadyCallback","ownerDocument","defaultView","onload","setAttribute","classList","intentClass","focus","serviceOrigin","handshaken","messageHandler","prop","transition","dimensions","removeIntentFrame","errorSerializer","deserialize","createPromise","service","services","listenClientData","messageEventListener","intentId","serviceWindow","search","terminated","terminate","resizeClient","transitionProperty","maxHeight","clientHeight","maxWidth","clientWidth","getData","getIntent","exposeIntentFrameRemoval","throw","serialize","mapErrorProperties","nativeProperties","property","workerType","_defineProperty","defineIndexV2","defineIndexV3","indexRef","queryV2","queryV3","getV3Options","wholeResponse","indexName","capitalize","indexDefinition","makeMapFunction","indexResult","makeMapReduceQuery","use_index","limit","skip","since","descending","charAt","toUpperCase","MAP_TEMPLATE","parseSelector","acc","LOGICOPERATORS","VALUEOPERATORS","normalizeSelector","filters","_filter","op","applySelector","lower","COUCHDB_LOWEST","upper","COUCHDB_INFINITY","inclusiveEnd","mrquery","firstFreeValueField","normalizedSelector","used","isFreeValue","FIELDSPLACEHOLDER","ï¿¿","_ref$options","_ref$doctypes","doctypes","getInfo","database","setDatabase","pluginLoaded","_pouchdb2","_pouchdbFind2","pouchdbAdapterCordovaSqlite","createIndexes","createIndex","getReplication","replication","setReplication","getReplicationUrl","basic","toBasicAuth","getReplicationPromise","replicationPromise","setReplicationPromise","live","replicationOfflineError","onError","replicate","info","onComplete","stop","getRepeatedReplication","interval","setRepeatedReplication","timer","setInterval","clearInterval","_pouchdb","_pouchdbFind","updateRelations","verb","refs","makeReferencesPath","params","currentPassPhrase","newPassPhrase","current_passphrase","new_passphrase","original","factories","construct","bind","partArgs","bound","symbols","ignoreCase","multiline","unicode","sticky","macrotask","Observer","isNode","head","last","notify","flush","domain","exit","enter","toggle","node","windowNames","getWindowNames","pargs","_","holder","pos","wksExt","$Symbol","$find","forced","createProperty","FProto","nameRE","strong","sqrt","$acosh","acosh","asinh","$asinh","$atanh","atanh","cbrt","clz32","LOG2E","cosh","EPSILON","EPSILON32","MAX32","MIN32","roundTiesToEven","fround","$abs","$sign","hypot","value1","value2","div","sum","larg","$imul","imul","UINT16","xn","yn","xl","yl","log10","LN10","log2","sinh","E","tanh","trunc","_isFinite","isInteger","isSafeInteger","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","Internal","GenericPromiseCapability","Wrapper","microtask","PROMISE","$Promise","empty","USE_NATIVE","FakePromise","PromiseRejectionEvent","sameConstructor","isThenable","newPromiseCapability","PromiseCapability","$$resolve","$$reject","perform","isReject","chain","_c","_v","reaction","handler","fail","_h","onHandleUnhandled","onUnhandled","abrupt","isUnhandled","onunhandledrejection","_a","onrejectionhandled","$reject","_w","$resolve","executor","onFulfilled","onRejected","capability","remaining","$index","alreadyCalled","race","rApply","fApply","thisArgument","argumentsList","L","rConstruct","NEW_TARGET_BUG","ARGS_BUG","Target","newTarget","$args","propertyKey","deleteProperty","getProto","$isExtensible","$preventExtensions","setProto","V","existingDescriptor","ownDesc","flags","$match","regexp","REPLACE","$replace","searchValue","replaceValue","SEARCH","$search","SPLIT","$split","_split","$push","$SPLIT","LENGTH","LAST_INDEX","NPCG","separator2","lastIndex","lastLength","lastLastIndex","splitLimit","separatorCopy","$at","codePointAt","ENDS_WITH","$endsWith","endPosition","$fromCodePoint","fromCodePoint","INCLUDES","callSite","tpl","STARTS_WITH","$startsWith","startsWith","$fails","wksDefine","keyOf","enumKeys","_create","gOPNExt","$JSON","_stringify","HIDDEN","TO_PRIMITIVE","SymbolRegistry","AllSymbols","OPSymbols","QObject","findChild","setSymbolDesc","protoDesc","wrap","sym","isSymbol","$defineProperties","$propertyIsEnumerable","$getOwnPropertyDescriptor","$getOwnPropertyNames","$getOwnPropertySymbols","IS_OP","for","keyFor","useSetter","useSimple","replacer","$replacer","InternalMap","each","weak","$WeakMap","freeze","$includes","getOwnPropertyDescriptors","getDesc","$values","$pad","padEnd","padStart","TO_STRING_TAG","ArrayValues","collections","Collection","$task","partial","MSIE","userAgent","EventEmitter","_events","_maxListeners","isNumber","isUndefined","defaultMaxListeners","setMaxListeners","er","listeners","newListener","g","fired","position","listenerCount","evlistener","emitter","INTERNAL","resolver","PENDING","outcome","safelyResolveThenable","QueueItem","callFulfilled","otherCallFulfilled","callRejected","otherCallRejected","unwrap","returnValue","handlers","getThen","thenable","onSuccess","tryToUnwrap","tryCatch","allResolver","resolveFromAll","outValue","resolved","REJECTED","FULFILLED","pad","padWith","upToLength","padding","targetLength","padRight","stringLexCompare","bLen","aChar","bChar","intToDecimalForm","int","isNeg","remainder","sourceDB","mapFun","reduceFun","temporary","pluginName","viewSignature","_cachedViews","cachedView","diffFunction","fullViewName","depDbs","depDbName","db_name","registerDependentDatabase","auto_compaction","adapter","lastSeqDoc","seq","QueryParseError","NotFoundError","parseViewName","isGenOne","sortByKeyThenValue","keyCompare","sliceResults","results","rowToDocId","emitError","tryCode","checkQueryParseError","startkeyName","endkeyName","group","group_level","defaultsTo","createIndexer","getDocsToPersist","docIdsToChangesAndEmits","getMetaDoc","defaultMetaDoc","metaDocId","getKeyValueDocs","metaDoc","processKvDocs","kvDocsRes","kvDocs","oldKeysMap","_deleted","indexableKeysToKeyValues","keyValue","newKeys","kvDoc","docData","saveKeyValues","seqDocId","docIds","listOfDocsToPersist","docsToPersist","bulkDocs","getQueue","persistentQueues","TaskQueue","updateView","updateViewInQueue","mapResults","processChange","currentSeq","complete","finish","processNextBatch","conflicts","CHANGES_BATCH_SIZE","change","lastKey","jl","complexKey","indexableKey","reduceView","shouldGroup","groups","lvl","reduceTry","queryView","queryViewInQueue","fetchFromView","viewOpts","totalRows","expectedKeys","parsedKeyAndDocId","pouchCollate","onMapResultsReady","finalResults","shouldReduce","attachments","binary","docIdsToDocs","cur","fetchPromises","keyStart","keyEnd","localViewCleanup","docsToViews","designDocName","viewsToStatus","ddocName","viewDBNames","statusIsGood","viewDBName","dbsToDelete","destroyPromises","__opts","queryPromised","createViewOpts","tempViewQueue","createView","cleanup","stale","viewCleanup","massageCreateIndexRequest","request","deleteIndex","pouchUpsert","updateDdoc","hasInvalidLanguage","viewExists","originalIndexDef","ddocId","signature","deltaFun","createFieldSorter","getFieldValuesAsArray","docFieldValue","aRow","bRow","aFieldValues","bFieldValues","collation","filterInMemoryFields","inMemoryFields","rowFilter","fieldSorter","matchCominationalSelector","matchSelector","userOperator","userValue","orMatchers","matchers","fieldExists","fieldIsNotUndefined","modField","divisor","mod","arrayContainsValue","arrayContainsAllValues","arraySize","regexMatch","typeMatch","$elemMatch","$exists","$mod","neValue","$in","$nin","$size","$all","$regex","$type","indexToSignature","doAllDocs","originalOpts","getIndexesRes","queryPlan","planQuery","indexToUse","queryOpts","isDescending","warning","checkFieldInIndex","indexField","userOperatorLosesPrecision","sortFieldsByIndex","aIdx","bIdx","getBasicInMemoryFields","needToFilterInMemory","getInMemoryFieldsFromNe","getInMemoryFields","coreInMemoryFields","checkIndexFieldsMatch","sortMatches","selectorMatches","isNonLogicalMatcher","logicalMatchers","checkFieldsLogicallySound","firstField","hasLogicalOperator","matcherKey","isInvalidNe","checkIndexMatches","fieldsMatch","findMatchingIndexes","indexMatches","findBestMatchingIndex","scoreIndex","userFieldsMap","matchingIndexes","defaultIndex","getSingleFieldQueryOptsFor","getSingleFieldCoreQueryPlan","combinedOpts","userOperators","newQueryOpts","getMultiFieldCoreQueryPlan","getMultiFieldQueryOpts","inclusiveStart","COLLATE_LO","COLLATE_HI","usingGtlt","previousKeys","previousWasEq","previousWasSame","gtltLostSpecificity","getDefaultQueryPlan","getCoreQueryPlan","userFieldsRes","coreQueryPlan","httpIndexes","localIndexes","selectColor","namespace","colors","createDebug","debug","enabled","curr","ms","prevTime","diff","coerce","unshift","format","formatter","formatters","formatArgs","logFn","useColors","color","enable","namespaces","skips","disable","humanize","h","fmtShort","fmtLong","plural","long","handled","UNHANDLED","_interopDefault","ex","isBinaryObject","cloneArrayBuffer","targetArray","sourceArray","cloneBinaryObject","size","webkitSlice","Ctor","funcToString","objectCtorString","newObject","toISOString","PouchPromise$1","adapterFun","logApiCall","logArgs","origCallback","responseArgs","_closed","_destroyed","taskqueue","isReady","addTask","failed","mangle","unmangle","Map$1","_store","Set$1","supportsMapAndSet","Map","Set","species","identityFunction","formatResultForOpenRevsGet","bulkGet","collapseResultsAndFinish","perDocResults","checkDone","numDone","numDocs","gotResult","docIndex","nextBatch","allRequests","upTo","MAX_NUM_CONCURRENT_REQUESTS","batch","processBatch","docIdx","docRequests","requestsById","docOpts","open_revs","formatResult","param","requests","ExportedMap","isChromeApp","chrome","local","hasLocalStorage","hasLocal","attachBrowserEvents","onChanged","dbName","newValue","attachEvent","Changes","events","_listeners","guardedConsole","randomNumber","maxTimeout","ratio","range","defaultBackOff","explainError","PouchError","createError","CustomPouchError","generateErrorFromResponse","UNKNOWN_ERROR","tryFilter","req","msg","BAD_REQUEST","filterChange","hasFilter","query_params","filterReturn","att","_attachments","stub","invalidIdError","INVALID_ID","RESERVED_ID","MISSING_ID","ee","parseDesignDocFunctionName","normalizeDesignDocFunctionName","normalized","parseUri","parser","uri","encoded","qName","qParser","$0","$1","$2","radix","uuid","chars","winningRev","metadata","winningId","winningPos","winningDeleted","toVisit","rev_tree","tree","branches","traverseRevTree","revs","newCtx","sortByPos","collectLeaves","leaves","isLeaf","collectConflicts","win","leaf","compactTree","revHash","rootToLeaf","history","sortByPos$1","binarySearch","comparator","mid","low","high","insertSorted","pathToTree","numStemmed","currentLeaf","compareTree","mergeTree","in_tree1","in_tree2","tree1","tree2","merged","doMerge","dontExpand","restree","branch","t1","t2","candidateParents","trees","parentIdx","elements","elementsLen","stem","depth","maybeStem","stemmed","stemmedNode","merge","newTree","stemmedRevs","revExists","splitRev","targetPos","targetId","getTrees","isDeleted","isLocalId","latest","historyNode","historyRev","evalFilter","scopedEval","evalView","tryCatchInChangeListener","Changes$2","onDestroy","onChange","isCancelled","doChanges","changeList","_conflicts","yankError","cleanDocs","atts","compareByIdThenRev","idCompare","aStart","_revisions","bStart","computeHeight","height","edges","prnt","edge","allDocsKeysQuery","api","_allDocs","subOpts","assign$1","optKey","doNextCompaction","_compactionQueue","last_seq","_compact","shift","attachmentNameError","AbstractPouchDB","TaskQueue$1","parseAdapter","adapters","PouchDB$5","preferredAdapters","adapterName","usePrefix","use_prefix","prepareForDestruction","onDestroyed","onClosed","onConstructorDestroyed","destructionListeners","_destructionListeners","prefixedName","backend","_adapter","valid","ready","setUpEventEmitter","Pouch","eventEmitter","destructListeners","parseRevisionInfo","INVALID_REV","makeRevTreeFromRevisions","revisions","revisionIds","parseDoc","newEdits","nRevNum","newRevId","revInfo","_rev_tree","specialKey","reservedWords","DOC_VALIDATION","dataWords","createBlob","properties","Builder","BlobBuilder","MSBlobBuilder","MozBlobBuilder","WebKitBlobBuilder","builder","getBlob","binaryStringToArrayBuffer","bin","buf","binStringToBluffer","binString","b64ToBluffer","b64","thisAtob","arrayBufferToBinaryString","readAsBinaryString","blob","FileReader","FileReaderSync","readAsArrayBuffer","reader","hasBinaryString","onloadend","blobToBinaryString","blobOrBuffer","blobToBase64","base64","thisBtoa","rawToBase64","sliceBlob","blob$$1","appendBlob","arrayBuffer","appendString","binaryMd5","setImmediateShim","loadNextChunk","currentChunk","chunkSize","chunks","inputIsString","MD5_CHUNK_SIZE","stringMd5","parseBase64","BAD_ARG","preprocessString","blobType","asBinary","content_type","preprocessBlob","preprocessAttachment","preprocessAttachments","docInfos","docv","overallErr","docInfo","processedAttachment","recv","updateDoc","revLimit","writeDoc","previousWinningRev","previouslyDeleted","isRoot","inConflict","REV_CONFLICT","newRev","rev_map","newRevIsDeleted","winningRev$$1","winningRevIsDeleted","delta","rootIsMissing","processDocs","fetchedDocs","tx","overallCallback","insertDoc","resultsIdx","MISSING_DOC","checkAllDocsDone","docsDone","docsToDo","new_edits","idsToDocs","currentDoc","docWritten","nextDoc","safeJsonParse","vuvuzela","safeJsonStringify","idbError","evt","IDB_ERROR","encodeMetadata","deletedOrLocal","decodeMetadata","storedObject","decodeDoc","_doc_id_rev","readBlobData","asBlob","fetchAttachmentsIfNecessary","txn","fetchAttachment","attObj","objectStore","ATTACH_STORE","onsuccess","postProcessAttachments","attNames","compactRevs","deleteOrphanedAttachments","possiblyOrphanedDigests","countReq","attAndSeqStore","IDBKeyRange","attStore","seqStore","BY_SEQ_STORE","ATTACH_AND_SEQ_STORE","cursor","openCursor","only","digestSeq","primaryKey","continue","openTransactionSafely","idb","stores","mode","transaction","idbBulkDocs","dbOpts","startTransaction","DOC_STORE","LOCAL_STORE","META_STORE","txnResult","onabort","ontimeout","oncomplete","docStore","bySeqStore","attachStore","attachAndSeqStore","metaStore","updateDocCountIfReady","verifyAttachments","preconditionErrored","fetchExistingDocs","onAllDocsProcessed","allDocsProcessed","idbProcessDocs","revs_limit","docCount","docCountDelta","numFetched","readMetadata","changesHandler$$1","_meta","verifyAttachment","MISSING_STUB","digests","filename","attErr","isUpdate","hasAttachments","writeAttachments","finishDoc","afterPutDoc","revsToDelete","metadataToStore","metaDataReq","afterPutMetadata","afterPutDocError","preventDefault","stopPropagation","getKeyReq","putReq","insertAttachmentMappings","onerror","collectResults","attachmentSaved","revpos","saveAttachment","attsAdded","attsToAdd","newAtt","docInfoError","blobSupport","runBatchedCursor","keyRange","batchSize","onBatch","onGetAll","valuesBatch","keysBatch","pseudoCursor","onGetAllKeys","continuePseudoCursor","newKeyRange","upperOpen","lowerBound","getAll","getAllKeys","onCursor","useGetAll","createKeyRange","upperBound","idbAllDocs","fetchDocAsynchronously","docIdRevIndex","allDocsInner","batchValues","batchValue","batchKeys","onResultsReady","onTxnComplete","keyRangeError","checkBlobSupport","DETECT_BLOB_SUPPORT_STORE","matchedChrome","matchedEdge","countDocs","applyNext","running","enqueueTask","processMetadataAndWinningDoc","winningDoc","lastSeq","filtered","numResults","returnDocs","onBatchDone","winningDocs","metadatas","fetchWinningDocAndMetadata","onGetMetadata","docIdRev","docIdsToMetadata","continuous","doc_ids","ExportedSet","return_docs","objectStores","IdbPouch","thisCallback","createSchema","createObjectStore","keyPath","autoIncrement","unique","addDeletedOrLocalIndex","createLocalStoreSchema","migrateLocalStore","localStore","seqCursor","addAttachAndSeqStore","migrateAttsAndSeqs","digestMap","migrateMetadata","decodeMetadataCompat","fetchMetadataSeq","metadataSeq","onGetMetadataSeq","instanceId","_bulkDocs","reqOpts","_get","_getAttachment","attachId","attachment","blobData","_info","updateSeq","doc_count","update_seq","idb_attachment_format","_changes","_close","cachedDBs","_getRevisionTree","_doCompaction","_getLocal","_putLocal","oldRev","oStore","oldDoc","_removeLocal","_destroy","openReq","openReqList","indexedDB","deleteDatabase","cached","tryStorageOption","ADAPTER_VERSION","onupgradeneeded","migration","migrations","oldVersion","currentTarget","completeSetup","storedMetaDoc","storeMetaDocIfReady","instanceKey","onversionchange","blobSupportPromise","decodeUtf8","escape","hexToInt","charCode","parseHexUtf8","parseHexUtf16","parseHexString","encoding","quote","escapeBlob","unescapeBlob","stringifyDoc","unstringifyDoc","qMarks","select","table","joiner","where","orderBy","compactRevs$1","deleteOrphans","seqs","sql","ATTACH_AND_SEQ_STORE$1","executeSql","digestsToCheck","nonOrphanedDigests","ATTACH_STORE$1","BY_SEQ_STORE$1","websqlError","errorNameMatch","errorName","errorReason","WSQ_ERROR","getSize","isAndroid","websqlBulkDocs","websqlChanges","_name","cnt","sqlArgs","deletedInt","insertId","dataWritten","fetchSql","attachmentErr","revsToCompact","DOC_STORE$1","metadataStr","websqlProcessDocs","userDocs","docInfoErrors","openDatabaseWithOpts","websql","description","openDBSafely","openDB$1","cachedResult","cachedDatabases","fetchAttachmentsIfNecessary$1","attOpts","WebSqlPouch$1","dbCreated","runMigration2","DOC_STORE_WINNINGSEQ_INDEX_SQL","BY_SEQ_STORE_DELETED_INDEX_SQL","runMigration3","LOCAL_STORE$1","doNext","runMigration4","updateRows","doc_id_rev","doc_id","BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL","runMigration5","nextPage","SELECT_DOCS","DOC_STORE_AND_BY_SEQ_JOINER","pageSize","addDigestSeq","digestSeqs","digestSeqPairs","attachAndRev","ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL","ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL","runMigration6","runMigration7","checkEncoding","onGetInstanceId","idRequests","idCallback","onGetVersion","dbVersion","META_STORE$1","attach","initSeq","initSeqArgs","ADAPTER_VERSION$1","setupDone","migrated","dbid","tasks","nextMigration","setup","fetchVersion","db_version","getMaxSeq","latest$$1","websqlOpts","POUCH_VERSION","openDBResult","readTransaction","theSeq","theDocCount","websql_encoding","latestRev","missingErr","deletedErr","criteria","fetchChanges","selectStmt","reportChange","maxSeq","escaped","putLocal","rowsAffected","removeLocal","canOpenTestDB","openDatabase","isValidWebSQL","hasLS","localStorageKey","openedTestDB","openDB","WebSQLPouch","_opts","wrappedFetch","wrappedPromise","fetchRequest","Headers","fetchOptions","processData","fetchResponse","statusCode","abort","xhRequest","xhr","timedout","abortReq","cleanUp","timeoutReq","onprogress","upload","XMLHttpRequest","exception","withCredentials","Accept","responseType","setRequestHeader","readyState","getResponseHeader","responseText","send","testXhr","ajax$1","hasXhr","defaultBody","ajaxCore$1","missing","res$2","defaultOptions","cache","ajax","ua","isSafari","isIE","isEdge","shouldCacheBust","isBlobUrl","hasArgs","now","pool","promiseFactories","runNext","runNextBatch","thisErr","readAttachmentsAsBlobOrBuffer","encodeDocId","preprocessAttachments$2","hasUrlPrefix","protocol","getHost","user","password","username","genDBUrl","genUrl","pathDel","host","paramsToStr","HttpPouch","ajax$$1","userOpts","reqAjax","ajaxOpts","log$1","_ajax","ajaxPromise","adapterFun$$1","skipSetup","skip_setup","setupPromise","checkExists","dbUrl","encodeAttachmentId","attachmentId","nAuth","Authorization","uuid$$1","compact","ping","compact_running","doBulkGet","doBulkGetShim","onResult","batchNum","numBatches","MAX_SIMULTANEOUS_REVS","supportsBulkGet","supportsBulkGetMap","fetchAttachments","filenames","fetchAllAttachments","docOrDocs","revs_info","remove","docOrId","optsOrRev","getAttachment","removeAttachment","putAttachment","_put","start_key","end_key","paramStr","batch_size","leftToFetch","feed","heartbeat","param_name","lastFetchedSeq","aborted","xhrOpts","fetched","raw_results_length","finished","revsDiff","TaskQueue$2","cachedViews","promiseForView","BuiltInError","createBuiltInError","jNum","evalFunctionWithEval","log$2","finalPromiseFactory","theSet","mapToKeysArray","tryMap","tryReduce","rereduce","readAttachmentsAsBlobOrBuffer$1","postprocessAttachments","addHttpParam","paramName","asJson","coerceInteger","integerCandidate","asNumber","coerceOptions","checkPositiveInteger","optionName","httpQuery","MAX_URL_LENGTH","keysAsString","customQuery","_query","customViewCleanup","_viewCleanup","processKeyValueDocs","oldKeys","CHANGES_BATCH_SIZE$1","createDocIdsToChangesAndEmits","createIndexableKeysToKeyValues","emittedKeyValue","origMap","builtInReduce","POSITIVE_INFINITY","groupKey","httpViewCleanup","isGenOne$1","fileHasChanged","localDoc","remoteDoc","getDocAttachments","getDocAttachmentsFromTargetOrSource","doCheckForLocalAttachments","createBulkGetOpts","diffs","missingRevs","missingRev","getDocs","getAllDocs","bulkGetOpts","bulkGetResponse","cancelled","bulkGetInfo","resultDocs","Boolean","hasConflicts","fetchRevisionOneDocs","getRevisionOneDocs","returnResult","updateCheckpoint","checkpoint","session","session_id","replicator","REPLICATOR","CHECKPOINT_VERSION","CHECKPOINT_HISTORY_SIZE","Checkpointer","compareReplicationLogs","srcDoc","tgtDoc","compareReplicationHistory","sourceHistory","targetHistory","sourceRest","targetRest","LOWEST_SEQ","sourceId","hasSessionId","sessionId","rest","isForbiddenError","backOff","back_off_function","backOffSet","current_back_off","STARTING_BACK_OFF","removeBackOffSetter","sortObjectPropertiesByKey","queryParams","generateReplicationId","filterFun","filterViewName","queryData","md5sum","initCheckpointer","checkpointer","repId","writeDocs","changedDocs","currentBatch","bulkOpts","completeReplication","errorsById","errorsNo","doc_write_failures","docs_written","finishBatch","outResult","writingCheckpoint","writeCheckpoint","getChanges","onCheckpointError","getDiffs","getBatchDocs","got","docs_read","startNextBatch","batches","processPendingBatch","abortReplication","pendingBatch","changesOpts","changesCompleted","replicationCompleted","fatalError","end_time","onChangesComplete","changesPending","onChangesError","abortChanges","batches_limit","_abortChanges","startChanges","getCheckpoint","start_time","_addedListeners","Replication","toPouch","PouchConstructor","replicateWrapper","replicateRet","srcPouch","targetPouch","sync$1","Sync","pullChange","direction","pushChange","pushDenied","pullDenied","pushPaused","pullPaused","pushActive","pullActive","removeAll","isChange","isDenied","isPaused","isActive","removed","addOneListener","canceled","optsPush","optsPull","pull","success","sync","other","lie","mangled","eventFunction","inprogress","notifyLocalWindows","nextSource","nextKey","MISSING_BULK_DOCS","QUERY_PARSE_ERROR","NOT_AN_OBJECT","hasName","filterChanges","newPromise","filterName","post","createAttachment","prevrevpos","was_delete","addToMissing","revId","processDoc","missingForId","missingObj","compactDocument","revTree","candidates","promises","finishOpenRevs","existing","splittedRev","revNo","currentPath","hashIndex","hashFoundAtRevPos","indexOfRev","howMany","_revs_info","incompatibleOpt","attachmentError","dependentDb","dependentDbs","depDB","destroyDb","deletedMap","trueName","execute","addToPreferredAdapters","defaults","defaultOpts","PouchAlt","__defaults","atob","platform","IDBPouch","WebSqlPouch","HttpPouch$1","_sum","_count","_stats","sumsqr","_sumsqr","mapreduce","updateTarget","updateSource","readOnlySource","comparisons","targetDoc","sourceDoc","1","_readyCalled","toUtf8","utf8Str2ArrayBuffer","returnUInt8Array","arrayBuffer2Utf8Str","concatenateArrayBuffers","hexToBinaryString","clamp","_hash","getState","setState","innerFn","outerFn","tryLocsList","protoGenerator","Generator","generator","Context","_invoke","makeInvokeMethod","GeneratorFunction","GeneratorFunctionPrototype","defineIteratorMethods","AsyncIterator","record","hasOwn","__await","unwrapped","enqueue","callInvokeWithMethodAndArg","previousPromise","GenStateSuspendedStart","GenStateExecuting","GenStateCompleted","doneResult","delegate","delegateResult","maybeInvokeDelegate","ContinueSentinel","sent","_sent","dispatchException","GenStateSuspendedYield","resultName","nextLoc","pushTryEntry","locs","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","iteratorMethod","iteratorSymbol","Op","toStringTagSymbol","toStringTag","inModule","runtime","regeneratorRuntime","NativeIteratorPrototype","Gp","displayName","isGeneratorFunction","genFun","mark","awrap","async","skipTempReset","rootEntry","rootRecord","rval","handle","loc","caught","hasCatch","hasFinally","finallyEntry","thrown","delegateYield","hasProp","arrayPrefix","objPrefix","numChar","parsedString","lastCh","numConsecutiveSlashes","normalizeName","normalizeValue","iteratorFor","items","support","header","consumed","bodyUsed","fileReaderReady","readBlobAsArrayBuffer","readBlobAsText","readAsText","readArrayBufferAsText","bufferClone","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","formData","FormData","_bodyFormData","URLSearchParams","isDataView","_bodyArrayBuffer","isArrayBufferView","rejected","decode","normalizeMethod","upcased","Request","referrer","form","trim","parseHeaders","rawHeaders","line","Response","bodyInit","statusText","viewClasses","isView","oldValue","thisArg","redirectStatuses","redirect","getAllResponseHeaders","responseURL","polyfill","__webpack_module_template_argument_0__","firebug","lastC","DEBUG","localstorage"],"mappings":"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","file":"cozy-client.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"client\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"client\"] = factory();\n\telse\n\t\troot[\"cozy\"] = root[\"cozy\"] || {}, root[\"cozy\"][\"client\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"client\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"client\"] = factory();\n\telse\n\t\troot[\"cozy\"] = root[\"cozy\"] || {}, root[\"cozy\"][\"client\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ((function(modules) {\n\t// Check all modules for deduplicated modules\n\tfor(var i in modules) {\n\t\tif(Object.prototype.hasOwnProperty.call(modules, i)) {\n\t\t\tswitch(typeof modules[i]) {\n\t\t\tcase \"function\": break;\n\t\t\tcase \"object\":\n\t\t\t\t// Module can be created from a template\n\t\t\t\tmodules[i] = (function(_m) {\n\t\t\t\t\tvar args = _m.slice(1), fn = modules[_m[0]];\n\t\t\t\t\treturn function (a,b,c) {\n\t\t\t\t\t\tfn.apply(this, [a,b,c].concat(args));\n\t\t\t\t\t};\n\t\t\t\t}(modules[i]));\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Module is a copy of another module\n\t\t\t\tmodules[i] = modules[modules[i]];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn modules;\n}([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(221);\n\tmodule.exports = __webpack_require__(113);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(2)\n\t  , core      = __webpack_require__(38)\n\t  , hide      = __webpack_require__(11)\n\t  , redefine  = __webpack_require__(20)\n\t  , ctx       = __webpack_require__(14)\n\t  , PROTOTYPE = 'prototype';\n\t\n\tvar $export = function(type, name, source){\n\t  var IS_FORCED = type & $export.F\n\t    , IS_GLOBAL = type & $export.G\n\t    , IS_STATIC = type & $export.S\n\t    , IS_PROTO  = type & $export.P\n\t    , IS_BIND   = type & $export.B\n\t    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]\n\t    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n\t    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})\n\t    , key, own, out, exp;\n\t  if(IS_GLOBAL)source = name;\n\t  for(key in source){\n\t    // contains in native\n\t    own = !IS_FORCED && target && target[key] !== undefined;\n\t    // export native or passed\n\t    out = (own ? target : source)[key];\n\t    // bind timers to global for call from export context\n\t    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n\t    // extend global\n\t    if(target)redefine(target, key, out, type & $export.U);\n\t    // export\n\t    if(exports[key] != out)hide(exports, key, exp);\n\t    if(IS_PROTO && expProto[key] != out)expProto[key] = out;\n\t  }\n\t};\n\tglobal.core = core;\n\t// type bitmap\n\t$export.F = 1;   // forced\n\t$export.G = 2;   // global\n\t$export.S = 4;   // static\n\t$export.P = 8;   // proto\n\t$export.B = 16;  // bind\n\t$export.W = 32;  // wrap\n\t$export.U = 64;  // safe\n\t$export.R = 128; // real proto method for `library` \n\tmodule.exports = $export;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\n\tvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n\t  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\n\tif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(5);\n\tmodule.exports = function(it){\n\t  if(!isObject(it))throw TypeError(it + ' is not an object!');\n\t  return it;\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar store      = __webpack_require__(69)('wks')\n\t  , uid        = __webpack_require__(25)\n\t  , Symbol     = __webpack_require__(2).Symbol\n\t  , USE_SYMBOL = typeof Symbol == 'function';\n\t\n\tvar $exports = module.exports = function(name){\n\t  return store[name] || (store[name] =\n\t    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n\t};\n\t\n\t$exports.store = store;\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  return typeof it === 'object' ? it !== null : typeof it === 'function';\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(exec){\n\t  try {\n\t    return !!exec();\n\t  } catch(e){\n\t    return true;\n\t  }\n\t};\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar anObject       = __webpack_require__(3)\n\t  , IE8_DOM_DEFINE = __webpack_require__(84)\n\t  , toPrimitive    = __webpack_require__(45)\n\t  , dP             = Object.defineProperty;\n\t\n\texports.f = __webpack_require__(9) ? Object.defineProperty : function defineProperty(O, P, Attributes){\n\t  anObject(O);\n\t  P = toPrimitive(P, true);\n\t  anObject(Attributes);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return dP(O, P, Attributes);\n\t  } catch(e){ /* empty */ }\n\t  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n\t  if('value' in Attributes)O[P] = Attributes.value;\n\t  return O;\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\tvar hasOwnProperty = {}.hasOwnProperty;\n\tmodule.exports = function(it, key){\n\t  return hasOwnProperty.call(it, key);\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Thank's IE8 for his funny defineProperty\n\tmodule.exports = !__webpack_require__(6)(function(){\n\t  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.15 ToLength\n\tvar toInteger = __webpack_require__(34)\n\t  , min       = Math.min;\n\tmodule.exports = function(it){\n\t  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(7)\n\t  , createDesc = __webpack_require__(19);\n\tmodule.exports = __webpack_require__(9) ? function(object, key, value){\n\t  return dP.f(object, key, createDesc(1, value));\n\t} : function(object, key, value){\n\t  object[key] = value;\n\t  return object;\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// to indexed object, toObject with fallback for non-array-like ES3 strings\n\tvar IObject = __webpack_require__(62)\n\t  , defined = __webpack_require__(17);\n\tmodule.exports = function(it){\n\t  return IObject(defined(it));\n\t};\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.FetchError = undefined;\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }(); /* global fetch */\n\t\n\t\n\texports.cozyFetch = cozyFetch;\n\texports.cozyFetchJSON = cozyFetchJSON;\n\texports.cozyFetchRawJSON = cozyFetchRawJSON;\n\t\n\tvar _auth_v = __webpack_require__(54);\n\t\n\tvar _utils = __webpack_require__(22);\n\t\n\tvar _jsonapi = __webpack_require__(79);\n\t\n\tvar _jsonapi2 = _interopRequireDefault(_jsonapi);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\tfunction cozyFetch(cozy, path) {\n\t  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  return cozy.fullpath(path).then(function (fullpath) {\n\t    var resp = void 0;\n\t    if (options.disableAuth) {\n\t      resp = fetch(fullpath, options);\n\t    } else if (options.manualAuthCredentials) {\n\t      resp = cozyFetchWithAuth(cozy, fullpath, options, options.manualAuthCredentials);\n\t    } else {\n\t      resp = cozy.authorize().then(function (credentials) {\n\t        return cozyFetchWithAuth(cozy, fullpath, options, credentials);\n\t      });\n\t    }\n\t    return resp.then(handleResponse);\n\t  });\n\t}\n\t\n\tfunction cozyFetchWithAuth(cozy, fullpath, options, credentials) {\n\t  if (credentials) {\n\t    options.headers = options.headers || {};\n\t    options.headers['Authorization'] = credentials.token.toAuthHeader();\n\t  }\n\t\n\t  // the option credentials:include tells fetch to include the cookies in the\n\t  // request even for cross-origin requests\n\t  options.credentials = 'include';\n\t\n\t  return Promise.all([cozy.isV2(), fetch(fullpath, options)]).then(function (_ref) {\n\t    var _ref2 = _slicedToArray(_ref, 2),\n\t        isV2 = _ref2[0],\n\t        res = _ref2[1];\n\t\n\t    if (res.status !== 400 && res.status !== 401 || isV2 || !credentials || options.dontRetry) {\n\t      return res;\n\t    }\n\t    // we try to refresh the token only for OAuth, ie, the client defined\n\t    // and the token is an instance of AccessToken.\n\t    var client = credentials.client,\n\t        token = credentials.token;\n\t\n\t    if (!client || !(token instanceof _auth_v.AccessToken)) {\n\t      return res;\n\t    }\n\t    options.dontRetry = true;\n\t    return (0, _utils.retry)(function () {\n\t      return (0, _auth_v.refreshToken)(cozy, client, token);\n\t    }, 3)().then(function (newToken) {\n\t      return cozy.saveCredentials(client, newToken);\n\t    }).then(function (credentials) {\n\t      return cozyFetchWithAuth(cozy, fullpath, options, credentials);\n\t    });\n\t  });\n\t}\n\t\n\tfunction cozyFetchJSON(cozy, method, path, body) {\n\t  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\t\n\t  var processJSONAPI = typeof options.processJSONAPI === 'undefined' || options.processJSONAPI;\n\t  return fetchJSON(cozy, method, path, body, options).then(function (response) {\n\t    return handleJSONResponse(response, processJSONAPI);\n\t  });\n\t}\n\t\n\tfunction cozyFetchRawJSON(cozy, method, path, body) {\n\t  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\t\n\t  return fetchJSON(cozy, method, path, body, options).then(function (response) {\n\t    return handleJSONResponse(response, false);\n\t  });\n\t}\n\t\n\tfunction fetchJSON(cozy, method, path, body) {\n\t  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\t\n\t  options.method = method;\n\t\n\t  var headers = options.headers = options.headers || {};\n\t\n\t  headers['Accept'] = 'application/json';\n\t\n\t  if (method !== 'GET' && method !== 'HEAD' && body !== undefined) {\n\t    if (headers['Content-Type']) {\n\t      options.body = body;\n\t    } else {\n\t      headers['Content-Type'] = 'application/json';\n\t      options.body = JSON.stringify(body);\n\t    }\n\t  }\n\t\n\t  return cozyFetch(cozy, path, options);\n\t}\n\t\n\tfunction handleResponse(res) {\n\t  if (res.ok) {\n\t    return res;\n\t  }\n\t  var data = void 0;\n\t  var contentType = res.headers.get('content-type');\n\t  if (contentType && contentType.indexOf('json') >= 0) {\n\t    data = res.json();\n\t  } else {\n\t    data = res.text();\n\t  }\n\t  return data.then(function (err) {\n\t    throw new FetchError(res, err);\n\t  });\n\t}\n\t\n\tfunction handleJSONResponse(res) {\n\t  var processJSONAPI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\t\n\t  var contentType = res.headers.get('content-type');\n\t  if (!contentType || contentType.indexOf('json') < 0) {\n\t    return res.text(function (data) {\n\t      throw new FetchError(res, new Error('Response is not JSON: ' + data));\n\t    });\n\t  }\n\t\n\t  var json = res.json();\n\t  if (contentType.indexOf('application/vnd.api+json') === 0 && processJSONAPI) {\n\t    return json.then(_jsonapi2.default);\n\t  } else {\n\t    return json;\n\t  }\n\t}\n\t\n\tvar FetchError = exports.FetchError = function (_Error) {\n\t  _inherits(FetchError, _Error);\n\t\n\t  function FetchError(res, reason) {\n\t    _classCallCheck(this, FetchError);\n\t\n\t    var _this = _possibleConstructorReturn(this, (FetchError.__proto__ || Object.getPrototypeOf(FetchError)).call(this));\n\t\n\t    if (Error.captureStackTrace) {\n\t      Error.captureStackTrace(_this, _this.constructor);\n\t    }\n\t    // XXX We have to hardcode this because babel doesn't play nice when extending Error\n\t    _this.name = 'FetchError';\n\t    _this.response = res;\n\t    _this.url = res.url;\n\t    _this.status = res.status;\n\t    _this.reason = reason;\n\t\n\t    Object.defineProperty(_this, 'message', {\n\t      value: reason.message || (typeof reason === 'string' ? reason : JSON.stringify(reason))\n\t    });\n\t    return _this;\n\t  }\n\t\n\t  return FetchError;\n\t}(Error);\n\t\n\tFetchError.isUnauthorized = function (err) {\n\t  // XXX We can't use err instanceof FetchError because of the caveats of babel\n\t  return err.name === 'FetchError' && err.status === 401;\n\t};\n\t\n\tFetchError.isNotFound = function (err) {\n\t  // XXX We can't use err instanceof FetchError because of the caveats of babel\n\t  return err.name === 'FetchError' && err.status === 404;\n\t};\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// optional / simple context binding\n\tvar aFunction = __webpack_require__(23);\n\tmodule.exports = function(fn, that, length){\n\t  aFunction(fn);\n\t  if(that === undefined)return fn;\n\t  switch(length){\n\t    case 1: return function(a){\n\t      return fn.call(that, a);\n\t    };\n\t    case 2: return function(a, b){\n\t      return fn.call(that, a, b);\n\t    };\n\t    case 3: return function(a, b, c){\n\t      return fn.call(that, a, b, c);\n\t    };\n\t  }\n\t  return function(/* ...args */){\n\t    return fn.apply(that, arguments);\n\t  };\n\t};\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tif(__webpack_require__(9)){\n\t  var LIBRARY             = __webpack_require__(30)\n\t    , global              = __webpack_require__(2)\n\t    , fails               = __webpack_require__(6)\n\t    , $export             = __webpack_require__(1)\n\t    , $typed              = __webpack_require__(72)\n\t    , $buffer             = __webpack_require__(100)\n\t    , ctx                 = __webpack_require__(14)\n\t    , anInstance          = __webpack_require__(27)\n\t    , propertyDesc        = __webpack_require__(19)\n\t    , hide                = __webpack_require__(11)\n\t    , redefineAll         = __webpack_require__(32)\n\t    , toInteger           = __webpack_require__(34)\n\t    , toLength            = __webpack_require__(10)\n\t    , toIndex             = __webpack_require__(44)\n\t    , toPrimitive         = __webpack_require__(45)\n\t    , has                 = __webpack_require__(8)\n\t    , same                = __webpack_require__(96)\n\t    , classof             = __webpack_require__(57)\n\t    , isObject            = __webpack_require__(5)\n\t    , toObject            = __webpack_require__(24)\n\t    , isArrayIter         = __webpack_require__(63)\n\t    , create              = __webpack_require__(40)\n\t    , getPrototypeOf      = __webpack_require__(42)\n\t    , gOPN                = __webpack_require__(41).f\n\t    , getIterFn           = __webpack_require__(73)\n\t    , uid                 = __webpack_require__(25)\n\t    , wks                 = __webpack_require__(4)\n\t    , createArrayMethod   = __webpack_require__(37)\n\t    , createArrayIncludes = __webpack_require__(56)\n\t    , speciesConstructor  = __webpack_require__(97)\n\t    , ArrayIterators      = __webpack_require__(74)\n\t    , Iterators           = __webpack_require__(29)\n\t    , $iterDetect         = __webpack_require__(50)\n\t    , setSpecies          = __webpack_require__(67)\n\t    , arrayFill           = __webpack_require__(55)\n\t    , arrayCopyWithin     = __webpack_require__(80)\n\t    , $DP                 = __webpack_require__(7)\n\t    , $GOPD               = __webpack_require__(18)\n\t    , dP                  = $DP.f\n\t    , gOPD                = $GOPD.f\n\t    , RangeError          = global.RangeError\n\t    , TypeError           = global.TypeError\n\t    , Uint8Array          = global.Uint8Array\n\t    , ARRAY_BUFFER        = 'ArrayBuffer'\n\t    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER\n\t    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'\n\t    , PROTOTYPE           = 'prototype'\n\t    , ArrayProto          = Array[PROTOTYPE]\n\t    , $ArrayBuffer        = $buffer.ArrayBuffer\n\t    , $DataView           = $buffer.DataView\n\t    , arrayForEach        = createArrayMethod(0)\n\t    , arrayFilter         = createArrayMethod(2)\n\t    , arraySome           = createArrayMethod(3)\n\t    , arrayEvery          = createArrayMethod(4)\n\t    , arrayFind           = createArrayMethod(5)\n\t    , arrayFindIndex      = createArrayMethod(6)\n\t    , arrayIncludes       = createArrayIncludes(true)\n\t    , arrayIndexOf        = createArrayIncludes(false)\n\t    , arrayValues         = ArrayIterators.values\n\t    , arrayKeys           = ArrayIterators.keys\n\t    , arrayEntries        = ArrayIterators.entries\n\t    , arrayLastIndexOf    = ArrayProto.lastIndexOf\n\t    , arrayReduce         = ArrayProto.reduce\n\t    , arrayReduceRight    = ArrayProto.reduceRight\n\t    , arrayJoin           = ArrayProto.join\n\t    , arraySort           = ArrayProto.sort\n\t    , arraySlice          = ArrayProto.slice\n\t    , arrayToString       = ArrayProto.toString\n\t    , arrayToLocaleString = ArrayProto.toLocaleString\n\t    , ITERATOR            = wks('iterator')\n\t    , TAG                 = wks('toStringTag')\n\t    , TYPED_CONSTRUCTOR   = uid('typed_constructor')\n\t    , DEF_CONSTRUCTOR     = uid('def_constructor')\n\t    , ALL_CONSTRUCTORS    = $typed.CONSTR\n\t    , TYPED_ARRAY         = $typed.TYPED\n\t    , VIEW                = $typed.VIEW\n\t    , WRONG_LENGTH        = 'Wrong length!';\n\t\n\t  var $map = createArrayMethod(1, function(O, length){\n\t    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n\t  });\n\t\n\t  var LITTLE_ENDIAN = fails(function(){\n\t    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n\t  });\n\t\n\t  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){\n\t    new Uint8Array(1).set({});\n\t  });\n\t\n\t  var strictToLength = function(it, SAME){\n\t    if(it === undefined)throw TypeError(WRONG_LENGTH);\n\t    var number = +it\n\t      , length = toLength(it);\n\t    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);\n\t    return length;\n\t  };\n\t\n\t  var toOffset = function(it, BYTES){\n\t    var offset = toInteger(it);\n\t    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');\n\t    return offset;\n\t  };\n\t\n\t  var validate = function(it){\n\t    if(isObject(it) && TYPED_ARRAY in it)return it;\n\t    throw TypeError(it + ' is not a typed array!');\n\t  };\n\t\n\t  var allocate = function(C, length){\n\t    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){\n\t      throw TypeError('It is not a typed array constructor!');\n\t    } return new C(length);\n\t  };\n\t\n\t  var speciesFromList = function(O, list){\n\t    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n\t  };\n\t\n\t  var fromList = function(C, list){\n\t    var index  = 0\n\t      , length = list.length\n\t      , result = allocate(C, length);\n\t    while(length > index)result[index] = list[index++];\n\t    return result;\n\t  };\n\t\n\t  var addGetter = function(it, key, internal){\n\t    dP(it, key, {get: function(){ return this._d[internal]; }});\n\t  };\n\t\n\t  var $from = function from(source /*, mapfn, thisArg */){\n\t    var O       = toObject(source)\n\t      , aLen    = arguments.length\n\t      , mapfn   = aLen > 1 ? arguments[1] : undefined\n\t      , mapping = mapfn !== undefined\n\t      , iterFn  = getIterFn(O)\n\t      , i, length, values, result, step, iterator;\n\t    if(iterFn != undefined && !isArrayIter(iterFn)){\n\t      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){\n\t        values.push(step.value);\n\t      } O = values;\n\t    }\n\t    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);\n\t    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){\n\t      result[i] = mapping ? mapfn(O[i], i) : O[i];\n\t    }\n\t    return result;\n\t  };\n\t\n\t  var $of = function of(/*...items*/){\n\t    var index  = 0\n\t      , length = arguments.length\n\t      , result = allocate(this, length);\n\t    while(length > index)result[index] = arguments[index++];\n\t    return result;\n\t  };\n\t\n\t  // iOS Safari 6.x fails here\n\t  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });\n\t\n\t  var $toLocaleString = function toLocaleString(){\n\t    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n\t  };\n\t\n\t  var proto = {\n\t    copyWithin: function copyWithin(target, start /*, end */){\n\t      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n\t    },\n\t    every: function every(callbackfn /*, thisArg */){\n\t      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t    },\n\t    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars\n\t      return arrayFill.apply(validate(this), arguments);\n\t    },\n\t    filter: function filter(callbackfn /*, thisArg */){\n\t      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n\t        arguments.length > 1 ? arguments[1] : undefined));\n\t    },\n\t    find: function find(predicate /*, thisArg */){\n\t      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n\t    },\n\t    findIndex: function findIndex(predicate /*, thisArg */){\n\t      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n\t    },\n\t    forEach: function forEach(callbackfn /*, thisArg */){\n\t      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t    },\n\t    indexOf: function indexOf(searchElement /*, fromIndex */){\n\t      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n\t    },\n\t    includes: function includes(searchElement /*, fromIndex */){\n\t      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n\t    },\n\t    join: function join(separator){ // eslint-disable-line no-unused-vars\n\t      return arrayJoin.apply(validate(this), arguments);\n\t    },\n\t    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars\n\t      return arrayLastIndexOf.apply(validate(this), arguments);\n\t    },\n\t    map: function map(mapfn /*, thisArg */){\n\t      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n\t    },\n\t    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars\n\t      return arrayReduce.apply(validate(this), arguments);\n\t    },\n\t    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars\n\t      return arrayReduceRight.apply(validate(this), arguments);\n\t    },\n\t    reverse: function reverse(){\n\t      var that   = this\n\t        , length = validate(that).length\n\t        , middle = Math.floor(length / 2)\n\t        , index  = 0\n\t        , value;\n\t      while(index < middle){\n\t        value         = that[index];\n\t        that[index++] = that[--length];\n\t        that[length]  = value;\n\t      } return that;\n\t    },\n\t    some: function some(callbackfn /*, thisArg */){\n\t      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t    },\n\t    sort: function sort(comparefn){\n\t      return arraySort.call(validate(this), comparefn);\n\t    },\n\t    subarray: function subarray(begin, end){\n\t      var O      = validate(this)\n\t        , length = O.length\n\t        , $begin = toIndex(begin, length);\n\t      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n\t        O.buffer,\n\t        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n\t        toLength((end === undefined ? length : toIndex(end, length)) - $begin)\n\t      );\n\t    }\n\t  };\n\t\n\t  var $slice = function slice(start, end){\n\t    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n\t  };\n\t\n\t  var $set = function set(arrayLike /*, offset */){\n\t    validate(this);\n\t    var offset = toOffset(arguments[1], 1)\n\t      , length = this.length\n\t      , src    = toObject(arrayLike)\n\t      , len    = toLength(src.length)\n\t      , index  = 0;\n\t    if(len + offset > length)throw RangeError(WRONG_LENGTH);\n\t    while(index < len)this[offset + index] = src[index++];\n\t  };\n\t\n\t  var $iterators = {\n\t    entries: function entries(){\n\t      return arrayEntries.call(validate(this));\n\t    },\n\t    keys: function keys(){\n\t      return arrayKeys.call(validate(this));\n\t    },\n\t    values: function values(){\n\t      return arrayValues.call(validate(this));\n\t    }\n\t  };\n\t\n\t  var isTAIndex = function(target, key){\n\t    return isObject(target)\n\t      && target[TYPED_ARRAY]\n\t      && typeof key != 'symbol'\n\t      && key in target\n\t      && String(+key) == String(key);\n\t  };\n\t  var $getDesc = function getOwnPropertyDescriptor(target, key){\n\t    return isTAIndex(target, key = toPrimitive(key, true))\n\t      ? propertyDesc(2, target[key])\n\t      : gOPD(target, key);\n\t  };\n\t  var $setDesc = function defineProperty(target, key, desc){\n\t    if(isTAIndex(target, key = toPrimitive(key, true))\n\t      && isObject(desc)\n\t      && has(desc, 'value')\n\t      && !has(desc, 'get')\n\t      && !has(desc, 'set')\n\t      // TODO: add validation descriptor w/o calling accessors\n\t      && !desc.configurable\n\t      && (!has(desc, 'writable') || desc.writable)\n\t      && (!has(desc, 'enumerable') || desc.enumerable)\n\t    ){\n\t      target[key] = desc.value;\n\t      return target;\n\t    } else return dP(target, key, desc);\n\t  };\n\t\n\t  if(!ALL_CONSTRUCTORS){\n\t    $GOPD.f = $getDesc;\n\t    $DP.f   = $setDesc;\n\t  }\n\t\n\t  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n\t    getOwnPropertyDescriptor: $getDesc,\n\t    defineProperty:           $setDesc\n\t  });\n\t\n\t  if(fails(function(){ arrayToString.call({}); })){\n\t    arrayToString = arrayToLocaleString = function toString(){\n\t      return arrayJoin.call(this);\n\t    }\n\t  }\n\t\n\t  var $TypedArrayPrototype$ = redefineAll({}, proto);\n\t  redefineAll($TypedArrayPrototype$, $iterators);\n\t  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n\t  redefineAll($TypedArrayPrototype$, {\n\t    slice:          $slice,\n\t    set:            $set,\n\t    constructor:    function(){ /* noop */ },\n\t    toString:       arrayToString,\n\t    toLocaleString: $toLocaleString\n\t  });\n\t  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n\t  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n\t  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n\t  addGetter($TypedArrayPrototype$, 'length', 'e');\n\t  dP($TypedArrayPrototype$, TAG, {\n\t    get: function(){ return this[TYPED_ARRAY]; }\n\t  });\n\t\n\t  module.exports = function(KEY, BYTES, wrapper, CLAMPED){\n\t    CLAMPED = !!CLAMPED;\n\t    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'\n\t      , ISNT_UINT8 = NAME != 'Uint8Array'\n\t      , GETTER     = 'get' + KEY\n\t      , SETTER     = 'set' + KEY\n\t      , TypedArray = global[NAME]\n\t      , Base       = TypedArray || {}\n\t      , TAC        = TypedArray && getPrototypeOf(TypedArray)\n\t      , FORCED     = !TypedArray || !$typed.ABV\n\t      , O          = {}\n\t      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n\t    var getter = function(that, index){\n\t      var data = that._d;\n\t      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n\t    };\n\t    var setter = function(that, index, value){\n\t      var data = that._d;\n\t      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n\t      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n\t    };\n\t    var addElement = function(that, index){\n\t      dP(that, index, {\n\t        get: function(){\n\t          return getter(this, index);\n\t        },\n\t        set: function(value){\n\t          return setter(this, index, value);\n\t        },\n\t        enumerable: true\n\t      });\n\t    };\n\t    if(FORCED){\n\t      TypedArray = wrapper(function(that, data, $offset, $length){\n\t        anInstance(that, TypedArray, NAME, '_d');\n\t        var index  = 0\n\t          , offset = 0\n\t          , buffer, byteLength, length, klass;\n\t        if(!isObject(data)){\n\t          length     = strictToLength(data, true)\n\t          byteLength = length * BYTES;\n\t          buffer     = new $ArrayBuffer(byteLength);\n\t        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){\n\t          buffer = data;\n\t          offset = toOffset($offset, BYTES);\n\t          var $len = data.byteLength;\n\t          if($length === undefined){\n\t            if($len % BYTES)throw RangeError(WRONG_LENGTH);\n\t            byteLength = $len - offset;\n\t            if(byteLength < 0)throw RangeError(WRONG_LENGTH);\n\t          } else {\n\t            byteLength = toLength($length) * BYTES;\n\t            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);\n\t          }\n\t          length = byteLength / BYTES;\n\t        } else if(TYPED_ARRAY in data){\n\t          return fromList(TypedArray, data);\n\t        } else {\n\t          return $from.call(TypedArray, data);\n\t        }\n\t        hide(that, '_d', {\n\t          b: buffer,\n\t          o: offset,\n\t          l: byteLength,\n\t          e: length,\n\t          v: new $DataView(buffer)\n\t        });\n\t        while(index < length)addElement(that, index++);\n\t      });\n\t      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n\t      hide(TypedArrayPrototype, 'constructor', TypedArray);\n\t    } else if(!$iterDetect(function(iter){\n\t      // V8 works with iterators, but fails in many other cases\n\t      // https://code.google.com/p/v8/issues/detail?id=4552\n\t      new TypedArray(null); // eslint-disable-line no-new\n\t      new TypedArray(iter); // eslint-disable-line no-new\n\t    }, true)){\n\t      TypedArray = wrapper(function(that, data, $offset, $length){\n\t        anInstance(that, TypedArray, NAME);\n\t        var klass;\n\t        // `ws` module bug, temporarily remove validation length for Uint8Array\n\t        // https://github.com/websockets/ws/pull/645\n\t        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));\n\t        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){\n\t          return $length !== undefined\n\t            ? new Base(data, toOffset($offset, BYTES), $length)\n\t            : $offset !== undefined\n\t              ? new Base(data, toOffset($offset, BYTES))\n\t              : new Base(data);\n\t        }\n\t        if(TYPED_ARRAY in data)return fromList(TypedArray, data);\n\t        return $from.call(TypedArray, data);\n\t      });\n\t      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){\n\t        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);\n\t      });\n\t      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n\t      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;\n\t    }\n\t    var $nativeIterator   = TypedArrayPrototype[ITERATOR]\n\t      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)\n\t      , $iterator         = $iterators.values;\n\t    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n\t    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n\t    hide(TypedArrayPrototype, VIEW, true);\n\t    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\t\n\t    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){\n\t      dP(TypedArrayPrototype, TAG, {\n\t        get: function(){ return NAME; }\n\t      });\n\t    }\n\t\n\t    O[NAME] = TypedArray;\n\t\n\t    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\t\n\t    $export($export.S, NAME, {\n\t      BYTES_PER_ELEMENT: BYTES,\n\t      from: $from,\n\t      of: $of\n\t    });\n\t\n\t    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\t\n\t    $export($export.P, NAME, proto);\n\t\n\t    setSpecies(NAME);\n\t\n\t    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});\n\t\n\t    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\t\n\t    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});\n\t\n\t    $export($export.P + $export.F * fails(function(){\n\t      new TypedArray(1).slice();\n\t    }), NAME, {slice: $slice});\n\t\n\t    $export($export.P + $export.F * (fails(function(){\n\t      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()\n\t    }) || !fails(function(){\n\t      TypedArrayPrototype.toLocaleString.call([1, 2]);\n\t    })), NAME, {toLocaleString: $toLocaleString});\n\t\n\t    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n\t    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);\n\t  };\n\t} else module.exports = function(){ /* empty */ };\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar Promise = __webpack_require__(106);\n\t\n\t/* istanbul ignore next */\n\texports.once = function (fun) {\n\t  var called = false;\n\t  return exports.getArguments(function (args) {\n\t    if (called) {\n\t      console.trace();\n\t      throw new Error('once called  more than once');\n\t    } else {\n\t      called = true;\n\t      fun.apply(this, args);\n\t    }\n\t  });\n\t};\n\t/* istanbul ignore next */\n\texports.getArguments = function (fun) {\n\t  return function () {\n\t    var len = arguments.length;\n\t    var args = new Array(len);\n\t    var i = -1;\n\t    while (++i < len) {\n\t      args[i] = arguments[i];\n\t    }\n\t    return fun.call(this, args);\n\t  };\n\t};\n\t/* istanbul ignore next */\n\texports.toPromise = function (func) {\n\t  //create the function we will be returning\n\t  return exports.getArguments(function (args) {\n\t    var self = this;\n\t    var tempCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n\t    // if the last argument is a function, assume its a callback\n\t    var usedCB;\n\t    if (tempCB) {\n\t      // if it was a callback, create a new callback which calls it,\n\t      // but do so async so we don't trap any errors\n\t      usedCB = function (err, resp) {\n\t        process.nextTick(function () {\n\t          tempCB(err, resp);\n\t        });\n\t      };\n\t    }\n\t    var promise = new Promise(function (fulfill, reject) {\n\t      try {\n\t        var callback = exports.once(function (err, mesg) {\n\t          if (err) {\n\t            reject(err);\n\t          } else {\n\t            fulfill(mesg);\n\t          }\n\t        });\n\t        // create a callback for this invocation\n\t        // apply the function in the orig context\n\t        args.push(callback);\n\t        func.apply(self, args);\n\t      } catch (e) {\n\t        reject(e);\n\t      }\n\t    });\n\t    // if there is a callback, call it back\n\t    if (usedCB) {\n\t      promise.then(function (result) {\n\t        usedCB(null, result);\n\t      }, usedCB);\n\t    }\n\t    promise.cancel = function () {\n\t      return this;\n\t    };\n\t    return promise;\n\t  });\n\t};\n\t\n\texports.inherits = __webpack_require__(75);\n\texports.Promise = Promise;\n\t\n\texports.clone = function (obj) {\n\t  return exports.extend(true, {}, obj);\n\t};\n\t\n\texports.extend = __webpack_require__(102);\n\t\n\texports.callbackify = function (fun) {\n\t  return exports.getArguments(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    exports.promisedCallback(promise, cb);\n\t    return promise;\n\t  });\n\t};\n\t\n\texports.promisedCallback = function (promise, callback) {\n\t  promise.then(function (res) {\n\t    process.nextTick(function () {\n\t      callback(null, res);\n\t    });\n\t  }, function (reason) {\n\t    process.nextTick(function () {\n\t      callback(reason);\n\t    });\n\t  });\n\t  return promise;\n\t};\n\t\n\tvar crypto = __webpack_require__(250);\n\tvar Md5 = __webpack_require__(108);\n\t\n\texports.MD5 = function (string) {\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    return crypto.createHash('md5').update(string).digest('hex');\n\t  } else {\n\t    return Md5.hash(string);\n\t  }\n\t};\n\t\n\texports.flatten = exports.getArguments(function (args) {\n\t  var res = [];\n\t  for (var i = 0, len = args.length; i < len; i++) {\n\t    var subArr = args[i];\n\t    if (Array.isArray(subArr)) {\n\t      res = res.concat(exports.flatten.apply(null, subArr));\n\t    } else {\n\t      res.push(subArr);\n\t    }\n\t  }\n\t  return res;\n\t});\n\t\n\texports.mergeObjects = function (arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    res = exports.extend(true, res, arr[i]);\n\t  }\n\t  return res;\n\t};\n\t\n\t// this would just be \"return doc[field]\", but fields\n\t// can be \"deep\" due to dot notation\n\texports.getFieldFromDoc = function (doc, parsedField) {\n\t  var value = doc;\n\t  for (var i = 0, len = parsedField.length; i < len; i++) {\n\t    var key = parsedField[i];\n\t    value = value[key];\n\t    if (!value) {\n\t      break;\n\t    }\n\t  }\n\t  return value;\n\t};\n\t\n\texports.setFieldInDoc = function (doc, parsedField, value) {\n\t  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n\t    var elem = parsedField[i];\n\t    doc = doc[elem] = {};\n\t  }\n\t  doc[parsedField[len-1]] = value;\n\t};\n\t\n\t// Converts a string in dot notation to an array of its components, with backslash escaping\n\texports.parseField = function (fieldName) {\n\t  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n\t  var fields = [];\n\t  var current = '';\n\t  for (var i = 0, len = fieldName.length; i < len; i++) {\n\t    var ch = fieldName[i];\n\t    if (ch === '.') {\n\t      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n\t        current = current.substring(0, current.length - 1) + '.';\n\t      } else { // not escaped, so delimiter\n\t        fields.push(current);\n\t        current = '';\n\t      }\n\t    } else { // normal character\n\t      current += ch;\n\t    }\n\t  }\n\t  fields.push(current);\n\t  return fields;\n\t};\n\t\n\t// Selects a list of fields defined in dot notation from one doc\n\t// and copies them to a new doc. Like underscore _.pick but supports nesting.\n\texports.pick = function (obj, arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var parsedField = exports.parseField(arr[i]);\n\t    var value = exports.getFieldFromDoc(obj, parsedField);\n\t    if(typeof value !== 'undefined') {\n\t      exports.setFieldInDoc(res, parsedField, value);\n\t    }\n\t  }\n\t  return res;\n\t};\n\t\n\t// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\n\texports.oneArrayIsSubArrayOfOther = function (left, right) {\n\t\n\t  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n\t    if (left[i] !== right[i]) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t};\n\t\n\t// e.g.['a', 'b', 'c'], ['a', 'b'] is false\n\texports.oneArrayIsStrictSubArrayOfOther = function (left, right) {\n\t\n\t  if (left.length > right.length) {\n\t    return false;\n\t  }\n\t\n\t  return exports.oneArrayIsSubArrayOfOther(left, right);\n\t};\n\t\n\t// same as above, but treat the left array as an unordered set\n\t// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\n\texports.oneSetIsSubArrayOfOther = function (left, right) {\n\t  left = left.slice();\n\t  for (var i = 0, len = right.length; i < len; i++) {\n\t    var field = right[i];\n\t    if (!left.length) {\n\t      break;\n\t    }\n\t    var leftIdx = left.indexOf(field);\n\t    if (leftIdx === -1) {\n\t      return false;\n\t    } else {\n\t      left.splice(leftIdx, 1);\n\t    }\n\t  }\n\t  return true;\n\t};\n\t\n\texports.compare = function (left, right) {\n\t  return left < right ? -1 : left > right ? 1 : 0;\n\t};\n\t\n\texports.arrayToObject = function (arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    res[arr[i]] = true;\n\t  }\n\t  return res;\n\t};\n\t\n\texports.max = function (arr, fun) {\n\t  var max = null;\n\t  var maxScore = -1;\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var element = arr[i];\n\t    var score = fun(element);\n\t    if (score > maxScore) {\n\t      maxScore = score;\n\t      max = element;\n\t    }\n\t  }\n\t  return max;\n\t};\n\t\n\texports.arrayEquals = function (arr1, arr2) {\n\t  if (arr1.length !== arr2.length) {\n\t    return false;\n\t  }\n\t  for (var i = 0, len = arr1.length; i < len; i++) {\n\t    if (arr1[i] !== arr2[i]) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t};\n\t\n\texports.uniq = function(arr) {\n\t  var obj = {};\n\t  for (var i = 0; i < arr.length; i++) {\n\t    obj['$' + arr[i]] = true;\n\t  }\n\t  return Object.keys(obj).map(function (key) {\n\t    return key.substring(1);\n\t  });\n\t};\n\t\n\texports.log = __webpack_require__(235)('pouchdb:find');\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t// 7.2.1 RequireObjectCoercible(argument)\n\tmodule.exports = function(it){\n\t  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n\t  return it;\n\t};\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar pIE            = __webpack_require__(43)\n\t  , createDesc     = __webpack_require__(19)\n\t  , toIObject      = __webpack_require__(12)\n\t  , toPrimitive    = __webpack_require__(45)\n\t  , has            = __webpack_require__(8)\n\t  , IE8_DOM_DEFINE = __webpack_require__(84)\n\t  , gOPD           = Object.getOwnPropertyDescriptor;\n\t\n\texports.f = __webpack_require__(9) ? gOPD : function getOwnPropertyDescriptor(O, P){\n\t  O = toIObject(O);\n\t  P = toPrimitive(P, true);\n\t  if(IE8_DOM_DEFINE)try {\n\t    return gOPD(O, P);\n\t  } catch(e){ /* empty */ }\n\t  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n\t};\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(bitmap, value){\n\t  return {\n\t    enumerable  : !(bitmap & 1),\n\t    configurable: !(bitmap & 2),\n\t    writable    : !(bitmap & 4),\n\t    value       : value\n\t  };\n\t};\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(2)\n\t  , hide      = __webpack_require__(11)\n\t  , has       = __webpack_require__(8)\n\t  , SRC       = __webpack_require__(25)('src')\n\t  , TO_STRING = 'toString'\n\t  , $toString = Function[TO_STRING]\n\t  , TPL       = ('' + $toString).split(TO_STRING);\n\t\n\t__webpack_require__(38).inspectSource = function(it){\n\t  return $toString.call(it);\n\t};\n\t\n\t(module.exports = function(O, key, val, safe){\n\t  var isFunction = typeof val == 'function';\n\t  if(isFunction)has(val, 'name') || hide(val, 'name', key);\n\t  if(O[key] === val)return;\n\t  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n\t  if(O === global){\n\t    O[key] = val;\n\t  } else {\n\t    if(!safe){\n\t      delete O[key];\n\t      hide(O, key, val);\n\t    } else {\n\t      if(O[key])O[key] = val;\n\t      else hide(O, key, val);\n\t    }\n\t  }\n\t// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n\t})(Function.prototype, TO_STRING, function toString(){\n\t  return typeof this == 'function' && this[SRC] || $toString.call(this);\n\t});\n\n/***/ },\n/* 21 */\n/***/ function(module, exports) {\n\n\t// shim for using process in browser\n\tvar process = module.exports = {};\n\t\n\t// cached from whatever global is present so that test runners that stub it\n\t// don't break things.  But we need to wrap it in a try catch in case it is\n\t// wrapped in strict mode code which doesn't define any globals.  It's inside a\n\t// function because try/catches deoptimize in certain engines.\n\t\n\tvar cachedSetTimeout;\n\tvar cachedClearTimeout;\n\t\n\tfunction defaultSetTimout() {\n\t    throw new Error('setTimeout has not been defined');\n\t}\n\tfunction defaultClearTimeout () {\n\t    throw new Error('clearTimeout has not been defined');\n\t}\n\t(function () {\n\t    try {\n\t        if (typeof setTimeout === 'function') {\n\t            cachedSetTimeout = setTimeout;\n\t        } else {\n\t            cachedSetTimeout = defaultSetTimout;\n\t        }\n\t    } catch (e) {\n\t        cachedSetTimeout = defaultSetTimout;\n\t    }\n\t    try {\n\t        if (typeof clearTimeout === 'function') {\n\t            cachedClearTimeout = clearTimeout;\n\t        } else {\n\t            cachedClearTimeout = defaultClearTimeout;\n\t        }\n\t    } catch (e) {\n\t        cachedClearTimeout = defaultClearTimeout;\n\t    }\n\t} ())\n\tfunction runTimeout(fun) {\n\t    if (cachedSetTimeout === setTimeout) {\n\t        //normal enviroments in sane situations\n\t        return setTimeout(fun, 0);\n\t    }\n\t    // if setTimeout wasn't available but was latter defined\n\t    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n\t        cachedSetTimeout = setTimeout;\n\t        return setTimeout(fun, 0);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedSetTimeout(fun, 0);\n\t    } catch(e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n\t            return cachedSetTimeout.call(null, fun, 0);\n\t        } catch(e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n\t            return cachedSetTimeout.call(this, fun, 0);\n\t        }\n\t    }\n\t\n\t\n\t}\n\tfunction runClearTimeout(marker) {\n\t    if (cachedClearTimeout === clearTimeout) {\n\t        //normal enviroments in sane situations\n\t        return clearTimeout(marker);\n\t    }\n\t    // if clearTimeout wasn't available but was latter defined\n\t    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n\t        cachedClearTimeout = clearTimeout;\n\t        return clearTimeout(marker);\n\t    }\n\t    try {\n\t        // when when somebody has screwed with setTimeout but no I.E. maddness\n\t        return cachedClearTimeout(marker);\n\t    } catch (e){\n\t        try {\n\t            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n\t            return cachedClearTimeout.call(null, marker);\n\t        } catch (e){\n\t            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n\t            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n\t            return cachedClearTimeout.call(this, marker);\n\t        }\n\t    }\n\t\n\t\n\t\n\t}\n\tvar queue = [];\n\tvar draining = false;\n\tvar currentQueue;\n\tvar queueIndex = -1;\n\t\n\tfunction cleanUpNextTick() {\n\t    if (!draining || !currentQueue) {\n\t        return;\n\t    }\n\t    draining = false;\n\t    if (currentQueue.length) {\n\t        queue = currentQueue.concat(queue);\n\t    } else {\n\t        queueIndex = -1;\n\t    }\n\t    if (queue.length) {\n\t        drainQueue();\n\t    }\n\t}\n\t\n\tfunction drainQueue() {\n\t    if (draining) {\n\t        return;\n\t    }\n\t    var timeout = runTimeout(cleanUpNextTick);\n\t    draining = true;\n\t\n\t    var len = queue.length;\n\t    while(len) {\n\t        currentQueue = queue;\n\t        queue = [];\n\t        while (++queueIndex < len) {\n\t            if (currentQueue) {\n\t                currentQueue[queueIndex].run();\n\t            }\n\t        }\n\t        queueIndex = -1;\n\t        len = queue.length;\n\t    }\n\t    currentQueue = null;\n\t    draining = false;\n\t    runClearTimeout(timeout);\n\t}\n\t\n\tprocess.nextTick = function (fun) {\n\t    var args = new Array(arguments.length - 1);\n\t    if (arguments.length > 1) {\n\t        for (var i = 1; i < arguments.length; i++) {\n\t            args[i - 1] = arguments[i];\n\t        }\n\t    }\n\t    queue.push(new Item(fun, args));\n\t    if (queue.length === 1 && !draining) {\n\t        runTimeout(drainQueue);\n\t    }\n\t};\n\t\n\t// v8 likes predictible objects\n\tfunction Item(fun, array) {\n\t    this.fun = fun;\n\t    this.array = array;\n\t}\n\tItem.prototype.run = function () {\n\t    this.fun.apply(null, this.array);\n\t};\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\tprocess.version = ''; // empty string to avoid regexp issues\n\tprocess.versions = {};\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\tprocess.umask = function() { return 0; };\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.unpromiser = unpromiser;\n\texports.isPromise = isPromise;\n\texports.isOnline = isOnline;\n\texports.isOffline = isOffline;\n\texports.sleep = sleep;\n\texports.retry = retry;\n\texports.getFuzzedDelay = getFuzzedDelay;\n\texports.getBackedoffDelay = getBackedoffDelay;\n\texports.createPath = createPath;\n\texports.encodeQuery = encodeQuery;\n\texports.decodeQuery = decodeQuery;\n\texports.warn = warn;\n\t/* global navigator */\n\tvar FuzzFactor = 0.3;\n\t\n\tfunction unpromiser(fn) {\n\t  return function () {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    var value = fn.apply(this, args);\n\t    if (!isPromise(value)) {\n\t      return value;\n\t    }\n\t    var l = args.length;\n\t    if (l === 0 || typeof args[l - 1] !== 'function') {\n\t      return;\n\t    }\n\t    var cb = args[l - 1];\n\t    value.then(function (res) {\n\t      return cb(null, res);\n\t    }, function (err) {\n\t      return cb(err, null);\n\t    });\n\t  };\n\t}\n\t\n\tfunction isPromise(value) {\n\t  return !!value && typeof value.then === 'function';\n\t}\n\t\n\tfunction isOnline() {\n\t  return typeof navigator !== 'undefined' ? navigator.onLine : true;\n\t}\n\t\n\tfunction isOffline() {\n\t  return !isOnline();\n\t}\n\t\n\tfunction sleep(time, args) {\n\t  return new Promise(function (resolve) {\n\t    setTimeout(resolve, time, args);\n\t  });\n\t}\n\t\n\tfunction retry(fn, count) {\n\t  var delay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 300;\n\t\n\t  return function doTry() {\n\t    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t      args[_key2] = arguments[_key2];\n\t    }\n\t\n\t    return fn.apply(undefined, args).catch(function (err) {\n\t      if (--count < 0) {\n\t        throw err;\n\t      }\n\t      return sleep(getBackedoffDelay(delay, count)).then(function () {\n\t        return doTry.apply(undefined, args);\n\t      });\n\t    });\n\t  };\n\t}\n\t\n\tfunction getFuzzedDelay(retryDelay) {\n\t  var fuzzingFactor = (Math.random() * 2 - 1) * FuzzFactor;\n\t  return retryDelay * (1.0 + fuzzingFactor);\n\t}\n\t\n\tfunction getBackedoffDelay(retryDelay) {\n\t  var retryCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\t\n\t  return getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1));\n\t}\n\t\n\tfunction createPath(cozy, isV2, doctype) {\n\t  var id = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\t  var query = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n\t\n\t  var route = '/data/';\n\t  if (!isV2) {\n\t    route += encodeURIComponent(doctype) + '/';\n\t  }\n\t  if (id !== '') {\n\t    route += encodeURIComponent(id);\n\t  }\n\t  var q = encodeQuery(query);\n\t  if (q !== '') {\n\t    route += '?' + q;\n\t  }\n\t  return route;\n\t}\n\t\n\tfunction encodeQuery(query) {\n\t  if (!query) {\n\t    return '';\n\t  }\n\t  var q = '';\n\t  for (var qname in query) {\n\t    if (q !== '') {\n\t      q += '&';\n\t    }\n\t    q += encodeURIComponent(qname) + '=' + encodeURIComponent(query[qname]);\n\t  }\n\t  return q;\n\t}\n\t\n\tfunction decodeQuery(url) {\n\t  var queryIndex = url.indexOf('?');\n\t  if (queryIndex < 0) {\n\t    queryIndex = url.length;\n\t  }\n\t  var queries = {};\n\t  var fragIndex = url.indexOf('#');\n\t  if (fragIndex < 0) {\n\t    fragIndex = url.length;\n\t  }\n\t  if (fragIndex < queryIndex) {\n\t    return queries;\n\t  }\n\t  var queryStr = url.slice(queryIndex + 1, fragIndex);\n\t  if (queryStr === '') {\n\t    return queries;\n\t  }\n\t  var parts = queryStr.split('&');\n\t  for (var i = 0; i < parts.length; i++) {\n\t    var pair = parts[i].split('=');\n\t    if (pair.length === 0 || pair[0] === '') {\n\t      continue;\n\t    }\n\t    var qname = decodeURIComponent(pair[0]);\n\t    if (queries.hasOwnProperty(qname)) {\n\t      continue;\n\t    }\n\t    if (pair.length === 1) {\n\t      queries[qname] = true;\n\t    } else if (pair.length === 2) {\n\t      queries[qname] = decodeURIComponent(pair[1]);\n\t    } else {\n\t      throw new Error('Malformed URL');\n\t    }\n\t  }\n\t  return queries;\n\t}\n\t\n\tvar warned = [];\n\tfunction warn(text) {\n\t  if (warned.indexOf(text) === -1) {\n\t    warned.push(text);\n\t    console.warn('cozy-client-js', text);\n\t  }\n\t}\n\n/***/ },\n/* 23 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it){\n\t  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n\t  return it;\n\t};\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.13 ToObject(argument)\n\tvar defined = __webpack_require__(17);\n\tmodule.exports = function(it){\n\t  return Object(defined(it));\n\t};\n\n/***/ },\n/* 25 */\n/***/ function(module, exports) {\n\n\tvar id = 0\n\t  , px = Math.random();\n\tmodule.exports = function(key){\n\t  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n\t};\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 22.1.3.31 Array.prototype[@@unscopables]\n\tvar UNSCOPABLES = __webpack_require__(4)('unscopables')\n\t  , ArrayProto  = Array.prototype;\n\tif(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(11)(ArrayProto, UNSCOPABLES, {});\n\tmodule.exports = function(key){\n\t  ArrayProto[UNSCOPABLES][key] = true;\n\t};\n\n/***/ },\n/* 27 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(it, Constructor, name, forbiddenField){\n\t  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n\t    throw TypeError(name + ': incorrect invocation!');\n\t  } return it;\n\t};\n\n/***/ },\n/* 28 */\n/***/ function(module, exports) {\n\n\tvar toString = {}.toString;\n\t\n\tmodule.exports = function(it){\n\t  return toString.call(it).slice(8, -1);\n\t};\n\n/***/ },\n/* 29 */\n/***/ function(module, exports) {\n\n\tmodule.exports = {};\n\n/***/ },\n/* 30 */\n/***/ function(module, exports) {\n\n\tmodule.exports = false;\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.14 / 15.2.3.14 Object.keys(O)\n\tvar $keys       = __webpack_require__(93)\n\t  , enumBugKeys = __webpack_require__(60);\n\t\n\tmodule.exports = Object.keys || function keys(O){\n\t  return $keys(O, enumBugKeys);\n\t};\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar redefine = __webpack_require__(20);\n\tmodule.exports = function(target, src, safe){\n\t  for(var key in src)redefine(target, key, src[key], safe);\n\t  return target;\n\t};\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar def = __webpack_require__(7).f\n\t  , has = __webpack_require__(8)\n\t  , TAG = __webpack_require__(4)('toStringTag');\n\t\n\tmodule.exports = function(it, tag, stat){\n\t  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n\t};\n\n/***/ },\n/* 34 */\n/***/ function(module, exports) {\n\n\t// 7.1.4 ToInteger\n\tvar ceil  = Math.ceil\n\t  , floor = Math.floor;\n\tmodule.exports = function(it){\n\t  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n\t};\n\n/***/ },\n/* 35 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(16);\n\tvar collate = __webpack_require__(53);\n\t\n\tfunction getKey(obj) {\n\t  return Object.keys(obj)[0];\n\t}\n\t\n\tfunction getValue(obj) {\n\t  return obj[getKey(obj)];\n\t}\n\t\n\t// normalize the \"sort\" value\n\tfunction massageSort(sort) {\n\t  if (!Array.isArray(sort)) {\n\t    throw new Error('invalid sort json - should be an array');\n\t  }\n\t  return sort.map(function (sorting) {\n\t    if (typeof sorting === 'string') {\n\t      var obj = {};\n\t      obj[sorting] = 'asc';\n\t      return obj;\n\t    } else {\n\t      return sorting;\n\t    }\n\t  });\n\t}\n\t\n\tvar combinationFields = ['$or', '$nor', '$not'];\n\tfunction isCombinationalField (field) {\n\t  return combinationFields.indexOf(field) > -1;\n\t}\n\t\n\t// collapse logically equivalent gt/gte values\n\tfunction mergeGtGte(operator, value, fieldMatchers) {\n\t  if (typeof fieldMatchers.$eq !== 'undefined') {\n\t    return; // do nothing\n\t  }\n\t  if (typeof fieldMatchers.$gte !== 'undefined') {\n\t    if (operator === '$gte') {\n\t      if (value > fieldMatchers.$gte) { // more specificity\n\t        fieldMatchers.$gte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value >= fieldMatchers.$gte) { // more specificity\n\t        delete fieldMatchers.$gte;\n\t        fieldMatchers.$gt = value;\n\t      }\n\t    }\n\t  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n\t    if (operator === '$gte') {\n\t      if (value > fieldMatchers.$gt) { // more specificity\n\t        delete fieldMatchers.$gt;\n\t        fieldMatchers.$gte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value > fieldMatchers.$gt) { // more specificity\n\t        fieldMatchers.$gt = value;\n\t      }\n\t    }\n\t  } else {\n\t    fieldMatchers[operator] = value;\n\t  }\n\t}\n\t\n\t// collapse logically equivalent lt/lte values\n\tfunction mergeLtLte(operator, value, fieldMatchers) {\n\t  if (typeof fieldMatchers.$eq !== 'undefined') {\n\t    return; // do nothing\n\t  }\n\t  if (typeof fieldMatchers.$lte !== 'undefined') {\n\t    if (operator === '$lte') {\n\t      if (value < fieldMatchers.$lte) { // more specificity\n\t        fieldMatchers.$lte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value <= fieldMatchers.$lte) { // more specificity\n\t        delete fieldMatchers.$lte;\n\t        fieldMatchers.$lt = value;\n\t      }\n\t    }\n\t  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n\t    if (operator === '$lte') {\n\t      if (value < fieldMatchers.$lt) { // more specificity\n\t        delete fieldMatchers.$lt;\n\t        fieldMatchers.$lte = value;\n\t      }\n\t    } else { // operator === '$gt'\n\t      if (value < fieldMatchers.$lt) { // more specificity\n\t        fieldMatchers.$lt = value;\n\t      }\n\t    }\n\t  } else {\n\t    fieldMatchers[operator] = value;\n\t  }\n\t}\n\t\n\t// combine $ne values into one array\n\tfunction mergeNe(value, fieldMatchers) {\n\t  if ('$ne' in fieldMatchers) {\n\t    // there are many things this could \"not\" be\n\t    fieldMatchers.$ne.push(value);\n\t  } else { // doesn't exist yet\n\t    fieldMatchers.$ne = [value];\n\t  }\n\t}\n\t\n\t// add $eq into the mix\n\tfunction mergeEq(value, fieldMatchers) {\n\t  // these all have less specificity than the $eq\n\t  // TODO: check for user errors here\n\t  delete fieldMatchers.$gt;\n\t  delete fieldMatchers.$gte;\n\t  delete fieldMatchers.$lt;\n\t  delete fieldMatchers.$lte;\n\t  delete fieldMatchers.$ne;\n\t  fieldMatchers.$eq = value;\n\t}\n\t\n\t// flatten an array of selectors joined by an $and operator\n\tfunction mergeAndedSelectors(selectors) {\n\t\n\t  // sort to ensure that e.g. if the user specified\n\t  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n\t  // just {$gt: 'b'}\n\t  var res = {};\n\t\n\t  selectors.forEach(function (selector) {\n\t    Object.keys(selector).forEach(function (field) {\n\t      var matcher = selector[field];\n\t      if (typeof matcher !== 'object') {\n\t        matcher = {$eq: matcher};\n\t      }\n\t\n\t      if (isCombinationalField(field)) {\n\t        if (matcher instanceof Array) {\n\t          res[field] = matcher.map(function (m) {\n\t            return mergeAndedSelectors([m]);\n\t          });\n\t        } else {\n\t          res[field] = mergeAndedSelectors([matcher]);\n\t        }\n\t      } else {\n\t        var fieldMatchers = res[field] = res[field] || {};\n\t        Object.keys(matcher).forEach(function (operator) {\n\t          var value = matcher[operator];\n\t\n\t          if (operator === '$gt' || operator === '$gte') {\n\t            return mergeGtGte(operator, value, fieldMatchers);\n\t          } else if (operator === '$lt' || operator === '$lte') {\n\t            return mergeLtLte(operator, value, fieldMatchers);\n\t          } else if (operator === '$ne') {\n\t            return mergeNe(value, fieldMatchers);\n\t          } else if (operator === '$eq') {\n\t            return mergeEq(value, fieldMatchers);\n\t          }\n\t          fieldMatchers[operator] = value;\n\t        });\n\t      }\n\t    });\n\t  });\n\t\n\t  return res;\n\t}\n\t\n\t//\n\t// normalize the selector\n\t//\n\tfunction massageSelector(input) {\n\t  var result = utils.clone(input);\n\t  var wasAnded = false;\n\t  if ('$and' in result) {\n\t    result = mergeAndedSelectors(result['$and']);\n\t    wasAnded = true;\n\t  }\n\t\n\t  if ('$not' in result) {\n\t    //This feels a little like forcing, but it will work for now,\n\t    //I would like to come back to this and make the merging of selectors a little more generic\n\t    result['$not'] = mergeAndedSelectors([result['$not']]);\n\t  }\n\t\n\t  var fields = Object.keys(result);\n\t\n\t  for (var i = 0; i < fields.length; i++) {\n\t    var field = fields[i];\n\t    var matcher = result[field];\n\t\n\t    if (typeof matcher !== 'object' || matcher === null) {\n\t      matcher = {$eq: matcher};\n\t    } else if ('$ne' in matcher && !wasAnded) {\n\t      // I put these in an array, since there may be more than one\n\t      // but in the \"mergeAnded\" operation, I already take care of that\n\t      matcher.$ne = [matcher.$ne];\n\t    }\n\t    result[field] = matcher;\n\t  }\n\t\n\t  return result;\n\t}\n\t\n\t\n\tfunction massageIndexDef(indexDef) {\n\t  indexDef.fields = indexDef.fields.map(function (field) {\n\t    if (typeof field === 'string') {\n\t      var obj = {};\n\t      obj[field] = 'asc';\n\t      return obj;\n\t    }\n\t    return field;\n\t  });\n\t  return indexDef;\n\t}\n\t\n\tfunction getKeyFromDoc(doc, index) {\n\t  var res = [];\n\t  for (var i = 0; i < index.def.fields.length; i++) {\n\t    var field = getKey(index.def.fields[i]);\n\t    res.push(doc[field]);\n\t  }\n\t  return res;\n\t}\n\t\n\t// have to do this manually because REASONS. I don't know why\n\t// CouchDB didn't implement inclusive_start\n\tfunction filterInclusiveStart(rows, targetValue, index) {\n\t  var indexFields = index.def.fields;\n\t  for (var i = 0, len = rows.length; i < len; i++) {\n\t    var row = rows[i];\n\t\n\t    // shave off any docs at the beginning that are <= the\n\t    // target value\n\t\n\t    var docKey = getKeyFromDoc(row.doc, index);\n\t    if (indexFields.length === 1) {\n\t      docKey = docKey[0]; // only one field, not multi-field\n\t    } else { // more than one field in index\n\t      // in the case where e.g. the user is searching {$gt: {a: 1}}\n\t      // but the index is [a, b], then we need to shorten the doc key\n\t      while (docKey.length > targetValue.length) {\n\t        docKey.pop();\n\t      }\n\t    }\n\t    //ABS as we just looking for values that don't match\n\t    if (Math.abs(collate.collate(docKey, targetValue)) > 0) {\n\t      // no need to filter any further; we're past the key\n\t      break;\n\t    }\n\t  }\n\t  return i > 0 ? rows.slice(i) : rows;\n\t}\n\t\n\tfunction reverseOptions(opts) {\n\t  var newOpts = utils.clone(opts);\n\t  delete newOpts.startkey;\n\t  delete newOpts.endkey;\n\t  delete newOpts.inclusive_start;\n\t  delete newOpts.inclusive_end;\n\t\n\t  if ('endkey' in opts) {\n\t    newOpts.startkey = opts.endkey;\n\t  }\n\t  if ('startkey' in opts) {\n\t    newOpts.endkey = opts.startkey;\n\t  }\n\t  if ('inclusive_start' in opts) {\n\t    newOpts.inclusive_end = opts.inclusive_start;\n\t  }\n\t  if ('inclusive_end' in opts) {\n\t    newOpts.inclusive_start = opts.inclusive_end;\n\t  }\n\t  return newOpts;\n\t}\n\t\n\tfunction validateIndex(index) {\n\t  var ascFields = index.fields.filter(function (field) {\n\t    return getValue(field) === 'asc';\n\t  });\n\t  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n\t    throw new Error('unsupported mixed sorting');\n\t  }\n\t}\n\t\n\tfunction validateSort (requestDef, index) {\n\t  if (index.defaultUsed && requestDef.sort) {\n\t    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n\t      return Object.keys(sortItem)[0] !== '_id';\n\t    }).map(function (sortItem) {\n\t      return Object.keys(sortItem)[0];\n\t    });\n\t\n\t    if (noneIdSorts.length > 0) {\n\t      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n\t      '\" when using the default index');\n\t    }\n\t  }\n\t\n\t  if (index.defaultUsed) {\n\t    return;\n\t  }\n\t}\n\t\n\tfunction validateFindRequest(requestDef) {\n\t  if (typeof requestDef.selector !== 'object') {\n\t    throw new Error('you must provide a selector when you find()');\n\t  }\n\t\n\t  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n\t  for (var i = 0; i < selectors.length; i++) {\n\t    var selector = selectors[i];\n\t    var keys = Object.keys(selector);\n\t    if (keys.length === 0) {\n\t      throw new Error('invalid empty selector');\n\t    }\n\t    //var selection = selector[keys[0]];\n\t    /*if (Object.keys(selection).length !== 1) {\n\t      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n\t        ' - it must have exactly one key/value');\n\t    }\n\t  }*/\n\t}\n\t\n\t// determine the maximum number of fields\n\t// we're going to need to query, e.g. if the user\n\t// has selection ['a'] and sorting ['a', 'b'], then we\n\t// need to use the longer of the two: ['a', 'b']\n\tfunction getUserFields(selector, sort) {\n\t  var selectorFields = Object.keys(selector);\n\t  var sortFields = sort? sort.map(getKey) : [];\n\t  var userFields;\n\t  if (selectorFields.length >= sortFields.length) {\n\t    userFields = selectorFields;\n\t  } else {\n\t    userFields = sortFields;\n\t  }\n\t\n\t  if (sortFields.length === 0) {\n\t    return {\n\t      fields: userFields\n\t    };\n\t  }\n\t\n\t  // sort according to the user's preferred sorting\n\t  userFields = userFields.sort(function (left, right) {\n\t    var leftIdx = sortFields.indexOf(left);\n\t    if (leftIdx === -1) {\n\t      leftIdx = Number.MAX_VALUE;\n\t    }\n\t    var rightIdx = sortFields.indexOf(right);\n\t    if (rightIdx === -1) {\n\t      rightIdx = Number.MAX_VALUE;\n\t    }\n\t    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n\t  });\n\t\n\t  return {\n\t    fields: userFields,\n\t    sortOrder: sort.map(getKey)\n\t  };\n\t}\n\t\n\tmodule.exports = {\n\t  getKey: getKey,\n\t  getValue: getValue,\n\t  massageSort: massageSort,\n\t  massageSelector: massageSelector,\n\t  validateIndex: validateIndex,\n\t  validateFindRequest: validateFindRequest,\n\t  validateSort: validateSort,\n\t  reverseOptions: reverseOptions,\n\t  filterInclusiveStart: filterInclusiveStart,\n\t  massageIndexDef: massageIndexDef,\n\t  parseField: utils.parseField,\n\t  getUserFields: getUserFields,\n\t  isCombinationalField: isCombinationalField\n\t};\n\n\n/***/ },\n/* 36 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.DOCTYPE_FILES = undefined;\n\texports.normalizeDoctype = normalizeDoctype;\n\t\n\tvar _utils = __webpack_require__(22);\n\t\n\tvar DOCTYPE_FILES = exports.DOCTYPE_FILES = 'io.cozy.files';\n\t\n\tvar KNOWN_DOCTYPES = {\n\t  'files': DOCTYPE_FILES,\n\t  'folder': DOCTYPE_FILES,\n\t  'contact': 'io.cozy.contacts',\n\t  'event': 'io.cozy.events',\n\t  'track': 'io.cozy.labs.music.track',\n\t  'playlist': 'io.cozy.labs.music.playlist'\n\t};\n\t\n\tvar REVERSE_KNOWN = {};\n\tObject.keys(KNOWN_DOCTYPES).forEach(function (k) {\n\t  REVERSE_KNOWN[KNOWN_DOCTYPES[k]] = k;\n\t});\n\t\n\tfunction normalizeDoctype(cozy, isV2, doctype) {\n\t  var isQualified = doctype.indexOf('.') !== -1;\n\t  if (isV2 && isQualified) {\n\t    var known = REVERSE_KNOWN[doctype];\n\t    if (known) return known;\n\t    return doctype.replace(/\\./g, '-');\n\t  }\n\t  if (!isV2 && !isQualified) {\n\t    var _known = KNOWN_DOCTYPES[doctype];\n\t    if (_known) {\n\t      (0, _utils.warn)('you are using a non-qualified doctype ' + doctype + ' assumed to be ' + _known);\n\t      return _known;\n\t    }\n\t    throw new Error('Doctype ' + doctype + ' should be qualified.');\n\t  }\n\t  return doctype;\n\t}\n\n/***/ },\n/* 37 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 0 -> Array#forEach\n\t// 1 -> Array#map\n\t// 2 -> Array#filter\n\t// 3 -> Array#some\n\t// 4 -> Array#every\n\t// 5 -> Array#find\n\t// 6 -> Array#findIndex\n\tvar ctx      = __webpack_require__(14)\n\t  , IObject  = __webpack_require__(62)\n\t  , toObject = __webpack_require__(24)\n\t  , toLength = __webpack_require__(10)\n\t  , asc      = __webpack_require__(121);\n\tmodule.exports = function(TYPE, $create){\n\t  var IS_MAP        = TYPE == 1\n\t    , IS_FILTER     = TYPE == 2\n\t    , IS_SOME       = TYPE == 3\n\t    , IS_EVERY      = TYPE == 4\n\t    , IS_FIND_INDEX = TYPE == 6\n\t    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX\n\t    , create        = $create || asc;\n\t  return function($this, callbackfn, that){\n\t    var O      = toObject($this)\n\t      , self   = IObject(O)\n\t      , f      = ctx(callbackfn, that, 3)\n\t      , length = toLength(self.length)\n\t      , index  = 0\n\t      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined\n\t      , val, res;\n\t    for(;length > index; index++)if(NO_HOLES || index in self){\n\t      val = self[index];\n\t      res = f(val, index, O);\n\t      if(TYPE){\n\t        if(IS_MAP)result[index] = res;            // map\n\t        else if(res)switch(TYPE){\n\t          case 3: return true;                    // some\n\t          case 5: return val;                     // find\n\t          case 6: return index;                   // findIndex\n\t          case 2: result.push(val);               // filter\n\t        } else if(IS_EVERY)return false;          // every\n\t      }\n\t    }\n\t    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n\t  };\n\t};\n\n/***/ },\n/* 38 */\n/***/ function(module, exports) {\n\n\tvar core = module.exports = {version: '2.4.0'};\n\tif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n/***/ },\n/* 39 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar META     = __webpack_require__(25)('meta')\n\t  , isObject = __webpack_require__(5)\n\t  , has      = __webpack_require__(8)\n\t  , setDesc  = __webpack_require__(7).f\n\t  , id       = 0;\n\tvar isExtensible = Object.isExtensible || function(){\n\t  return true;\n\t};\n\tvar FREEZE = !__webpack_require__(6)(function(){\n\t  return isExtensible(Object.preventExtensions({}));\n\t});\n\tvar setMeta = function(it){\n\t  setDesc(it, META, {value: {\n\t    i: 'O' + ++id, // object ID\n\t    w: {}          // weak collections IDs\n\t  }});\n\t};\n\tvar fastKey = function(it, create){\n\t  // return primitive with prefix\n\t  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return 'F';\n\t    // not necessary to add metadata\n\t    if(!create)return 'E';\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return object ID\n\t  } return it[META].i;\n\t};\n\tvar getWeak = function(it, create){\n\t  if(!has(it, META)){\n\t    // can't set metadata to uncaught frozen object\n\t    if(!isExtensible(it))return true;\n\t    // not necessary to add metadata\n\t    if(!create)return false;\n\t    // add missing metadata\n\t    setMeta(it);\n\t  // return hash weak collections IDs\n\t  } return it[META].w;\n\t};\n\t// add metadata on freeze-family methods calling\n\tvar onFreeze = function(it){\n\t  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n\t  return it;\n\t};\n\tvar meta = module.exports = {\n\t  KEY:      META,\n\t  NEED:     false,\n\t  fastKey:  fastKey,\n\t  getWeak:  getWeak,\n\t  onFreeze: onFreeze\n\t};\n\n/***/ },\n/* 40 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\n\tvar anObject    = __webpack_require__(3)\n\t  , dPs         = __webpack_require__(129)\n\t  , enumBugKeys = __webpack_require__(60)\n\t  , IE_PROTO    = __webpack_require__(68)('IE_PROTO')\n\t  , Empty       = function(){ /* empty */ }\n\t  , PROTOTYPE   = 'prototype';\n\t\n\t// Create object with fake `null` prototype: use iframe Object with cleared prototype\n\tvar createDict = function(){\n\t  // Thrash, waste and sodomy: IE GC bug\n\t  var iframe = __webpack_require__(59)('iframe')\n\t    , i      = enumBugKeys.length\n\t    , lt     = '<'\n\t    , gt     = '>'\n\t    , iframeDocument;\n\t  iframe.style.display = 'none';\n\t  __webpack_require__(83).appendChild(iframe);\n\t  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n\t  // createDict = iframe.contentWindow.Object;\n\t  // html.removeChild(iframe);\n\t  iframeDocument = iframe.contentWindow.document;\n\t  iframeDocument.open();\n\t  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n\t  iframeDocument.close();\n\t  createDict = iframeDocument.F;\n\t  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n\t  return createDict();\n\t};\n\t\n\tmodule.exports = Object.create || function create(O, Properties){\n\t  var result;\n\t  if(O !== null){\n\t    Empty[PROTOTYPE] = anObject(O);\n\t    result = new Empty;\n\t    Empty[PROTOTYPE] = null;\n\t    // add \"__proto__\" for Object.getPrototypeOf polyfill\n\t    result[IE_PROTO] = O;\n\t  } else result = createDict();\n\t  return Properties === undefined ? result : dPs(result, Properties);\n\t};\n\n\n/***/ },\n/* 41 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\n\tvar $keys      = __webpack_require__(93)\n\t  , hiddenKeys = __webpack_require__(60).concat('length', 'prototype');\n\t\n\texports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n\t  return $keys(O, hiddenKeys);\n\t};\n\n/***/ },\n/* 42 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\n\tvar has         = __webpack_require__(8)\n\t  , toObject    = __webpack_require__(24)\n\t  , IE_PROTO    = __webpack_require__(68)('IE_PROTO')\n\t  , ObjectProto = Object.prototype;\n\t\n\tmodule.exports = Object.getPrototypeOf || function(O){\n\t  O = toObject(O);\n\t  if(has(O, IE_PROTO))return O[IE_PROTO];\n\t  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n\t    return O.constructor.prototype;\n\t  } return O instanceof Object ? ObjectProto : null;\n\t};\n\n/***/ },\n/* 43 */\n/***/ function(module, exports) {\n\n\texports.f = {}.propertyIsEnumerable;\n\n/***/ },\n/* 44 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(34)\n\t  , max       = Math.max\n\t  , min       = Math.min;\n\tmodule.exports = function(index, length){\n\t  index = toInteger(index);\n\t  return index < 0 ? max(index + length, 0) : min(index, length);\n\t};\n\n/***/ },\n/* 45 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.1.1 ToPrimitive(input [, PreferredType])\n\tvar isObject = __webpack_require__(5);\n\t// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n\t// and the second argument - flag - preferred type is a string\n\tmodule.exports = function(it, S){\n\t  if(!isObject(it))return it;\n\t  var fn, val;\n\t  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n\t  throw TypeError(\"Can't convert object to primitive value\");\n\t};\n\n/***/ },\n/* 46 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar global            = __webpack_require__(2)\n\t  , $export           = __webpack_require__(1)\n\t  , redefine          = __webpack_require__(20)\n\t  , redefineAll       = __webpack_require__(32)\n\t  , meta              = __webpack_require__(39)\n\t  , forOf             = __webpack_require__(48)\n\t  , anInstance        = __webpack_require__(27)\n\t  , isObject          = __webpack_require__(5)\n\t  , fails             = __webpack_require__(6)\n\t  , $iterDetect       = __webpack_require__(50)\n\t  , setToStringTag    = __webpack_require__(33)\n\t  , inheritIfRequired = __webpack_require__(125);\n\t\n\tmodule.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){\n\t  var Base  = global[NAME]\n\t    , C     = Base\n\t    , ADDER = IS_MAP ? 'set' : 'add'\n\t    , proto = C && C.prototype\n\t    , O     = {};\n\t  var fixMethod = function(KEY){\n\t    var fn = proto[KEY];\n\t    redefine(proto, KEY,\n\t      KEY == 'delete' ? function(a){\n\t        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n\t      } : KEY == 'has' ? function has(a){\n\t        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n\t      } : KEY == 'get' ? function get(a){\n\t        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n\t      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }\n\t        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }\n\t    );\n\t  };\n\t  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){\n\t    new C().entries().next();\n\t  }))){\n\t    // create collection constructor\n\t    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n\t    redefineAll(C.prototype, methods);\n\t    meta.NEED = true;\n\t  } else {\n\t    var instance             = new C\n\t      // early implementations not supports chaining\n\t      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance\n\t      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n\t      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })\n\t      // most early implementations doesn't supports iterables, most modern - not close it correctly\n\t      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new\n\t      // for early implementations -0 and +0 not the same\n\t      , BUGGY_ZERO = !IS_WEAK && fails(function(){\n\t        // V8 ~ Chromium 42- fails only with 5+ elements\n\t        var $instance = new C()\n\t          , index     = 5;\n\t        while(index--)$instance[ADDER](index, index);\n\t        return !$instance.has(-0);\n\t      });\n\t    if(!ACCEPT_ITERABLES){ \n\t      C = wrapper(function(target, iterable){\n\t        anInstance(target, C, NAME);\n\t        var that = inheritIfRequired(new Base, target, C);\n\t        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n\t        return that;\n\t      });\n\t      C.prototype = proto;\n\t      proto.constructor = C;\n\t    }\n\t    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){\n\t      fixMethod('delete');\n\t      fixMethod('has');\n\t      IS_MAP && fixMethod('get');\n\t    }\n\t    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);\n\t    // weak collections should not contains .clear method\n\t    if(IS_WEAK && proto.clear)delete proto.clear;\n\t  }\n\t\n\t  setToStringTag(C, NAME);\n\t\n\t  O[NAME] = C;\n\t  $export($export.G + $export.W + $export.F * (C != Base), O);\n\t\n\t  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);\n\t\n\t  return C;\n\t};\n\n/***/ },\n/* 47 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar hide     = __webpack_require__(11)\n\t  , redefine = __webpack_require__(20)\n\t  , fails    = __webpack_require__(6)\n\t  , defined  = __webpack_require__(17)\n\t  , wks      = __webpack_require__(4);\n\t\n\tmodule.exports = function(KEY, length, exec){\n\t  var SYMBOL   = wks(KEY)\n\t    , fns      = exec(defined, SYMBOL, ''[KEY])\n\t    , strfn    = fns[0]\n\t    , rxfn     = fns[1];\n\t  if(fails(function(){\n\t    var O = {};\n\t    O[SYMBOL] = function(){ return 7; };\n\t    return ''[KEY](O) != 7;\n\t  })){\n\t    redefine(String.prototype, KEY, strfn);\n\t    hide(RegExp.prototype, SYMBOL, length == 2\n\t      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n\t      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n\t      ? function(string, arg){ return rxfn.call(string, this, arg); }\n\t      // 21.2.5.6 RegExp.prototype[@@match](string)\n\t      // 21.2.5.9 RegExp.prototype[@@search](string)\n\t      : function(string){ return rxfn.call(string, this); }\n\t    );\n\t  }\n\t};\n\n/***/ },\n/* 48 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ctx         = __webpack_require__(14)\n\t  , call        = __webpack_require__(88)\n\t  , isArrayIter = __webpack_require__(63)\n\t  , anObject    = __webpack_require__(3)\n\t  , toLength    = __webpack_require__(10)\n\t  , getIterFn   = __webpack_require__(73)\n\t  , BREAK       = {}\n\t  , RETURN      = {};\n\tvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n\t  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)\n\t    , f      = ctx(fn, that, entries ? 2 : 1)\n\t    , index  = 0\n\t    , length, step, iterator, result;\n\t  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n\t  // fast case for arrays with default iterator\n\t  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n\t    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n\t    if(result === BREAK || result === RETURN)return result;\n\t  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n\t    result = call(iterator, f, step.value, entries);\n\t    if(result === BREAK || result === RETURN)return result;\n\t  }\n\t};\n\texports.BREAK  = BREAK;\n\texports.RETURN = RETURN;\n\n/***/ },\n/* 49 */\n/***/ function(module, exports) {\n\n\t// fast apply, http://jsperf.lnkit.com/fast-apply/5\n\tmodule.exports = function(fn, args, that){\n\t  var un = that === undefined;\n\t  switch(args.length){\n\t    case 0: return un ? fn()\n\t                      : fn.call(that);\n\t    case 1: return un ? fn(args[0])\n\t                      : fn.call(that, args[0]);\n\t    case 2: return un ? fn(args[0], args[1])\n\t                      : fn.call(that, args[0], args[1]);\n\t    case 3: return un ? fn(args[0], args[1], args[2])\n\t                      : fn.call(that, args[0], args[1], args[2]);\n\t    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n\t                      : fn.call(that, args[0], args[1], args[2], args[3]);\n\t  } return              fn.apply(that, args);\n\t};\n\n/***/ },\n/* 50 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ITERATOR     = __webpack_require__(4)('iterator')\n\t  , SAFE_CLOSING = false;\n\t\n\ttry {\n\t  var riter = [7][ITERATOR]();\n\t  riter['return'] = function(){ SAFE_CLOSING = true; };\n\t  Array.from(riter, function(){ throw 2; });\n\t} catch(e){ /* empty */ }\n\t\n\tmodule.exports = function(exec, skipClosing){\n\t  if(!skipClosing && !SAFE_CLOSING)return false;\n\t  var safe = false;\n\t  try {\n\t    var arr  = [7]\n\t      , iter = arr[ITERATOR]();\n\t    iter.next = function(){ return {done: safe = true}; };\n\t    arr[ITERATOR] = function(){ return iter; };\n\t    exec(arr);\n\t  } catch(e){ /* empty */ }\n\t  return safe;\n\t};\n\n/***/ },\n/* 51 */\n/***/ function(module, exports) {\n\n\texports.f = Object.getOwnPropertySymbols;\n\n/***/ },\n/* 52 */\n/***/ function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\tvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\t\n\tvar scheduleDrain;\n\t\n\t{\n\t  if (Mutation) {\n\t    var called = 0;\n\t    var observer = new Mutation(nextTick);\n\t    var element = global.document.createTextNode('');\n\t    observer.observe(element, {\n\t      characterData: true\n\t    });\n\t    scheduleDrain = function () {\n\t      element.data = (called = ++called % 2);\n\t    };\n\t  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n\t    var channel = new global.MessageChannel();\n\t    channel.port1.onmessage = nextTick;\n\t    scheduleDrain = function () {\n\t      channel.port2.postMessage(0);\n\t    };\n\t  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n\t    scheduleDrain = function () {\n\t\n\t      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n\t      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n\t      var scriptEl = global.document.createElement('script');\n\t      scriptEl.onreadystatechange = function () {\n\t        nextTick();\n\t\n\t        scriptEl.onreadystatechange = null;\n\t        scriptEl.parentNode.removeChild(scriptEl);\n\t        scriptEl = null;\n\t      };\n\t      global.document.documentElement.appendChild(scriptEl);\n\t    };\n\t  } else {\n\t    scheduleDrain = function () {\n\t      setTimeout(nextTick, 0);\n\t    };\n\t  }\n\t}\n\t\n\tvar draining;\n\tvar queue = [];\n\t//named nextTick for less confusing stack traces\n\tfunction nextTick() {\n\t  draining = true;\n\t  var i, oldQueue;\n\t  var len = queue.length;\n\t  while (len) {\n\t    oldQueue = queue;\n\t    queue = [];\n\t    i = -1;\n\t    while (++i < len) {\n\t      oldQueue[i]();\n\t    }\n\t    len = queue.length;\n\t  }\n\t  draining = false;\n\t}\n\t\n\tmodule.exports = immediate;\n\tfunction immediate(task) {\n\t  if (queue.push(task) === 1 && !draining) {\n\t    scheduleDrain();\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 53 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\n\tvar MAGNITUDE_DIGITS = 3; // ditto\n\tvar SEP = ''; // set to '_' for easier debugging \n\t\n\tvar utils = __webpack_require__(223);\n\t\n\texports.collate = function (a, b) {\n\t\n\t  if (a === b) {\n\t    return 0;\n\t  }\n\t\n\t  a = exports.normalizeKey(a);\n\t  b = exports.normalizeKey(b);\n\t\n\t  var ai = collationIndex(a);\n\t  var bi = collationIndex(b);\n\t  if ((ai - bi) !== 0) {\n\t    return ai - bi;\n\t  }\n\t  if (a === null) {\n\t    return 0;\n\t  }\n\t  switch (typeof a) {\n\t    case 'number':\n\t      return a - b;\n\t    case 'boolean':\n\t      return a === b ? 0 : (a < b ? -1 : 1);\n\t    case 'string':\n\t      return stringCollate(a, b);\n\t  }\n\t  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n\t};\n\t\n\t// couch considers null/NaN/Infinity/-Infinity === undefined,\n\t// for the purposes of mapreduce indexes. also, dates get stringified.\n\texports.normalizeKey = function (key) {\n\t  switch (typeof key) {\n\t    case 'undefined':\n\t      return null;\n\t    case 'number':\n\t      if (key === Infinity || key === -Infinity || isNaN(key)) {\n\t        return null;\n\t      }\n\t      return key;\n\t    case 'object':\n\t      var origKey = key;\n\t      if (Array.isArray(key)) {\n\t        var len = key.length;\n\t        key = new Array(len);\n\t        for (var i = 0; i < len; i++) {\n\t          key[i] = exports.normalizeKey(origKey[i]);\n\t        }\n\t      } else if (key instanceof Date) {\n\t        return key.toJSON();\n\t      } else if (key !== null) { // generic object\n\t        key = {};\n\t        for (var k in origKey) {\n\t          if (origKey.hasOwnProperty(k)) {\n\t            var val = origKey[k];\n\t            if (typeof val !== 'undefined') {\n\t              key[k] = exports.normalizeKey(val);\n\t            }\n\t          }\n\t        }\n\t      }\n\t  }\n\t  return key;\n\t};\n\t\n\tfunction indexify(key) {\n\t  if (key !== null) {\n\t    switch (typeof key) {\n\t      case 'boolean':\n\t        return key ? 1 : 0;\n\t      case 'number':\n\t        return numToIndexableString(key);\n\t      case 'string':\n\t        // We've to be sure that key does not contain \\u0000\n\t        // Do order-preserving replacements:\n\t        // 0 -> 1, 1\n\t        // 1 -> 1, 2\n\t        // 2 -> 2, 2\n\t        return key\n\t          .replace(/\\u0002/g, '\\u0002\\u0002')\n\t          .replace(/\\u0001/g, '\\u0001\\u0002')\n\t          .replace(/\\u0000/g, '\\u0001\\u0001');\n\t      case 'object':\n\t        var isArray = Array.isArray(key);\n\t        var arr = isArray ? key : Object.keys(key);\n\t        var i = -1;\n\t        var len = arr.length;\n\t        var result = '';\n\t        if (isArray) {\n\t          while (++i < len) {\n\t            result += exports.toIndexableString(arr[i]);\n\t          }\n\t        } else {\n\t          while (++i < len) {\n\t            var objKey = arr[i];\n\t            result += exports.toIndexableString(objKey) +\n\t                exports.toIndexableString(key[objKey]);\n\t          }\n\t        }\n\t        return result;\n\t    }\n\t  }\n\t  return '';\n\t}\n\t\n\t// convert the given key to a string that would be appropriate\n\t// for lexical sorting, e.g. within a database, where the\n\t// sorting is the same given by the collate() function.\n\texports.toIndexableString = function (key) {\n\t  var zero = '\\u0000';\n\t  key = exports.normalizeKey(key);\n\t  return collationIndex(key) + SEP + indexify(key) + zero;\n\t};\n\t\n\tfunction parseNumber(str, i) {\n\t  var originalIdx = i;\n\t  var num;\n\t  var zero = str[i] === '1';\n\t  if (zero) {\n\t    num = 0;\n\t    i++;\n\t  } else {\n\t    var neg = str[i] === '0';\n\t    i++;\n\t    var numAsString = '';\n\t    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n\t    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n\t    if (neg) {\n\t      magnitude = -magnitude;\n\t    }\n\t    i += MAGNITUDE_DIGITS;\n\t    while (true) {\n\t      var ch = str[i];\n\t      if (ch === '\\u0000') {\n\t        break;\n\t      } else {\n\t        numAsString += ch;\n\t      }\n\t      i++;\n\t    }\n\t    numAsString = numAsString.split('.');\n\t    if (numAsString.length === 1) {\n\t      num = parseInt(numAsString, 10);\n\t    } else {\n\t      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n\t    }\n\t    if (neg) {\n\t      num = num - 10;\n\t    }\n\t    if (magnitude !== 0) {\n\t      // parseFloat is more reliable than pow due to rounding errors\n\t      // e.g. Number.MAX_VALUE would return Infinity if we did\n\t      // num * Math.pow(10, magnitude);\n\t      num = parseFloat(num + 'e' + magnitude);\n\t    }\n\t  }\n\t  return {num: num, length : i - originalIdx};\n\t}\n\t\n\t// move up the stack while parsing\n\t// this function moved outside of parseIndexableString for performance\n\tfunction pop(stack, metaStack) {\n\t  var obj = stack.pop();\n\t\n\t  if (metaStack.length) {\n\t    var lastMetaElement = metaStack[metaStack.length - 1];\n\t    if (obj === lastMetaElement.element) {\n\t      // popping a meta-element, e.g. an object whose value is another object\n\t      metaStack.pop();\n\t      lastMetaElement = metaStack[metaStack.length - 1];\n\t    }\n\t    var element = lastMetaElement.element;\n\t    var lastElementIndex = lastMetaElement.index;\n\t    if (Array.isArray(element)) {\n\t      element.push(obj);\n\t    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t      var key = stack.pop();\n\t      element[key] = obj;\n\t    } else {\n\t      stack.push(obj); // obj with key only\n\t    }\n\t  }\n\t}\n\t\n\texports.parseIndexableString = function (str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t\n\t  while (true) {\n\t    var collationIndex = str[i++];\n\t    if (collationIndex === '\\u0000') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case '1':\n\t        stack.push(null);\n\t        break;\n\t      case '2':\n\t        stack.push(str[i] === '1');\n\t        i++;\n\t        break;\n\t      case '3':\n\t        var parsedNum = parseNumber(str, i);\n\t        stack.push(parsedNum.num);\n\t        i += parsedNum.length;\n\t        break;\n\t      case '4':\n\t        var parsedStr = '';\n\t        while (true) {\n\t          var ch = str[i];\n\t          if (ch === '\\u0000') {\n\t            break;\n\t          }\n\t          parsedStr += ch;\n\t          i++;\n\t        }\n\t        // perform the reverse of the order-preserving replacement\n\t        // algorithm (see above)\n\t        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n\t          .replace(/\\u0001\\u0002/g, '\\u0001')\n\t          .replace(/\\u0002\\u0002/g, '\\u0002');\n\t        stack.push(parsedStr);\n\t        break;\n\t      case '5':\n\t        var arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '6':\n\t        var objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      default:\n\t        throw new Error(\n\t          'bad collationIndex or unexpectedly reached end of input: ' + collationIndex);\n\t    }\n\t  }\n\t};\n\t\n\tfunction arrayCollate(a, b) {\n\t  var len = Math.min(a.length, b.length);\n\t  for (var i = 0; i < len; i++) {\n\t    var sort = exports.collate(a[i], b[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t  }\n\t  return (a.length === b.length) ? 0 :\n\t    (a.length > b.length) ? 1 : -1;\n\t}\n\tfunction stringCollate(a, b) {\n\t  // See: https://github.com/daleharvey/pouchdb/issues/40\n\t  // This is incompatible with the CouchDB implementation, but its the\n\t  // best we can do for now\n\t  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n\t}\n\tfunction objectCollate(a, b) {\n\t  var ak = Object.keys(a), bk = Object.keys(b);\n\t  var len = Math.min(ak.length, bk.length);\n\t  for (var i = 0; i < len; i++) {\n\t    // First sort the keys\n\t    var sort = exports.collate(ak[i], bk[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t    // if the keys are equal sort the values\n\t    sort = exports.collate(a[ak[i]], b[bk[i]]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t\n\t  }\n\t  return (ak.length === bk.length) ? 0 :\n\t    (ak.length > bk.length) ? 1 : -1;\n\t}\n\t// The collation is defined by erlangs ordered terms\n\t// the atoms null, true, false come first, then numbers, strings,\n\t// arrays, then objects\n\t// null/undefined/NaN/Infinity/-Infinity are all considered null\n\tfunction collationIndex(x) {\n\t  var id = ['boolean', 'number', 'string', 'object'];\n\t  var idx = id.indexOf(typeof x);\n\t  //false if -1 otherwise true, but fast!!!!1\n\t  if (~idx) {\n\t    if (x === null) {\n\t      return 1;\n\t    }\n\t    if (Array.isArray(x)) {\n\t      return 5;\n\t    }\n\t    return idx < 3 ? (idx + 2) : (idx + 3);\n\t  }\n\t  if (Array.isArray(x)) {\n\t    return 5;\n\t  }\n\t}\n\t\n\t// conversion:\n\t// x yyy zz...zz\n\t// x = 0 for negative, 1 for 0, 2 for positive\n\t// y = exponent (for negative numbers negated) moved so that it's >= 0\n\t// z = mantisse\n\tfunction numToIndexableString(num) {\n\t\n\t  if (num === 0) {\n\t    return '1';\n\t  }\n\t\n\t  // convert number to exponential format for easier and\n\t  // more succinct string sorting\n\t  var expFormat = num.toExponential().split(/e\\+?/);\n\t  var magnitude = parseInt(expFormat[1], 10);\n\t\n\t  var neg = num < 0;\n\t\n\t  var result = neg ? '0' : '2';\n\t\n\t  // first sort by magnitude\n\t  // it's easier if all magnitudes are positive\n\t  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n\t  var magString = utils.padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\t\n\t  result += SEP + magString;\n\t\n\t  // then sort by the factor\n\t  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n\t  if (neg) { // for negative reverse ordering\n\t    factor = 10 - factor;\n\t  }\n\t\n\t  var factorStr = factor.toFixed(20);\n\t\n\t  // strip zeros from the end\n\t  factorStr = factorStr.replace(/\\.?0+$/, '');\n\t\n\t  result += SEP + factorStr;\n\t\n\t  return result;\n\t}\n\n\n/***/ },\n/* 54 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.AppToken = exports.AccessToken = exports.Client = exports.StateKey = exports.CredsKey = undefined;\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global btoa */\n\t\n\t\n\texports.client = client;\n\texports.registerClient = registerClient;\n\texports.updateClient = updateClient;\n\texports.unregisterClient = unregisterClient;\n\texports.getClient = getClient;\n\texports.getAuthCodeURL = getAuthCodeURL;\n\texports.getAccessToken = getAccessToken;\n\texports.refreshToken = refreshToken;\n\texports.oauthFlow = oauthFlow;\n\t\n\tvar _utils = __webpack_require__(22);\n\t\n\tvar _fetch = __webpack_require__(13);\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar StateSize = 16;\n\t\n\tvar CredsKey = exports.CredsKey = 'creds';\n\tvar StateKey = exports.StateKey = 'state';\n\t\n\tvar Client = exports.Client = function () {\n\t  function Client(opts) {\n\t    _classCallCheck(this, Client);\n\t\n\t    this.clientID = opts.clientID || opts.client_id || '';\n\t    this.clientSecret = opts.clientSecret || opts.client_secret || '';\n\t    this.registrationAccessToken = opts.registrationAccessToken || opts.registration_access_token || '';\n\t\n\t    if (opts.redirect_uris) {\n\t      this.redirectURI = opts.redirect_uris[0] || '';\n\t    } else {\n\t      this.redirectURI = opts.redirectURI || '';\n\t    }\n\t\n\t    this.softwareID = opts.softwareID || opts.software_id || '';\n\t    this.softwareVersion = opts.softwareVersion || opts.software_version || '';\n\t    this.clientName = opts.clientName || opts.client_name || '';\n\t    this.clientKind = opts.clientKind || opts.client_kind || '';\n\t    this.clientURI = opts.clientURI || opts.client_uri || '';\n\t\n\t    this.logoURI = opts.logoURI || opts.logo_uri || '';\n\t    this.policyURI = opts.policyURI || opts.policy_uri || '';\n\t\n\t    if (!this.registrationAccessToken) {\n\t      if (this.redirectURI === '') {\n\t        throw new Error('Missing redirectURI field');\n\t      }\n\t      if (this.softwareID === '') {\n\t        throw new Error('Missing softwareID field');\n\t      }\n\t      if (this.clientName === '') {\n\t        throw new Error('Missing clientName field');\n\t      }\n\t    }\n\t  }\n\t\n\t  _createClass(Client, [{\n\t    key: 'isRegistered',\n\t    value: function isRegistered() {\n\t      return this.clientID !== '';\n\t    }\n\t  }, {\n\t    key: 'toRegisterJSON',\n\t    value: function toRegisterJSON() {\n\t      return {\n\t        redirect_uris: [this.redirectURI],\n\t        software_id: this.softwareID,\n\t        software_version: this.softwareVersion,\n\t        client_name: this.clientName,\n\t        client_kind: this.clientKind,\n\t        client_uri: this.clientURI,\n\t        logo_uri: this.logoURI,\n\t        policy_uri: this.policyURI\n\t      };\n\t    }\n\t  }, {\n\t    key: 'toAuthHeader',\n\t    value: function toAuthHeader() {\n\t      return 'Bearer ' + this.registrationAccessToken;\n\t    }\n\t  }]);\n\t\n\t  return Client;\n\t}();\n\t\n\tvar AccessToken = exports.AccessToken = function () {\n\t  function AccessToken(opts) {\n\t    _classCallCheck(this, AccessToken);\n\t\n\t    this.tokenType = opts.tokenType || opts.token_type;\n\t    this.accessToken = opts.accessToken || opts.access_token;\n\t    this.refreshToken = opts.refreshToken || opts.refresh_token;\n\t    this.scope = opts.scope;\n\t  }\n\t\n\t  _createClass(AccessToken, [{\n\t    key: 'toAuthHeader',\n\t    value: function toAuthHeader() {\n\t      return 'Bearer ' + this.accessToken;\n\t    }\n\t  }, {\n\t    key: 'toBasicAuth',\n\t    value: function toBasicAuth() {\n\t      return 'user:' + this.accessToken + '@';\n\t    }\n\t  }]);\n\t\n\t  return AccessToken;\n\t}();\n\t\n\tvar AppToken = exports.AppToken = function () {\n\t  function AppToken(opts) {\n\t    _classCallCheck(this, AppToken);\n\t\n\t    this.token = opts.token || '';\n\t  }\n\t\n\t  _createClass(AppToken, [{\n\t    key: 'toAuthHeader',\n\t    value: function toAuthHeader() {\n\t      return 'Bearer ' + this.token;\n\t    }\n\t  }, {\n\t    key: 'toBasicAuth',\n\t    value: function toBasicAuth() {\n\t      return 'user:' + this.token + '@';\n\t    }\n\t  }]);\n\t\n\t  return AppToken;\n\t}();\n\t\n\tfunction client(cozy, clientParams) {\n\t  if (!clientParams) {\n\t    clientParams = cozy._clientParams;\n\t  }\n\t  if (clientParams instanceof Client) {\n\t    return clientParams;\n\t  }\n\t  return new Client(clientParams);\n\t}\n\t\n\tfunction registerClient(cozy, clientParams) {\n\t  var cli = client(cozy, clientParams);\n\t  if (cli.isRegistered()) {\n\t    return Promise.reject(new Error('Client already registered'));\n\t  }\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/auth/register', cli.toRegisterJSON(), {\n\t    disableAuth: true\n\t  }).then(function (data) {\n\t    return new Client(data);\n\t  });\n\t}\n\t\n\tfunction updateClient(cozy, clientParams) {\n\t  var resetSecret = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\t\n\t  var cli = client(cozy, clientParams);\n\t  if (!cli.isRegistered()) {\n\t    return Promise.reject(new Error('Client not registered'));\n\t  }\n\t  var data = cli.toRegisterJSON();\n\t  data.client_id = cli.clientID;\n\t  if (resetSecret) data.client_secret = cli.clientSecret;\n\t\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'PUT', '/auth/register/' + cli.clientID, data, {\n\t    manualAuthCredentials: {\n\t      token: cli\n\t    }\n\t  }).then(function (data) {\n\t    return createClient(data, cli);\n\t  });\n\t}\n\t\n\tfunction unregisterClient(cozy, clientParams) {\n\t  var cli = client(cozy, clientParams);\n\t  if (!cli.isRegistered()) {\n\t    return Promise.reject(new Error('Client not registered'));\n\t  }\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', '/auth/register/' + cli.clientID, null, {\n\t    manualAuthCredentials: {\n\t      token: cli\n\t    }\n\t  });\n\t}\n\t\n\t// getClient will retrive the registered client informations from the server.\n\tfunction getClient(cozy, clientParams) {\n\t  var cli = client(cozy, clientParams);\n\t  if (!cli.isRegistered()) {\n\t    return Promise.reject(new Error('Client not registered'));\n\t  }\n\t  if ((0, _utils.isOffline)()) {\n\t    return Promise.resolve(cli);\n\t  }\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/auth/register/' + cli.clientID, null, {\n\t    manualAuthCredentials: {\n\t      token: cli\n\t    }\n\t  }).then(function (data) {\n\t    return createClient(data, cli);\n\t  }).catch(function (err) {\n\t    // If we fall into an error while fetching the client (because of a\n\t    // bad connectivity for instance), we do not bail the whole process\n\t    // since the client should be able to continue with the persisted\n\t    // client and token.\n\t    //\n\t    // If it is an explicit Unauthorized error though, we bail, clear th\n\t    // cache and retry.\n\t    if (_fetch.FetchError.isUnauthorized(err) || _fetch.FetchError.isNotFound(err)) {\n\t      throw new Error('Client has been revoked');\n\t    }\n\t    throw err;\n\t  });\n\t}\n\t\n\t// createClient returns a new Client instance given on object containing the\n\t// data of the client, from the API, and an old instance of the client.\n\tfunction createClient(data, oldClient) {\n\t  var newClient = new Client(data);\n\t  // we need to keep track of the registrationAccessToken since it is send\n\t  // only on registration. The GET /auth/register/:client-id endpoint does\n\t  // not return this token.\n\t  var shouldPassRegistration = !!oldClient && oldClient.registrationAccessToken !== '' && newClient.registrationAccessToken === '';\n\t  if (shouldPassRegistration) {\n\t    newClient.registrationAccessToken = oldClient.registrationAccessToken;\n\t  }\n\t  return newClient;\n\t}\n\t\n\t// getAuthCodeURL returns a pair {authURL,state} given a registered client. The\n\t// state should be stored in order to be checked against on the user validation\n\t// phase.\n\tfunction getAuthCodeURL(cozy, client) {\n\t  var scopes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t\n\t  if (!(client instanceof Client)) {\n\t    client = new Client(client);\n\t  }\n\t  if (!client.isRegistered()) {\n\t    throw new Error('Client not registered');\n\t  }\n\t  var state = generateRandomState();\n\t  var query = {\n\t    'client_id': client.clientID,\n\t    'redirect_uri': client.redirectURI,\n\t    'state': state,\n\t    'response_type': 'code',\n\t    'scope': scopes.join(' ')\n\t  };\n\t  return {\n\t    url: cozy._url + ('/auth/authorize?' + (0, _utils.encodeQuery)(query)),\n\t    state: state\n\t  };\n\t}\n\t\n\t// getAccessToken perform a request on the access_token entrypoint with the\n\t// authorization_code grant type in order to generate a new access token for a\n\t// newly registered client.\n\t//\n\t// This method extracts the access code and state from the given URL. By\n\t// default it uses window.location.href. Also, it checks the given state with\n\t// the one specified in the URL query parameter to prevent CSRF attacks.\n\tfunction getAccessToken(cozy, client, state) {\n\t  var pageURL = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\t\n\t  if (!state) {\n\t    return Promise.reject(new Error('Missing state value'));\n\t  }\n\t  var grantQueries = getGrantCodeFromPageURL(pageURL);\n\t  if (grantQueries === null) {\n\t    return Promise.reject(new Error('Missing states from current URL'));\n\t  }\n\t  if (state !== grantQueries.state) {\n\t    return Promise.reject(new Error('Given state does not match url query state'));\n\t  }\n\t  return retrieveToken(cozy, client, null, {\n\t    'grant_type': 'authorization_code',\n\t    'code': grantQueries.code\n\t  });\n\t}\n\t\n\t// refreshToken perform a request on the access_token entrypoint with the\n\t// refresh_token grant type in order to refresh the given token.\n\tfunction refreshToken(cozy, client, token) {\n\t  return retrieveToken(cozy, client, token, {\n\t    'grant_type': 'refresh_token',\n\t    'refresh_token': token.refreshToken\n\t  });\n\t}\n\t\n\t// oauthFlow performs the stateful registration and access granting of an OAuth\n\t// client.\n\tfunction oauthFlow(cozy, storage, clientParams, onRegistered) {\n\t  var ignoreCachedCredentials = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\t\n\t  if (ignoreCachedCredentials) {\n\t    return storage.clear().then(function () {\n\t      return oauthFlow(cozy, storage, clientParams, onRegistered, false);\n\t    });\n\t  }\n\t\n\t  var tryCount = 0;\n\t\n\t  function clearAndRetry(err) {\n\t    if (tryCount++ > 0) {\n\t      throw err;\n\t    }\n\t    return storage.clear().then(function () {\n\t      return oauthFlow(cozy, storage, clientParams, onRegistered);\n\t    });\n\t  }\n\t\n\t  function registerNewClient() {\n\t    return storage.clear().then(function () {\n\t      return registerClient(cozy, clientParams);\n\t    }).then(function (client) {\n\t      var _getAuthCodeURL = getAuthCodeURL(cozy, client, clientParams.scopes),\n\t          url = _getAuthCodeURL.url,\n\t          state = _getAuthCodeURL.state;\n\t\n\t      return storage.save(StateKey, { client: client, url: url, state: state });\n\t    });\n\t  }\n\t\n\t  return Promise.all([storage.load(CredsKey), storage.load(StateKey)]).then(function (_ref) {\n\t    var _ref2 = _slicedToArray(_ref, 2),\n\t        credentials = _ref2[0],\n\t        storedState = _ref2[1];\n\t\n\t    // If credentials are cached we re-fetch the registered client with the\n\t    // said token. Fetching the client, if the token is outdated we should try\n\t    // the token is refreshed.\n\t    if (credentials) {\n\t      var oldClient = void 0,\n\t          _token = void 0;\n\t      try {\n\t        oldClient = new Client(credentials.client);\n\t        _token = new AccessToken(credentials.token);\n\t      } catch (err) {\n\t        // bad cache, we should clear and retry the process\n\t        return clearAndRetry(err);\n\t      }\n\t      return getClient(cozy, oldClient).then(function (client) {\n\t        return { client: client, token: _token };\n\t      }).catch(function (err) {\n\t        // If we fall into an error while fetching the client (because of a\n\t        // bad connectivity for instance), we do not bail the whole process\n\t        // since the client should be able to continue with the persisted\n\t        // client and token.\n\t        //\n\t        // If it is an explicit Unauthorized error though, we bail, clear th\n\t        // cache and retry.\n\t        if (_fetch.FetchError.isUnauthorized(err) || _fetch.FetchError.isNotFound(err)) {\n\t          throw new Error('Client has been revoked');\n\t        }\n\t        return { client: oldClient, token: _token };\n\t      });\n\t    }\n\t\n\t    // Otherwise register a new client if necessary (ie. no client is stored)\n\t    // and call the onRegistered callback to wait for the user to grant the\n\t    // access. Finally fetches to access token on success.\n\t    var statePromise = void 0;\n\t    if (!storedState) {\n\t      statePromise = registerNewClient();\n\t    } else {\n\t      statePromise = Promise.resolve(storedState);\n\t    }\n\t\n\t    var client = void 0,\n\t        state = void 0,\n\t        token = void 0;\n\t    return statePromise.then(function (data) {\n\t      client = data.client;\n\t      state = data.state;\n\t      return Promise.resolve(onRegistered(client, data.url));\n\t    }).then(function (pageURL) {\n\t      return getAccessToken(cozy, client, state, pageURL);\n\t    }).then(function (t) {\n\t      token = t;\n\t    }).then(function () {\n\t      return storage.delete(StateKey);\n\t    }).then(function () {\n\t      return { client: client, token: token };\n\t    });\n\t  }).then(function (creds) {\n\t    return storage.save(CredsKey, creds);\n\t  }, function (err) {\n\t    if (_fetch.FetchError.isUnauthorized(err)) {\n\t      return clearAndRetry(err);\n\t    } else {\n\t      throw err;\n\t    }\n\t  });\n\t}\n\t\n\t// retrieveToken perform a request on the access_token entrypoint in order to\n\t// fetch a token.\n\tfunction retrieveToken(cozy, client, token, query) {\n\t  if (!(client instanceof Client)) {\n\t    client = new Client(client);\n\t  }\n\t  if (!client.isRegistered()) {\n\t    return Promise.reject(new Error('Client not registered'));\n\t  }\n\t  var body = (0, _utils.encodeQuery)(Object.assign({}, query, {\n\t    'client_id': client.clientID,\n\t    'client_secret': client.clientSecret\n\t  }));\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/auth/access_token', body, {\n\t    disableAuth: token === null,\n\t    dontRetry: true,\n\t    manualAuthCredentials: { client: client, token: token },\n\t    headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n\t  }).then(function (data) {\n\t    data.refreshToken = data.refreshToken || query.refresh_token;\n\t    return new AccessToken(data);\n\t  });\n\t}\n\t\n\t// getGrantCodeFromPageURL extract the state and access_code query parameters\n\t// from the given url\n\tfunction getGrantCodeFromPageURL() {\n\t  var pageURL = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t\n\t  if (pageURL === '' && typeof window !== 'undefined') {\n\t    pageURL = window.location.href;\n\t  }\n\t  var queries = (0, _utils.decodeQuery)(pageURL);\n\t  if (!queries.hasOwnProperty('state')) {\n\t    return null;\n\t  }\n\t  return {\n\t    state: queries['state'],\n\t    code: queries['access_code']\n\t  };\n\t}\n\t\n\t// generateRandomState will try to generate a 128bits random value from a secure\n\t// pseudo random generator. It will fallback on Math.random if it cannot find\n\t// such generator.\n\tfunction generateRandomState() {\n\t  var buffer = void 0;\n\t  if (typeof window !== 'undefined' && typeof window.crypto !== 'undefined' && typeof window.crypto.getRandomValues === 'function') {\n\t    buffer = new Uint8Array(StateSize);\n\t    window.crypto.getRandomValues(buffer);\n\t  } else {\n\t    try {\n\t      buffer = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module \\\"crypto\\\"\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())).randomBytes(StateSize);\n\t    } catch (e) {}\n\t  }\n\t  if (!buffer) {\n\t    buffer = new Array(StateSize);\n\t    for (var i = 0; i < buffer.length; i++) {\n\t      buffer[i] = Math.floor(Math.random() * 255);\n\t    }\n\t  }\n\t  return btoa(String.fromCharCode.apply(null, buffer)).replace(/=+$/, '').replace(/\\//g, '_').replace(/\\+/g, '-');\n\t}\n\n/***/ },\n/* 55 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n\t'use strict';\n\tvar toObject = __webpack_require__(24)\n\t  , toIndex  = __webpack_require__(44)\n\t  , toLength = __webpack_require__(10);\n\tmodule.exports = function fill(value /*, start = 0, end = @length */){\n\t  var O      = toObject(this)\n\t    , length = toLength(O.length)\n\t    , aLen   = arguments.length\n\t    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)\n\t    , end    = aLen > 2 ? arguments[2] : undefined\n\t    , endPos = end === undefined ? length : toIndex(end, length);\n\t  while(endPos > index)O[index++] = value;\n\t  return O;\n\t};\n\n/***/ },\n/* 56 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// false -> Array#indexOf\n\t// true  -> Array#includes\n\tvar toIObject = __webpack_require__(12)\n\t  , toLength  = __webpack_require__(10)\n\t  , toIndex   = __webpack_require__(44);\n\tmodule.exports = function(IS_INCLUDES){\n\t  return function($this, el, fromIndex){\n\t    var O      = toIObject($this)\n\t      , length = toLength(O.length)\n\t      , index  = toIndex(fromIndex, length)\n\t      , value;\n\t    // Array#includes uses SameValueZero equality algorithm\n\t    if(IS_INCLUDES && el != el)while(length > index){\n\t      value = O[index++];\n\t      if(value != value)return true;\n\t    // Array#toIndex ignores holes, Array#includes - not\n\t    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n\t      if(O[index] === el)return IS_INCLUDES || index || 0;\n\t    } return !IS_INCLUDES && -1;\n\t  };\n\t};\n\n/***/ },\n/* 57 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// getting tag from 19.1.3.6 Object.prototype.toString()\n\tvar cof = __webpack_require__(28)\n\t  , TAG = __webpack_require__(4)('toStringTag')\n\t  // ES3 wrong here\n\t  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\t\n\t// fallback for IE11 Script Access Denied error\n\tvar tryGet = function(it, key){\n\t  try {\n\t    return it[key];\n\t  } catch(e){ /* empty */ }\n\t};\n\t\n\tmodule.exports = function(it){\n\t  var O, T, B;\n\t  return it === undefined ? 'Undefined' : it === null ? 'Null'\n\t    // @@toStringTag case\n\t    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n\t    // builtinTag case\n\t    : ARG ? cof(O)\n\t    // ES3 arguments fallback\n\t    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n\t};\n\n/***/ },\n/* 58 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $defineProperty = __webpack_require__(7)\n\t  , createDesc      = __webpack_require__(19);\n\t\n\tmodule.exports = function(object, index, value){\n\t  if(index in object)$defineProperty.f(object, index, createDesc(0, value));\n\t  else object[index] = value;\n\t};\n\n/***/ },\n/* 59 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(5)\n\t  , document = __webpack_require__(2).document\n\t  // in old IE typeof document.createElement is 'object'\n\t  , is = isObject(document) && isObject(document.createElement);\n\tmodule.exports = function(it){\n\t  return is ? document.createElement(it) : {};\n\t};\n\n/***/ },\n/* 60 */\n/***/ function(module, exports) {\n\n\t// IE 8- don't enum bug keys\n\tmodule.exports = (\n\t  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n\t).split(',');\n\n/***/ },\n/* 61 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar MATCH = __webpack_require__(4)('match');\n\tmodule.exports = function(KEY){\n\t  var re = /./;\n\t  try {\n\t    '/./'[KEY](re);\n\t  } catch(e){\n\t    try {\n\t      re[MATCH] = false;\n\t      return !'/./'[KEY](re);\n\t    } catch(f){ /* empty */ }\n\t  } return true;\n\t};\n\n/***/ },\n/* 62 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for non-array-like ES3 and non-enumerable old V8 strings\n\tvar cof = __webpack_require__(28);\n\tmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n\t  return cof(it) == 'String' ? it.split('') : Object(it);\n\t};\n\n/***/ },\n/* 63 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// check on default Array iterator\n\tvar Iterators  = __webpack_require__(29)\n\t  , ITERATOR   = __webpack_require__(4)('iterator')\n\t  , ArrayProto = Array.prototype;\n\t\n\tmodule.exports = function(it){\n\t  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n\t};\n\n/***/ },\n/* 64 */\n/***/ function(module, exports) {\n\n\t// 20.2.2.14 Math.expm1(x)\n\tvar $expm1 = Math.expm1;\n\tmodule.exports = (!$expm1\n\t  // Old FF bug\n\t  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168\n\t  // Tor Browser bug\n\t  || $expm1(-2e-17) != -2e-17\n\t) ? function expm1(x){\n\t  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;\n\t} : $expm1;\n\n/***/ },\n/* 65 */\n/***/ function(module, exports) {\n\n\t// 20.2.2.28 Math.sign(x)\n\tmodule.exports = Math.sign || function sign(x){\n\t  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n\t};\n\n/***/ },\n/* 66 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Works with __proto__ only. Old v8 can't work with null proto objects.\n\t/* eslint-disable no-proto */\n\tvar isObject = __webpack_require__(5)\n\t  , anObject = __webpack_require__(3);\n\tvar check = function(O, proto){\n\t  anObject(O);\n\t  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n\t};\n\tmodule.exports = {\n\t  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n\t    function(test, buggy, set){\n\t      try {\n\t        set = __webpack_require__(14)(Function.call, __webpack_require__(18).f(Object.prototype, '__proto__').set, 2);\n\t        set(test, []);\n\t        buggy = !(test instanceof Array);\n\t      } catch(e){ buggy = true; }\n\t      return function setPrototypeOf(O, proto){\n\t        check(O, proto);\n\t        if(buggy)O.__proto__ = proto;\n\t        else set(O, proto);\n\t        return O;\n\t      };\n\t    }({}, false) : undefined),\n\t  check: check\n\t};\n\n/***/ },\n/* 67 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar global      = __webpack_require__(2)\n\t  , dP          = __webpack_require__(7)\n\t  , DESCRIPTORS = __webpack_require__(9)\n\t  , SPECIES     = __webpack_require__(4)('species');\n\t\n\tmodule.exports = function(KEY){\n\t  var C = global[KEY];\n\t  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {\n\t    configurable: true,\n\t    get: function(){ return this; }\n\t  });\n\t};\n\n/***/ },\n/* 68 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar shared = __webpack_require__(69)('keys')\n\t  , uid    = __webpack_require__(25);\n\tmodule.exports = function(key){\n\t  return shared[key] || (shared[key] = uid(key));\n\t};\n\n/***/ },\n/* 69 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(2)\n\t  , SHARED = '__core-js_shared__'\n\t  , store  = global[SHARED] || (global[SHARED] = {});\n\tmodule.exports = function(key){\n\t  return store[key] || (store[key] = {});\n\t};\n\n/***/ },\n/* 70 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// helper for String#{startsWith, endsWith, includes}\n\tvar isRegExp = __webpack_require__(87)\n\t  , defined  = __webpack_require__(17);\n\t\n\tmodule.exports = function(that, searchString, NAME){\n\t  if(isRegExp(searchString))throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n\t  return String(defined(that));\n\t};\n\n/***/ },\n/* 71 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ctx                = __webpack_require__(14)\n\t  , invoke             = __webpack_require__(49)\n\t  , html               = __webpack_require__(83)\n\t  , cel                = __webpack_require__(59)\n\t  , global             = __webpack_require__(2)\n\t  , process            = global.process\n\t  , setTask            = global.setImmediate\n\t  , clearTask          = global.clearImmediate\n\t  , MessageChannel     = global.MessageChannel\n\t  , counter            = 0\n\t  , queue              = {}\n\t  , ONREADYSTATECHANGE = 'onreadystatechange'\n\t  , defer, channel, port;\n\tvar run = function(){\n\t  var id = +this;\n\t  if(queue.hasOwnProperty(id)){\n\t    var fn = queue[id];\n\t    delete queue[id];\n\t    fn();\n\t  }\n\t};\n\tvar listener = function(event){\n\t  run.call(event.data);\n\t};\n\t// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\n\tif(!setTask || !clearTask){\n\t  setTask = function setImmediate(fn){\n\t    var args = [], i = 1;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    queue[++counter] = function(){\n\t      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n\t    };\n\t    defer(counter);\n\t    return counter;\n\t  };\n\t  clearTask = function clearImmediate(id){\n\t    delete queue[id];\n\t  };\n\t  // Node.js 0.8-\n\t  if(__webpack_require__(28)(process) == 'process'){\n\t    defer = function(id){\n\t      process.nextTick(ctx(run, id, 1));\n\t    };\n\t  // Browsers with MessageChannel, includes WebWorkers\n\t  } else if(MessageChannel){\n\t    channel = new MessageChannel;\n\t    port    = channel.port2;\n\t    channel.port1.onmessage = listener;\n\t    defer = ctx(port.postMessage, port, 1);\n\t  // Browsers with postMessage, skip WebWorkers\n\t  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n\t  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n\t    defer = function(id){\n\t      global.postMessage(id + '', '*');\n\t    };\n\t    global.addEventListener('message', listener, false);\n\t  // IE8-\n\t  } else if(ONREADYSTATECHANGE in cel('script')){\n\t    defer = function(id){\n\t      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n\t        html.removeChild(this);\n\t        run.call(id);\n\t      };\n\t    };\n\t  // Rest old browsers\n\t  } else {\n\t    defer = function(id){\n\t      setTimeout(ctx(run, id, 1), 0);\n\t    };\n\t  }\n\t}\n\tmodule.exports = {\n\t  set:   setTask,\n\t  clear: clearTask\n\t};\n\n/***/ },\n/* 72 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global = __webpack_require__(2)\n\t  , hide   = __webpack_require__(11)\n\t  , uid    = __webpack_require__(25)\n\t  , TYPED  = uid('typed_array')\n\t  , VIEW   = uid('view')\n\t  , ABV    = !!(global.ArrayBuffer && global.DataView)\n\t  , CONSTR = ABV\n\t  , i = 0, l = 9, Typed;\n\t\n\tvar TypedArrayConstructors = (\n\t  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'\n\t).split(',');\n\t\n\twhile(i < l){\n\t  if(Typed = global[TypedArrayConstructors[i++]]){\n\t    hide(Typed.prototype, TYPED, true);\n\t    hide(Typed.prototype, VIEW, true);\n\t  } else CONSTR = false;\n\t}\n\t\n\tmodule.exports = {\n\t  ABV:    ABV,\n\t  CONSTR: CONSTR,\n\t  TYPED:  TYPED,\n\t  VIEW:   VIEW\n\t};\n\n/***/ },\n/* 73 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar classof   = __webpack_require__(57)\n\t  , ITERATOR  = __webpack_require__(4)('iterator')\n\t  , Iterators = __webpack_require__(29);\n\tmodule.exports = __webpack_require__(38).getIteratorMethod = function(it){\n\t  if(it != undefined)return it[ITERATOR]\n\t    || it['@@iterator']\n\t    || Iterators[classof(it)];\n\t};\n\n/***/ },\n/* 74 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar addToUnscopables = __webpack_require__(26)\n\t  , step             = __webpack_require__(90)\n\t  , Iterators        = __webpack_require__(29)\n\t  , toIObject        = __webpack_require__(12);\n\t\n\t// 22.1.3.4 Array.prototype.entries()\n\t// 22.1.3.13 Array.prototype.keys()\n\t// 22.1.3.29 Array.prototype.values()\n\t// 22.1.3.30 Array.prototype[@@iterator]()\n\tmodule.exports = __webpack_require__(89)(Array, 'Array', function(iterated, kind){\n\t  this._t = toIObject(iterated); // target\n\t  this._i = 0;                   // next index\n\t  this._k = kind;                // kind\n\t// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n\t}, function(){\n\t  var O     = this._t\n\t    , kind  = this._k\n\t    , index = this._i++;\n\t  if(!O || index >= O.length){\n\t    this._t = undefined;\n\t    return step(1);\n\t  }\n\t  if(kind == 'keys'  )return step(0, index);\n\t  if(kind == 'values')return step(0, O[index]);\n\t  return step(0, [index, O[index]]);\n\t}, 'values');\n\t\n\t// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\n\tIterators.Arguments = Iterators.Array;\n\t\n\taddToUnscopables('keys');\n\taddToUnscopables('values');\n\taddToUnscopables('entries');\n\n/***/ },\n/* 75 */\n/***/ function(module, exports) {\n\n\tif (typeof Object.create === 'function') {\n\t  // implementation from standard node.js 'util' module\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    ctor.prototype = Object.create(superCtor.prototype, {\n\t      constructor: {\n\t        value: ctor,\n\t        enumerable: false,\n\t        writable: true,\n\t        configurable: true\n\t      }\n\t    });\n\t  };\n\t} else {\n\t  // old school shim for old browsers\n\t  module.exports = function inherits(ctor, superCtor) {\n\t    ctor.super_ = superCtor\n\t    var TempCtor = function () {}\n\t    TempCtor.prototype = superCtor.prototype\n\t    ctor.prototype = new TempCtor()\n\t    ctor.prototype.constructor = ctor\n\t  }\n\t}\n\n\n/***/ },\n/* 76 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t/* istanbul ignore if */\n\texports.Promise = __webpack_require__(106);\n\t\n\texports.inherits = __webpack_require__(75);\n\texports.extend = __webpack_require__(102);\n\tvar argsarray = __webpack_require__(78);\n\t\n\t/* istanbul ignore next */\n\texports.promisedCallback = function (promise, callback) {\n\t  if (callback) {\n\t    promise.then(function (res) {\n\t      process.nextTick(function () {\n\t        callback(null, res);\n\t      });\n\t    }, function (reason) {\n\t      process.nextTick(function () {\n\t        callback(reason);\n\t      });\n\t    });\n\t  }\n\t  return promise;\n\t};\n\t\n\t/* istanbul ignore next */\n\texports.callbackify = function (fun) {\n\t  return argsarray(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    if (typeof cb === 'function') {\n\t      exports.promisedCallback(promise, cb);\n\t    }\n\t    return promise;\n\t  });\n\t};\n\t\n\t// Promise finally util similar to Q.finally\n\t/* istanbul ignore next */\n\texports.fin = function (promise, cb) {\n\t  return promise.then(function (res) {\n\t    var promise2 = cb();\n\t    if (typeof promise2.then === 'function') {\n\t      return promise2.then(function () {\n\t        return res;\n\t      });\n\t    }\n\t    return res;\n\t  }, function (reason) {\n\t    var promise2 = cb();\n\t    if (typeof promise2.then === 'function') {\n\t      return promise2.then(function () {\n\t        throw reason;\n\t      });\n\t    }\n\t    throw reason;\n\t  });\n\t};\n\t\n\texports.sequentialize = function (queue, promiseFactory) {\n\t  return function () {\n\t    var args = arguments;\n\t    var that = this;\n\t    return queue.add(function () {\n\t      return promiseFactory.apply(that, args);\n\t    });\n\t  };\n\t};\n\t\n\texports.flatten = function (arrs) {\n\t  var res = [];\n\t  for (var i = 0, len = arrs.length; i < len; i++) {\n\t    res = res.concat(arrs[i]);\n\t  }\n\t  return res;\n\t};\n\t\n\t// uniq an array of strings, order not guaranteed\n\t// similar to underscore/lodash _.uniq\n\texports.uniq = function (arr) {\n\t  var map = {};\n\t\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    map['$' + arr[i]] = true;\n\t  }\n\t\n\t  var keys = Object.keys(map);\n\t  var output = new Array(keys.length);\n\t\n\t  for (i = 0, len = keys.length; i < len; i++) {\n\t    output[i] = keys[i].substring(1);\n\t  }\n\t  return output;\n\t};\n\t\n\tvar crypto = __webpack_require__(251);\n\tvar Md5 = __webpack_require__(108);\n\t\n\texports.MD5 = function (string) {\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    return crypto.createHash('md5').update(string).digest('hex');\n\t  } else {\n\t    return Md5.hash(string);\n\t  }\n\t};\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ },\n/* 77 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar localUtils = __webpack_require__(35);\n\tvar abstractMapReduce = __webpack_require__(225);\n\tvar parseField = localUtils.parseField;\n\t\n\t//\n\t// One thing about these mappers:\n\t//\n\t// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n\t// what you want to do in this case is optimize for the smallest possible\n\t// function, since that's the thing that gets run over and over again.\n\t//\n\t// This code would be a lot simpler if all the if/elses were inside\n\t// the function, but it would also be a lot less performant.\n\t//\n\t\n\t\n\tfunction createDeepMultiMapper(fields, emit) {\n\t  return function (doc) {\n\t    var toEmit = [];\n\t    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n\t      var parsedField = parseField(fields[i]);\n\t      var value = doc;\n\t      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n\t        var key = parsedField[j];\n\t        value = value[key];\n\t        if (!value) {\n\t          break;\n\t        }\n\t      }\n\t      toEmit.push(value);\n\t    }\n\t    emit(toEmit);\n\t  };\n\t}\n\t\n\tfunction createDeepSingleMapper(field, emit) {\n\t  var parsedField = parseField(field);\n\t  return function (doc) {\n\t    var value = doc;\n\t    for (var i = 0, len = parsedField.length; i < len; i++) {\n\t      var key = parsedField[i];\n\t      value = value[key];\n\t      if (!value) {\n\t        return; // do nothing\n\t      }\n\t    }\n\t    emit(value);\n\t  };\n\t}\n\t\n\tfunction createShallowSingleMapper(field, emit) {\n\t  return function (doc) {\n\t    emit(doc[field]);\n\t  };\n\t}\n\t\n\tfunction createShallowMultiMapper(fields, emit) {\n\t  return function (doc) {\n\t    var toEmit = [];\n\t    for (var i = 0, len = fields.length; i < len; i++) {\n\t      toEmit.push(doc[fields[i]]);\n\t    }\n\t    emit(toEmit);\n\t  };\n\t}\n\t\n\tfunction checkShallow(fields) {\n\t  for (var i = 0, len = fields.length; i < len; i++) {\n\t    var field = fields[i];\n\t    if (field.indexOf('.') !== -1) {\n\t      return false;\n\t    }\n\t  }\n\t  return true;\n\t}\n\t\n\tfunction createMapper(fields, emit) {\n\t  var isShallow = checkShallow(fields);\n\t  var isSingle = fields.length === 1;\n\t\n\t  // notice we try to optimize for the most common case,\n\t  // i.e. single shallow indexes\n\t  if (isShallow) {\n\t    if (isSingle) {\n\t      return createShallowSingleMapper(fields[0], emit);\n\t    } else { // multi\n\t      return createShallowMultiMapper(fields, emit);\n\t    }\n\t  } else { // deep\n\t    if (isSingle) {\n\t      return createDeepSingleMapper(fields[0], emit);\n\t    } else { // multi\n\t      return createDeepMultiMapper(fields, emit);\n\t    }\n\t  }\n\t}\n\t\n\tfunction mapper(mapFunDef, emit) {\n\t  // mapFunDef is a list of fields\n\t\n\t  var fields = Object.keys(mapFunDef.fields);\n\t\n\t  return createMapper(fields, emit);\n\t}\n\t\n\t/* istanbul ignore next */\n\tfunction reducer(/*reduceFunDef*/) {\n\t  throw new Error('reduce not supported');\n\t}\n\t\n\tfunction ddocValidator(ddoc, viewName) {\n\t  var view = ddoc.views[viewName];\n\t  // This doesn't actually need to be here apparently, but\n\t  // I feel safer keeping it.\n\t  /* istanbul ignore if */\n\t  if (!view.map || !view.map.fields) {\n\t    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n\t      ' doesn\\'t have map.fields defined. ' +\n\t      'maybe it wasn\\'t created by this plugin?');\n\t  }\n\t}\n\t\n\tvar abstractMapper = abstractMapReduce({\n\t  name: 'indexes',\n\t  mapper: mapper,\n\t  reducer: reducer,\n\t  ddocValidator: ddocValidator\n\t});\n\t\n\tmodule.exports = abstractMapper;\n\n/***/ },\n/* 78 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = argsArray;\n\t\n\tfunction argsArray(fun) {\n\t  return function () {\n\t    var len = arguments.length;\n\t    if (len) {\n\t      var args = [];\n\t      var i = -1;\n\t      while (++i < len) {\n\t        args[i] = arguments[i];\n\t      }\n\t      return fun.call(this, args);\n\t    } else {\n\t      return fun.call(this, []);\n\t    }\n\t  };\n\t}\n\n/***/ },\n/* 79 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\tfunction indexKey(doc) {\n\t  return doc.type + '/' + doc.id;\n\t}\n\t\n\tfunction findByRef(resources, ref) {\n\t  return resources[indexKey(ref)];\n\t}\n\t\n\tfunction handleResource(rawResource, resources, links) {\n\t  var resource = {\n\t    _id: rawResource.id,\n\t    _type: rawResource.type,\n\t    _rev: rawResource.meta && rawResource.meta.rev,\n\t    links: Object.assign({}, rawResource.links, links),\n\t    attributes: rawResource.attributes,\n\t    relations: function relations(name) {\n\t      var rels = rawResource.relationships[name];\n\t      if (rels === undefined || rels.data === undefined) return undefined;\n\t      if (rels.data === null) return null;\n\t      if (!Array.isArray(rels.data)) return findByRef(resources, rels.data);\n\t      return rels.data.map(function (ref) {\n\t        return findByRef(resources, ref);\n\t      });\n\t    }\n\t  };\n\t  if (rawResource.relationships) {\n\t    resource.relationships = rawResource.relationships;\n\t  }\n\t\n\t  resources[indexKey(rawResource)] = resource;\n\t\n\t  return resource;\n\t}\n\t\n\tfunction handleTopLevel(doc) {\n\t  var resources = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t\n\t  // build an index of included resource by Type & ID\n\t  var included = doc.included;\n\t\n\t  if (Array.isArray(included)) {\n\t    included.forEach(function (r) {\n\t      return handleResource(r, resources, doc.links);\n\t    });\n\t  }\n\t\n\t  if (Array.isArray(doc.data)) {\n\t    return doc.data.map(function (r) {\n\t      return handleResource(r, resources, doc.links);\n\t    });\n\t  } else {\n\t    return handleResource(doc.data, resources, doc.links);\n\t  }\n\t}\n\t\n\texports.default = handleTopLevel;\n\n/***/ },\n/* 80 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n\t'use strict';\n\tvar toObject = __webpack_require__(24)\n\t  , toIndex  = __webpack_require__(44)\n\t  , toLength = __webpack_require__(10);\n\t\n\tmodule.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){\n\t  var O     = toObject(this)\n\t    , len   = toLength(O.length)\n\t    , to    = toIndex(target, len)\n\t    , from  = toIndex(start, len)\n\t    , end   = arguments.length > 2 ? arguments[2] : undefined\n\t    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)\n\t    , inc   = 1;\n\t  if(from < to && to < from + count){\n\t    inc  = -1;\n\t    from += count - 1;\n\t    to   += count - 1;\n\t  }\n\t  while(count-- > 0){\n\t    if(from in O)O[to] = O[from];\n\t    else delete O[to];\n\t    to   += inc;\n\t    from += inc;\n\t  } return O;\n\t};\n\n/***/ },\n/* 81 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar dP          = __webpack_require__(7).f\n\t  , create      = __webpack_require__(40)\n\t  , redefineAll = __webpack_require__(32)\n\t  , ctx         = __webpack_require__(14)\n\t  , anInstance  = __webpack_require__(27)\n\t  , defined     = __webpack_require__(17)\n\t  , forOf       = __webpack_require__(48)\n\t  , $iterDefine = __webpack_require__(89)\n\t  , step        = __webpack_require__(90)\n\t  , setSpecies  = __webpack_require__(67)\n\t  , DESCRIPTORS = __webpack_require__(9)\n\t  , fastKey     = __webpack_require__(39).fastKey\n\t  , SIZE        = DESCRIPTORS ? '_s' : 'size';\n\t\n\tvar getEntry = function(that, key){\n\t  // fast case\n\t  var index = fastKey(key), entry;\n\t  if(index !== 'F')return that._i[index];\n\t  // frozen object case\n\t  for(entry = that._f; entry; entry = entry.n){\n\t    if(entry.k == key)return entry;\n\t  }\n\t};\n\t\n\tmodule.exports = {\n\t  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n\t    var C = wrapper(function(that, iterable){\n\t      anInstance(that, C, NAME, '_i');\n\t      that._i = create(null); // index\n\t      that._f = undefined;    // first entry\n\t      that._l = undefined;    // last entry\n\t      that[SIZE] = 0;         // size\n\t      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n\t    });\n\t    redefineAll(C.prototype, {\n\t      // 23.1.3.1 Map.prototype.clear()\n\t      // 23.2.3.2 Set.prototype.clear()\n\t      clear: function clear(){\n\t        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){\n\t          entry.r = true;\n\t          if(entry.p)entry.p = entry.p.n = undefined;\n\t          delete data[entry.i];\n\t        }\n\t        that._f = that._l = undefined;\n\t        that[SIZE] = 0;\n\t      },\n\t      // 23.1.3.3 Map.prototype.delete(key)\n\t      // 23.2.3.4 Set.prototype.delete(value)\n\t      'delete': function(key){\n\t        var that  = this\n\t          , entry = getEntry(that, key);\n\t        if(entry){\n\t          var next = entry.n\n\t            , prev = entry.p;\n\t          delete that._i[entry.i];\n\t          entry.r = true;\n\t          if(prev)prev.n = next;\n\t          if(next)next.p = prev;\n\t          if(that._f == entry)that._f = next;\n\t          if(that._l == entry)that._l = prev;\n\t          that[SIZE]--;\n\t        } return !!entry;\n\t      },\n\t      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n\t      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n\t      forEach: function forEach(callbackfn /*, that = undefined */){\n\t        anInstance(this, C, 'forEach');\n\t        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)\n\t          , entry;\n\t        while(entry = entry ? entry.n : this._f){\n\t          f(entry.v, entry.k, this);\n\t          // revert to the last existing entry\n\t          while(entry && entry.r)entry = entry.p;\n\t        }\n\t      },\n\t      // 23.1.3.7 Map.prototype.has(key)\n\t      // 23.2.3.7 Set.prototype.has(value)\n\t      has: function has(key){\n\t        return !!getEntry(this, key);\n\t      }\n\t    });\n\t    if(DESCRIPTORS)dP(C.prototype, 'size', {\n\t      get: function(){\n\t        return defined(this[SIZE]);\n\t      }\n\t    });\n\t    return C;\n\t  },\n\t  def: function(that, key, value){\n\t    var entry = getEntry(that, key)\n\t      , prev, index;\n\t    // change existing entry\n\t    if(entry){\n\t      entry.v = value;\n\t    // create new entry\n\t    } else {\n\t      that._l = entry = {\n\t        i: index = fastKey(key, true), // <- index\n\t        k: key,                        // <- key\n\t        v: value,                      // <- value\n\t        p: prev = that._l,             // <- previous entry\n\t        n: undefined,                  // <- next entry\n\t        r: false                       // <- removed\n\t      };\n\t      if(!that._f)that._f = entry;\n\t      if(prev)prev.n = entry;\n\t      that[SIZE]++;\n\t      // add to index\n\t      if(index !== 'F')that._i[index] = entry;\n\t    } return that;\n\t  },\n\t  getEntry: getEntry,\n\t  setStrong: function(C, NAME, IS_MAP){\n\t    // add .keys, .values, .entries, [@@iterator]\n\t    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n\t    $iterDefine(C, NAME, function(iterated, kind){\n\t      this._t = iterated;  // target\n\t      this._k = kind;      // kind\n\t      this._l = undefined; // previous\n\t    }, function(){\n\t      var that  = this\n\t        , kind  = that._k\n\t        , entry = that._l;\n\t      // revert to the last existing entry\n\t      while(entry && entry.r)entry = entry.p;\n\t      // get next entry\n\t      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){\n\t        // or finish the iteration\n\t        that._t = undefined;\n\t        return step(1);\n\t      }\n\t      // return step by kind\n\t      if(kind == 'keys'  )return step(0, entry.k);\n\t      if(kind == 'values')return step(0, entry.v);\n\t      return step(0, [entry.k, entry.v]);\n\t    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);\n\t\n\t    // add [@@species], 23.1.2.2, 23.2.2.2\n\t    setSpecies(NAME);\n\t  }\n\t};\n\n/***/ },\n/* 82 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar redefineAll       = __webpack_require__(32)\n\t  , getWeak           = __webpack_require__(39).getWeak\n\t  , anObject          = __webpack_require__(3)\n\t  , isObject          = __webpack_require__(5)\n\t  , anInstance        = __webpack_require__(27)\n\t  , forOf             = __webpack_require__(48)\n\t  , createArrayMethod = __webpack_require__(37)\n\t  , $has              = __webpack_require__(8)\n\t  , arrayFind         = createArrayMethod(5)\n\t  , arrayFindIndex    = createArrayMethod(6)\n\t  , id                = 0;\n\t\n\t// fallback for uncaught frozen keys\n\tvar uncaughtFrozenStore = function(that){\n\t  return that._l || (that._l = new UncaughtFrozenStore);\n\t};\n\tvar UncaughtFrozenStore = function(){\n\t  this.a = [];\n\t};\n\tvar findUncaughtFrozen = function(store, key){\n\t  return arrayFind(store.a, function(it){\n\t    return it[0] === key;\n\t  });\n\t};\n\tUncaughtFrozenStore.prototype = {\n\t  get: function(key){\n\t    var entry = findUncaughtFrozen(this, key);\n\t    if(entry)return entry[1];\n\t  },\n\t  has: function(key){\n\t    return !!findUncaughtFrozen(this, key);\n\t  },\n\t  set: function(key, value){\n\t    var entry = findUncaughtFrozen(this, key);\n\t    if(entry)entry[1] = value;\n\t    else this.a.push([key, value]);\n\t  },\n\t  'delete': function(key){\n\t    var index = arrayFindIndex(this.a, function(it){\n\t      return it[0] === key;\n\t    });\n\t    if(~index)this.a.splice(index, 1);\n\t    return !!~index;\n\t  }\n\t};\n\t\n\tmodule.exports = {\n\t  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n\t    var C = wrapper(function(that, iterable){\n\t      anInstance(that, C, NAME, '_i');\n\t      that._i = id++;      // collection id\n\t      that._l = undefined; // leak store for uncaught frozen objects\n\t      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n\t    });\n\t    redefineAll(C.prototype, {\n\t      // 23.3.3.2 WeakMap.prototype.delete(key)\n\t      // 23.4.3.3 WeakSet.prototype.delete(value)\n\t      'delete': function(key){\n\t        if(!isObject(key))return false;\n\t        var data = getWeak(key);\n\t        if(data === true)return uncaughtFrozenStore(this)['delete'](key);\n\t        return data && $has(data, this._i) && delete data[this._i];\n\t      },\n\t      // 23.3.3.4 WeakMap.prototype.has(key)\n\t      // 23.4.3.4 WeakSet.prototype.has(value)\n\t      has: function has(key){\n\t        if(!isObject(key))return false;\n\t        var data = getWeak(key);\n\t        if(data === true)return uncaughtFrozenStore(this).has(key);\n\t        return data && $has(data, this._i);\n\t      }\n\t    });\n\t    return C;\n\t  },\n\t  def: function(that, key, value){\n\t    var data = getWeak(anObject(key), true);\n\t    if(data === true)uncaughtFrozenStore(that).set(key, value);\n\t    else data[that._i] = value;\n\t    return that;\n\t  },\n\t  ufstore: uncaughtFrozenStore\n\t};\n\n/***/ },\n/* 83 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2).document && document.documentElement;\n\n/***/ },\n/* 84 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = !__webpack_require__(9) && !__webpack_require__(6)(function(){\n\t  return Object.defineProperty(__webpack_require__(59)('div'), 'a', {get: function(){ return 7; }}).a != 7;\n\t});\n\n/***/ },\n/* 85 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.2 IsArray(argument)\n\tvar cof = __webpack_require__(28);\n\tmodule.exports = Array.isArray || function isArray(arg){\n\t  return cof(arg) == 'Array';\n\t};\n\n/***/ },\n/* 86 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.1.2.3 Number.isInteger(number)\n\tvar isObject = __webpack_require__(5)\n\t  , floor    = Math.floor;\n\tmodule.exports = function isInteger(it){\n\t  return !isObject(it) && isFinite(it) && floor(it) === it;\n\t};\n\n/***/ },\n/* 87 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.2.8 IsRegExp(argument)\n\tvar isObject = __webpack_require__(5)\n\t  , cof      = __webpack_require__(28)\n\t  , MATCH    = __webpack_require__(4)('match');\n\tmodule.exports = function(it){\n\t  var isRegExp;\n\t  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n\t};\n\n/***/ },\n/* 88 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// call something on iterator step with safe closing on error\n\tvar anObject = __webpack_require__(3);\n\tmodule.exports = function(iterator, fn, value, entries){\n\t  try {\n\t    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n\t  // 7.4.6 IteratorClose(iterator, completion)\n\t  } catch(e){\n\t    var ret = iterator['return'];\n\t    if(ret !== undefined)anObject(ret.call(iterator));\n\t    throw e;\n\t  }\n\t};\n\n/***/ },\n/* 89 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY        = __webpack_require__(30)\n\t  , $export        = __webpack_require__(1)\n\t  , redefine       = __webpack_require__(20)\n\t  , hide           = __webpack_require__(11)\n\t  , has            = __webpack_require__(8)\n\t  , Iterators      = __webpack_require__(29)\n\t  , $iterCreate    = __webpack_require__(126)\n\t  , setToStringTag = __webpack_require__(33)\n\t  , getPrototypeOf = __webpack_require__(42)\n\t  , ITERATOR       = __webpack_require__(4)('iterator')\n\t  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n\t  , FF_ITERATOR    = '@@iterator'\n\t  , KEYS           = 'keys'\n\t  , VALUES         = 'values';\n\t\n\tvar returnThis = function(){ return this; };\n\t\n\tmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n\t  $iterCreate(Constructor, NAME, next);\n\t  var getMethod = function(kind){\n\t    if(!BUGGY && kind in proto)return proto[kind];\n\t    switch(kind){\n\t      case KEYS: return function keys(){ return new Constructor(this, kind); };\n\t      case VALUES: return function values(){ return new Constructor(this, kind); };\n\t    } return function entries(){ return new Constructor(this, kind); };\n\t  };\n\t  var TAG        = NAME + ' Iterator'\n\t    , DEF_VALUES = DEFAULT == VALUES\n\t    , VALUES_BUG = false\n\t    , proto      = Base.prototype\n\t    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n\t    , $default   = $native || getMethod(DEFAULT)\n\t    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n\t    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n\t    , methods, key, IteratorPrototype;\n\t  // Fix native\n\t  if($anyNative){\n\t    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n\t    if(IteratorPrototype !== Object.prototype){\n\t      // Set @@toStringTag to native iterators\n\t      setToStringTag(IteratorPrototype, TAG, true);\n\t      // fix for some old engines\n\t      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n\t    }\n\t  }\n\t  // fix Array#{values, @@iterator}.name in V8 / FF\n\t  if(DEF_VALUES && $native && $native.name !== VALUES){\n\t    VALUES_BUG = true;\n\t    $default = function values(){ return $native.call(this); };\n\t  }\n\t  // Define iterator\n\t  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n\t    hide(proto, ITERATOR, $default);\n\t  }\n\t  // Plug for library\n\t  Iterators[NAME] = $default;\n\t  Iterators[TAG]  = returnThis;\n\t  if(DEFAULT){\n\t    methods = {\n\t      values:  DEF_VALUES ? $default : getMethod(VALUES),\n\t      keys:    IS_SET     ? $default : getMethod(KEYS),\n\t      entries: $entries\n\t    };\n\t    if(FORCED)for(key in methods){\n\t      if(!(key in proto))redefine(proto, key, methods[key]);\n\t    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n\t  }\n\t  return methods;\n\t};\n\n/***/ },\n/* 90 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function(done, value){\n\t  return {value: value, done: !!done};\n\t};\n\n/***/ },\n/* 91 */\n/***/ function(module, exports) {\n\n\t// 20.2.2.20 Math.log1p(x)\n\tmodule.exports = Math.log1p || function log1p(x){\n\t  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);\n\t};\n\n/***/ },\n/* 92 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// 19.1.2.1 Object.assign(target, source, ...)\n\tvar getKeys  = __webpack_require__(31)\n\t  , gOPS     = __webpack_require__(51)\n\t  , pIE      = __webpack_require__(43)\n\t  , toObject = __webpack_require__(24)\n\t  , IObject  = __webpack_require__(62)\n\t  , $assign  = Object.assign;\n\t\n\t// should work with symbols and should have deterministic property order (V8 bug)\n\tmodule.exports = !$assign || __webpack_require__(6)(function(){\n\t  var A = {}\n\t    , B = {}\n\t    , S = Symbol()\n\t    , K = 'abcdefghijklmnopqrst';\n\t  A[S] = 7;\n\t  K.split('').forEach(function(k){ B[k] = k; });\n\t  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n\t}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n\t  var T     = toObject(target)\n\t    , aLen  = arguments.length\n\t    , index = 1\n\t    , getSymbols = gOPS.f\n\t    , isEnum     = pIE.f;\n\t  while(aLen > index){\n\t    var S      = IObject(arguments[index++])\n\t      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n\t      , length = keys.length\n\t      , j      = 0\n\t      , key;\n\t    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n\t  } return T;\n\t} : $assign;\n\n/***/ },\n/* 93 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar has          = __webpack_require__(8)\n\t  , toIObject    = __webpack_require__(12)\n\t  , arrayIndexOf = __webpack_require__(56)(false)\n\t  , IE_PROTO     = __webpack_require__(68)('IE_PROTO');\n\t\n\tmodule.exports = function(object, names){\n\t  var O      = toIObject(object)\n\t    , i      = 0\n\t    , result = []\n\t    , key;\n\t  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n\t  // Don't enum bug & hidden keys\n\t  while(names.length > i)if(has(O, key = names[i++])){\n\t    ~arrayIndexOf(result, key) || result.push(key);\n\t  }\n\t  return result;\n\t};\n\n/***/ },\n/* 94 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getKeys   = __webpack_require__(31)\n\t  , toIObject = __webpack_require__(12)\n\t  , isEnum    = __webpack_require__(43).f;\n\tmodule.exports = function(isEntries){\n\t  return function(it){\n\t    var O      = toIObject(it)\n\t      , keys   = getKeys(O)\n\t      , length = keys.length\n\t      , i      = 0\n\t      , result = []\n\t      , key;\n\t    while(length > i)if(isEnum.call(O, key = keys[i++])){\n\t      result.push(isEntries ? [key, O[key]] : O[key]);\n\t    } return result;\n\t  };\n\t};\n\n/***/ },\n/* 95 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// all object keys, includes non-enumerable and symbols\n\tvar gOPN     = __webpack_require__(41)\n\t  , gOPS     = __webpack_require__(51)\n\t  , anObject = __webpack_require__(3)\n\t  , Reflect  = __webpack_require__(2).Reflect;\n\tmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it){\n\t  var keys       = gOPN.f(anObject(it))\n\t    , getSymbols = gOPS.f;\n\t  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n\t};\n\n/***/ },\n/* 96 */\n/***/ function(module, exports) {\n\n\t// 7.2.9 SameValue(x, y)\n\tmodule.exports = Object.is || function is(x, y){\n\t  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n\t};\n\n/***/ },\n/* 97 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 7.3.20 SpeciesConstructor(O, defaultConstructor)\n\tvar anObject  = __webpack_require__(3)\n\t  , aFunction = __webpack_require__(23)\n\t  , SPECIES   = __webpack_require__(4)('species');\n\tmodule.exports = function(O, D){\n\t  var C = anObject(O).constructor, S;\n\t  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n\t};\n\n/***/ },\n/* 98 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://github.com/tc39/proposal-string-pad-start-end\n\tvar toLength = __webpack_require__(10)\n\t  , repeat   = __webpack_require__(99)\n\t  , defined  = __webpack_require__(17);\n\t\n\tmodule.exports = function(that, maxLength, fillString, left){\n\t  var S            = String(defined(that))\n\t    , stringLength = S.length\n\t    , fillStr      = fillString === undefined ? ' ' : String(fillString)\n\t    , intMaxLength = toLength(maxLength);\n\t  if(intMaxLength <= stringLength || fillStr == '')return S;\n\t  var fillLen = intMaxLength - stringLength\n\t    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n\t  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);\n\t  return left ? stringFiller + S : S + stringFiller;\n\t};\n\n\n/***/ },\n/* 99 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar toInteger = __webpack_require__(34)\n\t  , defined   = __webpack_require__(17);\n\t\n\tmodule.exports = function repeat(count){\n\t  var str = String(defined(this))\n\t    , res = ''\n\t    , n   = toInteger(count);\n\t  if(n < 0 || n == Infinity)throw RangeError(\"Count can't be negative\");\n\t  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;\n\t  return res;\n\t};\n\n/***/ },\n/* 100 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar global         = __webpack_require__(2)\n\t  , DESCRIPTORS    = __webpack_require__(9)\n\t  , LIBRARY        = __webpack_require__(30)\n\t  , $typed         = __webpack_require__(72)\n\t  , hide           = __webpack_require__(11)\n\t  , redefineAll    = __webpack_require__(32)\n\t  , fails          = __webpack_require__(6)\n\t  , anInstance     = __webpack_require__(27)\n\t  , toInteger      = __webpack_require__(34)\n\t  , toLength       = __webpack_require__(10)\n\t  , gOPN           = __webpack_require__(41).f\n\t  , dP             = __webpack_require__(7).f\n\t  , arrayFill      = __webpack_require__(55)\n\t  , setToStringTag = __webpack_require__(33)\n\t  , ARRAY_BUFFER   = 'ArrayBuffer'\n\t  , DATA_VIEW      = 'DataView'\n\t  , PROTOTYPE      = 'prototype'\n\t  , WRONG_LENGTH   = 'Wrong length!'\n\t  , WRONG_INDEX    = 'Wrong index!'\n\t  , $ArrayBuffer   = global[ARRAY_BUFFER]\n\t  , $DataView      = global[DATA_VIEW]\n\t  , Math           = global.Math\n\t  , RangeError     = global.RangeError\n\t  , Infinity       = global.Infinity\n\t  , BaseBuffer     = $ArrayBuffer\n\t  , abs            = Math.abs\n\t  , pow            = Math.pow\n\t  , floor          = Math.floor\n\t  , log            = Math.log\n\t  , LN2            = Math.LN2\n\t  , BUFFER         = 'buffer'\n\t  , BYTE_LENGTH    = 'byteLength'\n\t  , BYTE_OFFSET    = 'byteOffset'\n\t  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER\n\t  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH\n\t  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;\n\t\n\t// IEEE754 conversions based on https://github.com/feross/ieee754\n\tvar packIEEE754 = function(value, mLen, nBytes){\n\t  var buffer = Array(nBytes)\n\t    , eLen   = nBytes * 8 - mLen - 1\n\t    , eMax   = (1 << eLen) - 1\n\t    , eBias  = eMax >> 1\n\t    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0\n\t    , i      = 0\n\t    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0\n\t    , e, m, c;\n\t  value = abs(value)\n\t  if(value != value || value === Infinity){\n\t    m = value != value ? 1 : 0;\n\t    e = eMax;\n\t  } else {\n\t    e = floor(log(value) / LN2);\n\t    if(value * (c = pow(2, -e)) < 1){\n\t      e--;\n\t      c *= 2;\n\t    }\n\t    if(e + eBias >= 1){\n\t      value += rt / c;\n\t    } else {\n\t      value += rt * pow(2, 1 - eBias);\n\t    }\n\t    if(value * c >= 2){\n\t      e++;\n\t      c /= 2;\n\t    }\n\t    if(e + eBias >= eMax){\n\t      m = 0;\n\t      e = eMax;\n\t    } else if(e + eBias >= 1){\n\t      m = (value * c - 1) * pow(2, mLen);\n\t      e = e + eBias;\n\t    } else {\n\t      m = value * pow(2, eBias - 1) * pow(2, mLen);\n\t      e = 0;\n\t    }\n\t  }\n\t  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n\t  e = e << mLen | m;\n\t  eLen += mLen;\n\t  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n\t  buffer[--i] |= s * 128;\n\t  return buffer;\n\t};\n\tvar unpackIEEE754 = function(buffer, mLen, nBytes){\n\t  var eLen  = nBytes * 8 - mLen - 1\n\t    , eMax  = (1 << eLen) - 1\n\t    , eBias = eMax >> 1\n\t    , nBits = eLen - 7\n\t    , i     = nBytes - 1\n\t    , s     = buffer[i--]\n\t    , e     = s & 127\n\t    , m;\n\t  s >>= 7;\n\t  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n\t  m = e & (1 << -nBits) - 1;\n\t  e >>= -nBits;\n\t  nBits += mLen;\n\t  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n\t  if(e === 0){\n\t    e = 1 - eBias;\n\t  } else if(e === eMax){\n\t    return m ? NaN : s ? -Infinity : Infinity;\n\t  } else {\n\t    m = m + pow(2, mLen);\n\t    e = e - eBias;\n\t  } return (s ? -1 : 1) * m * pow(2, e - mLen);\n\t};\n\t\n\tvar unpackI32 = function(bytes){\n\t  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n\t};\n\tvar packI8 = function(it){\n\t  return [it & 0xff];\n\t};\n\tvar packI16 = function(it){\n\t  return [it & 0xff, it >> 8 & 0xff];\n\t};\n\tvar packI32 = function(it){\n\t  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n\t};\n\tvar packF64 = function(it){\n\t  return packIEEE754(it, 52, 8);\n\t};\n\tvar packF32 = function(it){\n\t  return packIEEE754(it, 23, 4);\n\t};\n\t\n\tvar addGetter = function(C, key, internal){\n\t  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});\n\t};\n\t\n\tvar get = function(view, bytes, index, isLittleEndian){\n\t  var numIndex = +index\n\t    , intIndex = toInteger(numIndex);\n\t  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);\n\t  var store = view[$BUFFER]._b\n\t    , start = intIndex + view[$OFFSET]\n\t    , pack  = store.slice(start, start + bytes);\n\t  return isLittleEndian ? pack : pack.reverse();\n\t};\n\tvar set = function(view, bytes, index, conversion, value, isLittleEndian){\n\t  var numIndex = +index\n\t    , intIndex = toInteger(numIndex);\n\t  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);\n\t  var store = view[$BUFFER]._b\n\t    , start = intIndex + view[$OFFSET]\n\t    , pack  = conversion(+value);\n\t  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n\t};\n\t\n\tvar validateArrayBufferArguments = function(that, length){\n\t  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);\n\t  var numberLength = +length\n\t    , byteLength   = toLength(numberLength);\n\t  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);\n\t  return byteLength;\n\t};\n\t\n\tif(!$typed.ABV){\n\t  $ArrayBuffer = function ArrayBuffer(length){\n\t    var byteLength = validateArrayBufferArguments(this, length);\n\t    this._b       = arrayFill.call(Array(byteLength), 0);\n\t    this[$LENGTH] = byteLength;\n\t  };\n\t\n\t  $DataView = function DataView(buffer, byteOffset, byteLength){\n\t    anInstance(this, $DataView, DATA_VIEW);\n\t    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n\t    var bufferLength = buffer[$LENGTH]\n\t      , offset       = toInteger(byteOffset);\n\t    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');\n\t    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n\t    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);\n\t    this[$BUFFER] = buffer;\n\t    this[$OFFSET] = offset;\n\t    this[$LENGTH] = byteLength;\n\t  };\n\t\n\t  if(DESCRIPTORS){\n\t    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n\t    addGetter($DataView, BUFFER, '_b');\n\t    addGetter($DataView, BYTE_LENGTH, '_l');\n\t    addGetter($DataView, BYTE_OFFSET, '_o');\n\t  }\n\t\n\t  redefineAll($DataView[PROTOTYPE], {\n\t    getInt8: function getInt8(byteOffset){\n\t      return get(this, 1, byteOffset)[0] << 24 >> 24;\n\t    },\n\t    getUint8: function getUint8(byteOffset){\n\t      return get(this, 1, byteOffset)[0];\n\t    },\n\t    getInt16: function getInt16(byteOffset /*, littleEndian */){\n\t      var bytes = get(this, 2, byteOffset, arguments[1]);\n\t      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n\t    },\n\t    getUint16: function getUint16(byteOffset /*, littleEndian */){\n\t      var bytes = get(this, 2, byteOffset, arguments[1]);\n\t      return bytes[1] << 8 | bytes[0];\n\t    },\n\t    getInt32: function getInt32(byteOffset /*, littleEndian */){\n\t      return unpackI32(get(this, 4, byteOffset, arguments[1]));\n\t    },\n\t    getUint32: function getUint32(byteOffset /*, littleEndian */){\n\t      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n\t    },\n\t    getFloat32: function getFloat32(byteOffset /*, littleEndian */){\n\t      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n\t    },\n\t    getFloat64: function getFloat64(byteOffset /*, littleEndian */){\n\t      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n\t    },\n\t    setInt8: function setInt8(byteOffset, value){\n\t      set(this, 1, byteOffset, packI8, value);\n\t    },\n\t    setUint8: function setUint8(byteOffset, value){\n\t      set(this, 1, byteOffset, packI8, value);\n\t    },\n\t    setInt16: function setInt16(byteOffset, value /*, littleEndian */){\n\t      set(this, 2, byteOffset, packI16, value, arguments[2]);\n\t    },\n\t    setUint16: function setUint16(byteOffset, value /*, littleEndian */){\n\t      set(this, 2, byteOffset, packI16, value, arguments[2]);\n\t    },\n\t    setInt32: function setInt32(byteOffset, value /*, littleEndian */){\n\t      set(this, 4, byteOffset, packI32, value, arguments[2]);\n\t    },\n\t    setUint32: function setUint32(byteOffset, value /*, littleEndian */){\n\t      set(this, 4, byteOffset, packI32, value, arguments[2]);\n\t    },\n\t    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){\n\t      set(this, 4, byteOffset, packF32, value, arguments[2]);\n\t    },\n\t    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){\n\t      set(this, 8, byteOffset, packF64, value, arguments[2]);\n\t    }\n\t  });\n\t} else {\n\t  if(!fails(function(){\n\t    new $ArrayBuffer;     // eslint-disable-line no-new\n\t  }) || !fails(function(){\n\t    new $ArrayBuffer(.5); // eslint-disable-line no-new\n\t  })){\n\t    $ArrayBuffer = function ArrayBuffer(length){\n\t      return new BaseBuffer(validateArrayBufferArguments(this, length));\n\t    };\n\t    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n\t    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){\n\t      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);\n\t    };\n\t    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;\n\t  }\n\t  // iOS Safari 7.x bug\n\t  var view = new $DataView(new $ArrayBuffer(2))\n\t    , $setInt8 = $DataView[PROTOTYPE].setInt8;\n\t  view.setInt8(0, 2147483648);\n\t  view.setInt8(1, 2147483649);\n\t  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {\n\t    setInt8: function setInt8(byteOffset, value){\n\t      $setInt8.call(this, byteOffset, value << 24 >> 24);\n\t    },\n\t    setUint8: function setUint8(byteOffset, value){\n\t      $setInt8.call(this, byteOffset, value << 24 >> 24);\n\t    }\n\t  }, true);\n\t}\n\tsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\n\tsetToStringTag($DataView, DATA_VIEW);\n\thide($DataView[PROTOTYPE], $typed.VIEW, true);\n\texports[ARRAY_BUFFER] = $ArrayBuffer;\n\texports[DATA_VIEW] = $DataView;\n\n/***/ },\n/* 101 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.f = __webpack_require__(4);\n\n/***/ },\n/* 102 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// Extends method\n\t// (taken from http://code.jquery.com/jquery-1.9.0.js)\n\t// Populate the class2type map\n\tvar class2type = {};\n\t\n\tvar types = [\n\t  \"Boolean\", \"Number\", \"String\", \"Function\", \"Array\",\n\t  \"Date\", \"RegExp\", \"Object\", \"Error\"\n\t];\n\tfor (var i = 0; i < types.length; i++) {\n\t  var typename = types[i];\n\t  class2type[\"[object \" + typename + \"]\"] = typename.toLowerCase();\n\t}\n\t\n\tvar core_toString = class2type.toString;\n\tvar core_hasOwn = class2type.hasOwnProperty;\n\t\n\tfunction type(obj) {\n\t  if (obj === null) {\n\t    return String(obj);\n\t  }\n\t  return typeof obj === \"object\" || typeof obj === \"function\" ?\n\t    class2type[core_toString.call(obj)] || \"object\" :\n\t    typeof obj;\n\t}\n\t\n\tfunction isWindow(obj) {\n\t  return obj !== null && obj === obj.window;\n\t}\n\t\n\tfunction isPlainObject(obj) {\n\t  // Must be an Object.\n\t  // Because of IE, we also have to check the presence of\n\t  // the constructor property.\n\t  // Make sure that DOM nodes and window objects don't pass through, as well\n\t  if (!obj || type(obj) !== \"object\" || obj.nodeType || isWindow(obj)) {\n\t    return false;\n\t  }\n\t\n\t  try {\n\t    // Not own constructor property must be Object\n\t    if (obj.constructor &&\n\t      !core_hasOwn.call(obj, \"constructor\") &&\n\t      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n\t      return false;\n\t    }\n\t  } catch ( e ) {\n\t    // IE8,9 Will throw exceptions on certain host objects #9897\n\t    return false;\n\t  }\n\t\n\t  // Own properties are enumerated firstly, so to speed up,\n\t  // if last one is own, then all properties are own.\n\t  var key;\n\t  for (key in obj) {}\n\t\n\t  return key === undefined || core_hasOwn.call(obj, key);\n\t}\n\t\n\t\n\tfunction isFunction(obj) {\n\t  return type(obj) === \"function\";\n\t}\n\t\n\tvar isArray = Array.isArray || function (obj) {\n\t  return type(obj) === \"array\";\n\t};\n\t\n\tfunction extend() {\n\t  // originally extend() was recursive, but this ended up giving us\n\t  // \"call stack exceeded\", so it's been unrolled to use a literal stack\n\t  // (see https://github.com/pouchdb/pouchdb/issues/2543)\n\t  var stack = [];\n\t  var i = -1;\n\t  var len = arguments.length;\n\t  var args = new Array(len);\n\t  while (++i < len) {\n\t    args[i] = arguments[i];\n\t  }\n\t  var container = {};\n\t  stack.push({args: args, result: {container: container, key: 'key'}});\n\t  var next;\n\t  while ((next = stack.pop())) {\n\t    extendInner(stack, next.args, next.result);\n\t  }\n\t  return container.key;\n\t}\n\t\n\tfunction extendInner(stack, args, result) {\n\t  var options, name, src, copy, copyIsArray, clone,\n\t    target = args[0] || {},\n\t    i = 1,\n\t    length = args.length,\n\t    deep = false,\n\t    numericStringRegex = /\\d+/,\n\t    optionsIsArray;\n\t\n\t  // Handle a deep copy situation\n\t  if (typeof target === \"boolean\") {\n\t    deep = target;\n\t    target = args[1] || {};\n\t    // skip the boolean and the target\n\t    i = 2;\n\t  }\n\t\n\t  // Handle case when target is a string or something (possible in deep copy)\n\t  if (typeof target !== \"object\" && !isFunction(target)) {\n\t    target = {};\n\t  }\n\t\n\t  // extend jQuery itself if only one argument is passed\n\t  if (length === i) {\n\t    /* jshint validthis: true */\n\t    target = this;\n\t    --i;\n\t  }\n\t\n\t  for (; i < length; i++) {\n\t    // Only deal with non-null/undefined values\n\t    if ((options = args[i]) != null) {\n\t      optionsIsArray = isArray(options);\n\t      // Extend the base object\n\t      for (name in options) {\n\t        //if (options.hasOwnProperty(name)) {\n\t        if (!(name in Object.prototype)) {\n\t          if (optionsIsArray && !numericStringRegex.test(name)) {\n\t            continue;\n\t          }\n\t\n\t          src = target[name];\n\t          copy = options[name];\n\t\n\t          // Prevent never-ending loop\n\t          if (target === copy) {\n\t            continue;\n\t          }\n\t\n\t          // Recurse if we're merging plain objects or arrays\n\t          if (deep && copy && (isPlainObject(copy) ||\n\t              (copyIsArray = isArray(copy)))) {\n\t            if (copyIsArray) {\n\t              copyIsArray = false;\n\t              clone = src && isArray(src) ? src : [];\n\t\n\t            } else {\n\t              clone = src && isPlainObject(src) ? src : {};\n\t            }\n\t\n\t            // Never move original objects, clone them\n\t            stack.push({\n\t              args: [deep, clone, copy],\n\t              result: {\n\t                container: target,\n\t                key: name\n\t              }\n\t            });\n\t\n\t          // Don't bring in undefined values\n\t          } else if (copy !== undefined) {\n\t            if (!(isArray(options) && isFunction(copy))) {\n\t              target[name] = copy;\n\t            }\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }\n\t\n\t  // \"Return\" the modified object by setting the key\n\t  // on the given container\n\t  result.container[result.key] = target;\n\t}\n\t\n\t\n\tmodule.exports = extend;\n\t\n\t\n\n\n/***/ },\n/* 103 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar upsert = __webpack_require__(107).upsert;\n\t\n\tmodule.exports = function (db, doc, diffFun) {\n\t  return upsert.apply(db, [doc, diffFun]);\n\t};\n\n/***/ },\n/* 104 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(16);\n\t\n\tvar localUtils = __webpack_require__(35);\n\tvar massageIndexDef = localUtils.massageIndexDef;\n\t\n\tfunction getIndexes(db) {\n\t  // just search through all the design docs and filter in-memory.\n\t  // hopefully there aren't that many ddocs.\n\t  return db.allDocs({\n\t    startkey: '_design/',\n\t    endkey: '_design/\\uffff',\n\t    include_docs: true\n\t  }).then(function (allDocsRes) {\n\t    var res = {\n\t      indexes: [{\n\t        ddoc: null,\n\t        name: '_all_docs',\n\t        type: 'special',\n\t        def: {\n\t          fields: [{_id: 'asc'}]\n\t        }\n\t      }]\n\t    };\n\t\n\t    res.indexes = utils.flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n\t      return row.doc.language === 'query';\n\t    }).map(function (row) {\n\t      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\t\n\t      return viewNames.map(function (viewName) {\n\t        var view = row.doc.views[viewName];\n\t        return {\n\t          ddoc: row.id,\n\t          name: viewName,\n\t          type: 'json',\n\t          def: massageIndexDef(view.options.def)\n\t        };\n\t      });\n\t    }));\n\t\n\t    // these are sorted by view name for some reason\n\t    res.indexes.sort(function (left, right) {\n\t      return utils.compare(left.name, right.name);\n\t    });\n\t    res.total_rows = res.indexes.length;\n\t    return res;\n\t  });\n\t}\n\t\n\tmodule.exports = getIndexes;\n\n\n/***/ },\n/* 105 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(16);\n\tvar clone = utils.clone;\n\t\n\t// we restucture the supplied JSON considerably, because the official\n\t// Mango API is very particular about a lot of this stuff, but we like\n\t// to be liberal with what we accept in order to prevent mental\n\t// breakdowns in our users\n\tmodule.exports = function (requestDef) {\n\t  requestDef = clone(requestDef);\n\t\n\t  if (!requestDef.index) {\n\t    requestDef.index = {};\n\t  }\n\t\n\t  ['type', 'name', 'ddoc'].forEach(function (key) {\n\t    if (requestDef.index[key]) {\n\t      requestDef[key] = requestDef.index[key];\n\t      delete requestDef.index[key];\n\t    }\n\t  });\n\t\n\t  if (requestDef.fields) {\n\t    requestDef.index.fields = requestDef.fields;\n\t    delete requestDef.fields;\n\t  }\n\t\n\t  if (!requestDef.type) {\n\t    requestDef.type = 'json';\n\t  }\n\t  return requestDef;\n\t};\n\n/***/ },\n/* 106 */\n[253, 238],\n/* 107 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar PouchPromise = __webpack_require__(240);\n\t\n\t// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n\t// the diffFun tells us what delta to apply to the doc.  it either returns\n\t// the doc, or false if it doesn't need to do an update after all\n\tfunction upsertInner(db, docId, diffFun) {\n\t  if (typeof docId !== 'string') {\n\t    return PouchPromise.reject(new Error('doc id is required'));\n\t  }\n\t\n\t  return db.get(docId).catch(function (err) {\n\t    /* istanbul ignore next */\n\t    if (err.status !== 404) {\n\t      throw err;\n\t    }\n\t    return {};\n\t  }).then(function (doc) {\n\t    // the user might change the _rev, so save it for posterity\n\t    var docRev = doc._rev;\n\t    var newDoc = diffFun(doc);\n\t\n\t    if (!newDoc) {\n\t      // if the diffFun returns falsy, we short-circuit as\n\t      // an optimization\n\t      return { updated: false, rev: docRev };\n\t    }\n\t\n\t    // users aren't allowed to modify these values,\n\t    // so reset them here\n\t    newDoc._id = docId;\n\t    newDoc._rev = docRev;\n\t    return tryAndPut(db, newDoc, diffFun);\n\t  });\n\t}\n\t\n\tfunction tryAndPut(db, doc, diffFun) {\n\t  return db.put(doc).then(function (res) {\n\t    return {\n\t      updated: true,\n\t      rev: res.rev\n\t    };\n\t  }, function (err) {\n\t    /* istanbul ignore next */\n\t    if (err.status !== 409) {\n\t      throw err;\n\t    }\n\t    return upsertInner(db, doc._id, diffFun);\n\t  });\n\t}\n\t\n\texports.upsert = function upsert(docId, diffFun, cb) {\n\t  var db = this;\n\t  var promise = upsertInner(db, docId, diffFun);\n\t  if (typeof cb !== 'function') {\n\t    return promise;\n\t  }\n\t  promise.then(function (resp) {\n\t    cb(null, resp);\n\t  }, cb);\n\t};\n\t\n\texports.putIfNotExists = function putIfNotExists(docId, doc, cb) {\n\t  var db = this;\n\t\n\t  if (typeof docId !== 'string') {\n\t    cb = doc;\n\t    doc = docId;\n\t    docId = doc._id;\n\t  }\n\t\n\t  var diffFun = function (existingDoc) {\n\t    if (existingDoc._rev) {\n\t      return false; // do nothing\n\t    }\n\t    return doc;\n\t  };\n\t\n\t  var promise = upsertInner(db, docId, diffFun);\n\t  if (typeof cb !== 'function') {\n\t    return promise;\n\t  }\n\t  promise.then(function (resp) {\n\t    cb(null, resp);\n\t  }, cb);\n\t};\n\t\n\t\n\t/* istanbul ignore next */\n\tif (typeof window !== 'undefined' && window.PouchDB) {\n\t  window.PouchDB.plugin(exports);\n\t}\n\n\n/***/ },\n/* 108 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*jshint bitwise:false*/\n\t/*global unescape*/\n\t\n\t(function (factory) {\n\t    if (true) {\n\t        // Node/CommonJS\n\t        module.exports = factory();\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        // AMD\n\t        define(factory);\n\t    } else {\n\t        // Browser globals (with support for web workers)\n\t        var glob;\n\t        try {\n\t            glob = window;\n\t        } catch (e) {\n\t            glob = self;\n\t        }\n\t\n\t        glob.SparkMD5 = factory();\n\t    }\n\t}(function (undefined) {\n\t\n\t    'use strict';\n\t\n\t    ////////////////////////////////////////////////////////////////////////////\n\t\n\t    /*\n\t     * Fastest md5 implementation around (JKM md5)\n\t     * Credits: Joseph Myers\n\t     *\n\t     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n\t     * @see http://jsperf.com/md5-shootout/7\n\t     */\n\t\n\t    /* this function is much faster,\n\t      so if possible we use it. Some IEs\n\t      are the only ones I know of that\n\t      need the idiotic second function,\n\t      generated by an if clause.  */\n\t    var add32 = function (a, b) {\n\t        return (a + b) & 0xFFFFFFFF;\n\t    },\n\t\n\t    cmn = function (q, a, b, x, s, t) {\n\t        a = add32(add32(a, q), add32(x, t));\n\t        return add32((a << s) | (a >>> (32 - s)), b);\n\t    },\n\t\n\t    ff = function (a, b, c, d, x, s, t) {\n\t        return cmn((b & c) | ((~b) & d), a, b, x, s, t);\n\t    },\n\t\n\t    gg = function (a, b, c, d, x, s, t) {\n\t        return cmn((b & d) | (c & (~d)), a, b, x, s, t);\n\t    },\n\t\n\t    hh = function (a, b, c, d, x, s, t) {\n\t        return cmn(b ^ c ^ d, a, b, x, s, t);\n\t    },\n\t\n\t    ii = function (a, b, c, d, x, s, t) {\n\t        return cmn(c ^ (b | (~d)), a, b, x, s, t);\n\t    },\n\t\n\t    md5cycle = function (x, k) {\n\t        var a = x[0],\n\t            b = x[1],\n\t            c = x[2],\n\t            d = x[3];\n\t\n\t        a = ff(a, b, c, d, k[0], 7, -680876936);\n\t        d = ff(d, a, b, c, k[1], 12, -389564586);\n\t        c = ff(c, d, a, b, k[2], 17, 606105819);\n\t        b = ff(b, c, d, a, k[3], 22, -1044525330);\n\t        a = ff(a, b, c, d, k[4], 7, -176418897);\n\t        d = ff(d, a, b, c, k[5], 12, 1200080426);\n\t        c = ff(c, d, a, b, k[6], 17, -1473231341);\n\t        b = ff(b, c, d, a, k[7], 22, -45705983);\n\t        a = ff(a, b, c, d, k[8], 7, 1770035416);\n\t        d = ff(d, a, b, c, k[9], 12, -1958414417);\n\t        c = ff(c, d, a, b, k[10], 17, -42063);\n\t        b = ff(b, c, d, a, k[11], 22, -1990404162);\n\t        a = ff(a, b, c, d, k[12], 7, 1804603682);\n\t        d = ff(d, a, b, c, k[13], 12, -40341101);\n\t        c = ff(c, d, a, b, k[14], 17, -1502002290);\n\t        b = ff(b, c, d, a, k[15], 22, 1236535329);\n\t\n\t        a = gg(a, b, c, d, k[1], 5, -165796510);\n\t        d = gg(d, a, b, c, k[6], 9, -1069501632);\n\t        c = gg(c, d, a, b, k[11], 14, 643717713);\n\t        b = gg(b, c, d, a, k[0], 20, -373897302);\n\t        a = gg(a, b, c, d, k[5], 5, -701558691);\n\t        d = gg(d, a, b, c, k[10], 9, 38016083);\n\t        c = gg(c, d, a, b, k[15], 14, -660478335);\n\t        b = gg(b, c, d, a, k[4], 20, -405537848);\n\t        a = gg(a, b, c, d, k[9], 5, 568446438);\n\t        d = gg(d, a, b, c, k[14], 9, -1019803690);\n\t        c = gg(c, d, a, b, k[3], 14, -187363961);\n\t        b = gg(b, c, d, a, k[8], 20, 1163531501);\n\t        a = gg(a, b, c, d, k[13], 5, -1444681467);\n\t        d = gg(d, a, b, c, k[2], 9, -51403784);\n\t        c = gg(c, d, a, b, k[7], 14, 1735328473);\n\t        b = gg(b, c, d, a, k[12], 20, -1926607734);\n\t\n\t        a = hh(a, b, c, d, k[5], 4, -378558);\n\t        d = hh(d, a, b, c, k[8], 11, -2022574463);\n\t        c = hh(c, d, a, b, k[11], 16, 1839030562);\n\t        b = hh(b, c, d, a, k[14], 23, -35309556);\n\t        a = hh(a, b, c, d, k[1], 4, -1530992060);\n\t        d = hh(d, a, b, c, k[4], 11, 1272893353);\n\t        c = hh(c, d, a, b, k[7], 16, -155497632);\n\t        b = hh(b, c, d, a, k[10], 23, -1094730640);\n\t        a = hh(a, b, c, d, k[13], 4, 681279174);\n\t        d = hh(d, a, b, c, k[0], 11, -358537222);\n\t        c = hh(c, d, a, b, k[3], 16, -722521979);\n\t        b = hh(b, c, d, a, k[6], 23, 76029189);\n\t        a = hh(a, b, c, d, k[9], 4, -640364487);\n\t        d = hh(d, a, b, c, k[12], 11, -421815835);\n\t        c = hh(c, d, a, b, k[15], 16, 530742520);\n\t        b = hh(b, c, d, a, k[2], 23, -995338651);\n\t\n\t        a = ii(a, b, c, d, k[0], 6, -198630844);\n\t        d = ii(d, a, b, c, k[7], 10, 1126891415);\n\t        c = ii(c, d, a, b, k[14], 15, -1416354905);\n\t        b = ii(b, c, d, a, k[5], 21, -57434055);\n\t        a = ii(a, b, c, d, k[12], 6, 1700485571);\n\t        d = ii(d, a, b, c, k[3], 10, -1894986606);\n\t        c = ii(c, d, a, b, k[10], 15, -1051523);\n\t        b = ii(b, c, d, a, k[1], 21, -2054922799);\n\t        a = ii(a, b, c, d, k[8], 6, 1873313359);\n\t        d = ii(d, a, b, c, k[15], 10, -30611744);\n\t        c = ii(c, d, a, b, k[6], 15, -1560198380);\n\t        b = ii(b, c, d, a, k[13], 21, 1309151649);\n\t        a = ii(a, b, c, d, k[4], 6, -145523070);\n\t        d = ii(d, a, b, c, k[11], 10, -1120210379);\n\t        c = ii(c, d, a, b, k[2], 15, 718787259);\n\t        b = ii(b, c, d, a, k[9], 21, -343485551);\n\t\n\t        x[0] = add32(a, x[0]);\n\t        x[1] = add32(b, x[1]);\n\t        x[2] = add32(c, x[2]);\n\t        x[3] = add32(d, x[3]);\n\t    },\n\t\n\t    /* there needs to be support for Unicode here,\n\t       * unless we pretend that we can redefine the MD-5\n\t       * algorithm for multi-byte characters (perhaps\n\t       * by adding every four 16-bit characters and\n\t       * shortening the sum to 32 bits). Otherwise\n\t       * I suggest performing MD-5 as if every character\n\t       * was two bytes--e.g., 0040 0025 = @%--but then\n\t       * how will an ordinary MD-5 sum be matched?\n\t       * There is no way to standardize text to something\n\t       * like UTF-8 before transformation; speed cost is\n\t       * utterly prohibitive. The JavaScript standard\n\t       * itself needs to look at this: it should start\n\t       * providing access to strings as preformed UTF-8\n\t       * 8-bit unsigned value arrays.\n\t       */\n\t    md5blk = function (s) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n\t        }\n\t        return md5blks;\n\t    },\n\t\n\t    md5blk_array = function (a) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n\t        }\n\t        return md5blks;\n\t    },\n\t\n\t    md51 = function (s) {\n\t        var n = s.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk(s.substring(i - 64, i)));\n\t        }\n\t        s = s.substring(i - 64);\n\t        length = s.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t        return state;\n\t    },\n\t\n\t    md51_array = function (a) {\n\t        var n = a.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n\t        }\n\t\n\t        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n\t        // containing the last element of the parent array if the sub array specified starts\n\t        // beyond the length of the parent array - weird.\n\t        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n\t        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\t\n\t        length = a.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t\n\t        return state;\n\t    },\n\t\n\t    hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'],\n\t\n\t    rhex = function (n) {\n\t        var s = '',\n\t            j;\n\t        for (j = 0; j < 4; j += 1) {\n\t            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n\t        }\n\t        return s;\n\t    },\n\t\n\t    hex = function (x) {\n\t        var i;\n\t        for (i = 0; i < x.length; i += 1) {\n\t            x[i] = rhex(x[i]);\n\t        }\n\t        return x.join('');\n\t    },\n\t\n\t    md5 = function (s) {\n\t        return hex(md51(s));\n\t    },\n\t\n\t\n\t\n\t    ////////////////////////////////////////////////////////////////////////////\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation.\n\t     *\n\t     * Use this class to perform an incremental md5, otherwise use the\n\t     * static methods instead.\n\t     */\n\t    SparkMD5 = function () {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    };\n\t\n\t\n\t    // In some cases the fast add32 function cannot be used..\n\t    if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {\n\t        add32 = function (x, y) {\n\t            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n\t                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t            return (msw << 16) | (lsw & 0xFFFF);\n\t        };\n\t    }\n\t\n\t\n\t    /**\n\t     * Appends a string.\n\t     * A conversion will be applied if an utf8 string is detected.\n\t     *\n\t     * @param {String} str The string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.append = function (str) {\n\t        // converts the string to utf8 bytes if necessary\n\t        if (/[\\u0080-\\uFFFF]/.test(str)) {\n\t            str = unescape(encodeURIComponent(str));\n\t        }\n\t\n\t        // then append as binary\n\t        this.appendBinary(str);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Appends a binary string.\n\t     *\n\t     * @param {String} contents The binary string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.appendBinary = function (contents) {\n\t        this._buff += contents;\n\t        this._length += contents.length;\n\t\n\t        var length = this._buff.length,\n\t            i;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._state, md5blk(this._buff.substring(i - 64, i)));\n\t        }\n\t\n\t        this._buff = this._buff.substr(i - 64);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     * Use the raw parameter to obtain the raw result instead of the hex one.\n\t     *\n\t     * @param {Boolean} raw True to get the raw result, false to get the hex result\n\t     *\n\t     * @return {String|Array} The result\n\t     */\n\t    SparkMD5.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            i,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = !!raw ? this._state : hex(this._state);\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Finish the final calculation based on the tail.\n\t     *\n\t     * @param {Array}  tail   The tail (will be modified)\n\t     * @param {Number} length The length of the remaining buffer\n\t     */\n\t    SparkMD5.prototype._finish = function (tail, length) {\n\t        var i = length,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(this._state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Do the final computation based on the tail and length\n\t        // Beware that the final length may not fit in 32 bits so we take care of that\n\t        tmp = this._length * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t        md5cycle(this._state, tail);\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.reset = function () {\n\t        this._buff = \"\";\n\t        this._length = 0;\n\t        this._state = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Releases memory used by the incremental buffer and other aditional\n\t     * resources. If you plan to use the instance again, use reset instead.\n\t     */\n\t    SparkMD5.prototype.destroy = function () {\n\t        delete this._state;\n\t        delete this._buff;\n\t        delete this._length;\n\t    };\n\t\n\t\n\t    /**\n\t     * Performs the md5 hash on a string.\n\t     * A conversion will be applied if utf8 string is detected.\n\t     *\n\t     * @param {String}  str The string\n\t     * @param {Boolean} raw True to get the raw result, false to get the hex result\n\t     *\n\t     * @return {String|Array} The result\n\t     */\n\t    SparkMD5.hash = function (str, raw) {\n\t        // converts the string to utf8 bytes if necessary\n\t        if (/[\\u0080-\\uFFFF]/.test(str)) {\n\t            str = unescape(encodeURIComponent(str));\n\t        }\n\t\n\t        var hash = md51(str);\n\t\n\t        return !!raw ? hash : hex(hash);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a binary string.\n\t     *\n\t     * @param {String}  content The binary string\n\t     * @param {Boolean} raw     True to get the raw result, false to get the hex result\n\t     *\n\t     * @return {String|Array} The result\n\t     */\n\t    SparkMD5.hashBinary = function (content, raw) {\n\t        var hash = md51(content);\n\t\n\t        return !!raw ? hash : hex(hash);\n\t    };\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation for array buffers.\n\t     *\n\t     * Use this class to perform an incremental md5 ONLY for array buffers.\n\t     */\n\t    SparkMD5.ArrayBuffer = function () {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    };\n\t\n\t    ////////////////////////////////////////////////////////////////////////////\n\t\n\t    /**\n\t     * Appends an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array to be appended\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n\t        // TODO: we could avoid the concatenation here but the algorithm would be more complex\n\t        //       if you find yourself needing extra performance, please make a PR.\n\t        var buff = this._concatArrayBuffer(this._buff, arr),\n\t            length = buff.length,\n\t            i;\n\t\n\t        this._length += arr.byteLength;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._state, md5blk_array(buff.subarray(i - 64, i)));\n\t        }\n\t\n\t        // Avoids IE10 weirdness (documented above)\n\t        this._buff = (i - 64) < length ? buff.subarray(i - 64) : new Uint8Array(0);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     * Use the raw parameter to obtain the raw result instead of the hex one.\n\t     *\n\t     * @param {Boolean} raw True to get the raw result, false to get the hex result\n\t     *\n\t     * @return {String|Array} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            i,\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = !!raw ? this._state : hex(this._state);\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.reset = function () {\n\t        this._buff = new Uint8Array(0);\n\t        this._length = 0;\n\t        this._state = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Releases memory used by the incremental buffer and other aditional\n\t     * resources. If you plan to use the instance again, use reset instead.\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\t\n\t    /**\n\t     * Concats two array buffers, returning a new one.\n\t     *\n\t     * @param  {ArrayBuffer} first  The first array buffer\n\t     * @param  {ArrayBuffer} second The second array buffer\n\t     *\n\t     * @return {ArrayBuffer} The new array buffer\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype._concatArrayBuffer = function (first, second) {\n\t        var firstLength = first.length,\n\t            result = new Uint8Array(firstLength + second.byteLength);\n\t\n\t        result.set(first);\n\t        result.set(new Uint8Array(second), firstLength);\n\t\n\t        return result;\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array buffer\n\t     * @param {Boolean}     raw True to get the raw result, false to get the hex result\n\t     *\n\t     * @return {String|Array} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n\t        var hash = md51_array(new Uint8Array(arr));\n\t\n\t        return !!raw ? hash : hex(hash);\n\t    };\n\t\n\t    return SparkMD5;\n\t}));\n\n\n/***/ },\n/* 109 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar LocalStorage = exports.LocalStorage = function () {\n\t  function LocalStorage(storage, prefix) {\n\t    _classCallCheck(this, LocalStorage);\n\t\n\t    if (!storage && typeof window !== 'undefined') {\n\t      storage = window.localStorage;\n\t    }\n\t    this.storage = storage;\n\t    this.prefix = prefix || 'cozy:oauth:';\n\t  }\n\t\n\t  _createClass(LocalStorage, [{\n\t    key: 'save',\n\t    value: function save(key, value) {\n\t      var _this = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        _this.storage.setItem(_this.prefix + key, JSON.stringify(value));\n\t        resolve(value);\n\t      });\n\t    }\n\t  }, {\n\t    key: 'load',\n\t    value: function load(key) {\n\t      var _this2 = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        var item = _this2.storage.getItem(_this2.prefix + key);\n\t        if (!item) {\n\t          resolve();\n\t        } else {\n\t          resolve(JSON.parse(item));\n\t        }\n\t      });\n\t    }\n\t  }, {\n\t    key: 'delete',\n\t    value: function _delete(key) {\n\t      var _this3 = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        return resolve(_this3.storage.removeItem(_this3.prefix + key));\n\t      });\n\t    }\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      var _this4 = this;\n\t\n\t      return new Promise(function (resolve) {\n\t        var storage = _this4.storage;\n\t        for (var i = 0; i < storage.length; i++) {\n\t          var key = storage.key(i);\n\t          if (key.indexOf(_this4.prefix) === 0) {\n\t            storage.removeItem(key);\n\t          }\n\t        }\n\t        resolve();\n\t      });\n\t    }\n\t  }]);\n\t\n\t  return LocalStorage;\n\t}();\n\t\n\tvar MemoryStorage = exports.MemoryStorage = function () {\n\t  function MemoryStorage() {\n\t    _classCallCheck(this, MemoryStorage);\n\t\n\t    this.hash = Object.create(null);\n\t  }\n\t\n\t  _createClass(MemoryStorage, [{\n\t    key: 'save',\n\t    value: function save(key, value) {\n\t      this.hash[key] = value;\n\t      return Promise.resolve(value);\n\t    }\n\t  }, {\n\t    key: 'load',\n\t    value: function load(key) {\n\t      return Promise.resolve(this.hash[key]);\n\t    }\n\t  }, {\n\t    key: 'delete',\n\t    value: function _delete(key) {\n\t      var deleted = delete this.hash[key];\n\t      return Promise.resolve(deleted);\n\t    }\n\t  }, {\n\t    key: 'clear',\n\t    value: function clear() {\n\t      this.hash = Object.create(null);\n\t      return Promise.resolve();\n\t    }\n\t  }]);\n\n\t  return MemoryStorage;\n\t}();\n\n/***/ },\n/* 110 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\texports.getAppToken = getAppToken;\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t/* global btoa */\n\tvar V2TOKEN_ABORT_TIMEOUT = 3000;\n\t\n\tfunction getAppToken() {\n\t  return new Promise(function (resolve, reject) {\n\t    if (typeof window === 'undefined') {\n\t      return reject(new Error('getV2Token should be used in browser'));\n\t    } else if (!window.parent) {\n\t      return reject(new Error('getV2Token should be used in iframe'));\n\t    } else if (!window.parent.postMessage) {\n\t      return reject(new Error('getV2Token should be used in modern browser'));\n\t    }\n\t    var origin = window.location.origin;\n\t    var intent = { action: 'getToken' };\n\t    var timeout = null;\n\t    var receiver = function receiver(event) {\n\t      var token = void 0;\n\t      try {\n\t        token = new AppToken({\n\t          appName: event.data.appName,\n\t          token: event.data.token\n\t        });\n\t      } catch (e) {\n\t        reject(e);\n\t        return;\n\t      }\n\t      window.removeEventListener('message', receiver);\n\t      clearTimeout(timeout);\n\t      resolve({ client: null, token: token });\n\t    };\n\t    window.addEventListener('message', receiver, false);\n\t    window.parent.postMessage(intent, origin);\n\t    timeout = setTimeout(function () {\n\t      reject(new Error('No response from parent iframe after 3s'));\n\t    }, V2TOKEN_ABORT_TIMEOUT);\n\t  });\n\t}\n\t\n\tvar AppToken = exports.AppToken = function () {\n\t  function AppToken(opts) {\n\t    _classCallCheck(this, AppToken);\n\t\n\t    this.appName = opts.appName || '';\n\t    this.token = opts.token || '';\n\t  }\n\t\n\t  _createClass(AppToken, [{\n\t    key: 'toAuthHeader',\n\t    value: function toAuthHeader() {\n\t      return 'Basic ' + btoa(this.appName + ':' + this.token);\n\t    }\n\t  }]);\n\n\t  return AppToken;\n\t}();\n\n/***/ },\n/* 111 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.create = create;\n\texports.find = find;\n\texports.findMany = findMany;\n\texports.findAll = findAll;\n\texports.changesFeed = changesFeed;\n\texports.update = update;\n\texports.updateAttributes = updateAttributes;\n\texports._delete = _delete;\n\t\n\tvar _utils = __webpack_require__(22);\n\t\n\tvar _doctypes = __webpack_require__(36);\n\t\n\tvar _fetch = __webpack_require__(13);\n\t\n\tvar NOREV = 'stack-v2-no-rev';\n\t\n\tfunction create(cozy, doctype, attributes) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    if (isV2) {\n\t      attributes.docType = doctype;\n\t    }\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, attributes._id);\n\t    var httpVerb = attributes._id ? 'PUT' : 'POST';\n\t    delete attributes._id;\n\t    return (0, _fetch.cozyFetchJSON)(cozy, httpVerb, path, attributes).then(function (resp) {\n\t      if (isV2) {\n\t        return find(cozy, doctype, resp._id);\n\t      } else {\n\t        return resp.data;\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\tfunction find(cozy, doctype, id) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t\n\t    if (!id) {\n\t      return Promise.reject(new Error('Missing id parameter'));\n\t    }\n\t\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, id);\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'GET', path).then(function (resp) {\n\t      if (isV2) {\n\t        return Object.assign(resp, { _rev: NOREV });\n\t      } else {\n\t        return resp;\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\tfunction findMany(cozy, doctype, ids) {\n\t  if (!(ids instanceof Array)) {\n\t    return Promise.reject(new Error('Parameter ids must be a non-empty array'));\n\t  }\n\t  if (ids.length === 0) {\n\t    // So users don't need to be defensive regarding the array content.\n\t    // This should not hide issues in user code since the result will be an\n\t    // empty object anyway.\n\t    return Promise.resolve({});\n\t  }\n\t\n\t  return cozy.isV2().then(function (isV2) {\n\t    if (isV2) {\n\t      return Promise.reject(new Error('findMany is not available on v2'));\n\t    }\n\t\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, '_all_docs', { include_docs: true });\n\t\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, { keys: ids }).then(function (resp) {\n\t      var docs = {};\n\t\n\t      var _iteratorNormalCompletion = true;\n\t      var _didIteratorError = false;\n\t      var _iteratorError = undefined;\n\t\n\t      try {\n\t        for (var _iterator = resp.rows[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t          var row = _step.value;\n\t          var key = row.key,\n\t              doc = row.doc,\n\t              error = row.error;\n\t\n\t          docs[key] = error ? { error: error } : { doc: doc };\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError = true;\n\t        _iteratorError = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion && _iterator.return) {\n\t            _iterator.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError) {\n\t            throw _iteratorError;\n\t          }\n\t        }\n\t      }\n\t\n\t      return docs;\n\t    }).catch(function (error) {\n\t      if (error.status !== 404) return Promise.reject(error);\n\t\n\t      // When no doc was ever created and the database does not exist yet,\n\t      // the response will be a 404 error.\n\t      var docs = {};\n\t\n\t      var _iteratorNormalCompletion2 = true;\n\t      var _didIteratorError2 = false;\n\t      var _iteratorError2 = undefined;\n\t\n\t      try {\n\t        for (var _iterator2 = ids[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t          var id = _step2.value;\n\t\n\t          docs[id] = { error: error };\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError2 = true;\n\t        _iteratorError2 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t            _iterator2.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError2) {\n\t            throw _iteratorError2;\n\t          }\n\t        }\n\t      }\n\t\n\t      return docs;\n\t    });\n\t  });\n\t}\n\t\n\tfunction findAll(cozy, doctype) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    if (isV2) {\n\t      return Promise.reject(new Error('findAll is not available on v2'));\n\t    }\n\t\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, '_all_docs', { include_docs: true });\n\t\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, {}).then(function (resp) {\n\t      var docs = [];\n\t\n\t      var _iteratorNormalCompletion3 = true;\n\t      var _didIteratorError3 = false;\n\t      var _iteratorError3 = undefined;\n\t\n\t      try {\n\t        for (var _iterator3 = resp.rows[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t          var row = _step3.value;\n\t          var doc = row.doc;\n\t          // if not couchDB indexes\n\t\n\t          if (!doc._id.match(/_design\\//)) docs.push(doc);\n\t        }\n\t      } catch (err) {\n\t        _didIteratorError3 = true;\n\t        _iteratorError3 = err;\n\t      } finally {\n\t        try {\n\t          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t            _iterator3.return();\n\t          }\n\t        } finally {\n\t          if (_didIteratorError3) {\n\t            throw _iteratorError3;\n\t          }\n\t        }\n\t      }\n\t\n\t      return docs;\n\t    }).catch(function (error) {\n\t      // the _all_docs endpoint returns a 404 error if no document with the given\n\t      // doctype exists.\n\t      if (error.status === 404) return [];\n\t      throw error;\n\t    });\n\t  });\n\t}\n\t\n\tfunction changesFeed(cozy, doctype, options) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, '_changes', options);\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'GET', path);\n\t  });\n\t}\n\t\n\tfunction update(cozy, doctype, doc, changes) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    var _id = doc._id,\n\t        _rev = doc._rev;\n\t\n\t\n\t    if (!_id) {\n\t      return Promise.reject(new Error('Missing _id field in passed document'));\n\t    }\n\t\n\t    if (!isV2 && !_rev) {\n\t      return Promise.reject(new Error('Missing _rev field in passed document'));\n\t    }\n\t\n\t    if (isV2) {\n\t      changes = Object.assign({ _id: _id }, changes);\n\t    } else {\n\t      changes = Object.assign({ _id: _id, _rev: _rev }, changes);\n\t    }\n\t\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, _id);\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'PUT', path, changes).then(function (resp) {\n\t      if (isV2) {\n\t        return find(cozy, doctype, _id);\n\t      } else {\n\t        return resp.data;\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\tfunction updateAttributes(cozy, doctype, _id, changes) {\n\t  var tries = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 3;\n\t\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    return find(cozy, doctype, _id).then(function (doc) {\n\t      return update(cozy, doctype, doc, Object.assign({ _id: _id }, doc, changes));\n\t    }).catch(function (err) {\n\t      if (tries > 0) {\n\t        return updateAttributes(cozy, doctype, _id, changes, tries - 1);\n\t      } else {\n\t        throw err;\n\t      }\n\t    });\n\t  });\n\t}\n\t\n\tfunction _delete(cozy, doctype, doc) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    var _id = doc._id,\n\t        _rev = doc._rev;\n\t\n\t\n\t    if (!_id) {\n\t      return Promise.reject(new Error('Missing _id field in passed document'));\n\t    }\n\t\n\t    if (!isV2 && !_rev) {\n\t      return Promise.reject(new Error('Missing _rev field in passed document'));\n\t    }\n\t\n\t    var query = isV2 ? null : { rev: _rev };\n\t    var path = (0, _utils.createPath)(cozy, isV2, doctype, _id, query);\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', path).then(function (resp) {\n\t      if (isV2) {\n\t        return { id: _id, rev: NOREV };\n\t      } else {\n\t        return resp;\n\t      }\n\t    });\n\t  });\n\t}\n\n/***/ },\n/* 112 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.TRASH_DIR_ID = exports.ROOT_DIR_ID = undefined;\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; /* global Blob, File */\n\t\n\t\n\texports.create = create;\n\texports.createDirectory = createDirectory;\n\texports.createDirectoryByPath = createDirectoryByPath;\n\texports.updateById = updateById;\n\texports.updateAttributesById = updateAttributesById;\n\texports.updateAttributesByPath = updateAttributesByPath;\n\texports.trashById = trashById;\n\texports.statById = statById;\n\texports.statByPath = statByPath;\n\texports.downloadById = downloadById;\n\texports.downloadByPath = downloadByPath;\n\texports.getDownloadLinkByPath = getDownloadLinkByPath;\n\texports.getDownloadLinkById = getDownloadLinkById;\n\texports.getFilePath = getFilePath;\n\texports.getCollectionShareLink = getCollectionShareLink;\n\texports.getArchiveLinkByPaths = getArchiveLinkByPaths;\n\texports.getArchiveLinkByIds = getArchiveLinkByIds;\n\texports.listTrash = listTrash;\n\texports.clearTrash = clearTrash;\n\texports.restoreById = restoreById;\n\texports.destroyById = destroyById;\n\t\n\tvar _fetch = __webpack_require__(13);\n\t\n\tvar _jsonapi = __webpack_require__(79);\n\t\n\tvar _jsonapi2 = _interopRequireDefault(_jsonapi);\n\t\n\tvar _doctypes = __webpack_require__(36);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// global variables\n\tvar ROOT_DIR_ID = exports.ROOT_DIR_ID = 'io.cozy.files.root-dir';\n\tvar TRASH_DIR_ID = exports.TRASH_DIR_ID = 'io.cozy.files.trash-dir';\n\t\n\tvar contentTypeOctetStream = 'application/octet-stream';\n\t\n\tfunction doUpload(cozy, data, method, path, options) {\n\t  if (!data) {\n\t    throw new Error('missing data argument');\n\t  }\n\t\n\t  // transform any ArrayBufferView to ArrayBuffer\n\t  if (data.buffer && data.buffer instanceof ArrayBuffer) {\n\t    data = data.buffer;\n\t  }\n\t\n\t  var isBuffer = typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer;\n\t  var isFile = typeof File !== 'undefined' && data instanceof File;\n\t  var isBlob = typeof Blob !== 'undefined' && data instanceof Blob;\n\t  var isStream = data.readable === true && typeof data.pipe === 'function';\n\t  var isString = typeof data === 'string';\n\t\n\t  if (!isBuffer && !isFile && !isBlob && !isStream && !isString) {\n\t    throw new Error('invalid data type');\n\t  }\n\t\n\t  var _ref = options || {},\n\t      contentType = _ref.contentType,\n\t      checksum = _ref.checksum,\n\t      lastModifiedDate = _ref.lastModifiedDate,\n\t      ifMatch = _ref.ifMatch;\n\t\n\t  if (!contentType) {\n\t    if (isBuffer) {\n\t      contentType = contentTypeOctetStream;\n\t    } else if (isFile) {\n\t      contentType = data.type || contentTypeOctetStream;\n\t      if (!lastModifiedDate) {\n\t        lastModifiedDate = data.lastModifiedDate;\n\t      }\n\t    } else if (isBlob) {\n\t      contentType = data.type || contentTypeOctetStream;\n\t    } else if (isStream) {\n\t      contentType = contentTypeOctetStream;\n\t    } else if (typeof data === 'string') {\n\t      contentType = 'text/plain';\n\t    }\n\t  }\n\t\n\t  if (lastModifiedDate && typeof lastModifiedDate === 'string') {\n\t    lastModifiedDate = new Date(lastModifiedDate);\n\t  }\n\t\n\t  return (0, _fetch.cozyFetch)(cozy, path, {\n\t    method: method,\n\t    headers: {\n\t      'Content-Type': contentType,\n\t      'Content-MD5': checksum || '',\n\t      'Date': lastModifiedDate ? lastModifiedDate.toGMTString() : '',\n\t      'If-Match': ifMatch || ''\n\t    },\n\t    body: data\n\t  }).then(function (res) {\n\t    var json = res.json();\n\t    if (!res.ok) {\n\t      return json.then(function (err) {\n\t        throw err;\n\t      });\n\t    } else {\n\t      return json.then(_jsonapi2.default);\n\t    }\n\t  });\n\t}\n\t\n\tfunction create(cozy, data, options) {\n\t  var _ref2 = options || {},\n\t      name = _ref2.name,\n\t      dirID = _ref2.dirID,\n\t      executable = _ref2.executable;\n\t\n\t  // handle case where data is a file and contains the name\n\t\n\t\n\t  if (!name && typeof data.name === 'string') {\n\t    name = data.name;\n\t  }\n\t\n\t  if (typeof name !== 'string' || name === '') {\n\t    throw new Error('missing name argument');\n\t  }\n\t\n\t  if (executable === undefined) {\n\t    executable = false;\n\t  }\n\t\n\t  var path = '/files/' + encodeURIComponent(dirID || '');\n\t  var query = '?Name=' + encodeURIComponent(name) + '&Type=file&Executable=' + executable;\n\t  return doUpload(cozy, data, 'POST', '' + path + query, options);\n\t}\n\t\n\tfunction createDirectory(cozy, options) {\n\t  var _ref3 = options || {},\n\t      name = _ref3.name,\n\t      dirID = _ref3.dirID,\n\t      lastModifiedDate = _ref3.lastModifiedDate;\n\t\n\t  if (typeof name !== 'string' || name === '') {\n\t    throw new Error('missing name argument');\n\t  }\n\t\n\t  if (lastModifiedDate && typeof lastModifiedDate === 'string') {\n\t    lastModifiedDate = new Date(lastModifiedDate);\n\t  }\n\t\n\t  var path = '/files/' + encodeURIComponent(dirID || '');\n\t  var query = '?Name=' + encodeURIComponent(name) + '&Type=directory';\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '' + path + query, undefined, {\n\t    headers: {\n\t      'Date': lastModifiedDate ? lastModifiedDate.toGMTString() : ''\n\t    }\n\t  });\n\t}\n\t\n\tfunction getDirectoryOrCreate(cozy, name, parentDirectory) {\n\t  if (parentDirectory && !parentDirectory.attributes) throw new Error('Malformed parent directory');\n\t\n\t  var path = (parentDirectory._id === ROOT_DIR_ID ? '' : parentDirectory.attributes.path) + '/' + name;\n\t\n\t  return cozy.files.statByPath(path || '/').catch(function (error) {\n\t    var parsedError = JSON.parse(error.message);\n\t    var errors = parsedError.errors;\n\t    if (errors && errors.length && errors[0].status === '404') {\n\t      return cozy.files.createDirectory({\n\t        name: name,\n\t        dirID: parentDirectory && parentDirectory._id\n\t      });\n\t    }\n\t\n\t    throw errors;\n\t  });\n\t}\n\t\n\tfunction createDirectoryByPath(cozy, path) {\n\t  var parts = path.split('/').filter(function (part) {\n\t    return part !== '';\n\t  });\n\t\n\t  var rootDirectoryPromise = cozy.files.statById(ROOT_DIR_ID);\n\t\n\t  return parts.length ? parts.reduce(function (parentDirectoryPromise, part) {\n\t    return parentDirectoryPromise.then(function (parentDirectory) {\n\t      return getDirectoryOrCreate(cozy, part, parentDirectory);\n\t    });\n\t  }, rootDirectoryPromise) : rootDirectoryPromise;\n\t}\n\t\n\tfunction updateById(cozy, id, data, options) {\n\t  return doUpload(cozy, data, 'PUT', '/files/' + encodeURIComponent(id), options);\n\t}\n\t\n\tfunction doUpdateAttributes(cozy, attrs, path, options) {\n\t  if (!attrs || (typeof attrs === 'undefined' ? 'undefined' : _typeof(attrs)) !== 'object') {\n\t    throw new Error('missing attrs argument');\n\t  }\n\t\n\t  var _ref4 = options || {},\n\t      ifMatch = _ref4.ifMatch;\n\t\n\t  var body = { data: { attributes: attrs } };\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'PATCH', path, body, {\n\t    headers: {\n\t      'If-Match': ifMatch || ''\n\t    }\n\t  });\n\t}\n\t\n\tfunction updateAttributesById(cozy, id, attrs, options) {\n\t  return doUpdateAttributes(cozy, attrs, '/files/' + encodeURIComponent(id), options);\n\t}\n\t\n\tfunction updateAttributesByPath(cozy, path, attrs, options) {\n\t  return doUpdateAttributes(cozy, attrs, '/files/metadata?Path=' + encodeURIComponent(path), options);\n\t}\n\t\n\tfunction trashById(cozy, id, options) {\n\t  if (typeof id !== 'string' || id === '') {\n\t    throw new Error('missing id argument');\n\t  }\n\t\n\t  var _ref5 = options || {},\n\t      ifMatch = _ref5.ifMatch;\n\t\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', '/files/' + encodeURIComponent(id), undefined, {\n\t    headers: {\n\t      'If-Match': ifMatch || ''\n\t    }\n\t  });\n\t}\n\t\n\tfunction statById(cozy, id) {\n\t  var offline = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\t  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\n\t  if (offline && cozy.offline.hasDatabase(_doctypes.DOCTYPE_FILES)) {\n\t    var db = cozy.offline.getDatabase(_doctypes.DOCTYPE_FILES);\n\t    return Promise.all([db.get(id), db.find(Object.assign({ selector: { 'dir_id': id } }, options))]).then(function (_ref6) {\n\t      var _ref7 = _slicedToArray(_ref6, 2),\n\t          doc = _ref7[0],\n\t          children = _ref7[1];\n\t\n\t      if (id === ROOT_DIR_ID) {\n\t        children.docs = children.docs.filter(function (doc) {\n\t          return doc._id !== TRASH_DIR_ID;\n\t        });\n\t      }\n\t      children = sortFiles(children.docs.map(function (doc) {\n\t        return addIsDir(toJsonApi(cozy, doc));\n\t      }));\n\t      return addIsDir(toJsonApi(cozy, doc, children));\n\t    });\n\t  }\n\t  var query = Object.keys(options).length === 0 ? '' : '?' + encodePageOptions(options);\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/files/' + encodeURIComponent(id) + query).then(addIsDir);\n\t}\n\t\n\tfunction statByPath(cozy, path) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/files/metadata?Path=' + encodeURIComponent(path)).then(addIsDir);\n\t}\n\t\n\tfunction downloadById(cozy, id) {\n\t  return (0, _fetch.cozyFetch)(cozy, '/files/download/' + encodeURIComponent(id));\n\t}\n\t\n\tfunction downloadByPath(cozy, path) {\n\t  return (0, _fetch.cozyFetch)(cozy, '/files/download?Path=' + encodeURIComponent(path));\n\t}\n\t\n\tfunction extractResponseLinkRelated(res) {\n\t  var href = res.links && res.links.related;\n\t  if (!href) throw new Error('No related link in server response');\n\t  return href;\n\t}\n\t\n\tfunction getDownloadLinkByPath(cozy, path) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/files/downloads?Path=' + encodeURIComponent(path)).then(extractResponseLinkRelated);\n\t}\n\t\n\tfunction getDownloadLinkById(cozy, id) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/files/downloads?Id=' + encodeURIComponent(id)).then(extractResponseLinkRelated);\n\t}\n\t\n\tfunction getFilePath(cozy) {\n\t  var file = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\t  var folder = arguments[2];\n\t\n\t  if (!folder || !folder.attributes) {\n\t    throw Error('Folder should be valid with an attributes.path property');\n\t  }\n\t\n\t  var folderPath = folder.attributes.path.endsWith('/') ? folder.attributes.path : folder.attributes.path + '/';\n\t\n\t  return '' + folderPath + file.name;\n\t}\n\t\n\tfunction getCollectionShareLink(cozy, id, collectionType) {\n\t  if (!id) {\n\t    return Promise.reject(Error('An id should be provided to create a share link'));\n\t  }\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/permissions?codes=email', {\n\t    data: {\n\t      type: 'io.cozy.permissions',\n\t      attributes: {\n\t        permissions: {\n\t          files: {\n\t            type: 'io.cozy.files',\n\t            verbs: ['GET'],\n\t            values: [id],\n\t            selector: 'referenced_by'\n\t          },\n\t          collection: {\n\t            type: collectionType,\n\t            verbs: ['GET'],\n\t            values: [id]\n\t          }\n\t        }\n\t      }\n\t    }\n\t  }).then(function (data) {\n\t    return { sharecode: 'sharecode=' + data.attributes.codes.email, id: 'id=' + id };\n\t  });\n\t}\n\t\n\tfunction getArchiveLinkByPaths(cozy, paths) {\n\t  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'files';\n\t\n\t  var archive = {\n\t    type: 'io.cozy.archives',\n\t    attributes: {\n\t      name: name,\n\t      files: paths\n\t    }\n\t  };\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/files/archive', { data: archive }).then(extractResponseLinkRelated);\n\t}\n\t\n\tfunction getArchiveLinkByIds(cozy, ids) {\n\t  var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'files';\n\t\n\t  var archive = {\n\t    type: 'io.cozy.archives',\n\t    attributes: {\n\t      name: name,\n\t      ids: ids\n\t    }\n\t  };\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/files/archive', { data: archive }).then(extractResponseLinkRelated);\n\t}\n\t\n\tfunction listTrash(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/files/trash');\n\t}\n\t\n\tfunction clearTrash(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', '/files/trash');\n\t}\n\t\n\tfunction restoreById(cozy, id) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/files/trash/' + encodeURIComponent(id));\n\t}\n\t\n\tfunction destroyById(cozy, id, options) {\n\t  var _ref8 = options || {},\n\t      ifMatch = _ref8.ifMatch;\n\t\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', '/files/trash/' + encodeURIComponent(id), undefined, {\n\t    headers: {\n\t      'If-Match': ifMatch || ''\n\t    }\n\t  });\n\t}\n\t\n\tfunction addIsDir(obj) {\n\t  obj.isDir = obj.attributes.type === 'directory';\n\t  return obj;\n\t}\n\t\n\tfunction encodePageOptions(options) {\n\t  var opts = [];\n\t  for (var name in options) {\n\t    opts.push('page[' + encodeURIComponent(name) + ']=' + encodeURIComponent(options[name]));\n\t  }\n\t  return opts.join('&');\n\t}\n\t\n\tfunction toJsonApi(cozy, doc) {\n\t  var contents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\t\n\t  var clone = JSON.parse(JSON.stringify(doc));\n\t  delete clone._id;\n\t  delete clone._rev;\n\t  return {\n\t    _id: doc._id,\n\t    _rev: doc._rev,\n\t    _type: _doctypes.DOCTYPE_FILES,\n\t    attributes: clone,\n\t    relationships: {\n\t      contents: {\n\t        data: contents,\n\t        meta: {\n\t          count: contents.length\n\t        }\n\t      }\n\t    },\n\t    relations: function relations(name) {\n\t      if (name === 'contents') {\n\t        return contents;\n\t      }\n\t    }\n\t  };\n\t}\n\t\n\tfunction sortFiles(allFiles) {\n\t  var folders = allFiles.filter(function (f) {\n\t    return f.attributes.type === 'directory';\n\t  });\n\t  var files = allFiles.filter(function (f) {\n\t    return f.attributes.type !== 'directory';\n\t  });\n\t  var sort = function sort(files) {\n\t    return files.sort(function (a, b) {\n\t      return a.attributes.name.localeCompare(b.attributes.name);\n\t    });\n\t  };\n\t  return sort(folders).concat(sort(files));\n\t}\n\n/***/ },\n/* 113 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /* global fetch URL */\n\t\n\t\n\t__webpack_require__(198);\n\t\n\t__webpack_require__(203);\n\t\n\t__webpack_require__(206);\n\t\n\t__webpack_require__(207);\n\t\n\t__webpack_require__(201);\n\t\n\t__webpack_require__(204);\n\t\n\t__webpack_require__(202);\n\t\n\t__webpack_require__(205);\n\t\n\t__webpack_require__(199);\n\t\n\t__webpack_require__(200);\n\t\n\t__webpack_require__(142);\n\t\n\t__webpack_require__(189);\n\t\n\t__webpack_require__(208);\n\t\n\t__webpack_require__(209);\n\t\n\t__webpack_require__(171);\n\t\n\t__webpack_require__(172);\n\t\n\t__webpack_require__(173);\n\t\n\t__webpack_require__(174);\n\t\n\t__webpack_require__(177);\n\t\n\t__webpack_require__(175);\n\t\n\t__webpack_require__(176);\n\t\n\t__webpack_require__(178);\n\t\n\t__webpack_require__(179);\n\t\n\t__webpack_require__(180);\n\t\n\t__webpack_require__(181);\n\t\n\t__webpack_require__(183);\n\t\n\t__webpack_require__(182);\n\t\n\t__webpack_require__(170);\n\t\n\t__webpack_require__(197);\n\t\n\t__webpack_require__(167);\n\t\n\t__webpack_require__(168);\n\t\n\t__webpack_require__(169);\n\t\n\t__webpack_require__(141);\n\t\n\t__webpack_require__(194);\n\t\n\t__webpack_require__(192);\n\t\n\t__webpack_require__(190);\n\t\n\t__webpack_require__(195);\n\t\n\t__webpack_require__(196);\n\t\n\t__webpack_require__(191);\n\t\n\t__webpack_require__(193);\n\t\n\t__webpack_require__(184);\n\t\n\t__webpack_require__(185);\n\t\n\t__webpack_require__(186);\n\t\n\t__webpack_require__(188);\n\t\n\t__webpack_require__(187);\n\t\n\t__webpack_require__(139);\n\t\n\t__webpack_require__(140);\n\t\n\t__webpack_require__(135);\n\t\n\t__webpack_require__(138);\n\t\n\t__webpack_require__(137);\n\t\n\t__webpack_require__(136);\n\t\n\t__webpack_require__(74);\n\t\n\t__webpack_require__(161);\n\t\n\t__webpack_require__(162);\n\t\n\t__webpack_require__(164);\n\t\n\t__webpack_require__(163);\n\t\n\t__webpack_require__(160);\n\t\n\t__webpack_require__(166);\n\t\n\t__webpack_require__(165);\n\t\n\t__webpack_require__(143);\n\t\n\t__webpack_require__(144);\n\t\n\t__webpack_require__(145);\n\t\n\t__webpack_require__(146);\n\t\n\t__webpack_require__(147);\n\t\n\t__webpack_require__(148);\n\t\n\t__webpack_require__(149);\n\t\n\t__webpack_require__(150);\n\t\n\t__webpack_require__(151);\n\t\n\t__webpack_require__(152);\n\t\n\t__webpack_require__(154);\n\t\n\t__webpack_require__(153);\n\t\n\t__webpack_require__(155);\n\t\n\t__webpack_require__(156);\n\t\n\t__webpack_require__(157);\n\t\n\t__webpack_require__(158);\n\t\n\t__webpack_require__(159);\n\t\n\t__webpack_require__(210);\n\t\n\t__webpack_require__(213);\n\t\n\t__webpack_require__(211);\n\t\n\t__webpack_require__(212);\n\t\n\t__webpack_require__(215);\n\t\n\t__webpack_require__(214);\n\t\n\t__webpack_require__(218);\n\t\n\t__webpack_require__(217);\n\t\n\t__webpack_require__(216);\n\t\n\t__webpack_require__(246);\n\t\n\tvar _utils = __webpack_require__(22);\n\t\n\tvar _auth_storage = __webpack_require__(109);\n\t\n\tvar _auth_v = __webpack_require__(110);\n\t\n\tvar _auth_v2 = __webpack_require__(54);\n\t\n\tvar auth = _interopRequireWildcard(_auth_v2);\n\t\n\tvar _data = __webpack_require__(111);\n\t\n\tvar data = _interopRequireWildcard(_data);\n\t\n\tvar _fetch = __webpack_require__(13);\n\t\n\tvar cozyFetch = _interopRequireWildcard(_fetch);\n\t\n\tvar _mango = __webpack_require__(116);\n\t\n\tvar mango = _interopRequireWildcard(_mango);\n\t\n\tvar _files = __webpack_require__(112);\n\t\n\tvar files = _interopRequireWildcard(_files);\n\t\n\tvar _intents = __webpack_require__(114);\n\t\n\tvar intents = _interopRequireWildcard(_intents);\n\t\n\tvar _jobs = __webpack_require__(115);\n\t\n\tvar jobs = _interopRequireWildcard(_jobs);\n\t\n\tvar _offline = __webpack_require__(117);\n\t\n\tvar offline = _interopRequireWildcard(_offline);\n\t\n\tvar _settings = __webpack_require__(119);\n\t\n\tvar settings = _interopRequireWildcard(_settings);\n\t\n\tvar _relations = __webpack_require__(118);\n\t\n\tvar relations = _interopRequireWildcard(_relations);\n\t\n\tfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar AppTokenV3 = auth.AppToken,\n\t    AccessTokenV3 = auth.AccessToken,\n\t    ClientV3 = auth.Client;\n\t\n\t\n\tvar AuthNone = 0;\n\tvar AuthRunning = 1;\n\tvar AuthError = 2;\n\tvar AuthOK = 3;\n\t\n\tvar defaultClientParams = {\n\t  softwareID: 'github.com/cozy/cozy-client-js'\n\t};\n\t\n\tvar dataProto = {\n\t  create: data.create,\n\t  find: data.find,\n\t  findMany: data.findMany,\n\t  findAll: data.findAll,\n\t  update: data.update,\n\t  delete: data._delete,\n\t  updateAttributes: data.updateAttributes,\n\t  changesFeed: data.changesFeed,\n\t  defineIndex: mango.defineIndex,\n\t  query: mango.query,\n\t  addReferencedFiles: relations.addReferencedFiles,\n\t  removeReferencedFiles: relations.removeReferencedFiles,\n\t  listReferencedFiles: relations.listReferencedFiles,\n\t  fetchReferencedFiles: relations.fetchReferencedFiles,\n\t  destroy: function destroy() {\n\t    (0, _utils.warn)('destroy is deprecated, use cozy.data.delete instead.');\n\t    return data._delete.apply(data, arguments);\n\t  }\n\t};\n\t\n\tvar authProto = {\n\t  client: auth.client,\n\t  registerClient: auth.registerClient,\n\t  updateClient: auth.updateClient,\n\t  unregisterClient: auth.unregisterClient,\n\t  getClient: auth.getClient,\n\t  getAuthCodeURL: auth.getAuthCodeURL,\n\t  getAccessToken: auth.getAccessToken,\n\t  refreshToken: auth.refreshToken\n\t};\n\t\n\tvar filesProto = {\n\t  create: files.create,\n\t  createDirectory: files.createDirectory,\n\t  createDirectoryByPath: files.createDirectoryByPath,\n\t  updateById: files.updateById,\n\t  updateAttributesById: files.updateAttributesById,\n\t  updateAttributesByPath: files.updateAttributesByPath,\n\t  trashById: files.trashById,\n\t  statById: files.statById,\n\t  statByPath: files.statByPath,\n\t  downloadById: files.downloadById,\n\t  downloadByPath: files.downloadByPath,\n\t  getDownloadLinkById: files.getDownloadLinkById,\n\t  getDownloadLink: files.getDownloadLinkByPath, // DEPRECATED, should be removed very soon\n\t  getDownloadLinkByPath: files.getDownloadLinkByPath,\n\t  getArchiveLink: function getArchiveLink() {\n\t    (0, _utils.warn)('getArchiveLink is deprecated, use cozy.files.getArchiveLinkByPaths instead.');\n\t    return files.getArchiveLinkByPaths.apply(files, arguments);\n\t  },\n\t  getArchiveLinkByPaths: files.getArchiveLinkByPaths,\n\t  getArchiveLinkByIds: files.getArchiveLinkByIds,\n\t  getFilePath: files.getFilePath,\n\t  getCollectionShareLink: files.getCollectionShareLink,\n\t  query: mango.queryFiles,\n\t  listTrash: files.listTrash,\n\t  clearTrash: files.clearTrash,\n\t  restoreById: files.restoreById,\n\t  destroyById: files.destroyById\n\t};\n\t\n\tvar intentsProto = {\n\t  create: intents.create,\n\t  createService: intents.createService\n\t};\n\t\n\tvar jobsProto = {\n\t  create: jobs.create,\n\t  count: jobs.count,\n\t  queued: jobs.queued\n\t};\n\t\n\tvar offlineProto = {\n\t  init: offline.init,\n\t  getDoctypes: offline.getDoctypes,\n\t  // database\n\t  hasDatabase: offline.hasDatabase,\n\t  getDatabase: offline.getDatabase,\n\t  createDatabase: offline.createDatabase,\n\t  destroyDatabase: offline.destroyDatabase,\n\t  destroyAllDatabase: offline.destroyAllDatabase,\n\t  // replication\n\t  hasReplication: offline.hasReplication,\n\t  replicateFromCozy: offline.replicateFromCozy,\n\t  stopReplication: offline.stopReplication,\n\t  stopAllReplication: offline.stopAllReplication,\n\t  // repeated replication\n\t  hasRepeatedReplication: offline.hasRepeatedReplication,\n\t  startRepeatedReplication: offline.startRepeatedReplication,\n\t  stopRepeatedReplication: offline.stopRepeatedReplication,\n\t  stopAllRepeatedReplication: offline.stopAllRepeatedReplication\n\t};\n\t\n\tvar settingsProto = {\n\t  diskUsage: settings.diskUsage,\n\t  changePassphrase: settings.changePassphrase,\n\t  getInstance: settings.getInstance,\n\t  updateInstance: settings.updateInstance,\n\t  getClients: settings.getClients,\n\t  deleteClientById: settings.deleteClientById,\n\t  updateLastSync: settings.updateLastSync\n\t};\n\t\n\tvar Client = function () {\n\t  function Client(options) {\n\t    _classCallCheck(this, Client);\n\t\n\t    this.data = {};\n\t    this.files = {};\n\t    this.intents = {};\n\t    this.jobs = {};\n\t    this.offline = {};\n\t    this.settings = {};\n\t    this.auth = {\n\t      Client: ClientV3,\n\t      AccessToken: AccessTokenV3,\n\t      AppToken: AppTokenV3,\n\t      AppTokenV2: _auth_v.AppToken,\n\t      LocalStorage: _auth_storage.LocalStorage,\n\t      MemoryStorage: _auth_storage.MemoryStorage\n\t    };\n\t    this._inited = false;\n\t    if (options) {\n\t      this.init(options);\n\t    }\n\t  }\n\t\n\t  _createClass(Client, [{\n\t    key: 'init',\n\t    value: function init() {\n\t      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\t\n\t      this._inited = true;\n\t      this._oauth = false; // is oauth activated or not\n\t      this._token = null; // application token\n\t      this._authstate = AuthNone;\n\t      this._authcreds = null;\n\t      this._storage = null;\n\t      this._version = options.version || null;\n\t      this._offline = null;\n\t\n\t      var token = options.token;\n\t      var oauth = options.oauth;\n\t      if (token && oauth) {\n\t        throw new Error('Cannot specify an application token with a oauth activated');\n\t      }\n\t\n\t      if (token) {\n\t        this._token = new AppTokenV3({ token: token });\n\t      } else if (oauth) {\n\t        this._oauth = true;\n\t        this._storage = oauth.storage;\n\t        this._clientParams = Object.assign({}, defaultClientParams, oauth.clientParams);\n\t        this._onRegistered = oauth.onRegistered || nopOnRegistered;\n\t      }\n\t\n\t      var url = options.cozyURL || '';\n\t      while (url[url.length - 1] === '/') {\n\t        url = url.slice(0, -1);\n\t      }\n\t\n\t      this._url = url;\n\t\n\t      var disablePromises = !!options.disablePromises;\n\t      addToProto(this, this.data, dataProto, disablePromises);\n\t      addToProto(this, this.auth, authProto, disablePromises);\n\t      addToProto(this, this.files, filesProto, disablePromises);\n\t      addToProto(this, this.intents, intentsProto, disablePromises);\n\t      addToProto(this, this.jobs, jobsProto, disablePromises);\n\t      addToProto(this, this.offline, offlineProto, disablePromises);\n\t      addToProto(this, this.settings, settingsProto, disablePromises);\n\t\n\t      if (options.offline) {\n\t        this.offline.init(options.offline);\n\t      }\n\t\n\t      // Exposing cozyFetchJSON to make some development easier. Should be temporary.\n\t      this.fetchJSON = function _fetchJSON() {\n\t        var args = [this].concat(Array.prototype.slice.call(arguments));\n\t        return cozyFetch.cozyFetchJSON.apply(this, args);\n\t      };\n\t    }\n\t  }, {\n\t    key: 'authorize',\n\t    value: function authorize() {\n\t      var _this = this;\n\t\n\t      var forceTokenRefresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\t\n\t      var state = this._authstate;\n\t      if (state === AuthOK || state === AuthRunning) {\n\t        return this._authcreds;\n\t      }\n\t\n\t      this._authstate = AuthRunning;\n\t      this._authcreds = this.isV2().then(function (isV2) {\n\t        if (isV2 && _this._oauth) {\n\t          throw new Error('OAuth is not supported on the V2 stack');\n\t        }\n\t        if (_this._oauth) {\n\t          if (forceTokenRefresh && _this._clientParams.redirectURI) {\n\t            var url = new URL(_this._clientParams.redirectURI);\n\t            if (!url.searchParams.has('reconnect')) url.searchParams.append('reconnect', 1);\n\t            _this._clientParams.redirectURI = url.toString();\n\t          }\n\t          return auth.oauthFlow(_this, _this._storage, _this._clientParams, _this._onRegistered, forceTokenRefresh);\n\t        }\n\t        // we expect to be on a client side application running in a browser\n\t        // with cookie-based authentication.\n\t        if (isV2) {\n\t          return (0, _auth_v.getAppToken)();\n\t        } else if (_this._token) {\n\t          return Promise.resolve({ client: null, token: _this._token });\n\t        } else {\n\t          throw new Error('Missing application token');\n\t        }\n\t      });\n\t\n\t      this._authcreds.then(function () {\n\t        _this._authstate = AuthOK;\n\t      }, function () {\n\t        _this._authstate = AuthError;\n\t      });\n\t\n\t      return this._authcreds;\n\t    }\n\t  }, {\n\t    key: 'saveCredentials',\n\t    value: function saveCredentials(client, token) {\n\t      var creds = { client: client, token: token };\n\t      if (!this._storage || this._authstate === AuthRunning) {\n\t        return Promise.resolve(creds);\n\t      }\n\t      this._storage.save(auth.CredsKey, creds);\n\t      this._authcreds = Promise.resolve(creds);\n\t      return this._authcreds;\n\t    }\n\t  }, {\n\t    key: 'fullpath',\n\t    value: function fullpath(path) {\n\t      var _this2 = this;\n\t\n\t      return this.isV2().then(function (isV2) {\n\t        var pathprefix = isV2 ? '/ds-api' : '';\n\t        return _this2._url + pathprefix + path;\n\t      });\n\t    }\n\t  }, {\n\t    key: 'isV2',\n\t    value: function isV2() {\n\t      var _this3 = this;\n\t\n\t      if (!this._version) {\n\t        return (0, _utils.retry)(function () {\n\t          return fetch(_this3._url + '/status/');\n\t        }, 3)().then(function (res) {\n\t          if (!res.ok) {\n\t            throw new Error('Could not fetch cozy status');\n\t          } else {\n\t            return res.json();\n\t          }\n\t        }).then(function (status) {\n\t          _this3._version = status.datasystem !== undefined ? 2 : 3;\n\t          return _this3.isV2();\n\t        });\n\t      }\n\t      return Promise.resolve(this._version === 2);\n\t    }\n\t  }]);\n\t\n\t  return Client;\n\t}();\n\t\n\tfunction nopOnRegistered() {\n\t  throw new Error('Missing onRegistered callback');\n\t}\n\t\n\tfunction protoify(context, fn) {\n\t  return function prototyped() {\n\t    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n\t      args[_key] = arguments[_key];\n\t    }\n\t\n\t    return fn.apply(undefined, [context].concat(args));\n\t  };\n\t}\n\t\n\tfunction addToProto(ctx, obj, proto, disablePromises) {\n\t  for (var attr in proto) {\n\t    var fn = protoify(ctx, proto[attr]);\n\t    if (disablePromises) {\n\t      fn = (0, _utils.unpromiser)(fn);\n\t    }\n\t    obj[attr] = fn;\n\t  }\n\t}\n\t\n\tmodule.exports = new Client();\n\tObject.assign(module.exports, { Client: Client, LocalStorage: _auth_storage.LocalStorage, MemoryStorage: _auth_storage.MemoryStorage });\n\n/***/ },\n/* 114 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.create = create;\n\texports.createService = createService;\n\t\n\tvar _fetch = __webpack_require__(13);\n\t\n\tvar intentClass = 'coz-intent';\n\t\n\t// helper to serialize/deserialize an error for/from postMessage\n\tvar errorSerializer = function () {\n\t  function mapErrorProperties(from, to) {\n\t    var result = Object.assign(to, from);\n\t    var nativeProperties = ['name', 'message'];\n\t    return nativeProperties.reduce(function (result, property) {\n\t      if (from[property]) {\n\t        to[property] = from[property];\n\t      }\n\t      return result;\n\t    }, result);\n\t  }\n\t  return {\n\t    serialize: function serialize(error) {\n\t      return mapErrorProperties(error, {});\n\t    },\n\t    deserialize: function deserialize(data) {\n\t      return mapErrorProperties(data, new Error(data.message));\n\t    }\n\t  };\n\t}();\n\t\n\t// inject iframe for service in given element\n\tfunction injectService(url, element, intent, data, onReadyCallback) {\n\t  var document = element.ownerDocument;\n\t  if (!document) throw new Error('Cannot retrieve document object from given element');\n\t\n\t  var window = document.defaultView;\n\t  if (!window) throw new Error('Cannot retrieve window object from document');\n\t\n\t  var iframe = document.createElement('iframe');\n\t  // if callback provided for when iframe is loaded\n\t  if (typeof onReadyCallback === 'function') iframe.onload = onReadyCallback;\n\t  // TODO: implement 'title' attribute\n\t  iframe.setAttribute('src', url);\n\t  iframe.classList.add(intentClass);\n\t  element.appendChild(iframe);\n\t  iframe.focus();\n\t\n\t  // Keeps only http://domain:port/\n\t  var serviceOrigin = url.split('/', 3).join('/');\n\t\n\t  return new Promise(function (resolve, reject) {\n\t    var handshaken = false;\n\t    var messageHandler = function messageHandler(event) {\n\t      if (event.origin !== serviceOrigin) return;\n\t\n\t      if (event.data.type === 'load') {\n\t        // Safari 9.1 (At least) send a MessageEvent when the iframe loads,\n\t        // making the handshake fails.\n\t        console.warn && console.warn('Cozy Client ignored MessageEvent having data.type `load`.');\n\t        return;\n\t      }\n\t\n\t      if (event.data.type === 'intent-' + intent._id + ':ready') {\n\t        handshaken = true;\n\t        return event.source.postMessage(data, event.origin);\n\t      }\n\t\n\t      if (handshaken && event.data.type === 'intent-' + intent._id + ':resize') {\n\t        ['width', 'height', 'maxWidth', 'maxHeight'].forEach(function (prop) {\n\t          if (event.data.transition) element.style.transition = event.data.transition;\n\t          if (event.data.dimensions[prop]) element.style[prop] = event.data.dimensions[prop] + 'px';\n\t        });\n\t\n\t        return true;\n\t      }\n\t\n\t      window.removeEventListener('message', messageHandler);\n\t      var removeIntentFrame = function removeIntentFrame() {\n\t        // check if the parent node has not been already removed from the DOM\n\t        iframe.parentNode && iframe.parentNode.removeChild(iframe);\n\t      };\n\t\n\t      if (handshaken && event.data.type === 'intent-' + intent._id + ':exposeFrameRemoval') {\n\t        return resolve({ removeIntentFrame: removeIntentFrame, doc: event.data.document });\n\t      }\n\t\n\t      removeIntentFrame();\n\t\n\t      if (event.data.type === 'intent-' + intent._id + ':error') {\n\t        return reject(errorSerializer.deserialize(event.data.error));\n\t      }\n\t\n\t      if (handshaken && event.data.type === 'intent-' + intent._id + ':cancel') {\n\t        return resolve(null);\n\t      }\n\t\n\t      if (handshaken && event.data.type === 'intent-' + intent._id + ':done') {\n\t        return resolve(event.data.document);\n\t      }\n\t\n\t      if (!handshaken) {\n\t        return reject(new Error('Unexpected handshake message from intent service'));\n\t      }\n\t\n\t      // We may be in a state where the messageHandler is still attached to then\n\t      // window, but will not be needed anymore. For example, the service failed\n\t      // before adding the `unload` listener, so no `intent:cancel` message has\n\t      // never been sent.\n\t      // So we simply ignore other messages, and this listener will stay here,\n\t      // waiting for a message which will never come, forever (almost).\n\t    };\n\t\n\t    window.addEventListener('message', messageHandler);\n\t  });\n\t}\n\t\n\tfunction create(cozy, action, type) {\n\t  var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t  var permissions = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n\t\n\t  if (!action) throw new Error('Misformed intent, \"action\" property must be provided');\n\t  if (!type) throw new Error('Misformed intent, \"type\" property must be provided');\n\t\n\t  var createPromise = (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/intents', {\n\t    data: {\n\t      type: 'io.cozy.intents',\n\t      attributes: {\n\t        action: action,\n\t        type: type,\n\t        data: data,\n\t        permissions: permissions\n\t      }\n\t    }\n\t  });\n\t\n\t  createPromise.start = function (element, onReadyCallback) {\n\t    return createPromise.then(function (intent) {\n\t      var service = intent.attributes.services && intent.attributes.services[0];\n\t\n\t      if (!service) {\n\t        return Promise.reject(new Error('Unable to find a service'));\n\t      }\n\t\n\t      return injectService(service.href, element, intent, data, onReadyCallback);\n\t    });\n\t  };\n\t\n\t  return createPromise;\n\t}\n\t\n\tfunction listenClientData(intent, window) {\n\t  return new Promise(function (resolve, reject) {\n\t    var messageEventListener = function messageEventListener(event) {\n\t      if (event.origin !== intent.attributes.client) return;\n\t\n\t      window.removeEventListener('message', messageEventListener);\n\t      resolve(event.data);\n\t    };\n\t\n\t    window.addEventListener('message', messageEventListener);\n\t    window.parent.postMessage({\n\t      type: 'intent-' + intent._id + ':ready'\n\t    }, intent.attributes.client);\n\t  });\n\t}\n\t\n\t// returns a service to communicate with intent client\n\tfunction createService(cozy, intentId, serviceWindow) {\n\t  serviceWindow = serviceWindow || typeof window !== 'undefined' && window;\n\t  if (!serviceWindow) throw new Error('Intent service should be used in browser');\n\t\n\t  intentId = intentId || serviceWindow.location.search.split('=')[1];\n\t  if (!intentId) throw new Error('Cannot retrieve intent from URL');\n\t\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/intents/' + intentId).then(function (intent) {\n\t    var terminated = false;\n\t\n\t    var _terminate = function _terminate(message) {\n\t      if (terminated) throw new Error('Intent service has already been terminated');\n\t      terminated = true;\n\t      serviceWindow.parent.postMessage(message, intent.attributes.client);\n\t    };\n\t\n\t    var resizeClient = function resizeClient(dimensions, transitionProperty) {\n\t      if (terminated) throw new Error('Intent service has been terminated');\n\t\n\t      var message = {\n\t        type: 'intent-' + intent._id + ':resize',\n\t        // if a dom element is passed, calculate its size\n\t        dimensions: dimensions.element ? Object.assign({}, dimensions, {\n\t          maxHeight: dimensions.element.clientHeight,\n\t          maxWidth: dimensions.element.clientWidth\n\t        }) : dimensions,\n\t        transition: transitionProperty\n\t      };\n\t\n\t      serviceWindow.parent.postMessage(message, intent.attributes.client);\n\t    };\n\t\n\t    var cancel = function cancel() {\n\t      _terminate({ type: 'intent-' + intent._id + ':cancel' });\n\t    };\n\t\n\t    // Prevent unfulfilled client promises when this window unloads for a\n\t    // reason or another.\n\t    serviceWindow.addEventListener('unload', function () {\n\t      if (!terminated) cancel();\n\t    });\n\t\n\t    return listenClientData(intent, serviceWindow).then(function (data) {\n\t      return {\n\t        getData: function getData() {\n\t          return data;\n\t        },\n\t        getIntent: function getIntent() {\n\t          return intent;\n\t        },\n\t        terminate: function terminate(doc) {\n\t          if (data && data.exposeIntentFrameRemoval) {\n\t            return _terminate({\n\t              type: 'intent-' + intent._id + ':exposeFrameRemoval',\n\t              document: doc\n\t            });\n\t          } else {\n\t            return _terminate({\n\t              type: 'intent-' + intent._id + ':done',\n\t              document: doc\n\t            });\n\t          }\n\t        },\n\t        throw: function _throw(error) {\n\t          return _terminate({\n\t            type: 'intent-' + intent._id + ':error',\n\t            error: errorSerializer.serialize(error)\n\t          });\n\t        },\n\t        resizeClient: resizeClient,\n\t        cancel: cancel\n\t      };\n\t    });\n\t  });\n\t}\n\n/***/ },\n/* 115 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.count = count;\n\texports.queued = queued;\n\texports.create = create;\n\t\n\tvar _fetch = __webpack_require__(13);\n\t\n\tfunction count(cozy, workerType) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/jobs/queue/' + workerType).then(function (data) {\n\t    return data.length;\n\t  });\n\t}\n\t\n\tfunction queued(cozy, workerType) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/jobs/queue/' + workerType);\n\t}\n\t\n\tfunction create(cozy, workerType, args, options) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/jobs/queue/' + workerType, {\n\t    data: {\n\t      type: 'io.cozy.jobs',\n\t      attributes: {\n\t        arguments: args || {},\n\t        options: options || {}\n\t      }\n\t    }\n\t  });\n\t}\n\n/***/ },\n/* 116 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\texports.defineIndex = defineIndex;\n\texports.query = query;\n\texports.queryFiles = queryFiles;\n\texports.parseSelector = parseSelector;\n\texports.normalizeSelector = normalizeSelector;\n\texports.makeMapReduceQuery = makeMapReduceQuery;\n\t\n\tvar _utils = __webpack_require__(22);\n\t\n\tvar _doctypes = __webpack_require__(36);\n\t\n\tvar _fetch = __webpack_require__(13);\n\t\n\tfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\t\n\tfunction defineIndex(cozy, doctype, fields) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    doctype = (0, _doctypes.normalizeDoctype)(cozy, isV2, doctype);\n\t    if (!Array.isArray(fields) || fields.length === 0) {\n\t      throw new Error('defineIndex fields should be a non-empty array');\n\t    }\n\t    if (isV2) {\n\t      return defineIndexV2(cozy, doctype, fields);\n\t    } else {\n\t      return defineIndexV3(cozy, doctype, fields);\n\t    }\n\t  });\n\t}\n\t\n\tfunction query(cozy, indexRef, options) {\n\t  return cozy.isV2().then(function (isV2) {\n\t    if (!indexRef) {\n\t      throw new Error('query should be passed the indexRef');\n\t    }\n\t    if (isV2) {\n\t      return queryV2(cozy, indexRef, options);\n\t    } else {\n\t      return queryV3(cozy, indexRef, options);\n\t    }\n\t  });\n\t}\n\t\n\tfunction queryFiles(cozy, indexRef, options) {\n\t  var opts = getV3Options(indexRef, options);\n\t  return (0, _fetch.cozyFetchRawJSON)(cozy, 'POST', '/files/_find', opts).then(function (response) {\n\t    return options.wholeResponse ? response : response.docs;\n\t  });\n\t}\n\t\n\t// Internals\n\t\n\tvar VALUEOPERATORS = ['$eq', '$gt', '$gte', '$lt', '$lte'];\n\tvar LOGICOPERATORS = ['$or', '$and', '$not'];\n\t\n\t/* eslint-disable */\n\tvar MAP_TEMPLATE = function (doc) {\n\t  if (doc.docType.toLowerCase() === 'DOCTYPEPLACEHOLDER') {\n\t    emit(FIELDSPLACEHOLDER, doc);\n\t  }\n\t}.toString().replace(/ /g, '').replace(/\\n/g, '');\n\tvar COUCHDB_INFINITY = { '\\uFFFF': '\\uFFFF' };\n\tvar COUCHDB_LOWEST = null;\n\t/* eslint-enable */\n\t\n\t// defineIndexV2 is equivalent to defineIndex but only works for V2.\n\t// It transforms the index fields into a map reduce view.\n\tfunction defineIndexV2(cozy, doctype, fields) {\n\t  var indexName = 'by' + fields.map(capitalize).join('');\n\t  var indexDefinition = { map: makeMapFunction(doctype, fields), reduce: '_count' };\n\t  var path = '/request/' + doctype + '/' + indexName + '/';\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'PUT', path, indexDefinition).then(function () {\n\t    return { doctype: doctype, type: 'mapreduce', name: indexName, fields: fields };\n\t  });\n\t}\n\t\n\tfunction defineIndexV3(cozy, doctype, fields) {\n\t  var path = (0, _utils.createPath)(cozy, false, doctype, '_index');\n\t  var indexDefinition = { 'index': { fields: fields } };\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, indexDefinition).then(function (response) {\n\t    var indexResult = { doctype: doctype, type: 'mango', name: response.id, fields: fields };\n\t\n\t    if (response.result === 'exists') return indexResult;\n\t\n\t    // indexes might not be usable right after being created; so we delay the resolving until they are\n\t    var selector = {};\n\t    selector[fields[0]] = { '$gt': null };\n\t\n\t    var opts = getV3Options(indexResult, { 'selector': selector });\n\t    var path = (0, _utils.createPath)(cozy, false, indexResult.doctype, '_find');\n\t    return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, opts).then(function () {\n\t      return indexResult;\n\t    }).catch(function () {\n\t      // one retry\n\t      return (0, _utils.sleep)(1000).then(function () {\n\t        return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, opts);\n\t      }).then(function () {\n\t        return indexResult;\n\t      }).catch(function () {\n\t        return (0, _utils.sleep)(500).then(function () {\n\t          return indexResult;\n\t        });\n\t      });\n\t    });\n\t  });\n\t}\n\t\n\t// queryV2 is equivalent to query but only works for V2.\n\t// It transforms the query into a _views call using makeMapReduceQuery\n\tfunction queryV2(cozy, indexRef, options) {\n\t  if (indexRef.type !== 'mapreduce') {\n\t    throw new Error('query indexRef should be the return value of defineIndexV2');\n\t  }\n\t  if (options.fields) {\n\t    (0, _utils.warn)('query fields will be ignored on v2');\n\t  }\n\t\n\t  var path = '/request/' + indexRef.doctype + '/' + indexRef.name + '/';\n\t  var opts = makeMapReduceQuery(indexRef, options);\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, opts).then(function (response) {\n\t    return response.map(function (r) {\n\t      return r.value;\n\t    });\n\t  });\n\t}\n\t\n\t// queryV3 is equivalent to query but only works for V3\n\tfunction queryV3(cozy, indexRef, options) {\n\t  var opts = getV3Options(indexRef, options);\n\t\n\t  var path = (0, _utils.createPath)(cozy, false, indexRef.doctype, '_find');\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', path, opts).then(function (response) {\n\t    return options.wholeResponse ? response : response.docs;\n\t  });\n\t}\n\t\n\tfunction getV3Options(indexRef, options) {\n\t  if (indexRef.type !== 'mango') {\n\t    throw new Error('indexRef should be the return value of defineIndexV3');\n\t  }\n\t\n\t  var opts = {\n\t    use_index: indexRef.name,\n\t    fields: options.fields,\n\t    selector: options.selector,\n\t    limit: options.limit,\n\t    skip: options.skip,\n\t    since: options.since,\n\t    sort: options.sort\n\t  };\n\t\n\t  if (options.descending) {\n\t    opts.sort = indexRef.fields.map(function (f) {\n\t      return _defineProperty({}, f, 'desc');\n\t    });\n\t  }\n\t\n\t  return opts;\n\t}\n\t\n\t// misc\n\tfunction capitalize(name) {\n\t  return name.charAt(0).toUpperCase() + name.slice(1);\n\t}\n\t\n\tfunction makeMapFunction(doctype, fields) {\n\t  fields = '[' + fields.map(function (name) {\n\t    return 'doc.' + name;\n\t  }).join(',') + ']';\n\t\n\t  return MAP_TEMPLATE.replace('DOCTYPEPLACEHOLDER', doctype.toLowerCase()).replace('FIELDSPLACEHOLDER', fields);\n\t}\n\t\n\t// parseSelector takes a mango selector and returns it as an array of filter\n\t// a filter is [path, operator, value] array\n\t// a path is an array of field names\n\t// This function is only exported so it can be unit tested.\n\t// Example :\n\t// parseSelector({\"test\":{\"deep\": {\"$gt\": 3}}})\n\t// [[['test', 'deep'], '$gt', 3 ]]\n\tfunction parseSelector(selector) {\n\t  var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\t  var operator = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '$eq';\n\t\n\t  if ((typeof selector === 'undefined' ? 'undefined' : _typeof(selector)) !== 'object') {\n\t    return [[path, operator, selector]];\n\t  }\n\t\n\t  var keys = Object.keys(selector);\n\t  if (keys.length === 0) {\n\t    throw new Error('empty selector');\n\t  } else {\n\t    return keys.reduce(function (acc, k) {\n\t      if (LOGICOPERATORS.indexOf(k) !== -1) {\n\t        throw new Error('cozy-client-js does not support mango logic ops');\n\t      } else if (VALUEOPERATORS.indexOf(k) !== -1) {\n\t        return acc.concat(parseSelector(selector[k], path, k));\n\t      } else {\n\t        return acc.concat(parseSelector(selector[k], path.concat(k), '$eq'));\n\t      }\n\t    }, []);\n\t  }\n\t}\n\t\n\t// normalizeSelector takes a mango selector and returns it as an object\n\t// normalized.\n\t// This function is only exported so it can be unit tested.\n\t// Example :\n\t// parseSelector({\"test\":{\"deep\": {\"$gt\": 3}}})\n\t// {\"test.deep\": {\"$gt\": 3}}\n\tfunction normalizeSelector(selector) {\n\t  var filters = parseSelector(selector);\n\t  return filters.reduce(function (acc, filter) {\n\t    var _filter = _slicedToArray(filter, 3),\n\t        path = _filter[0],\n\t        op = _filter[1],\n\t        value = _filter[2];\n\t\n\t    var field = path.join('.');\n\t    acc[field] = acc[field] || {};\n\t    acc[field][op] = value;\n\t    return acc;\n\t  }, {});\n\t}\n\t\n\t// applySelector takes the normalized selector for the current field\n\t// and append the proper values to opts.startkey, opts.endkey\n\tfunction applySelector(selector, opts) {\n\t  var value = selector['$eq'];\n\t  var lower = COUCHDB_LOWEST;\n\t  var upper = COUCHDB_INFINITY;\n\t  var inclusiveEnd = void 0;\n\t\n\t  if (value) {\n\t    opts.startkey.push(value);\n\t    opts.endkey.push(value);\n\t    return false;\n\t  }\n\t\n\t  value = selector['$gt'];\n\t  if (value) {\n\t    throw new Error('operator $gt (strict greater than) not supported');\n\t  }\n\t\n\t  value = selector['$gte'];\n\t  if (value) {\n\t    lower = value;\n\t  }\n\t\n\t  value = selector['$lte'];\n\t  if (value) {\n\t    upper = value;\n\t    inclusiveEnd = true;\n\t  }\n\t\n\t  value = selector['$lt'];\n\t  if (value) {\n\t    upper = value;\n\t    inclusiveEnd = false;\n\t  }\n\t\n\t  opts.startkey.push(lower);\n\t  opts.endkey.push(upper);\n\t  if (inclusiveEnd !== undefined) opts.inclusive_end = inclusiveEnd;\n\t  return true;\n\t}\n\t\n\t// makeMapReduceQuery takes a mango query and generate _views call parameters\n\t// to obtain same results depending on fields in the passed indexRef.\n\tfunction makeMapReduceQuery(indexRef, query) {\n\t  var mrquery = {\n\t    startkey: [],\n\t    endkey: [],\n\t    reduce: false\n\t  };\n\t  var firstFreeValueField = null;\n\t  var normalizedSelector = normalizeSelector(query.selector);\n\t\n\t  indexRef.fields.forEach(function (field) {\n\t    var selector = normalizedSelector[field];\n\t\n\t    if (selector && firstFreeValueField != null) {\n\t      throw new Error('Selector on field ' + field + ', but not on ' + firstFreeValueField + ' which is higher in index fields.');\n\t    } else if (selector) {\n\t      selector.used = true;\n\t      var isFreeValue = applySelector(selector, mrquery);\n\t      if (isFreeValue) firstFreeValueField = field;\n\t    } else if (firstFreeValueField == null) {\n\t      firstFreeValueField = field;\n\t      mrquery.endkey.push(COUCHDB_INFINITY);\n\t    }\n\t  });\n\t\n\t  Object.keys(normalizedSelector).forEach(function (field) {\n\t    if (!normalizedSelector[field].used) {\n\t      throw new Error('Cant apply selector on ' + field + ', it is not in index');\n\t    }\n\t  });\n\t\n\t  if (query.descending) {\n\t    mrquery = {\n\t      descending: true,\n\t      reduce: false,\n\t      startkey: mrquery.endkey,\n\t      endkey: mrquery.startkey,\n\t      inclusive_end: mrquery.inclusive_end\n\t    };\n\t  }\n\t\n\t  return mrquery;\n\t}\n\n/***/ },\n/* 117 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.replicationOfflineError = undefined;\n\texports.init = init;\n\texports.getDoctypes = getDoctypes;\n\texports.hasDatabase = hasDatabase;\n\texports.getDatabase = getDatabase;\n\texports.setDatabase = setDatabase;\n\texports.createDatabase = createDatabase;\n\texports.destroyDatabase = destroyDatabase;\n\texports.destroyAllDatabase = destroyAllDatabase;\n\texports.hasReplication = hasReplication;\n\texports.replicateFromCozy = replicateFromCozy;\n\texports.stopReplication = stopReplication;\n\texports.stopAllReplication = stopAllReplication;\n\texports.hasRepeatedReplication = hasRepeatedReplication;\n\texports.startRepeatedReplication = startRepeatedReplication;\n\texports.stopRepeatedReplication = stopRepeatedReplication;\n\texports.stopAllRepeatedReplication = stopAllRepeatedReplication;\n\t\n\tvar _doctypes = __webpack_require__(36);\n\t\n\tvar _auth_v = __webpack_require__(54);\n\t\n\tvar _utils = __webpack_require__(22);\n\t\n\tvar _pouchdb = __webpack_require__(241);\n\t\n\tvar _pouchdb2 = _interopRequireDefault(_pouchdb);\n\t\n\tvar _pouchdbFind = __webpack_require__(234);\n\t\n\tvar _pouchdbFind2 = _interopRequireDefault(_pouchdbFind);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar replicationOfflineError = exports.replicationOfflineError = 'Replication abort, your device is actually offline.'; /* global pouchdbAdapterCordovaSqlite */\n\t\n\t\n\tvar pluginLoaded = false;\n\t\n\t/*\n\t  For each doctype we have some parameters:\n\t  cozy._offline[doctype] = {\n\t    database: pouchdb database\n\t    replication: the pouchdb replication\n\t    replicationPromise: promise of replication\n\t    interval: repeated replication interval\n\t  }\n\t*/\n\t\n\tfunction init(cozy, _ref) {\n\t  var _ref$options = _ref.options,\n\t      options = _ref$options === undefined ? {} : _ref$options,\n\t      _ref$doctypes = _ref.doctypes,\n\t      doctypes = _ref$doctypes === undefined ? [] : _ref$doctypes;\n\t  var _iteratorNormalCompletion = true;\n\t  var _didIteratorError = false;\n\t  var _iteratorError = undefined;\n\t\n\t  try {\n\t    for (var _iterator = doctypes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t      var doctype = _step.value;\n\t\n\t      createDatabase(cozy, doctype, options);\n\t    }\n\t  } catch (err) {\n\t    _didIteratorError = true;\n\t    _iteratorError = err;\n\t  } finally {\n\t    try {\n\t      if (!_iteratorNormalCompletion && _iterator.return) {\n\t        _iterator.return();\n\t      }\n\t    } finally {\n\t      if (_didIteratorError) {\n\t        throw _iteratorError;\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// helper\n\t\n\tfunction getInfo(cozy, doctype) {\n\t  cozy._offline = cozy._offline || [];\n\t  cozy._offline[doctype] = cozy._offline[doctype] || {};\n\t  return cozy._offline[doctype];\n\t}\n\t\n\tfunction getDoctypes(cozy) {\n\t  cozy._offline = cozy._offline || [];\n\t  return Object.keys(cozy._offline);\n\t}\n\t\n\t//\n\t// DATABASE\n\t//\n\t\n\tfunction hasDatabase(cozy, doctype) {\n\t  return getDatabase(cozy, doctype) !== undefined;\n\t}\n\t\n\tfunction getDatabase(cozy, doctype) {\n\t  return getInfo(cozy, doctype).database;\n\t}\n\t\n\tfunction setDatabase(cozy, doctype, database) {\n\t  cozy._offline[doctype].database = database;\n\t  return getDatabase(cozy, doctype);\n\t}\n\t\n\tfunction createDatabase(cozy, doctype) {\n\t  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  if (!pluginLoaded) {\n\t    _pouchdb2.default.plugin(_pouchdbFind2.default);\n\t    if (typeof pouchdbAdapterCordovaSqlite !== 'undefined') _pouchdb2.default.plugin(pouchdbAdapterCordovaSqlite);\n\t    pluginLoaded = true;\n\t  }\n\t\n\t  if (hasDatabase(cozy, doctype)) {\n\t    return Promise.resolve(getDatabase(cozy, doctype));\n\t  }\n\t\n\t  setDatabase(cozy, doctype, new _pouchdb2.default(doctype, options));\n\t  return createIndexes(cozy, doctype).then(function () {\n\t    return getDatabase(cozy, doctype);\n\t  });\n\t}\n\t\n\tfunction destroyDatabase(cozy, doctype) {\n\t  if (!hasDatabase(cozy, doctype)) {\n\t    return Promise.resolve(false);\n\t  }\n\t\n\t  return stopRepeatedReplication(cozy, doctype).then(function () {\n\t    return stopReplication(cozy, doctype);\n\t  }).then(function () {\n\t    return getDatabase(cozy, doctype).destroy();\n\t  }).then(function (response) {\n\t    setDatabase(cozy, doctype, undefined);\n\t    return response;\n\t  });\n\t}\n\t\n\tfunction destroyAllDatabase(cozy) {\n\t  var doctypes = getDoctypes(cozy);\n\t  var destroy = function destroy(doctype) {\n\t    return destroyDatabase(cozy, doctype);\n\t  };\n\t  return Promise.all(doctypes.map(destroy));\n\t}\n\t\n\tfunction createIndexes(cozy, doctype) {\n\t  if (doctype === _doctypes.DOCTYPE_FILES) {\n\t    return getDatabase(cozy, doctype).createIndex({ index: { fields: ['dir_id'] } });\n\t  }\n\t  return Promise.resolve();\n\t}\n\t\n\t//\n\t// REPLICATION\n\t//\n\t\n\tfunction hasReplication(cozy, doctype) {\n\t  return getReplication(cozy, doctype) !== undefined;\n\t}\n\t\n\tfunction getReplication(cozy, doctype) {\n\t  return getInfo(cozy, doctype).replication;\n\t}\n\t\n\tfunction setReplication(cozy, doctype, replication) {\n\t  cozy._offline[doctype].replication = replication;\n\t  return getReplication(cozy, doctype);\n\t}\n\t\n\tfunction getReplicationUrl(cozy, doctype) {\n\t  return cozy.authorize().then(function (credentials) {\n\t    var basic = credentials.token.toBasicAuth();\n\t    return (cozy._url + '/data/' + doctype).replace('//', '//' + basic);\n\t  });\n\t}\n\t\n\tfunction getReplicationPromise(cozy, doctype) {\n\t  return getInfo(cozy, doctype).replicationPromise;\n\t}\n\t\n\tfunction setReplicationPromise(cozy, doctype, promise) {\n\t  cozy._offline[doctype].replicationPromise = promise;\n\t  return getReplicationPromise(cozy, doctype);\n\t}\n\t\n\tfunction replicateFromCozy(cozy, doctype) {\n\t  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\t\n\t  return setReplicationPromise(cozy, doctype, new Promise(function (resolve, reject) {\n\t    if (!hasDatabase(cozy, doctype)) {\n\t      createDatabase(cozy, doctype);\n\t    }\n\t    if (options.live === true) {\n\t      return reject(new Error('You can\\'t use `live` option with Cozy couchdb.'));\n\t    }\n\t\n\t    if ((0, _utils.isOffline)()) {\n\t      reject(replicationOfflineError);\n\t      options.onError && options.onError(replicationOfflineError);\n\t      return;\n\t    }\n\t\n\t    getReplicationUrl(cozy, doctype).then(function (url) {\n\t      return setReplication(cozy, doctype, getDatabase(cozy, doctype).replicate.from(url, options).on('complete', function (info) {\n\t        setReplication(cozy, doctype, undefined);\n\t        resolve(info);\n\t        options.onComplete && options.onComplete(info);\n\t      }).on('error', function (err) {\n\t        if (err.error === 'code=400, message=Expired token') {\n\t          cozy.authorize().then(function (_ref2) {\n\t            var client = _ref2.client,\n\t                token = _ref2.token;\n\t\n\t            (0, _auth_v.refreshToken)(cozy, client, token).then(function (newToken) {\n\t              return cozy.saveCredentials(client, newToken);\n\t            }).then(function (credentials) {\n\t              return replicateFromCozy(cozy, doctype, options);\n\t            });\n\t          });\n\t        } else {\n\t          console.warn('ReplicateFromCozy \\'' + doctype + '\\' Error:');\n\t          console.warn(err);\n\t          setReplication(cozy, doctype, undefined);\n\t          reject(err);\n\t          options.onError && options.onError(err);\n\t        }\n\t      }));\n\t    });\n\t  }));\n\t}\n\t\n\tfunction stopReplication(cozy, doctype) {\n\t  if (!getDatabase(cozy, doctype) || !hasReplication(cozy, doctype)) {\n\t    return Promise.resolve();\n\t  }\n\t\n\t  return new Promise(function (resolve) {\n\t    try {\n\t      getReplicationPromise(cozy, doctype).then(function () {\n\t        resolve();\n\t      });\n\t      getReplication(cozy, doctype).cancel();\n\t      // replication is set to undefined by complete replication\n\t    } catch (e) {\n\t      resolve();\n\t    }\n\t  });\n\t}\n\t\n\tfunction stopAllReplication(cozy) {\n\t  var doctypes = getDoctypes(cozy);\n\t  var stop = function stop(doctype) {\n\t    return stopReplication(cozy, doctype);\n\t  };\n\t  return Promise.all(doctypes.map(stop));\n\t}\n\t\n\t//\n\t// REPEATED REPLICATION\n\t//\n\t\n\tfunction getRepeatedReplication(cozy, doctype) {\n\t  return getInfo(cozy, doctype).interval;\n\t}\n\t\n\tfunction setRepeatedReplication(cozy, doctype, interval) {\n\t  cozy._offline[doctype].interval = interval;\n\t}\n\t\n\tfunction hasRepeatedReplication(cozy, doctype) {\n\t  return getRepeatedReplication(cozy, doctype) !== undefined;\n\t}\n\t\n\tfunction startRepeatedReplication(cozy, doctype, timer) {\n\t  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\t\n\t  // TODO: add timer limitation for not flooding Gozy\n\t  if (hasRepeatedReplication(cozy, doctype)) {\n\t    return getRepeatedReplication(cozy, doctype);\n\t  }\n\t\n\t  return setRepeatedReplication(cozy, doctype, setInterval(function () {\n\t    if ((0, _utils.isOffline)()) {\n\t      // network is offline, replication cannot be launched\n\t      console.info(replicationOfflineError);\n\t      return;\n\t    }\n\t    if (!hasReplication(cozy, doctype)) {\n\t      replicateFromCozy(cozy, doctype, options);\n\t      // TODO: add replicationToCozy\n\t    }\n\t  }, timer * 1000));\n\t}\n\t\n\tfunction stopRepeatedReplication(cozy, doctype) {\n\t  if (hasRepeatedReplication(cozy, doctype)) {\n\t    clearInterval(getRepeatedReplication(cozy, doctype));\n\t    setRepeatedReplication(cozy, doctype, undefined);\n\t  }\n\t  if (hasReplication(cozy, doctype)) {\n\t    return stopReplication(cozy, doctype);\n\t  }\n\t\n\t  return Promise.resolve();\n\t}\n\t\n\tfunction stopAllRepeatedReplication(cozy) {\n\t  var doctypes = getDoctypes(cozy);\n\t  var stop = function stop(doctype) {\n\t    return stopRepeatedReplication(cozy, doctype);\n\t  };\n\t  return Promise.all(doctypes.map(stop));\n\t}\n\n/***/ },\n/* 118 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.removeReferencedFiles = exports.addReferencedFiles = undefined;\n\texports.listReferencedFiles = listReferencedFiles;\n\texports.fetchReferencedFiles = fetchReferencedFiles;\n\t\n\tvar _fetch = __webpack_require__(13);\n\t\n\tvar _doctypes = __webpack_require__(36);\n\t\n\tfunction updateRelations(verb) {\n\t  return function (cozy, doc, ids) {\n\t    if (!doc) throw new Error('missing doc argument');\n\t    if (!Array.isArray(ids)) ids = [ids];\n\t\n\t    var refs = ids.map(function (id) {\n\t      return { type: _doctypes.DOCTYPE_FILES, id: id };\n\t    });\n\t\n\t    return (0, _fetch.cozyFetchJSON)(cozy, verb, makeReferencesPath(doc), { data: refs });\n\t  };\n\t}\n\t\n\tvar addReferencedFiles = exports.addReferencedFiles = updateRelations('POST');\n\tvar removeReferencedFiles = exports.removeReferencedFiles = updateRelations('DELETE');\n\t\n\tfunction listReferencedFiles(cozy, doc) {\n\t  if (!doc) throw new Error('missing doc argument');\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', makeReferencesPath(doc)).then(function (files) {\n\t    return files.map(function (file) {\n\t      return file._id;\n\t    });\n\t  });\n\t}\n\t\n\tfunction fetchReferencedFiles(cozy, doc, options) {\n\t  if (!doc) throw new Error('missing doc argument');\n\t  var params = Object.keys(options).map(function (key) {\n\t    return '&page[' + key + ']=' + options[key];\n\t  }).join('');\n\t  // As datetime is the only sort option available, I see no reason to not have it by default\n\t  return (0, _fetch.cozyFetchRawJSON)(cozy, 'GET', makeReferencesPath(doc) + '?include=files&sort=datetime' + params);\n\t}\n\t\n\tfunction makeReferencesPath(doc) {\n\t  var type = encodeURIComponent(doc._type);\n\t  var id = encodeURIComponent(doc._id);\n\t  return '/data/' + type + '/' + id + '/relationships/references';\n\t}\n\n/***/ },\n/* 119 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.diskUsage = diskUsage;\n\texports.changePassphrase = changePassphrase;\n\texports.getInstance = getInstance;\n\texports.updateInstance = updateInstance;\n\texports.getClients = getClients;\n\texports.deleteClientById = deleteClientById;\n\texports.updateLastSync = updateLastSync;\n\t\n\tvar _fetch = __webpack_require__(13);\n\t\n\tfunction diskUsage(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/settings/disk-usage');\n\t}\n\t\n\tfunction changePassphrase(cozy, currentPassPhrase, newPassPhrase) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'PUT', '/settings/passphrase', {\n\t    current_passphrase: currentPassPhrase,\n\t    new_passphrase: newPassPhrase\n\t  });\n\t}\n\t\n\tfunction getInstance(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/settings/instance');\n\t}\n\t\n\tfunction updateInstance(cozy, instance) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'PUT', '/settings/instance', instance);\n\t}\n\t\n\tfunction getClients(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'GET', '/settings/clients');\n\t}\n\t\n\tfunction deleteClientById(cozy, id) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'DELETE', '/settings/clients/' + id);\n\t}\n\t\n\tfunction updateLastSync(cozy) {\n\t  return (0, _fetch.cozyFetchJSON)(cozy, 'POST', '/settings/synchronized');\n\t}\n\n/***/ },\n/* 120 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject = __webpack_require__(5)\n\t  , isArray  = __webpack_require__(85)\n\t  , SPECIES  = __webpack_require__(4)('species');\n\t\n\tmodule.exports = function(original){\n\t  var C;\n\t  if(isArray(original)){\n\t    C = original.constructor;\n\t    // cross-realm fallback\n\t    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;\n\t    if(isObject(C)){\n\t      C = C[SPECIES];\n\t      if(C === null)C = undefined;\n\t    }\n\t  } return C === undefined ? Array : C;\n\t};\n\n/***/ },\n/* 121 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\n\tvar speciesConstructor = __webpack_require__(120);\n\t\n\tmodule.exports = function(original, length){\n\t  return new (speciesConstructor(original))(length);\n\t};\n\n/***/ },\n/* 122 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar aFunction  = __webpack_require__(23)\n\t  , isObject   = __webpack_require__(5)\n\t  , invoke     = __webpack_require__(49)\n\t  , arraySlice = [].slice\n\t  , factories  = {};\n\t\n\tvar construct = function(F, len, args){\n\t  if(!(len in factories)){\n\t    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';\n\t    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n\t  } return factories[len](F, args);\n\t};\n\t\n\tmodule.exports = Function.bind || function bind(that /*, args... */){\n\t  var fn       = aFunction(this)\n\t    , partArgs = arraySlice.call(arguments, 1);\n\t  var bound = function(/* args... */){\n\t    var args = partArgs.concat(arraySlice.call(arguments));\n\t    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n\t  };\n\t  if(isObject(fn.prototype))bound.prototype = fn.prototype;\n\t  return bound;\n\t};\n\n/***/ },\n/* 123 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// all enumerable object keys, includes symbols\n\tvar getKeys = __webpack_require__(31)\n\t  , gOPS    = __webpack_require__(51)\n\t  , pIE     = __webpack_require__(43);\n\tmodule.exports = function(it){\n\t  var result     = getKeys(it)\n\t    , getSymbols = gOPS.f;\n\t  if(getSymbols){\n\t    var symbols = getSymbols(it)\n\t      , isEnum  = pIE.f\n\t      , i       = 0\n\t      , key;\n\t    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n\t  } return result;\n\t};\n\n/***/ },\n/* 124 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// 21.2.5.3 get RegExp.prototype.flags\n\tvar anObject = __webpack_require__(3);\n\tmodule.exports = function(){\n\t  var that   = anObject(this)\n\t    , result = '';\n\t  if(that.global)     result += 'g';\n\t  if(that.ignoreCase) result += 'i';\n\t  if(that.multiline)  result += 'm';\n\t  if(that.unicode)    result += 'u';\n\t  if(that.sticky)     result += 'y';\n\t  return result;\n\t};\n\n/***/ },\n/* 125 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar isObject       = __webpack_require__(5)\n\t  , setPrototypeOf = __webpack_require__(66).set;\n\tmodule.exports = function(that, target, C){\n\t  var P, S = target.constructor;\n\t  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){\n\t    setPrototypeOf(that, P);\n\t  } return that;\n\t};\n\n/***/ },\n/* 126 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar create         = __webpack_require__(40)\n\t  , descriptor     = __webpack_require__(19)\n\t  , setToStringTag = __webpack_require__(33)\n\t  , IteratorPrototype = {};\n\t\n\t// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\n\t__webpack_require__(11)(IteratorPrototype, __webpack_require__(4)('iterator'), function(){ return this; });\n\t\n\tmodule.exports = function(Constructor, NAME, next){\n\t  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n\t  setToStringTag(Constructor, NAME + ' Iterator');\n\t};\n\n/***/ },\n/* 127 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar getKeys   = __webpack_require__(31)\n\t  , toIObject = __webpack_require__(12);\n\tmodule.exports = function(object, el){\n\t  var O      = toIObject(object)\n\t    , keys   = getKeys(O)\n\t    , length = keys.length\n\t    , index  = 0\n\t    , key;\n\t  while(length > index)if(O[key = keys[index++]] === el)return key;\n\t};\n\n/***/ },\n/* 128 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global    = __webpack_require__(2)\n\t  , macrotask = __webpack_require__(71).set\n\t  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n\t  , process   = global.process\n\t  , Promise   = global.Promise\n\t  , isNode    = __webpack_require__(28)(process) == 'process';\n\t\n\tmodule.exports = function(){\n\t  var head, last, notify;\n\t\n\t  var flush = function(){\n\t    var parent, fn;\n\t    if(isNode && (parent = process.domain))parent.exit();\n\t    while(head){\n\t      fn   = head.fn;\n\t      head = head.next;\n\t      try {\n\t        fn();\n\t      } catch(e){\n\t        if(head)notify();\n\t        else last = undefined;\n\t        throw e;\n\t      }\n\t    } last = undefined;\n\t    if(parent)parent.enter();\n\t  };\n\t\n\t  // Node.js\n\t  if(isNode){\n\t    notify = function(){\n\t      process.nextTick(flush);\n\t    };\n\t  // browsers with MutationObserver\n\t  } else if(Observer){\n\t    var toggle = true\n\t      , node   = document.createTextNode('');\n\t    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n\t    notify = function(){\n\t      node.data = toggle = !toggle;\n\t    };\n\t  // environments with maybe non-completely correct, but existent Promise\n\t  } else if(Promise && Promise.resolve){\n\t    var promise = Promise.resolve();\n\t    notify = function(){\n\t      promise.then(flush);\n\t    };\n\t  // for other environments - macrotask based on:\n\t  // - setImmediate\n\t  // - MessageChannel\n\t  // - window.postMessag\n\t  // - onreadystatechange\n\t  // - setTimeout\n\t  } else {\n\t    notify = function(){\n\t      // strange IE + webpack dev server bug - use .call(global)\n\t      macrotask.call(global, flush);\n\t    };\n\t  }\n\t\n\t  return function(fn){\n\t    var task = {fn: fn, next: undefined};\n\t    if(last)last.next = task;\n\t    if(!head){\n\t      head = task;\n\t      notify();\n\t    } last = task;\n\t  };\n\t};\n\n/***/ },\n/* 129 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP       = __webpack_require__(7)\n\t  , anObject = __webpack_require__(3)\n\t  , getKeys  = __webpack_require__(31);\n\t\n\tmodule.exports = __webpack_require__(9) ? Object.defineProperties : function defineProperties(O, Properties){\n\t  anObject(O);\n\t  var keys   = getKeys(Properties)\n\t    , length = keys.length\n\t    , i = 0\n\t    , P;\n\t  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n\t  return O;\n\t};\n\n/***/ },\n/* 130 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\n\tvar toIObject = __webpack_require__(12)\n\t  , gOPN      = __webpack_require__(41).f\n\t  , toString  = {}.toString;\n\t\n\tvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n\t  ? Object.getOwnPropertyNames(window) : [];\n\t\n\tvar getWindowNames = function(it){\n\t  try {\n\t    return gOPN(it);\n\t  } catch(e){\n\t    return windowNames.slice();\n\t  }\n\t};\n\t\n\tmodule.exports.f = function getOwnPropertyNames(it){\n\t  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n\t};\n\n\n/***/ },\n/* 131 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar path      = __webpack_require__(132)\n\t  , invoke    = __webpack_require__(49)\n\t  , aFunction = __webpack_require__(23);\n\tmodule.exports = function(/* ...pargs */){\n\t  var fn     = aFunction(this)\n\t    , length = arguments.length\n\t    , pargs  = Array(length)\n\t    , i      = 0\n\t    , _      = path._\n\t    , holder = false;\n\t  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;\n\t  return function(/* ...args */){\n\t    var that = this\n\t      , aLen = arguments.length\n\t      , j = 0, k = 0, args;\n\t    if(!holder && !aLen)return invoke(fn, pargs, that);\n\t    args = pargs.slice();\n\t    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];\n\t    while(aLen > k)args.push(arguments[k++]);\n\t    return invoke(fn, args, that);\n\t  };\n\t};\n\n/***/ },\n/* 132 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(2);\n\n/***/ },\n/* 133 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar toInteger = __webpack_require__(34)\n\t  , defined   = __webpack_require__(17);\n\t// true  -> String#at\n\t// false -> String#codePointAt\n\tmodule.exports = function(TO_STRING){\n\t  return function(that, pos){\n\t    var s = String(defined(that))\n\t      , i = toInteger(pos)\n\t      , l = s.length\n\t      , a, b;\n\t    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n\t    a = s.charCodeAt(i);\n\t    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n\t      ? TO_STRING ? s.charAt(i) : a\n\t      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n\t  };\n\t};\n\n/***/ },\n/* 134 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar global         = __webpack_require__(2)\n\t  , core           = __webpack_require__(38)\n\t  , LIBRARY        = __webpack_require__(30)\n\t  , wksExt         = __webpack_require__(101)\n\t  , defineProperty = __webpack_require__(7).f;\n\tmodule.exports = function(name){\n\t  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n\t  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n\t};\n\n/***/ },\n/* 135 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.P, 'Array', {copyWithin: __webpack_require__(80)});\n\t\n\t__webpack_require__(26)('copyWithin');\n\n/***/ },\n/* 136 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.P, 'Array', {fill: __webpack_require__(55)});\n\t\n\t__webpack_require__(26)('fill');\n\n/***/ },\n/* 137 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\n\tvar $export = __webpack_require__(1)\n\t  , $find   = __webpack_require__(37)(6)\n\t  , KEY     = 'findIndex'\n\t  , forced  = true;\n\t// Shouldn't skip holes\n\tif(KEY in [])Array(1)[KEY](function(){ forced = false; });\n\t$export($export.P + $export.F * forced, 'Array', {\n\t  findIndex: function findIndex(callbackfn/*, that = undefined */){\n\t    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\t__webpack_require__(26)(KEY);\n\n/***/ },\n/* 138 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\n\tvar $export = __webpack_require__(1)\n\t  , $find   = __webpack_require__(37)(5)\n\t  , KEY     = 'find'\n\t  , forced  = true;\n\t// Shouldn't skip holes\n\tif(KEY in [])Array(1)[KEY](function(){ forced = false; });\n\t$export($export.P + $export.F * forced, 'Array', {\n\t  find: function find(callbackfn/*, that = undefined */){\n\t    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\t__webpack_require__(26)(KEY);\n\n/***/ },\n/* 139 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar ctx            = __webpack_require__(14)\n\t  , $export        = __webpack_require__(1)\n\t  , toObject       = __webpack_require__(24)\n\t  , call           = __webpack_require__(88)\n\t  , isArrayIter    = __webpack_require__(63)\n\t  , toLength       = __webpack_require__(10)\n\t  , createProperty = __webpack_require__(58)\n\t  , getIterFn      = __webpack_require__(73);\n\t\n\t$export($export.S + $export.F * !__webpack_require__(50)(function(iter){ Array.from(iter); }), 'Array', {\n\t  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n\t  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n\t    var O       = toObject(arrayLike)\n\t      , C       = typeof this == 'function' ? this : Array\n\t      , aLen    = arguments.length\n\t      , mapfn   = aLen > 1 ? arguments[1] : undefined\n\t      , mapping = mapfn !== undefined\n\t      , index   = 0\n\t      , iterFn  = getIterFn(O)\n\t      , length, result, step, iterator;\n\t    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n\t    // if object isn't iterable or it's array with default iterator - use simple case\n\t    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n\t      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n\t        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n\t      }\n\t    } else {\n\t      length = toLength(O.length);\n\t      for(result = new C(length); length > index; index++){\n\t        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n\t      }\n\t    }\n\t    result.length = index;\n\t    return result;\n\t  }\n\t});\n\n\n/***/ },\n/* 140 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $export        = __webpack_require__(1)\n\t  , createProperty = __webpack_require__(58);\n\t\n\t// WebKit Array.of isn't generic\n\t$export($export.S + $export.F * __webpack_require__(6)(function(){\n\t  function F(){}\n\t  return !(Array.of.call(F) instanceof F);\n\t}), 'Array', {\n\t  // 22.1.2.3 Array.of( ...items)\n\t  of: function of(/* ...args */){\n\t    var index  = 0\n\t      , aLen   = arguments.length\n\t      , result = new (typeof this == 'function' ? this : Array)(aLen);\n\t    while(aLen > index)createProperty(result, index, arguments[index++]);\n\t    result.length = aLen;\n\t    return result;\n\t  }\n\t});\n\n/***/ },\n/* 141 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar dP         = __webpack_require__(7).f\n\t  , createDesc = __webpack_require__(19)\n\t  , has        = __webpack_require__(8)\n\t  , FProto     = Function.prototype\n\t  , nameRE     = /^\\s*function ([^ (]*)/\n\t  , NAME       = 'name';\n\t\n\tvar isExtensible = Object.isExtensible || function(){\n\t  return true;\n\t};\n\t\n\t// 19.2.4.2 name\n\tNAME in FProto || __webpack_require__(9) && dP(FProto, NAME, {\n\t  configurable: true,\n\t  get: function(){\n\t    try {\n\t      var that = this\n\t        , name = ('' + that).match(nameRE)[1];\n\t      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));\n\t      return name;\n\t    } catch(e){\n\t      return '';\n\t    }\n\t  }\n\t});\n\n/***/ },\n/* 142 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar strong = __webpack_require__(81);\n\t\n\t// 23.1 Map Objects\n\tmodule.exports = __webpack_require__(46)('Map', function(get){\n\t  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n\t}, {\n\t  // 23.1.3.6 Map.prototype.get(key)\n\t  get: function get(key){\n\t    var entry = strong.getEntry(this, key);\n\t    return entry && entry.v;\n\t  },\n\t  // 23.1.3.9 Map.prototype.set(key, value)\n\t  set: function set(key, value){\n\t    return strong.def(this, key === 0 ? 0 : key, value);\n\t  }\n\t}, strong, true);\n\n/***/ },\n/* 143 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.3 Math.acosh(x)\n\tvar $export = __webpack_require__(1)\n\t  , log1p   = __webpack_require__(91)\n\t  , sqrt    = Math.sqrt\n\t  , $acosh  = Math.acosh;\n\t\n\t$export($export.S + $export.F * !($acosh\n\t  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n\t  && Math.floor($acosh(Number.MAX_VALUE)) == 710\n\t  // Tor Browser bug: Math.acosh(Infinity) -> NaN \n\t  && $acosh(Infinity) == Infinity\n\t), 'Math', {\n\t  acosh: function acosh(x){\n\t    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n\t      ? Math.log(x) + Math.LN2\n\t      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n\t  }\n\t});\n\n/***/ },\n/* 144 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.5 Math.asinh(x)\n\tvar $export = __webpack_require__(1)\n\t  , $asinh  = Math.asinh;\n\t\n\tfunction asinh(x){\n\t  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));\n\t}\n\t\n\t// Tor Browser bug: Math.asinh(0) -> -0 \n\t$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});\n\n/***/ },\n/* 145 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.7 Math.atanh(x)\n\tvar $export = __webpack_require__(1)\n\t  , $atanh  = Math.atanh;\n\t\n\t// Tor Browser bug: Math.atanh(-0) -> 0 \n\t$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {\n\t  atanh: function atanh(x){\n\t    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;\n\t  }\n\t});\n\n/***/ },\n/* 146 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.9 Math.cbrt(x)\n\tvar $export = __webpack_require__(1)\n\t  , sign    = __webpack_require__(65);\n\t\n\t$export($export.S, 'Math', {\n\t  cbrt: function cbrt(x){\n\t    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);\n\t  }\n\t});\n\n/***/ },\n/* 147 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.11 Math.clz32(x)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Math', {\n\t  clz32: function clz32(x){\n\t    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;\n\t  }\n\t});\n\n/***/ },\n/* 148 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.12 Math.cosh(x)\n\tvar $export = __webpack_require__(1)\n\t  , exp     = Math.exp;\n\t\n\t$export($export.S, 'Math', {\n\t  cosh: function cosh(x){\n\t    return (exp(x = +x) + exp(-x)) / 2;\n\t  }\n\t});\n\n/***/ },\n/* 149 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.14 Math.expm1(x)\n\tvar $export = __webpack_require__(1)\n\t  , $expm1  = __webpack_require__(64);\n\t\n\t$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});\n\n/***/ },\n/* 150 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.16 Math.fround(x)\n\tvar $export   = __webpack_require__(1)\n\t  , sign      = __webpack_require__(65)\n\t  , pow       = Math.pow\n\t  , EPSILON   = pow(2, -52)\n\t  , EPSILON32 = pow(2, -23)\n\t  , MAX32     = pow(2, 127) * (2 - EPSILON32)\n\t  , MIN32     = pow(2, -126);\n\t\n\tvar roundTiesToEven = function(n){\n\t  return n + 1 / EPSILON - 1 / EPSILON;\n\t};\n\t\n\t\n\t$export($export.S, 'Math', {\n\t  fround: function fround(x){\n\t    var $abs  = Math.abs(x)\n\t      , $sign = sign(x)\n\t      , a, result;\n\t    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n\t    a = (1 + EPSILON32 / EPSILON) * $abs;\n\t    result = a - (a - $abs);\n\t    if(result > MAX32 || result != result)return $sign * Infinity;\n\t    return $sign * result;\n\t  }\n\t});\n\n/***/ },\n/* 151 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])\n\tvar $export = __webpack_require__(1)\n\t  , abs     = Math.abs;\n\t\n\t$export($export.S, 'Math', {\n\t  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars\n\t    var sum  = 0\n\t      , i    = 0\n\t      , aLen = arguments.length\n\t      , larg = 0\n\t      , arg, div;\n\t    while(i < aLen){\n\t      arg = abs(arguments[i++]);\n\t      if(larg < arg){\n\t        div  = larg / arg;\n\t        sum  = sum * div * div + 1;\n\t        larg = arg;\n\t      } else if(arg > 0){\n\t        div  = arg / larg;\n\t        sum += div * div;\n\t      } else sum += arg;\n\t    }\n\t    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n\t  }\n\t});\n\n/***/ },\n/* 152 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.18 Math.imul(x, y)\n\tvar $export = __webpack_require__(1)\n\t  , $imul   = Math.imul;\n\t\n\t// some WebKit versions fails with big numbers, some has wrong arity\n\t$export($export.S + $export.F * __webpack_require__(6)(function(){\n\t  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;\n\t}), 'Math', {\n\t  imul: function imul(x, y){\n\t    var UINT16 = 0xffff\n\t      , xn = +x\n\t      , yn = +y\n\t      , xl = UINT16 & xn\n\t      , yl = UINT16 & yn;\n\t    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n\t  }\n\t});\n\n/***/ },\n/* 153 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.21 Math.log10(x)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Math', {\n\t  log10: function log10(x){\n\t    return Math.log(x) / Math.LN10;\n\t  }\n\t});\n\n/***/ },\n/* 154 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.20 Math.log1p(x)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Math', {log1p: __webpack_require__(91)});\n\n/***/ },\n/* 155 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.22 Math.log2(x)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Math', {\n\t  log2: function log2(x){\n\t    return Math.log(x) / Math.LN2;\n\t  }\n\t});\n\n/***/ },\n/* 156 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.28 Math.sign(x)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Math', {sign: __webpack_require__(65)});\n\n/***/ },\n/* 157 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.30 Math.sinh(x)\n\tvar $export = __webpack_require__(1)\n\t  , expm1   = __webpack_require__(64)\n\t  , exp     = Math.exp;\n\t\n\t// V8 near Chromium 38 has a problem with very small numbers\n\t$export($export.S + $export.F * __webpack_require__(6)(function(){\n\t  return !Math.sinh(-2e-17) != -2e-17;\n\t}), 'Math', {\n\t  sinh: function sinh(x){\n\t    return Math.abs(x = +x) < 1\n\t      ? (expm1(x) - expm1(-x)) / 2\n\t      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);\n\t  }\n\t});\n\n/***/ },\n/* 158 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.33 Math.tanh(x)\n\tvar $export = __webpack_require__(1)\n\t  , expm1   = __webpack_require__(64)\n\t  , exp     = Math.exp;\n\t\n\t$export($export.S, 'Math', {\n\t  tanh: function tanh(x){\n\t    var a = expm1(x = +x)\n\t      , b = expm1(-x);\n\t    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\n\t  }\n\t});\n\n/***/ },\n/* 159 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.2.2.34 Math.trunc(x)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Math', {\n\t  trunc: function trunc(it){\n\t    return (it > 0 ? Math.floor : Math.ceil)(it);\n\t  }\n\t});\n\n/***/ },\n/* 160 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.1.2.1 Number.EPSILON\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});\n\n/***/ },\n/* 161 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.1.2.2 Number.isFinite(number)\n\tvar $export   = __webpack_require__(1)\n\t  , _isFinite = __webpack_require__(2).isFinite;\n\t\n\t$export($export.S, 'Number', {\n\t  isFinite: function isFinite(it){\n\t    return typeof it == 'number' && _isFinite(it);\n\t  }\n\t});\n\n/***/ },\n/* 162 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.1.2.3 Number.isInteger(number)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Number', {isInteger: __webpack_require__(86)});\n\n/***/ },\n/* 163 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.1.2.4 Number.isNaN(number)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Number', {\n\t  isNaN: function isNaN(number){\n\t    return number != number;\n\t  }\n\t});\n\n/***/ },\n/* 164 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.1.2.5 Number.isSafeInteger(number)\n\tvar $export   = __webpack_require__(1)\n\t  , isInteger = __webpack_require__(86)\n\t  , abs       = Math.abs;\n\t\n\t$export($export.S, 'Number', {\n\t  isSafeInteger: function isSafeInteger(number){\n\t    return isInteger(number) && abs(number) <= 0x1fffffffffffff;\n\t  }\n\t});\n\n/***/ },\n/* 165 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.1.2.6 Number.MAX_SAFE_INTEGER\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});\n\n/***/ },\n/* 166 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 20.1.2.10 Number.MIN_SAFE_INTEGER\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});\n\n/***/ },\n/* 167 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.1 Object.assign(target, source)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S + $export.F, 'Object', {assign: __webpack_require__(92)});\n\n/***/ },\n/* 168 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.10 Object.is(value1, value2)\n\tvar $export = __webpack_require__(1);\n\t$export($export.S, 'Object', {is: __webpack_require__(96)});\n\n/***/ },\n/* 169 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 19.1.3.19 Object.setPrototypeOf(O, proto)\n\tvar $export = __webpack_require__(1);\n\t$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(66).set});\n\n/***/ },\n/* 170 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar LIBRARY            = __webpack_require__(30)\n\t  , global             = __webpack_require__(2)\n\t  , ctx                = __webpack_require__(14)\n\t  , classof            = __webpack_require__(57)\n\t  , $export            = __webpack_require__(1)\n\t  , isObject           = __webpack_require__(5)\n\t  , aFunction          = __webpack_require__(23)\n\t  , anInstance         = __webpack_require__(27)\n\t  , forOf              = __webpack_require__(48)\n\t  , speciesConstructor = __webpack_require__(97)\n\t  , task               = __webpack_require__(71).set\n\t  , microtask          = __webpack_require__(128)()\n\t  , PROMISE            = 'Promise'\n\t  , TypeError          = global.TypeError\n\t  , process            = global.process\n\t  , $Promise           = global[PROMISE]\n\t  , process            = global.process\n\t  , isNode             = classof(process) == 'process'\n\t  , empty              = function(){ /* empty */ }\n\t  , Internal, GenericPromiseCapability, Wrapper;\n\t\n\tvar USE_NATIVE = !!function(){\n\t  try {\n\t    // correct subclassing with @@species support\n\t    var promise     = $Promise.resolve(1)\n\t      , FakePromise = (promise.constructor = {})[__webpack_require__(4)('species')] = function(exec){ exec(empty, empty); };\n\t    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n\t    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n\t  } catch(e){ /* empty */ }\n\t}();\n\t\n\t// helpers\n\tvar sameConstructor = function(a, b){\n\t  // with library wrapper special case\n\t  return a === b || a === $Promise && b === Wrapper;\n\t};\n\tvar isThenable = function(it){\n\t  var then;\n\t  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n\t};\n\tvar newPromiseCapability = function(C){\n\t  return sameConstructor($Promise, C)\n\t    ? new PromiseCapability(C)\n\t    : new GenericPromiseCapability(C);\n\t};\n\tvar PromiseCapability = GenericPromiseCapability = function(C){\n\t  var resolve, reject;\n\t  this.promise = new C(function($$resolve, $$reject){\n\t    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n\t    resolve = $$resolve;\n\t    reject  = $$reject;\n\t  });\n\t  this.resolve = aFunction(resolve);\n\t  this.reject  = aFunction(reject);\n\t};\n\tvar perform = function(exec){\n\t  try {\n\t    exec();\n\t  } catch(e){\n\t    return {error: e};\n\t  }\n\t};\n\tvar notify = function(promise, isReject){\n\t  if(promise._n)return;\n\t  promise._n = true;\n\t  var chain = promise._c;\n\t  microtask(function(){\n\t    var value = promise._v\n\t      , ok    = promise._s == 1\n\t      , i     = 0;\n\t    var run = function(reaction){\n\t      var handler = ok ? reaction.ok : reaction.fail\n\t        , resolve = reaction.resolve\n\t        , reject  = reaction.reject\n\t        , domain  = reaction.domain\n\t        , result, then;\n\t      try {\n\t        if(handler){\n\t          if(!ok){\n\t            if(promise._h == 2)onHandleUnhandled(promise);\n\t            promise._h = 1;\n\t          }\n\t          if(handler === true)result = value;\n\t          else {\n\t            if(domain)domain.enter();\n\t            result = handler(value);\n\t            if(domain)domain.exit();\n\t          }\n\t          if(result === reaction.promise){\n\t            reject(TypeError('Promise-chain cycle'));\n\t          } else if(then = isThenable(result)){\n\t            then.call(result, resolve, reject);\n\t          } else resolve(result);\n\t        } else reject(value);\n\t      } catch(e){\n\t        reject(e);\n\t      }\n\t    };\n\t    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n\t    promise._c = [];\n\t    promise._n = false;\n\t    if(isReject && !promise._h)onUnhandled(promise);\n\t  });\n\t};\n\tvar onUnhandled = function(promise){\n\t  task.call(global, function(){\n\t    var value = promise._v\n\t      , abrupt, handler, console;\n\t    if(isUnhandled(promise)){\n\t      abrupt = perform(function(){\n\t        if(isNode){\n\t          process.emit('unhandledRejection', value, promise);\n\t        } else if(handler = global.onunhandledrejection){\n\t          handler({promise: promise, reason: value});\n\t        } else if((console = global.console) && console.error){\n\t          console.error('Unhandled promise rejection', value);\n\t        }\n\t      });\n\t      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n\t      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n\t    } promise._a = undefined;\n\t    if(abrupt)throw abrupt.error;\n\t  });\n\t};\n\tvar isUnhandled = function(promise){\n\t  if(promise._h == 1)return false;\n\t  var chain = promise._a || promise._c\n\t    , i     = 0\n\t    , reaction;\n\t  while(chain.length > i){\n\t    reaction = chain[i++];\n\t    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n\t  } return true;\n\t};\n\tvar onHandleUnhandled = function(promise){\n\t  task.call(global, function(){\n\t    var handler;\n\t    if(isNode){\n\t      process.emit('rejectionHandled', promise);\n\t    } else if(handler = global.onrejectionhandled){\n\t      handler({promise: promise, reason: promise._v});\n\t    }\n\t  });\n\t};\n\tvar $reject = function(value){\n\t  var promise = this;\n\t  if(promise._d)return;\n\t  promise._d = true;\n\t  promise = promise._w || promise; // unwrap\n\t  promise._v = value;\n\t  promise._s = 2;\n\t  if(!promise._a)promise._a = promise._c.slice();\n\t  notify(promise, true);\n\t};\n\tvar $resolve = function(value){\n\t  var promise = this\n\t    , then;\n\t  if(promise._d)return;\n\t  promise._d = true;\n\t  promise = promise._w || promise; // unwrap\n\t  try {\n\t    if(promise === value)throw TypeError(\"Promise can't be resolved itself\");\n\t    if(then = isThenable(value)){\n\t      microtask(function(){\n\t        var wrapper = {_w: promise, _d: false}; // wrap\n\t        try {\n\t          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n\t        } catch(e){\n\t          $reject.call(wrapper, e);\n\t        }\n\t      });\n\t    } else {\n\t      promise._v = value;\n\t      promise._s = 1;\n\t      notify(promise, false);\n\t    }\n\t  } catch(e){\n\t    $reject.call({_w: promise, _d: false}, e); // wrap\n\t  }\n\t};\n\t\n\t// constructor polyfill\n\tif(!USE_NATIVE){\n\t  // 25.4.3.1 Promise(executor)\n\t  $Promise = function Promise(executor){\n\t    anInstance(this, $Promise, PROMISE, '_h');\n\t    aFunction(executor);\n\t    Internal.call(this);\n\t    try {\n\t      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n\t    } catch(err){\n\t      $reject.call(this, err);\n\t    }\n\t  };\n\t  Internal = function Promise(executor){\n\t    this._c = [];             // <- awaiting reactions\n\t    this._a = undefined;      // <- checked in isUnhandled reactions\n\t    this._s = 0;              // <- state\n\t    this._d = false;          // <- done\n\t    this._v = undefined;      // <- value\n\t    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n\t    this._n = false;          // <- notify\n\t  };\n\t  Internal.prototype = __webpack_require__(32)($Promise.prototype, {\n\t    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n\t    then: function then(onFulfilled, onRejected){\n\t      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));\n\t      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;\n\t      reaction.fail   = typeof onRejected == 'function' && onRejected;\n\t      reaction.domain = isNode ? process.domain : undefined;\n\t      this._c.push(reaction);\n\t      if(this._a)this._a.push(reaction);\n\t      if(this._s)notify(this, false);\n\t      return reaction.promise;\n\t    },\n\t    // 25.4.5.1 Promise.prototype.catch(onRejected)\n\t    'catch': function(onRejected){\n\t      return this.then(undefined, onRejected);\n\t    }\n\t  });\n\t  PromiseCapability = function(){\n\t    var promise  = new Internal;\n\t    this.promise = promise;\n\t    this.resolve = ctx($resolve, promise, 1);\n\t    this.reject  = ctx($reject, promise, 1);\n\t  };\n\t}\n\t\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});\n\t__webpack_require__(33)($Promise, PROMISE);\n\t__webpack_require__(67)(PROMISE);\n\tWrapper = __webpack_require__(38)[PROMISE];\n\t\n\t// statics\n\t$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n\t  // 25.4.4.5 Promise.reject(r)\n\t  reject: function reject(r){\n\t    var capability = newPromiseCapability(this)\n\t      , $$reject   = capability.reject;\n\t    $$reject(r);\n\t    return capability.promise;\n\t  }\n\t});\n\t$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n\t  // 25.4.4.6 Promise.resolve(x)\n\t  resolve: function resolve(x){\n\t    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n\t    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;\n\t    var capability = newPromiseCapability(this)\n\t      , $$resolve  = capability.resolve;\n\t    $$resolve(x);\n\t    return capability.promise;\n\t  }\n\t});\n\t$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(50)(function(iter){\n\t  $Promise.all(iter)['catch'](empty);\n\t})), PROMISE, {\n\t  // 25.4.4.1 Promise.all(iterable)\n\t  all: function all(iterable){\n\t    var C          = this\n\t      , capability = newPromiseCapability(C)\n\t      , resolve    = capability.resolve\n\t      , reject     = capability.reject;\n\t    var abrupt = perform(function(){\n\t      var values    = []\n\t        , index     = 0\n\t        , remaining = 1;\n\t      forOf(iterable, false, function(promise){\n\t        var $index        = index++\n\t          , alreadyCalled = false;\n\t        values.push(undefined);\n\t        remaining++;\n\t        C.resolve(promise).then(function(value){\n\t          if(alreadyCalled)return;\n\t          alreadyCalled  = true;\n\t          values[$index] = value;\n\t          --remaining || resolve(values);\n\t        }, reject);\n\t      });\n\t      --remaining || resolve(values);\n\t    });\n\t    if(abrupt)reject(abrupt.error);\n\t    return capability.promise;\n\t  },\n\t  // 25.4.4.4 Promise.race(iterable)\n\t  race: function race(iterable){\n\t    var C          = this\n\t      , capability = newPromiseCapability(C)\n\t      , reject     = capability.reject;\n\t    var abrupt = perform(function(){\n\t      forOf(iterable, false, function(promise){\n\t        C.resolve(promise).then(capability.resolve, reject);\n\t      });\n\t    });\n\t    if(abrupt)reject(abrupt.error);\n\t    return capability.promise;\n\t  }\n\t});\n\n/***/ },\n/* 171 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\n\tvar $export   = __webpack_require__(1)\n\t  , aFunction = __webpack_require__(23)\n\t  , anObject  = __webpack_require__(3)\n\t  , rApply    = (__webpack_require__(2).Reflect || {}).apply\n\t  , fApply    = Function.apply;\n\t// MS Edge argumentsList argument is optional\n\t$export($export.S + $export.F * !__webpack_require__(6)(function(){\n\t  rApply(function(){});\n\t}), 'Reflect', {\n\t  apply: function apply(target, thisArgument, argumentsList){\n\t    var T = aFunction(target)\n\t      , L = anObject(argumentsList);\n\t    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);\n\t  }\n\t});\n\n/***/ },\n/* 172 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\n\tvar $export    = __webpack_require__(1)\n\t  , create     = __webpack_require__(40)\n\t  , aFunction  = __webpack_require__(23)\n\t  , anObject   = __webpack_require__(3)\n\t  , isObject   = __webpack_require__(5)\n\t  , fails      = __webpack_require__(6)\n\t  , bind       = __webpack_require__(122)\n\t  , rConstruct = (__webpack_require__(2).Reflect || {}).construct;\n\t\n\t// MS Edge supports only 2 arguments and argumentsList argument is optional\n\t// FF Nightly sets third argument as `new.target`, but does not create `this` from it\n\tvar NEW_TARGET_BUG = fails(function(){\n\t  function F(){}\n\t  return !(rConstruct(function(){}, [], F) instanceof F);\n\t});\n\tvar ARGS_BUG = !fails(function(){\n\t  rConstruct(function(){});\n\t});\n\t\n\t$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {\n\t  construct: function construct(Target, args /*, newTarget*/){\n\t    aFunction(Target);\n\t    anObject(args);\n\t    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n\t    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);\n\t    if(Target == newTarget){\n\t      // w/o altered newTarget, optimization for 0-4 arguments\n\t      switch(args.length){\n\t        case 0: return new Target;\n\t        case 1: return new Target(args[0]);\n\t        case 2: return new Target(args[0], args[1]);\n\t        case 3: return new Target(args[0], args[1], args[2]);\n\t        case 4: return new Target(args[0], args[1], args[2], args[3]);\n\t      }\n\t      // w/o altered newTarget, lot of arguments case\n\t      var $args = [null];\n\t      $args.push.apply($args, args);\n\t      return new (bind.apply(Target, $args));\n\t    }\n\t    // with altered newTarget, not support built-in constructors\n\t    var proto    = newTarget.prototype\n\t      , instance = create(isObject(proto) ? proto : Object.prototype)\n\t      , result   = Function.apply.call(Target, instance, args);\n\t    return isObject(result) ? result : instance;\n\t  }\n\t});\n\n/***/ },\n/* 173 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\n\tvar dP          = __webpack_require__(7)\n\t  , $export     = __webpack_require__(1)\n\t  , anObject    = __webpack_require__(3)\n\t  , toPrimitive = __webpack_require__(45);\n\t\n\t// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n\t$export($export.S + $export.F * __webpack_require__(6)(function(){\n\t  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});\n\t}), 'Reflect', {\n\t  defineProperty: function defineProperty(target, propertyKey, attributes){\n\t    anObject(target);\n\t    propertyKey = toPrimitive(propertyKey, true);\n\t    anObject(attributes);\n\t    try {\n\t      dP.f(target, propertyKey, attributes);\n\t      return true;\n\t    } catch(e){\n\t      return false;\n\t    }\n\t  }\n\t});\n\n/***/ },\n/* 174 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.4 Reflect.deleteProperty(target, propertyKey)\n\tvar $export  = __webpack_require__(1)\n\t  , gOPD     = __webpack_require__(18).f\n\t  , anObject = __webpack_require__(3);\n\t\n\t$export($export.S, 'Reflect', {\n\t  deleteProperty: function deleteProperty(target, propertyKey){\n\t    var desc = gOPD(anObject(target), propertyKey);\n\t    return desc && !desc.configurable ? false : delete target[propertyKey];\n\t  }\n\t});\n\n/***/ },\n/* 175 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\n\tvar gOPD     = __webpack_require__(18)\n\t  , $export  = __webpack_require__(1)\n\t  , anObject = __webpack_require__(3);\n\t\n\t$export($export.S, 'Reflect', {\n\t  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){\n\t    return gOPD.f(anObject(target), propertyKey);\n\t  }\n\t});\n\n/***/ },\n/* 176 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.8 Reflect.getPrototypeOf(target)\n\tvar $export  = __webpack_require__(1)\n\t  , getProto = __webpack_require__(42)\n\t  , anObject = __webpack_require__(3);\n\t\n\t$export($export.S, 'Reflect', {\n\t  getPrototypeOf: function getPrototypeOf(target){\n\t    return getProto(anObject(target));\n\t  }\n\t});\n\n/***/ },\n/* 177 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.6 Reflect.get(target, propertyKey [, receiver])\n\tvar gOPD           = __webpack_require__(18)\n\t  , getPrototypeOf = __webpack_require__(42)\n\t  , has            = __webpack_require__(8)\n\t  , $export        = __webpack_require__(1)\n\t  , isObject       = __webpack_require__(5)\n\t  , anObject       = __webpack_require__(3);\n\t\n\tfunction get(target, propertyKey/*, receiver*/){\n\t  var receiver = arguments.length < 3 ? target : arguments[2]\n\t    , desc, proto;\n\t  if(anObject(target) === receiver)return target[propertyKey];\n\t  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')\n\t    ? desc.value\n\t    : desc.get !== undefined\n\t      ? desc.get.call(receiver)\n\t      : undefined;\n\t  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);\n\t}\n\t\n\t$export($export.S, 'Reflect', {get: get});\n\n/***/ },\n/* 178 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.9 Reflect.has(target, propertyKey)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Reflect', {\n\t  has: function has(target, propertyKey){\n\t    return propertyKey in target;\n\t  }\n\t});\n\n/***/ },\n/* 179 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.10 Reflect.isExtensible(target)\n\tvar $export       = __webpack_require__(1)\n\t  , anObject      = __webpack_require__(3)\n\t  , $isExtensible = Object.isExtensible;\n\t\n\t$export($export.S, 'Reflect', {\n\t  isExtensible: function isExtensible(target){\n\t    anObject(target);\n\t    return $isExtensible ? $isExtensible(target) : true;\n\t  }\n\t});\n\n/***/ },\n/* 180 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.11 Reflect.ownKeys(target)\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.S, 'Reflect', {ownKeys: __webpack_require__(95)});\n\n/***/ },\n/* 181 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.12 Reflect.preventExtensions(target)\n\tvar $export            = __webpack_require__(1)\n\t  , anObject           = __webpack_require__(3)\n\t  , $preventExtensions = Object.preventExtensions;\n\t\n\t$export($export.S, 'Reflect', {\n\t  preventExtensions: function preventExtensions(target){\n\t    anObject(target);\n\t    try {\n\t      if($preventExtensions)$preventExtensions(target);\n\t      return true;\n\t    } catch(e){\n\t      return false;\n\t    }\n\t  }\n\t});\n\n/***/ },\n/* 182 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.14 Reflect.setPrototypeOf(target, proto)\n\tvar $export  = __webpack_require__(1)\n\t  , setProto = __webpack_require__(66);\n\t\n\tif(setProto)$export($export.S, 'Reflect', {\n\t  setPrototypeOf: function setPrototypeOf(target, proto){\n\t    setProto.check(target, proto);\n\t    try {\n\t      setProto.set(target, proto);\n\t      return true;\n\t    } catch(e){\n\t      return false;\n\t    }\n\t  }\n\t});\n\n/***/ },\n/* 183 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\n\tvar dP             = __webpack_require__(7)\n\t  , gOPD           = __webpack_require__(18)\n\t  , getPrototypeOf = __webpack_require__(42)\n\t  , has            = __webpack_require__(8)\n\t  , $export        = __webpack_require__(1)\n\t  , createDesc     = __webpack_require__(19)\n\t  , anObject       = __webpack_require__(3)\n\t  , isObject       = __webpack_require__(5);\n\t\n\tfunction set(target, propertyKey, V/*, receiver*/){\n\t  var receiver = arguments.length < 4 ? target : arguments[3]\n\t    , ownDesc  = gOPD.f(anObject(target), propertyKey)\n\t    , existingDescriptor, proto;\n\t  if(!ownDesc){\n\t    if(isObject(proto = getPrototypeOf(target))){\n\t      return set(proto, propertyKey, V, receiver);\n\t    }\n\t    ownDesc = createDesc(0);\n\t  }\n\t  if(has(ownDesc, 'value')){\n\t    if(ownDesc.writable === false || !isObject(receiver))return false;\n\t    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);\n\t    existingDescriptor.value = V;\n\t    dP.f(receiver, propertyKey, existingDescriptor);\n\t    return true;\n\t  }\n\t  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);\n\t}\n\t\n\t$export($export.S, 'Reflect', {set: set});\n\n/***/ },\n/* 184 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 21.2.5.3 get RegExp.prototype.flags()\n\tif(__webpack_require__(9) && /./g.flags != 'g')__webpack_require__(7).f(RegExp.prototype, 'flags', {\n\t  configurable: true,\n\t  get: __webpack_require__(124)\n\t});\n\n/***/ },\n/* 185 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// @@match logic\n\t__webpack_require__(47)('match', 1, function(defined, MATCH, $match){\n\t  // 21.1.3.11 String.prototype.match(regexp)\n\t  return [function match(regexp){\n\t    'use strict';\n\t    var O  = defined(this)\n\t      , fn = regexp == undefined ? undefined : regexp[MATCH];\n\t    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n\t  }, $match];\n\t});\n\n/***/ },\n/* 186 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// @@replace logic\n\t__webpack_require__(47)('replace', 2, function(defined, REPLACE, $replace){\n\t  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\n\t  return [function replace(searchValue, replaceValue){\n\t    'use strict';\n\t    var O  = defined(this)\n\t      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n\t    return fn !== undefined\n\t      ? fn.call(searchValue, O, replaceValue)\n\t      : $replace.call(String(O), searchValue, replaceValue);\n\t  }, $replace];\n\t});\n\n/***/ },\n/* 187 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// @@search logic\n\t__webpack_require__(47)('search', 1, function(defined, SEARCH, $search){\n\t  // 21.1.3.15 String.prototype.search(regexp)\n\t  return [function search(regexp){\n\t    'use strict';\n\t    var O  = defined(this)\n\t      , fn = regexp == undefined ? undefined : regexp[SEARCH];\n\t    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n\t  }, $search];\n\t});\n\n/***/ },\n/* 188 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// @@split logic\n\t__webpack_require__(47)('split', 2, function(defined, SPLIT, $split){\n\t  'use strict';\n\t  var isRegExp   = __webpack_require__(87)\n\t    , _split     = $split\n\t    , $push      = [].push\n\t    , $SPLIT     = 'split'\n\t    , LENGTH     = 'length'\n\t    , LAST_INDEX = 'lastIndex';\n\t  if(\n\t    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n\t    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n\t    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n\t    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n\t    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n\t    ''[$SPLIT](/.?/)[LENGTH]\n\t  ){\n\t    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group\n\t    // based on es5-shim implementation, need to rework it\n\t    $split = function(separator, limit){\n\t      var string = String(this);\n\t      if(separator === undefined && limit === 0)return [];\n\t      // If `separator` is not a regex, use native split\n\t      if(!isRegExp(separator))return _split.call(string, separator, limit);\n\t      var output = [];\n\t      var flags = (separator.ignoreCase ? 'i' : '') +\n\t                  (separator.multiline ? 'm' : '') +\n\t                  (separator.unicode ? 'u' : '') +\n\t                  (separator.sticky ? 'y' : '');\n\t      var lastLastIndex = 0;\n\t      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;\n\t      // Make `global` and avoid `lastIndex` issues by working with a copy\n\t      var separatorCopy = new RegExp(separator.source, flags + 'g');\n\t      var separator2, match, lastIndex, lastLength, i;\n\t      // Doesn't need flags gy, but they don't hurt\n\t      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\\\s)', flags);\n\t      while(match = separatorCopy.exec(string)){\n\t        // `separatorCopy.lastIndex` is not reliable cross-browser\n\t        lastIndex = match.index + match[0][LENGTH];\n\t        if(lastIndex > lastLastIndex){\n\t          output.push(string.slice(lastLastIndex, match.index));\n\t          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG\n\t          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){\n\t            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;\n\t          });\n\t          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));\n\t          lastLength = match[0][LENGTH];\n\t          lastLastIndex = lastIndex;\n\t          if(output[LENGTH] >= splitLimit)break;\n\t        }\n\t        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n\t      }\n\t      if(lastLastIndex === string[LENGTH]){\n\t        if(lastLength || !separatorCopy.test(''))output.push('');\n\t      } else output.push(string.slice(lastLastIndex));\n\t      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n\t    };\n\t  // Chakra, V8\n\t  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){\n\t    $split = function(separator, limit){\n\t      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);\n\t    };\n\t  }\n\t  // 21.1.3.17 String.prototype.split(separator, limit)\n\t  return [function split(separator, limit){\n\t    var O  = defined(this)\n\t      , fn = separator == undefined ? undefined : separator[SPLIT];\n\t    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);\n\t  }, $split];\n\t});\n\n/***/ },\n/* 189 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar strong = __webpack_require__(81);\n\t\n\t// 23.2 Set Objects\n\tmodule.exports = __webpack_require__(46)('Set', function(get){\n\t  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n\t}, {\n\t  // 23.2.3.1 Set.prototype.add(value)\n\t  add: function add(value){\n\t    return strong.def(this, value = value === 0 ? 0 : value, value);\n\t  }\n\t}, strong);\n\n/***/ },\n/* 190 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar $export = __webpack_require__(1)\n\t  , $at     = __webpack_require__(133)(false);\n\t$export($export.P, 'String', {\n\t  // 21.1.3.3 String.prototype.codePointAt(pos)\n\t  codePointAt: function codePointAt(pos){\n\t    return $at(this, pos);\n\t  }\n\t});\n\n/***/ },\n/* 191 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\n\t'use strict';\n\tvar $export   = __webpack_require__(1)\n\t  , toLength  = __webpack_require__(10)\n\t  , context   = __webpack_require__(70)\n\t  , ENDS_WITH = 'endsWith'\n\t  , $endsWith = ''[ENDS_WITH];\n\t\n\t$export($export.P + $export.F * __webpack_require__(61)(ENDS_WITH), 'String', {\n\t  endsWith: function endsWith(searchString /*, endPosition = @length */){\n\t    var that = context(this, searchString, ENDS_WITH)\n\t      , endPosition = arguments.length > 1 ? arguments[1] : undefined\n\t      , len    = toLength(that.length)\n\t      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)\n\t      , search = String(searchString);\n\t    return $endsWith\n\t      ? $endsWith.call(that, search, end)\n\t      : that.slice(end - search.length, end) === search;\n\t  }\n\t});\n\n/***/ },\n/* 192 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export        = __webpack_require__(1)\n\t  , toIndex        = __webpack_require__(44)\n\t  , fromCharCode   = String.fromCharCode\n\t  , $fromCodePoint = String.fromCodePoint;\n\t\n\t// length should be 1, old FF problem\n\t$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n\t  // 21.1.2.2 String.fromCodePoint(...codePoints)\n\t  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars\n\t    var res  = []\n\t      , aLen = arguments.length\n\t      , i    = 0\n\t      , code;\n\t    while(aLen > i){\n\t      code = +arguments[i++];\n\t      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');\n\t      res.push(code < 0x10000\n\t        ? fromCharCode(code)\n\t        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n\t      );\n\t    } return res.join('');\n\t  }\n\t});\n\n/***/ },\n/* 193 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n\t'use strict';\n\tvar $export  = __webpack_require__(1)\n\t  , context  = __webpack_require__(70)\n\t  , INCLUDES = 'includes';\n\t\n\t$export($export.P + $export.F * __webpack_require__(61)(INCLUDES), 'String', {\n\t  includes: function includes(searchString /*, position = 0 */){\n\t    return !!~context(this, searchString, INCLUDES)\n\t      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\n/***/ },\n/* 194 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export   = __webpack_require__(1)\n\t  , toIObject = __webpack_require__(12)\n\t  , toLength  = __webpack_require__(10);\n\t\n\t$export($export.S, 'String', {\n\t  // 21.1.2.4 String.raw(callSite, ...substitutions)\n\t  raw: function raw(callSite){\n\t    var tpl  = toIObject(callSite.raw)\n\t      , len  = toLength(tpl.length)\n\t      , aLen = arguments.length\n\t      , res  = []\n\t      , i    = 0;\n\t    while(len > i){\n\t      res.push(String(tpl[i++]));\n\t      if(i < aLen)res.push(String(arguments[i]));\n\t    } return res.join('');\n\t  }\n\t});\n\n/***/ },\n/* 195 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export = __webpack_require__(1);\n\t\n\t$export($export.P, 'String', {\n\t  // 21.1.3.13 String.prototype.repeat(count)\n\t  repeat: __webpack_require__(99)\n\t});\n\n/***/ },\n/* 196 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n\t'use strict';\n\tvar $export     = __webpack_require__(1)\n\t  , toLength    = __webpack_require__(10)\n\t  , context     = __webpack_require__(70)\n\t  , STARTS_WITH = 'startsWith'\n\t  , $startsWith = ''[STARTS_WITH];\n\t\n\t$export($export.P + $export.F * __webpack_require__(61)(STARTS_WITH), 'String', {\n\t  startsWith: function startsWith(searchString /*, position = 0 */){\n\t    var that   = context(this, searchString, STARTS_WITH)\n\t      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))\n\t      , search = String(searchString);\n\t    return $startsWith\n\t      ? $startsWith.call(that, search, index)\n\t      : that.slice(index, index + search.length) === search;\n\t  }\n\t});\n\n/***/ },\n/* 197 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// ECMAScript 6 symbols shim\n\tvar global         = __webpack_require__(2)\n\t  , has            = __webpack_require__(8)\n\t  , DESCRIPTORS    = __webpack_require__(9)\n\t  , $export        = __webpack_require__(1)\n\t  , redefine       = __webpack_require__(20)\n\t  , META           = __webpack_require__(39).KEY\n\t  , $fails         = __webpack_require__(6)\n\t  , shared         = __webpack_require__(69)\n\t  , setToStringTag = __webpack_require__(33)\n\t  , uid            = __webpack_require__(25)\n\t  , wks            = __webpack_require__(4)\n\t  , wksExt         = __webpack_require__(101)\n\t  , wksDefine      = __webpack_require__(134)\n\t  , keyOf          = __webpack_require__(127)\n\t  , enumKeys       = __webpack_require__(123)\n\t  , isArray        = __webpack_require__(85)\n\t  , anObject       = __webpack_require__(3)\n\t  , toIObject      = __webpack_require__(12)\n\t  , toPrimitive    = __webpack_require__(45)\n\t  , createDesc     = __webpack_require__(19)\n\t  , _create        = __webpack_require__(40)\n\t  , gOPNExt        = __webpack_require__(130)\n\t  , $GOPD          = __webpack_require__(18)\n\t  , $DP            = __webpack_require__(7)\n\t  , $keys          = __webpack_require__(31)\n\t  , gOPD           = $GOPD.f\n\t  , dP             = $DP.f\n\t  , gOPN           = gOPNExt.f\n\t  , $Symbol        = global.Symbol\n\t  , $JSON          = global.JSON\n\t  , _stringify     = $JSON && $JSON.stringify\n\t  , PROTOTYPE      = 'prototype'\n\t  , HIDDEN         = wks('_hidden')\n\t  , TO_PRIMITIVE   = wks('toPrimitive')\n\t  , isEnum         = {}.propertyIsEnumerable\n\t  , SymbolRegistry = shared('symbol-registry')\n\t  , AllSymbols     = shared('symbols')\n\t  , OPSymbols      = shared('op-symbols')\n\t  , ObjectProto    = Object[PROTOTYPE]\n\t  , USE_NATIVE     = typeof $Symbol == 'function'\n\t  , QObject        = global.QObject;\n\t// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\n\tvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\t\n\t// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\n\tvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n\t  return _create(dP({}, 'a', {\n\t    get: function(){ return dP(this, 'a', {value: 7}).a; }\n\t  })).a != 7;\n\t}) ? function(it, key, D){\n\t  var protoDesc = gOPD(ObjectProto, key);\n\t  if(protoDesc)delete ObjectProto[key];\n\t  dP(it, key, D);\n\t  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n\t} : dP;\n\t\n\tvar wrap = function(tag){\n\t  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n\t  sym._k = tag;\n\t  return sym;\n\t};\n\t\n\tvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n\t  return typeof it == 'symbol';\n\t} : function(it){\n\t  return it instanceof $Symbol;\n\t};\n\t\n\tvar $defineProperty = function defineProperty(it, key, D){\n\t  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n\t  anObject(it);\n\t  key = toPrimitive(key, true);\n\t  anObject(D);\n\t  if(has(AllSymbols, key)){\n\t    if(!D.enumerable){\n\t      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n\t      it[HIDDEN][key] = true;\n\t    } else {\n\t      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n\t      D = _create(D, {enumerable: createDesc(0, false)});\n\t    } return setSymbolDesc(it, key, D);\n\t  } return dP(it, key, D);\n\t};\n\tvar $defineProperties = function defineProperties(it, P){\n\t  anObject(it);\n\t  var keys = enumKeys(P = toIObject(P))\n\t    , i    = 0\n\t    , l = keys.length\n\t    , key;\n\t  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n\t  return it;\n\t};\n\tvar $create = function create(it, P){\n\t  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n\t};\n\tvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n\t  var E = isEnum.call(this, key = toPrimitive(key, true));\n\t  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n\t  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n\t};\n\tvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n\t  it  = toIObject(it);\n\t  key = toPrimitive(key, true);\n\t  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n\t  var D = gOPD(it, key);\n\t  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n\t  return D;\n\t};\n\tvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n\t  var names  = gOPN(toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n\t  } return result;\n\t};\n\tvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n\t  var IS_OP  = it === ObjectProto\n\t    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n\t    , result = []\n\t    , i      = 0\n\t    , key;\n\t  while(names.length > i){\n\t    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n\t  } return result;\n\t};\n\t\n\t// 19.4.1.1 Symbol([description])\n\tif(!USE_NATIVE){\n\t  $Symbol = function Symbol(){\n\t    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n\t    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n\t    var $set = function(value){\n\t      if(this === ObjectProto)$set.call(OPSymbols, value);\n\t      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n\t      setSymbolDesc(this, tag, createDesc(1, value));\n\t    };\n\t    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n\t    return wrap(tag);\n\t  };\n\t  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n\t    return this._k;\n\t  });\n\t\n\t  $GOPD.f = $getOwnPropertyDescriptor;\n\t  $DP.f   = $defineProperty;\n\t  __webpack_require__(41).f = gOPNExt.f = $getOwnPropertyNames;\n\t  __webpack_require__(43).f  = $propertyIsEnumerable;\n\t  __webpack_require__(51).f = $getOwnPropertySymbols;\n\t\n\t  if(DESCRIPTORS && !__webpack_require__(30)){\n\t    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n\t  }\n\t\n\t  wksExt.f = function(name){\n\t    return wrap(wks(name));\n\t  }\n\t}\n\t\n\t$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\t\n\tfor(var symbols = (\n\t  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n\t  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n\t).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\t\n\tfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n\t  // 19.4.2.1 Symbol.for(key)\n\t  'for': function(key){\n\t    return has(SymbolRegistry, key += '')\n\t      ? SymbolRegistry[key]\n\t      : SymbolRegistry[key] = $Symbol(key);\n\t  },\n\t  // 19.4.2.5 Symbol.keyFor(sym)\n\t  keyFor: function keyFor(key){\n\t    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n\t    throw TypeError(key + ' is not a symbol!');\n\t  },\n\t  useSetter: function(){ setter = true; },\n\t  useSimple: function(){ setter = false; }\n\t});\n\t\n\t$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n\t  // 19.1.2.2 Object.create(O [, Properties])\n\t  create: $create,\n\t  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n\t  defineProperty: $defineProperty,\n\t  // 19.1.2.3 Object.defineProperties(O, Properties)\n\t  defineProperties: $defineProperties,\n\t  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n\t  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n\t  // 19.1.2.7 Object.getOwnPropertyNames(O)\n\t  getOwnPropertyNames: $getOwnPropertyNames,\n\t  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n\t  getOwnPropertySymbols: $getOwnPropertySymbols\n\t});\n\t\n\t// 24.3.2 JSON.stringify(value [, replacer [, space]])\n\t$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n\t  var S = $Symbol();\n\t  // MS Edge converts symbol values to JSON as {}\n\t  // WebKit converts symbol values to JSON as null\n\t  // V8 throws on boxed symbols\n\t  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n\t})), 'JSON', {\n\t  stringify: function stringify(it){\n\t    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n\t    var args = [it]\n\t      , i    = 1\n\t      , replacer, $replacer;\n\t    while(arguments.length > i)args.push(arguments[i++]);\n\t    replacer = args[1];\n\t    if(typeof replacer == 'function')$replacer = replacer;\n\t    if($replacer || !isArray(replacer))replacer = function(key, value){\n\t      if($replacer)value = $replacer.call(this, key, value);\n\t      if(!isSymbol(value))return value;\n\t    };\n\t    args[1] = replacer;\n\t    return _stringify.apply($JSON, args);\n\t  }\n\t});\n\t\n\t// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n\t$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(11)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n\t// 19.4.3.5 Symbol.prototype[@@toStringTag]\n\tsetToStringTag($Symbol, 'Symbol');\n\t// 20.2.1.9 Math[@@toStringTag]\n\tsetToStringTag(Math, 'Math', true);\n\t// 24.3.3 JSON[@@toStringTag]\n\tsetToStringTag(global.JSON, 'JSON', true);\n\n/***/ },\n/* 198 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export = __webpack_require__(1);\n\t$export($export.G + $export.W + $export.F * !__webpack_require__(72).ABV, {\n\t  DataView: __webpack_require__(100).DataView\n\t});\n\n/***/ },\n/* 199 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(15)('Float32', 4, function(init){\n\t  return function Float32Array(data, byteOffset, length){\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n/***/ },\n/* 200 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(15)('Float64', 8, function(init){\n\t  return function Float64Array(data, byteOffset, length){\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n/***/ },\n/* 201 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(15)('Int16', 2, function(init){\n\t  return function Int16Array(data, byteOffset, length){\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n/***/ },\n/* 202 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(15)('Int32', 4, function(init){\n\t  return function Int32Array(data, byteOffset, length){\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n/***/ },\n/* 203 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(15)('Int8', 1, function(init){\n\t  return function Int8Array(data, byteOffset, length){\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n/***/ },\n/* 204 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(15)('Uint16', 2, function(init){\n\t  return function Uint16Array(data, byteOffset, length){\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n/***/ },\n/* 205 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(15)('Uint32', 4, function(init){\n\t  return function Uint32Array(data, byteOffset, length){\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n/***/ },\n/* 206 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(15)('Uint8', 1, function(init){\n\t  return function Uint8Array(data, byteOffset, length){\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t});\n\n/***/ },\n/* 207 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(15)('Uint8', 1, function(init){\n\t  return function Uint8ClampedArray(data, byteOffset, length){\n\t    return init(this, data, byteOffset, length);\n\t  };\n\t}, true);\n\n/***/ },\n/* 208 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar each         = __webpack_require__(37)(0)\n\t  , redefine     = __webpack_require__(20)\n\t  , meta         = __webpack_require__(39)\n\t  , assign       = __webpack_require__(92)\n\t  , weak         = __webpack_require__(82)\n\t  , isObject     = __webpack_require__(5)\n\t  , getWeak      = meta.getWeak\n\t  , isExtensible = Object.isExtensible\n\t  , uncaughtFrozenStore = weak.ufstore\n\t  , tmp          = {}\n\t  , InternalMap;\n\t\n\tvar wrapper = function(get){\n\t  return function WeakMap(){\n\t    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n\t  };\n\t};\n\t\n\tvar methods = {\n\t  // 23.3.3.3 WeakMap.prototype.get(key)\n\t  get: function get(key){\n\t    if(isObject(key)){\n\t      var data = getWeak(key);\n\t      if(data === true)return uncaughtFrozenStore(this).get(key);\n\t      return data ? data[this._i] : undefined;\n\t    }\n\t  },\n\t  // 23.3.3.5 WeakMap.prototype.set(key, value)\n\t  set: function set(key, value){\n\t    return weak.def(this, key, value);\n\t  }\n\t};\n\t\n\t// 23.3 WeakMap Objects\n\tvar $WeakMap = module.exports = __webpack_require__(46)('WeakMap', wrapper, methods, weak, true, true);\n\t\n\t// IE11 WeakMap frozen keys fix\n\tif(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){\n\t  InternalMap = weak.getConstructor(wrapper);\n\t  assign(InternalMap.prototype, methods);\n\t  meta.NEED = true;\n\t  each(['delete', 'has', 'get', 'set'], function(key){\n\t    var proto  = $WeakMap.prototype\n\t      , method = proto[key];\n\t    redefine(proto, key, function(a, b){\n\t      // store frozen objects on internal weakmap shim\n\t      if(isObject(a) && !isExtensible(a)){\n\t        if(!this._f)this._f = new InternalMap;\n\t        var result = this._f[key](a, b);\n\t        return key == 'set' ? this : result;\n\t      // store all the rest on native weakmap\n\t      } return method.call(this, a, b);\n\t    });\n\t  });\n\t}\n\n/***/ },\n/* 209 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar weak = __webpack_require__(82);\n\t\n\t// 23.4 WeakSet Objects\n\t__webpack_require__(46)('WeakSet', function(get){\n\t  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n\t}, {\n\t  // 23.4.3.1 WeakSet.prototype.add(value)\n\t  add: function add(value){\n\t    return weak.def(this, value, true);\n\t  }\n\t}, weak, false, true);\n\n/***/ },\n/* 210 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// https://github.com/tc39/Array.prototype.includes\n\tvar $export   = __webpack_require__(1)\n\t  , $includes = __webpack_require__(56)(true);\n\t\n\t$export($export.P, 'Array', {\n\t  includes: function includes(el /*, fromIndex = 0 */){\n\t    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n\t  }\n\t});\n\t\n\t__webpack_require__(26)('includes');\n\n/***/ },\n/* 211 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://github.com/tc39/proposal-object-values-entries\n\tvar $export  = __webpack_require__(1)\n\t  , $entries = __webpack_require__(94)(true);\n\t\n\t$export($export.S, 'Object', {\n\t  entries: function entries(it){\n\t    return $entries(it);\n\t  }\n\t});\n\n/***/ },\n/* 212 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://github.com/tc39/proposal-object-getownpropertydescriptors\n\tvar $export        = __webpack_require__(1)\n\t  , ownKeys        = __webpack_require__(95)\n\t  , toIObject      = __webpack_require__(12)\n\t  , gOPD           = __webpack_require__(18)\n\t  , createProperty = __webpack_require__(58);\n\t\n\t$export($export.S, 'Object', {\n\t  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){\n\t    var O       = toIObject(object)\n\t      , getDesc = gOPD.f\n\t      , keys    = ownKeys(O)\n\t      , result  = {}\n\t      , i       = 0\n\t      , key;\n\t    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));\n\t    return result;\n\t  }\n\t});\n\n/***/ },\n/* 213 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// https://github.com/tc39/proposal-object-values-entries\n\tvar $export = __webpack_require__(1)\n\t  , $values = __webpack_require__(94)(false);\n\t\n\t$export($export.S, 'Object', {\n\t  values: function values(it){\n\t    return $values(it);\n\t  }\n\t});\n\n/***/ },\n/* 214 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// https://github.com/tc39/proposal-string-pad-start-end\n\tvar $export = __webpack_require__(1)\n\t  , $pad    = __webpack_require__(98);\n\t\n\t$export($export.P, 'String', {\n\t  padEnd: function padEnd(maxLength /*, fillString = ' ' */){\n\t    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n\t  }\n\t});\n\n/***/ },\n/* 215 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t// https://github.com/tc39/proposal-string-pad-start-end\n\tvar $export = __webpack_require__(1)\n\t  , $pad    = __webpack_require__(98);\n\t\n\t$export($export.P, 'String', {\n\t  padStart: function padStart(maxLength /*, fillString = ' ' */){\n\t    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n\t  }\n\t});\n\n/***/ },\n/* 216 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $iterators    = __webpack_require__(74)\n\t  , redefine      = __webpack_require__(20)\n\t  , global        = __webpack_require__(2)\n\t  , hide          = __webpack_require__(11)\n\t  , Iterators     = __webpack_require__(29)\n\t  , wks           = __webpack_require__(4)\n\t  , ITERATOR      = wks('iterator')\n\t  , TO_STRING_TAG = wks('toStringTag')\n\t  , ArrayValues   = Iterators.Array;\n\t\n\tfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n\t  var NAME       = collections[i]\n\t    , Collection = global[NAME]\n\t    , proto      = Collection && Collection.prototype\n\t    , key;\n\t  if(proto){\n\t    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);\n\t    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n\t    Iterators[NAME] = ArrayValues;\n\t    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);\n\t  }\n\t}\n\n/***/ },\n/* 217 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar $export = __webpack_require__(1)\n\t  , $task   = __webpack_require__(71);\n\t$export($export.G + $export.B, {\n\t  setImmediate:   $task.set,\n\t  clearImmediate: $task.clear\n\t});\n\n/***/ },\n/* 218 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// ie9- setTimeout & setInterval additional parameters fix\n\tvar global     = __webpack_require__(2)\n\t  , $export    = __webpack_require__(1)\n\t  , invoke     = __webpack_require__(49)\n\t  , partial    = __webpack_require__(131)\n\t  , navigator  = global.navigator\n\t  , MSIE       = !!navigator && /MSIE .\\./.test(navigator.userAgent); // <- dirty ie9- check\n\tvar wrap = function(set){\n\t  return MSIE ? function(fn, time /*, ...args */){\n\t    return set(invoke(\n\t      partial,\n\t      [].slice.call(arguments, 2),\n\t      typeof fn == 'function' ? fn : Function(fn)\n\t    ), time);\n\t  } : set;\n\t};\n\t$export($export.G + $export.B + $export.F * MSIE, {\n\t  setTimeout:  wrap(global.setTimeout),\n\t  setInterval: wrap(global.setInterval)\n\t});\n\n/***/ },\n/* 219 */\n/***/ function(module, exports) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      } else {\n\t        // At least give some kind of context to the user\n\t        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n\t        err.context = er;\n\t        throw err;\n\t      }\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        args = Array.prototype.slice.call(arguments, 1);\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    args = Array.prototype.slice.call(arguments, 1);\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else if (listeners) {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.prototype.listenerCount = function(type) {\n\t  if (this._events) {\n\t    var evlistener = this._events[type];\n\t\n\t    if (isFunction(evlistener))\n\t      return 1;\n\t    else if (evlistener)\n\t      return evlistener.length;\n\t  }\n\t  return 0;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  return emitter.listenerCount(type);\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 220 */\n/***/ function(module, exports) {\n\n\t\n\t/**\n\t * isArray\n\t */\n\t\n\tvar isArray = Array.isArray;\n\t\n\t/**\n\t * toString\n\t */\n\t\n\tvar str = Object.prototype.toString;\n\t\n\t/**\n\t * Whether or not the given `val`\n\t * is an array.\n\t *\n\t * example:\n\t *\n\t *        isArray([]);\n\t *        // > true\n\t *        isArray(arguments);\n\t *        // > false\n\t *        isArray('');\n\t *        // > false\n\t *\n\t * @param {mixed} val\n\t * @return {bool}\n\t */\n\t\n\tmodule.exports = isArray || function (val) {\n\t  return !! val && '[object Array]' == str.call(val);\n\t};\n\n\n/***/ },\n/* 221 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// the whatwg-fetch polyfill installs the fetch() function\n\t// on the global object (window or self)\n\t//\n\t// Return that as the export for use in Webpack, Browserify etc.\n\t__webpack_require__(249);\n\tmodule.exports = self.fetch.bind(self);\n\n\n/***/ },\n/* 222 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\tvar immediate = __webpack_require__(52);\n\t\n\t/* istanbul ignore next */\n\tfunction INTERNAL() {}\n\t\n\tvar handlers = {};\n\t\n\tvar REJECTED = ['REJECTED'];\n\tvar FULFILLED = ['FULFILLED'];\n\tvar PENDING = ['PENDING'];\n\t\n\tmodule.exports = Promise;\n\t\n\tfunction Promise(resolver) {\n\t  if (typeof resolver !== 'function') {\n\t    throw new TypeError('resolver must be a function');\n\t  }\n\t  this.state = PENDING;\n\t  this.queue = [];\n\t  this.outcome = void 0;\n\t  if (resolver !== INTERNAL) {\n\t    safelyResolveThenable(this, resolver);\n\t  }\n\t}\n\t\n\tPromise.prototype[\"catch\"] = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\tPromise.prototype.then = function (onFulfilled, onRejected) {\n\t  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n\t    typeof onRejected !== 'function' && this.state === REJECTED) {\n\t    return this;\n\t  }\n\t  var promise = new this.constructor(INTERNAL);\n\t  if (this.state !== PENDING) {\n\t    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n\t    unwrap(promise, resolver, this.outcome);\n\t  } else {\n\t    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n\t  }\n\t\n\t  return promise;\n\t};\n\tfunction QueueItem(promise, onFulfilled, onRejected) {\n\t  this.promise = promise;\n\t  if (typeof onFulfilled === 'function') {\n\t    this.onFulfilled = onFulfilled;\n\t    this.callFulfilled = this.otherCallFulfilled;\n\t  }\n\t  if (typeof onRejected === 'function') {\n\t    this.onRejected = onRejected;\n\t    this.callRejected = this.otherCallRejected;\n\t  }\n\t}\n\tQueueItem.prototype.callFulfilled = function (value) {\n\t  handlers.resolve(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallFulfilled = function (value) {\n\t  unwrap(this.promise, this.onFulfilled, value);\n\t};\n\tQueueItem.prototype.callRejected = function (value) {\n\t  handlers.reject(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallRejected = function (value) {\n\t  unwrap(this.promise, this.onRejected, value);\n\t};\n\t\n\tfunction unwrap(promise, func, value) {\n\t  immediate(function () {\n\t    var returnValue;\n\t    try {\n\t      returnValue = func(value);\n\t    } catch (e) {\n\t      return handlers.reject(promise, e);\n\t    }\n\t    if (returnValue === promise) {\n\t      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n\t    } else {\n\t      handlers.resolve(promise, returnValue);\n\t    }\n\t  });\n\t}\n\t\n\thandlers.resolve = function (self, value) {\n\t  var result = tryCatch(getThen, value);\n\t  if (result.status === 'error') {\n\t    return handlers.reject(self, result.value);\n\t  }\n\t  var thenable = result.value;\n\t\n\t  if (thenable) {\n\t    safelyResolveThenable(self, thenable);\n\t  } else {\n\t    self.state = FULFILLED;\n\t    self.outcome = value;\n\t    var i = -1;\n\t    var len = self.queue.length;\n\t    while (++i < len) {\n\t      self.queue[i].callFulfilled(value);\n\t    }\n\t  }\n\t  return self;\n\t};\n\thandlers.reject = function (self, error) {\n\t  self.state = REJECTED;\n\t  self.outcome = error;\n\t  var i = -1;\n\t  var len = self.queue.length;\n\t  while (++i < len) {\n\t    self.queue[i].callRejected(error);\n\t  }\n\t  return self;\n\t};\n\t\n\tfunction getThen(obj) {\n\t  // Make sure we only access the accessor once as required by the spec\n\t  var then = obj && obj.then;\n\t  if (obj && typeof obj === 'object' && typeof then === 'function') {\n\t    return function appyThen() {\n\t      then.apply(obj, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction safelyResolveThenable(self, thenable) {\n\t  // Either fulfill, reject or reject with error\n\t  var called = false;\n\t  function onError(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.reject(self, value);\n\t  }\n\t\n\t  function onSuccess(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.resolve(self, value);\n\t  }\n\t\n\t  function tryToUnwrap() {\n\t    thenable(onSuccess, onError);\n\t  }\n\t\n\t  var result = tryCatch(tryToUnwrap);\n\t  if (result.status === 'error') {\n\t    onError(result.value);\n\t  }\n\t}\n\t\n\tfunction tryCatch(func, value) {\n\t  var out = {};\n\t  try {\n\t    out.value = func(value);\n\t    out.status = 'success';\n\t  } catch (e) {\n\t    out.status = 'error';\n\t    out.value = e;\n\t  }\n\t  return out;\n\t}\n\t\n\tPromise.resolve = resolve;\n\tfunction resolve(value) {\n\t  if (value instanceof this) {\n\t    return value;\n\t  }\n\t  return handlers.resolve(new this(INTERNAL), value);\n\t}\n\t\n\tPromise.reject = reject;\n\tfunction reject(reason) {\n\t  var promise = new this(INTERNAL);\n\t  return handlers.reject(promise, reason);\n\t}\n\t\n\tPromise.all = all;\n\tfunction all(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var values = new Array(len);\n\t  var resolved = 0;\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    allResolver(iterable[i], i);\n\t  }\n\t  return promise;\n\t  function allResolver(value, i) {\n\t    self.resolve(value).then(resolveFromAll, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t    function resolveFromAll(outValue) {\n\t      values[i] = outValue;\n\t      if (++resolved === len && !called) {\n\t        called = true;\n\t        handlers.resolve(promise, values);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tPromise.race = race;\n\tfunction race(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    resolver(iterable[i]);\n\t  }\n\t  return promise;\n\t  function resolver(value) {\n\t    self.resolve(value).then(function (response) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.resolve(promise, response);\n\t      }\n\t    }, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t  }\n\t}\n\n\n/***/ },\n/* 223 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tfunction pad(str, padWith, upToLength) {\n\t  var padding = '';\n\t  var targetLength = upToLength - str.length;\n\t  while (padding.length < targetLength) {\n\t    padding += padWith;\n\t  }\n\t  return padding;\n\t}\n\t\n\texports.padLeft = function (str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return padding + str;\n\t};\n\t\n\texports.padRight = function (str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return str + padding;\n\t};\n\t\n\texports.stringLexCompare = function (a, b) {\n\t\n\t  var aLen = a.length;\n\t  var bLen = b.length;\n\t\n\t  var i;\n\t  for (i = 0; i < aLen; i++) {\n\t    if (i === bLen) {\n\t      // b is shorter substring of a\n\t      return 1;\n\t    }\n\t    var aChar = a.charAt(i);\n\t    var bChar = b.charAt(i);\n\t    if (aChar !== bChar) {\n\t      return aChar < bChar ? -1 : 1;\n\t    }\n\t  }\n\t\n\t  if (aLen < bLen) {\n\t    // a is shorter substring of b\n\t    return -1;\n\t  }\n\t\n\t  return 0;\n\t};\n\t\n\t/*\n\t * returns the decimal form for the given integer, i.e. writes\n\t * out all the digits (in base-10) instead of using scientific notation\n\t */\n\texports.intToDecimalForm = function (int) {\n\t\n\t  var isNeg = int < 0;\n\t  var result = '';\n\t\n\t  do {\n\t    var remainder = isNeg ? -Math.ceil(int % 10) : Math.floor(int % 10);\n\t\n\t    result = remainder + result;\n\t    int = isNeg ? Math.ceil(int / 10) : Math.floor(int / 10);\n\t  } while (int);\n\t\n\t\n\t  if (isNeg && result !== '0') {\n\t    result = '-' + result;\n\t  }\n\t\n\t  return result;\n\t};\n\n/***/ },\n/* 224 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar upsert = __webpack_require__(103);\n\tvar utils = __webpack_require__(76);\n\tvar Promise = utils.Promise;\n\t\n\tfunction stringify(input) {\n\t  if (!input) {\n\t    return 'undefined'; // backwards compat for empty reduce\n\t  }\n\t  // for backwards compat with mapreduce, functions/strings are stringified\n\t  // as-is. everything else is JSON-stringified.\n\t  switch (typeof input) {\n\t    case 'function':\n\t      // e.g. a mapreduce map\n\t      return input.toString();\n\t    case 'string':\n\t      // e.g. a mapreduce built-in _reduce function\n\t      return input.toString();\n\t    default:\n\t      // e.g. a JSON object in the case of mango queries\n\t      return JSON.stringify(input);\n\t  }\n\t}\n\t\n\tmodule.exports = function (opts) {\n\t  var sourceDB = opts.db;\n\t  var viewName = opts.viewName;\n\t  var mapFun = opts.map;\n\t  var reduceFun = opts.reduce;\n\t  var temporary = opts.temporary;\n\t  var pluginName = opts.pluginName;\n\t\n\t  // the \"undefined\" part is for backwards compatibility\n\t  var viewSignature = stringify(mapFun) + stringify(reduceFun) +\n\t    'undefined';\n\t\n\t  if (!temporary && sourceDB._cachedViews) {\n\t    var cachedView = sourceDB._cachedViews[viewSignature];\n\t    if (cachedView) {\n\t      return Promise.resolve(cachedView);\n\t    }\n\t  }\n\t\n\t  return sourceDB.info().then(function (info) {\n\t\n\t    var depDbName = info.db_name + '-mrview-' +\n\t      (temporary ? 'temp' : utils.MD5(viewSignature));\n\t\n\t    // save the view name in the source PouchDB so it can be cleaned up if necessary\n\t    // (e.g. when the _design doc is deleted, remove all associated view data)\n\t    function diffFunction(doc) {\n\t      doc.views = doc.views || {};\n\t      var fullViewName = viewName;\n\t      if (fullViewName.indexOf('/') === -1) {\n\t        fullViewName = viewName + '/' + viewName;\n\t      }\n\t      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n\t      /* istanbul ignore if */\n\t      if (depDbs[depDbName]) {\n\t        return; // no update necessary\n\t      }\n\t      depDbs[depDbName] = true;\n\t      return doc;\n\t    }\n\t    return upsert(sourceDB, '_local/' + pluginName, diffFunction).then(function () {\n\t      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n\t        var db = res.db;\n\t        db.auto_compaction = true;\n\t        var view = {\n\t          name: depDbName,\n\t          db: db, \n\t          sourceDB: sourceDB,\n\t          adapter: sourceDB.adapter,\n\t          mapFun: mapFun,\n\t          reduceFun: reduceFun\n\t        };\n\t        return view.db.get('_local/lastSeq').catch(function (err) {\n\t          /* istanbul ignore if */\n\t          if (err.status !== 404) {\n\t            throw err;\n\t          }\n\t        }).then(function (lastSeqDoc) {\n\t          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n\t          if (!temporary) {\n\t            sourceDB._cachedViews = sourceDB._cachedViews || {};\n\t            sourceDB._cachedViews[viewSignature] = view;\n\t            view.db.on('destroyed', function () {\n\t              delete sourceDB._cachedViews[viewSignature];\n\t            });\n\t          }\n\t          return view;\n\t        });\n\t      });\n\t    });\n\t  });\n\t};\n\n\n/***/ },\n/* 225 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\t\n\tvar pouchCollate = __webpack_require__(53);\n\tvar TaskQueue = __webpack_require__(226);\n\tvar collate = pouchCollate.collate;\n\tvar toIndexableString = pouchCollate.toIndexableString;\n\tvar normalizeKey = pouchCollate.normalizeKey;\n\tvar createView = __webpack_require__(224);\n\tvar log;\n\t/* istanbul ignore else */\n\tif ((typeof console !== 'undefined') && (typeof console.log === 'function')) {\n\t  log = Function.prototype.bind.call(console.log, console);\n\t} else {\n\t  log = function () {};\n\t}\n\tvar utils = __webpack_require__(76);\n\tvar Promise = utils.Promise;\n\tvar persistentQueues = {};\n\tvar tempViewQueue = new TaskQueue();\n\tvar CHANGES_BATCH_SIZE = 50;\n\t\n\tfunction QueryParseError(message) {\n\t  this.status = 400;\n\t  this.name = 'query_parse_error';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, QueryParseError);\n\t  } catch (e) {}\n\t}\n\t\n\tutils.inherits(QueryParseError, Error);\n\t\n\tfunction NotFoundError(message) {\n\t  this.status = 404;\n\t  this.name = 'not_found';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, NotFoundError);\n\t  } catch (e) {}\n\t}\n\t\n\tutils.inherits(NotFoundError, Error);\n\t\n\tfunction parseViewName(name) {\n\t  // can be either 'ddocname/viewname' or just 'viewname'\n\t  // (where the ddoc name is the same)\n\t  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n\t}\n\t\n\tfunction isGenOne(changes) {\n\t  // only return true if the current change is 1-\n\t  // and there are no other leafs\n\t  return changes.length === 1 && /^1-/.test(changes[0].rev);\n\t}\n\t\n\tfunction sortByKeyThenValue(x, y) {\n\t  var keyCompare = collate(x.key, y.key);\n\t  return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n\t}\n\t\n\tfunction sliceResults(results, limit, skip) {\n\t  skip = skip || 0;\n\t  if (typeof limit === 'number') {\n\t    return results.slice(skip, limit + skip);\n\t  } else if (skip > 0) {\n\t    return results.slice(skip);\n\t  }\n\t  return results;\n\t}\n\t\n\tfunction rowToDocId(row) {\n\t  var val = row.value;\n\t  // Users can explicitly specify a joined doc _id, or it\n\t  // defaults to the doc _id that emitted the key/value.\n\t  var docId = (val && typeof val === 'object' && val._id) || row.id;\n\t  return docId;\n\t}\n\t\n\tfunction emitError(db, e) {\n\t  try {\n\t    db.emit('error', e);\n\t  } catch (err) {\n\t    console.error(\n\t      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n\t      'You can debug this error by doing:\\n' +\n\t      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n\t      'Please double-check your map/reduce function.');\n\t    console.error(e);\n\t  }\n\t}\n\t\n\tfunction tryCode(db, fun, args) {\n\t  // emit an event if there was an error thrown by a map/reduce function.\n\t  // putting try/catches in a single function also avoids deoptimizations.\n\t  try {\n\t    return {\n\t      output : fun.apply(null, args)\n\t    };\n\t  } catch (e) {\n\t    emitError(db, e);\n\t    return {error: e};\n\t  }\n\t}\n\t\n\tfunction checkQueryParseError(options, fun) {\n\t  var startkeyName = options.descending ? 'endkey' : 'startkey';\n\t  var endkeyName = options.descending ? 'startkey' : 'endkey';\n\t\n\t  if (typeof options[startkeyName] !== 'undefined' &&\n\t    typeof options[endkeyName] !== 'undefined' &&\n\t    collate(options[startkeyName], options[endkeyName]) > 0) {\n\t    throw new QueryParseError('No rows can match your key range, reverse your ' +\n\t    'start_key and end_key or set {descending : true}');\n\t  } else if (fun.reduce && options.reduce !== false) {\n\t    if (options.include_docs) {\n\t      throw new QueryParseError('{include_docs:true} is invalid for reduce');\n\t    } else if (options.keys && options.keys.length > 1 &&\n\t      !options.group && !options.group_level) {\n\t      throw new QueryParseError('Multi-key fetches for reduce views must use {group: true}');\n\t    }\n\t  }\n\t  if (options.group_level) {\n\t    if (typeof options.group_level !== 'number') {\n\t      throw new QueryParseError('Invalid value for integer: \"' + options.group_level + '\"');\n\t    }\n\t    if (options.group_level < 0) {\n\t      throw new QueryParseError('Invalid value for positive integer: ' +\n\t      '\"' + options.group_level + '\"');\n\t    }\n\t  }\n\t}\n\t\n\tfunction defaultsTo(value) {\n\t  return function (reason) {\n\t    /* istanbul ignore else */\n\t    if (reason.status === 404) {\n\t      return value;\n\t    } else {\n\t      throw reason;\n\t    }\n\t  };\n\t}\n\t\n\tfunction createIndexer(def) {\n\t\n\t  var pluginName = def.name;\n\t  var mapper = def.mapper;\n\t  var reducer = def.reducer;\n\t  var ddocValidator = def.ddocValidator;\n\t\n\t\n\t  // returns a promise for a list of docs to update, based on the input docId.\n\t  // the order doesn't matter, because post-3.2.0, bulkDocs\n\t  // is an atomic operation in all three adapters.\n\t  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n\t    var metaDocId = '_local/doc_' + docId;\n\t    var defaultMetaDoc = {_id: metaDocId, keys: []};\n\t    var docData = docIdsToChangesAndEmits[docId];\n\t    var indexableKeysToKeyValues = docData.indexableKeysToKeyValues;\n\t    var changes = docData.changes;\n\t\n\t    function getMetaDoc() {\n\t      if (isGenOne(changes)) {\n\t        // generation 1, so we can safely assume initial state\n\t        // for performance reasons (avoids unnecessary GETs)\n\t        return Promise.resolve(defaultMetaDoc);\n\t      }\n\t      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n\t    }\n\t\n\t    function getKeyValueDocs(metaDoc) {\n\t      if (!metaDoc.keys.length) {\n\t        // no keys, no need for a lookup\n\t        return Promise.resolve({rows: []});\n\t      }\n\t      return view.db.allDocs({\n\t        keys: metaDoc.keys,\n\t        include_docs: true\n\t      });\n\t    }\n\t\n\t    function processKvDocs(metaDoc, kvDocsRes) {\n\t      var kvDocs = [];\n\t      var oldKeysMap = {};\n\t\n\t      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n\t        var row = kvDocsRes.rows[i];\n\t        var doc = row.doc;\n\t        if (!doc) { // deleted\n\t          continue;\n\t        }\n\t        kvDocs.push(doc);\n\t        oldKeysMap[doc._id] = true;\n\t        doc._deleted = !indexableKeysToKeyValues[doc._id];\n\t        if (!doc._deleted) {\n\t          var keyValue = indexableKeysToKeyValues[doc._id];\n\t          if ('value' in keyValue) {\n\t            doc.value = keyValue.value;\n\t          }\n\t        }\n\t      }\n\t\n\t      var newKeys = Object.keys(indexableKeysToKeyValues);\n\t      newKeys.forEach(function (key) {\n\t        if (!oldKeysMap[key]) {\n\t          // new doc\n\t          var kvDoc = {\n\t            _id: key\n\t          };\n\t          var keyValue = indexableKeysToKeyValues[key];\n\t          if ('value' in keyValue) {\n\t            kvDoc.value = keyValue.value;\n\t          }\n\t          kvDocs.push(kvDoc);\n\t        }\n\t      });\n\t      metaDoc.keys = utils.uniq(newKeys.concat(metaDoc.keys));\n\t      kvDocs.push(metaDoc);\n\t\n\t      return kvDocs;\n\t    }\n\t\n\t    return getMetaDoc().then(function (metaDoc) {\n\t      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n\t        return processKvDocs(metaDoc, kvDocsRes);\n\t      });\n\t    });\n\t  }\n\t\n\t  // updates all emitted key/value docs and metaDocs in the mrview database\n\t  // for the given batch of documents from the source database\n\t  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n\t    var seqDocId = '_local/lastSeq';\n\t    return view.db.get(seqDocId)\n\t    .catch(defaultsTo({_id: seqDocId, seq: 0}))\n\t    .then(function (lastSeqDoc) {\n\t      var docIds = Object.keys(docIdsToChangesAndEmits);\n\t      return Promise.all(docIds.map(function (docId) {\n\t        return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n\t      })).then(function (listOfDocsToPersist) {\n\t        var docsToPersist = utils.flatten(listOfDocsToPersist);\n\t        lastSeqDoc.seq = seq;\n\t        docsToPersist.push(lastSeqDoc);\n\t        // write all docs in a single operation, update the seq once\n\t        return view.db.bulkDocs({docs : docsToPersist});\n\t      });\n\t    });\n\t  }\n\t\n\t  function getQueue(view) {\n\t    var viewName = typeof view === 'string' ? view : view.name;\n\t    var queue = persistentQueues[viewName];\n\t    if (!queue) {\n\t      queue = persistentQueues[viewName] = new TaskQueue();\n\t    }\n\t    return queue;\n\t  }\n\t\n\t  function updateView(view) {\n\t    return utils.sequentialize(getQueue(view), function () {\n\t      return updateViewInQueue(view);\n\t    })();\n\t  }\n\t\n\t  function updateViewInQueue(view) {\n\t    // bind the emit function once\n\t    var mapResults;\n\t    var doc;\n\t\n\t    function emit(key, value) {\n\t      var output = {id: doc._id, key: normalizeKey(key)};\n\t      // Don't explicitly store the value unless it's defined and non-null.\n\t      // This saves on storage space, because often people don't use it.\n\t      if (typeof value !== 'undefined' && value !== null) {\n\t        output.value = normalizeKey(value);\n\t      }\n\t      mapResults.push(output);\n\t    }\n\t\n\t    var mapFun = mapper(view.mapFun, emit);\n\t\n\t    var currentSeq = view.seq || 0;\n\t\n\t    function processChange(docIdsToChangesAndEmits, seq) {\n\t      return function () {\n\t        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n\t      };\n\t    }\n\t\n\t    var queue = new TaskQueue();\n\t\n\t    return new Promise(function (resolve, reject) {\n\t\n\t      function complete() {\n\t        queue.finish().then(function () {\n\t          view.seq = currentSeq;\n\t          resolve();\n\t        });\n\t      }\n\t\n\t      function processNextBatch() {\n\t        view.sourceDB.changes({\n\t          conflicts: true,\n\t          include_docs: true,\n\t          style: 'all_docs',\n\t          since: currentSeq,\n\t          limit: CHANGES_BATCH_SIZE\n\t        }).on('complete', function (response) {\n\t          var results = response.results;\n\t          if (!results.length) {\n\t            return complete();\n\t          }\n\t          var docIdsToChangesAndEmits = {};\n\t          for (var i = 0, l = results.length; i < l; i++) {\n\t            var change = results[i];\n\t            if (change.doc._id[0] !== '_') {\n\t              mapResults = [];\n\t              doc = change.doc;\n\t\n\t              if (!doc._deleted) {\n\t                tryCode(view.sourceDB, mapFun, [doc]);\n\t              }\n\t              mapResults.sort(sortByKeyThenValue);\n\t\n\t              var indexableKeysToKeyValues = {};\n\t              var lastKey;\n\t              for (var j = 0, jl = mapResults.length; j < jl; j++) {\n\t                var obj = mapResults[j];\n\t                var complexKey = [obj.key, obj.id];\n\t                if (collate(obj.key, lastKey) === 0) {\n\t                  complexKey.push(j); // dup key+id, so make it unique\n\t                }\n\t                var indexableKey = toIndexableString(complexKey);\n\t                indexableKeysToKeyValues[indexableKey] = obj;\n\t                lastKey = obj.key;\n\t              }\n\t              docIdsToChangesAndEmits[change.doc._id] = {\n\t                indexableKeysToKeyValues: indexableKeysToKeyValues,\n\t                changes: change.changes\n\t              };\n\t            }\n\t            currentSeq = change.seq;\n\t          }\n\t          queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\t          if (results.length < CHANGES_BATCH_SIZE) {\n\t            return complete();\n\t          }\n\t          return processNextBatch();\n\t        }).on('error', onError);\n\t        /* istanbul ignore next */\n\t        function onError(err) {\n\t          reject(err);\n\t        }\n\t      }\n\t\n\t      processNextBatch();\n\t    });\n\t  }\n\t\n\t  function reduceView(view, results, options) {\n\t    if (options.group_level === 0) {\n\t      delete options.group_level;\n\t    }\n\t\n\t    var shouldGroup = options.group || options.group_level;\n\t\n\t    var reduceFun = reducer(view.reduceFun);\n\t\n\t    var groups = [];\n\t    var lvl = options.group_level;\n\t    results.forEach(function (e) {\n\t      var last = groups[groups.length - 1];\n\t      var key = shouldGroup ? e.key : null;\n\t\n\t      // only set group_level for array keys\n\t      if (shouldGroup && Array.isArray(key) && typeof lvl === 'number') {\n\t        key = key.length > lvl ? key.slice(0, lvl) : key;\n\t      }\n\t\n\t      if (last && collate(last.key[0][0], key) === 0) {\n\t        last.key.push([key, e.id]);\n\t        last.value.push(e.value);\n\t        return;\n\t      }\n\t      groups.push({key: [\n\t        [key, e.id]\n\t      ], value: [e.value]});\n\t    });\n\t    for (var i = 0, len = groups.length; i < len; i++) {\n\t      var e = groups[i];\n\t      var reduceTry = tryCode(view.sourceDB, reduceFun, [e.key, e.value, false]);\n\t      // TODO: can't do instanceof BuiltInError because this class is buried\n\t      // in mapreduce.js\n\t      if (reduceTry.error && /BuiltInError/.test(reduceTry.error.constructor)) {\n\t        // CouchDB returns an error if a built-in errors out\n\t        throw reduceTry.error;\n\t      }\n\t      // CouchDB just sets the value to null if a non-built-in errors out\n\t      e.value = reduceTry.error ? null : reduceTry.output;\n\t      e.key = e.key[0][0];\n\t    }\n\t    // no total_rows/offset when reducing\n\t    return {rows: sliceResults(groups, options.limit, options.skip)};\n\t  }\n\t\n\t  function queryView(view, opts) {\n\t    return utils.sequentialize(getQueue(view), function () {\n\t      return queryViewInQueue(view, opts);\n\t    })();\n\t  }\n\t\n\t  function queryViewInQueue(view, opts) {\n\t    var totalRows;\n\t    var shouldReduce = view.reduceFun && opts.reduce !== false;\n\t    var skip = opts.skip || 0;\n\t    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n\t      // equivalent query\n\t      opts.limit = 0;\n\t      delete opts.keys;\n\t    }\n\t\n\t    function fetchFromView(viewOpts) {\n\t      viewOpts.include_docs = true;\n\t      return view.db.allDocs(viewOpts).then(function (res) {\n\t        totalRows = res.total_rows;\n\t        return res.rows.map(function (result) {\n\t\n\t          // implicit migration - in older versions of PouchDB,\n\t          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n\t          // this is tested in a migration test\n\t          /* istanbul ignore next */\n\t          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n\t              result.doc.value !== null) {\n\t            var keys = Object.keys(result.doc.value).sort();\n\t            // this detection method is not perfect, but it's unlikely the user\n\t            // emitted a value which was an object with these 3 exact keys\n\t            var expectedKeys = ['id', 'key', 'value'];\n\t            if (!(keys < expectedKeys || keys > expectedKeys)) {\n\t              return result.doc.value;\n\t            }\n\t          }\n\t\n\t          var parsedKeyAndDocId = pouchCollate.parseIndexableString(result.doc._id);\n\t          return {\n\t            key: parsedKeyAndDocId[0],\n\t            id: parsedKeyAndDocId[1],\n\t            value: ('value' in result.doc ? result.doc.value : null)\n\t          };\n\t        });\n\t      });\n\t    }\n\t\n\t    function onMapResultsReady(rows) {\n\t      var finalResults;\n\t      if (shouldReduce) {\n\t        finalResults = reduceView(view, rows, opts);\n\t      } else {\n\t        finalResults = {\n\t          total_rows: totalRows,\n\t          offset: skip,\n\t          rows: rows\n\t        };\n\t      }\n\t      if (opts.include_docs) {\n\t        var docIds = utils.uniq(rows.map(rowToDocId));\n\t\n\t        return view.sourceDB.allDocs({\n\t          keys: docIds,\n\t          include_docs: true,\n\t          conflicts: opts.conflicts,\n\t          attachments: opts.attachments,\n\t          binary: opts.binary\n\t        }).then(function (allDocsRes) {\n\t          var docIdsToDocs = {};\n\t          allDocsRes.rows.forEach(function (row) {\n\t            if (row.doc) {\n\t              docIdsToDocs['$' + row.id] = row.doc;\n\t            }\n\t          });\n\t          rows.forEach(function (row) {\n\t            var docId = rowToDocId(row);\n\t            var doc = docIdsToDocs['$' + docId];\n\t            if (doc) {\n\t              row.doc = doc;\n\t            }\n\t          });\n\t          return finalResults;\n\t        });\n\t      } else {\n\t        return finalResults;\n\t      }\n\t    }\n\t\n\t    var flatten = function (array) {\n\t      return array.reduce(function (prev, cur) {\n\t        return prev.concat(cur);\n\t      });\n\t    };\n\t\n\t    if (typeof opts.keys !== 'undefined') {\n\t      var keys = opts.keys;\n\t      var fetchPromises = keys.map(function (key) {\n\t        var viewOpts = {\n\t          startkey : toIndexableString([key]),\n\t          endkey   : toIndexableString([key, {}])\n\t        };\n\t        return fetchFromView(viewOpts);\n\t      });\n\t      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n\t    } else { // normal query, no 'keys'\n\t      var viewOpts = {\n\t        descending : opts.descending\n\t      };\n\t      if (typeof opts.startkey !== 'undefined') {\n\t        viewOpts.startkey = opts.descending ?\n\t          toIndexableString([opts.startkey, {}]) :\n\t          toIndexableString([opts.startkey]);\n\t      }\n\t      if (typeof opts.endkey !== 'undefined') {\n\t        var inclusiveEnd = opts.inclusive_end !== false;\n\t        if (opts.descending) {\n\t          inclusiveEnd = !inclusiveEnd;\n\t        }\n\t\n\t        viewOpts.endkey = toIndexableString(inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);\n\t      }\n\t      if (typeof opts.key !== 'undefined') {\n\t        var keyStart = toIndexableString([opts.key]);\n\t        var keyEnd = toIndexableString([opts.key, {}]);\n\t        if (viewOpts.descending) {\n\t          viewOpts.endkey = keyStart;\n\t          viewOpts.startkey = keyEnd;\n\t        } else {\n\t          viewOpts.startkey = keyStart;\n\t          viewOpts.endkey = keyEnd;\n\t        }\n\t      }\n\t      if (!shouldReduce) {\n\t        if (typeof opts.limit === 'number') {\n\t          viewOpts.limit = opts.limit;\n\t        }\n\t        viewOpts.skip = skip;\n\t      }\n\t      return fetchFromView(viewOpts).then(onMapResultsReady);\n\t    }\n\t  }\n\t\n\t  function localViewCleanup(db) {\n\t    return db.get('_local/' + pluginName).then(function (metaDoc) {\n\t      var docsToViews = {};\n\t      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n\t        var parts = parseViewName(fullViewName);\n\t        var designDocName = '_design/' + parts[0];\n\t        var viewName = parts[1];\n\t        docsToViews[designDocName] = docsToViews[designDocName] || {};\n\t        docsToViews[designDocName][viewName] = true;\n\t      });\n\t      var opts = {\n\t        keys : Object.keys(docsToViews),\n\t        include_docs : true\n\t      };\n\t      return db.allDocs(opts).then(function (res) {\n\t        var viewsToStatus = {};\n\t        res.rows.forEach(function (row) {\n\t          var ddocName = row.key.substring(8);\n\t          Object.keys(docsToViews[row.key]).forEach(function (viewName) {\n\t            var fullViewName = ddocName + '/' + viewName;\n\t            /* istanbul ignore if */\n\t            if (!metaDoc.views[fullViewName]) {\n\t              // new format, without slashes, to support PouchDB 2.2.0\n\t              // migration test in pouchdb's browser.migration.js verifies this\n\t              fullViewName = viewName;\n\t            }\n\t            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n\t            // design doc deleted, or view function nonexistent\n\t            var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];\n\t            viewDBNames.forEach(function (viewDBName) {\n\t              viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;\n\t            });\n\t          });\n\t        });\n\t        var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {\n\t          return !viewsToStatus[viewDBName];\n\t        });\n\t        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n\t          return utils.sequentialize(getQueue(viewDBName), function () {\n\t            return new db.constructor(viewDBName, db.__opts).destroy();\n\t          })();\n\t        });\n\t        return Promise.all(destroyPromises).then(function () {\n\t          return {ok: true};\n\t        });\n\t      });\n\t    }, defaultsTo({ok: true}));\n\t  }\n\t\n\t  function queryPromised(db, fun, opts) {\n\t    if (typeof fun !== 'string') {\n\t      // temp_view\n\t      checkQueryParseError(opts, fun);\n\t\n\t      var createViewOpts = {\n\t        db : db,\n\t        viewName : 'temp_view/temp_view',\n\t        map : fun.map,\n\t        reduce : fun.reduce,\n\t        temporary : true,\n\t        pluginName: pluginName\n\t      };\n\t      tempViewQueue.add(function () {\n\t        return createView(createViewOpts).then(function (view) {\n\t          function cleanup() {\n\t            return view.db.destroy();\n\t          }\n\t          return utils.fin(updateView(view).then(function () {\n\t            return queryView(view, opts);\n\t          }), cleanup);\n\t        });\n\t      });\n\t      return tempViewQueue.finish();\n\t    } else {\n\t      // persistent view\n\t      var fullViewName = fun;\n\t      var parts = parseViewName(fullViewName);\n\t      var designDocName = parts[0];\n\t      var viewName = parts[1];\n\t      return db.get('_design/' + designDocName).then(function (doc) {\n\t        var fun = doc.views && doc.views[viewName];\n\t\n\t        if (!fun) {\n\t          // basic validator; it's assumed that every subclass would want this\n\t          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n\t            viewName);\n\t        }\n\t\n\t        ddocValidator(doc, viewName);\n\t        checkQueryParseError(opts, fun);\n\t\n\t        var createViewOpts = {\n\t          db : db,\n\t          viewName : fullViewName,\n\t          map : fun.map,\n\t          reduce : fun.reduce,\n\t          pluginName: pluginName\n\t        };\n\t        return createView(createViewOpts).then(function (view) {\n\t          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n\t            if (opts.stale === 'update_after') {\n\t              process.nextTick(function () {\n\t                updateView(view);\n\t              });\n\t            }\n\t            return queryView(view, opts);\n\t          } else { // stale not ok\n\t            return updateView(view).then(function () {\n\t              return queryView(view, opts);\n\t            });\n\t          }\n\t        });\n\t      });\n\t    }\n\t  }\n\t\n\t  var query = function (fun, opts, callback) {\n\t    var db = this;\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = utils.extend(true, {}, opts);\n\t\n\t    if (typeof fun === 'function') {\n\t      fun = {map : fun};\n\t    }\n\t\n\t    var promise = Promise.resolve().then(function () {\n\t      return queryPromised(db, fun, opts);\n\t    });\n\t    utils.promisedCallback(promise, callback);\n\t    return promise;\n\t  };\n\t\n\t  var viewCleanup = utils.callbackify(function () {\n\t    var db = this;\n\t    return localViewCleanup(db);\n\t  });\n\t\n\t  return {\n\t    query: query,\n\t    viewCleanup: viewCleanup\n\t  };\n\t}\n\t\n\tmodule.exports = createIndexer;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ },\n/* 226 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t/*\n\t * Simple task queue to sequentialize actions. Assumes callbacks will eventually fire (once).\n\t */\n\t\n\tvar Promise = __webpack_require__(76).Promise;\n\t\n\tfunction TaskQueue() {\n\t  this.promise = new Promise(function (fulfill) {fulfill(); });\n\t}\n\tTaskQueue.prototype.add = function (promiseFactory) {\n\t  this.promise = this.promise.catch(function () {\n\t    // just recover\n\t  }).then(function () {\n\t    return promiseFactory();\n\t  });\n\t  return this.promise;\n\t};\n\tTaskQueue.prototype.finish = function () {\n\t  return this.promise;\n\t};\n\t\n\tmodule.exports = TaskQueue;\n\n\n/***/ },\n/* 227 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar massageCreateIndexRequest = __webpack_require__(105);\n\t\n\tfunction createIndex(db, requestDef, callback) {\n\t  requestDef = massageCreateIndexRequest(requestDef);\n\t\n\t  db.request({\n\t    method: 'POST',\n\t    url: '_index',\n\t    body: requestDef\n\t  }, callback);\n\t}\n\t\n\tfunction find(db, requestDef, callback) {\n\t  db.request({\n\t    method: 'POST',\n\t    url: '_find',\n\t    body: requestDef\n\t  }, callback);\n\t}\n\t\n\tfunction getIndexes(db, callback) {\n\t  db.request({\n\t    method: 'GET',\n\t    url: '_index'\n\t  }, callback);\n\t}\n\t\n\tfunction deleteIndex(db, indexDef, callback) {\n\t\n\t\n\t  var ddoc = indexDef.ddoc;\n\t  var type = indexDef.type || 'json';\n\t  var name = indexDef.name;\n\t\n\t  if (!ddoc) {\n\t    return callback(new Error('you must provide an index\\'s ddoc'));\n\t  }\n\t\n\t  if (!name) {\n\t    return callback(new Error('you must provide an index\\'s name'));\n\t  }\n\t\n\t  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\t\n\t  db.request({\n\t    method: 'DELETE',\n\t    url: url\n\t  }, callback);\n\t}\n\t\n\texports.createIndex = createIndex;\n\texports.find = find;\n\texports.getIndexes = getIndexes;\n\texports.deleteIndex = deleteIndex;\n\n/***/ },\n/* 228 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(16);\n\tvar log = utils.log;\n\t\n\tvar pouchUpsert = __webpack_require__(107);\n\tvar abstractMapper = __webpack_require__(77);\n\tvar localUtils = __webpack_require__(35);\n\tvar validateIndex = localUtils.validateIndex;\n\tvar massageIndexDef = localUtils.massageIndexDef;\n\tvar massageCreateIndexRequest = __webpack_require__(105);\n\t\n\tfunction upsert(db, docId, diffFun) {\n\t  return pouchUpsert.upsert.call(db, docId, diffFun);\n\t}\n\t\n\tfunction createIndex(db, requestDef) {\n\t  requestDef = massageCreateIndexRequest(requestDef);\n\t  var originalIndexDef = utils.clone(requestDef.index);\n\t  requestDef.index = massageIndexDef(requestDef.index);\n\t\n\t  validateIndex(requestDef.index);\n\t\n\t  var md5 = utils.MD5(JSON.stringify(requestDef));\n\t\n\t  var viewName = requestDef.name || ('idx-' + md5);\n\t\n\t  var ddocName = requestDef.ddoc || ('idx-' + md5);\n\t  var ddocId = '_design/' + ddocName;\n\t\n\t  var hasInvalidLanguage = false;\n\t  var viewExists = false;\n\t\n\t  function updateDdoc(doc) {\n\t    if (doc._rev && doc.language !== 'query') {\n\t      hasInvalidLanguage = true;\n\t    }\n\t    doc.language = 'query';\n\t    doc.views = doc.views || {};\n\t\n\t    viewExists = !!doc.views[viewName];\n\t\n\t    if (viewExists) {\n\t      return false;\n\t    }\n\t\n\t    doc.views[viewName] = {\n\t      map: {\n\t        fields: utils.mergeObjects(requestDef.index.fields)\n\t      },\n\t      reduce: '_count',\n\t      options: {\n\t        def: originalIndexDef\n\t      }\n\t    };\n\t\n\t    return doc;\n\t  }\n\t\n\t  log('creating index', ddocId);\n\t\n\t  return upsert(db, ddocId, updateDdoc).then(function () {\n\t    if (hasInvalidLanguage) {\n\t      throw new Error('invalid language for ddoc with id \"' +\n\t      ddocId +\n\t      '\" (should be \"query\")');\n\t    }\n\t  }).then(function () {\n\t    // kick off a build\n\t    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n\t    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n\t    var signature = ddocName + '/' + viewName;\n\t    return abstractMapper.query.call(db, signature, {\n\t      limit: 0,\n\t      reduce: false\n\t    }).then(function () {\n\t      return {\n\t        id: ddocId,\n\t        name: viewName,\n\t        result: viewExists ? 'exists' : 'created'\n\t      };\n\t    });\n\t  });\n\t}\n\t\n\tmodule.exports = createIndex;\n\n\n/***/ },\n/* 229 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar abstractMapper = __webpack_require__(77);\n\tvar upsert = __webpack_require__(103);\n\t\n\tfunction deleteIndex(db, index) {\n\t\n\t  if (!index.ddoc) {\n\t    throw new Error('you must supply an index.ddoc when deleting');\n\t  }\n\t\n\t  if (!index.name) {\n\t    throw new Error('you must supply an index.name when deleting');\n\t  }\n\t\n\t  var docId = index.ddoc;\n\t  var viewName = index.name;\n\t\n\t  function deltaFun (doc) {\n\t    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n\t      // only one view in this ddoc, delete the whole ddoc\n\t      return {_id: docId, _deleted: true};\n\t    }\n\t    // more than one view here, just remove the view\n\t    delete doc.views[viewName];\n\t    return doc;\n\t  }\n\t\n\t  return upsert(db, docId, deltaFun).then(function () {\n\t    return abstractMapper.viewCleanup.apply(db);\n\t  }).then(function () {\n\t    return {ok: true};\n\t  });\n\t}\n\t\n\tmodule.exports = deleteIndex;\n\n/***/ },\n/* 230 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t//\n\t// Do an in-memory filtering of rows that aren't covered by the index.\n\t// E.g. if the user is asking for foo=1 and bar=2, but the index\n\t// only covers \"foo\", then this in-memory filter would take care of\n\t// \"bar\".\n\t//\n\t\n\tvar isArray = __webpack_require__(220);\n\tvar collate = __webpack_require__(53).collate;\n\tvar localUtils = __webpack_require__(35);\n\tvar isCombinationalField = localUtils.isCombinationalField;\n\tvar getKey = localUtils.getKey;\n\tvar getValue = localUtils.getValue;\n\tvar parseField = localUtils.parseField;\n\tvar utils = __webpack_require__(16);\n\tvar getFieldFromDoc = utils.getFieldFromDoc;\n\t\n\t// create a comparator based on the sort object\n\tfunction createFieldSorter(sort) {\n\t\n\t  function getFieldValuesAsArray(doc) {\n\t    return sort.map(function (sorting) {\n\t      var fieldName = getKey(sorting);\n\t      var parsedField = parseField(fieldName);\n\t      var docFieldValue = getFieldFromDoc(doc, parsedField);\n\t      return docFieldValue;\n\t    });\n\t  }\n\t\n\t  return function (aRow, bRow) {\n\t    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n\t    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n\t    var collation = collate(aFieldValues, bFieldValues);\n\t    if (collation !== 0) {\n\t      return collation;\n\t    }\n\t    // this is what mango seems to do\n\t    return utils.compare(aRow.doc._id, bRow.doc._id);\n\t  };\n\t}\n\t\n\tfunction filterInMemoryFields (rows, requestDef, inMemoryFields) {\n\t  rows = rows.filter(function (row) {\n\t    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n\t  });\n\t\n\t  if (requestDef.sort) {\n\t    // in-memory sort\n\t    var fieldSorter = createFieldSorter(requestDef.sort);\n\t    rows = rows.sort(fieldSorter);\n\t    if (typeof requestDef.sort[0] !== 'string' &&\n\t        getValue(requestDef.sort[0]) === 'desc') {\n\t      rows = rows.reverse();\n\t    }\n\t  }\n\t\n\t  if ('limit' in requestDef || 'skip' in requestDef) {\n\t    // have to do the limit in-memory\n\t    var skip = requestDef.skip || 0;\n\t    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n\t    rows = rows.slice(skip, limit);\n\t  }\n\t  return rows;\n\t}\n\t\n\tfunction rowFilter (doc, selector, inMemoryFields) {\n\t  return inMemoryFields.every(function (field) {\n\t    var matcher = selector[field];\n\t    var parsedField = parseField(field);\n\t    var docFieldValue = getFieldFromDoc(doc, parsedField);\n\t    if (isCombinationalField(field)) {\n\t      return matchCominationalSelector(field, matcher, doc);\n\t    }\n\t\n\t    return matchSelector(matcher, doc, parsedField, docFieldValue);\n\t  });\n\t}\n\t\n\tfunction matchSelector (matcher, doc, parsedField, docFieldValue) {\n\t  if (!matcher) {\n\t    // no filtering necessary; this field is just needed for sorting\n\t    return true;\n\t  }\n\t\n\t  return Object.keys(matcher).every(function (userOperator) {\n\t    var userValue = matcher[userOperator];\n\t    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n\t  });\n\t}\n\t\n\tfunction matchCominationalSelector (field, matcher, doc) {\n\t\n\t  if (field === '$or') {\n\t    return matcher.some(function (orMatchers) {\n\t      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n\t    });\n\t  }\n\t\n\t  if (field === '$not') {\n\t    return !rowFilter(doc, matcher, Object.keys(matcher));\n\t  }\n\t\n\t  //`$nor`\n\t  return !matcher.find(function (orMatchers) {\n\t    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n\t  });\n\t\n\t}\n\t\n\tfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n\t  if (!matchers[userOperator]) {\n\t    throw new Error('unknown operator \"' + userOperator +\n\t      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n\t      '$nin, $size, $mod, $regex, $elemMatch, $type or $all');\n\t  }\n\t  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n\t}\n\t\n\tfunction fieldExists(docFieldValue) {\n\t  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n\t}\n\t\n\tfunction fieldIsNotUndefined(docFieldValue) {\n\t  return typeof docFieldValue !== 'undefined';\n\t}\n\t\n\tfunction modField (docFieldValue, userValue) {\n\t  var divisor = userValue[0];\n\t  var mod = userValue[1];\n\t  if (divisor === 0) {\n\t    throw new Error('Bad divisor, cannot divide by zero');\n\t  }\n\t\n\t  if (parseInt(divisor, 10) !== divisor ) {\n\t    throw new Error('Divisor is not an integer');\n\t  }\n\t\n\t  if (parseInt(mod, 10) !== mod ) {\n\t    throw new Error('Modulus is not an integer');\n\t  }\n\t\n\t  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n\t    return false;\n\t  }\n\t\n\t  return docFieldValue % divisor === mod;\n\t}\n\t\n\tfunction arrayContainsValue (docFieldValue, userValue) {\n\t  return userValue.some(function (val) {\n\t    if (docFieldValue instanceof Array) {\n\t      return docFieldValue.indexOf(val) > -1;\n\t    }\n\t\n\t    return docFieldValue === val;\n\t  });\n\t}\n\t\n\tfunction arrayContainsAllValues (docFieldValue, userValue) {\n\t  return userValue.every(function (val) {\n\t    return docFieldValue.indexOf(val) > -1;\n\t  });\n\t}\n\t\n\tfunction arraySize (docFieldValue, userValue) {\n\t  return docFieldValue.length === userValue;\n\t}\n\t\n\tfunction regexMatch(docFieldValue, userValue) {\n\t  var re = new RegExp(userValue);\n\t\n\t  return re.test(docFieldValue);\n\t}\n\t\n\tfunction typeMatch(docFieldValue, userValue) {\n\t\n\t  switch (userValue) {\n\t    case 'null':\n\t      return docFieldValue === null;\n\t    case 'boolean':\n\t      return typeof(docFieldValue) === 'boolean';\n\t    case 'number':\n\t      return typeof(docFieldValue) === 'number';\n\t    case 'string':\n\t      return typeof(docFieldValue) === 'string';\n\t    case 'array':\n\t      return docFieldValue instanceof Array;\n\t    case 'object':\n\t      return ({}).toString.call(docFieldValue) === '[object Object]';\n\t  }\n\t\n\t  throw new Error(userValue + ' not supported as a type.' +\n\t                  'Please use one of object, string, array, number, boolean or null.');\n\t\n\t}\n\t\n\tvar matchers = {\n\t\n\t  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n\t    if (!isArray(docFieldValue)) {\n\t      return false;\n\t    }\n\t\n\t    if (docFieldValue.length === 0) {\n\t      return false;\n\t    }\n\t\n\t    if (typeof docFieldValue[0] === 'object') {\n\t      return docFieldValue.some(function (val) {\n\t        return rowFilter(val, userValue, Object.keys(userValue));\n\t      });\n\t    }\n\t\n\t    return docFieldValue.some(function (val) {\n\t      return matchSelector(userValue, doc, parsedField, val);\n\t    });\n\t  },\n\t\n\t  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n\t  },\n\t\n\t  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n\t  },\n\t\n\t  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n\t  },\n\t\n\t  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n\t  },\n\t\n\t  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n\t  },\n\t\n\t  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n\t    //a field that is null is still considered to exist\n\t    if (userValue) {\n\t      return fieldIsNotUndefined(docFieldValue);\n\t    }\n\t\n\t    return !fieldIsNotUndefined(docFieldValue);\n\t  },\n\t\n\t  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n\t  },\n\t\n\t  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n\t    return userValue.every(function (neValue) {\n\t      return collate(docFieldValue, neValue) !== 0;\n\t    });\n\t  },\n\t  '$in': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n\t  },\n\t\n\t  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n\t  },\n\t\n\t  '$size': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n\t  },\n\t\n\t  '$all': function (doc, userValue, parsedField, docFieldValue) {\n\t    return isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n\t  },\n\t\n\t  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n\t    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n\t  },\n\t\n\t  '$type': function (doc, userValue, parsedField, docFieldValue) {\n\t    return typeMatch(docFieldValue, userValue);\n\t  }\n\t};\n\t\n\tmodule.exports = filterInMemoryFields;\n\n\n/***/ },\n/* 231 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(16);\n\tvar clone = utils.clone;\n\tvar getIndexes = __webpack_require__(104);\n\tvar collate = __webpack_require__(53).collate;\n\tvar abstractMapper = __webpack_require__(77);\n\tvar planQuery = __webpack_require__(232);\n\tvar localUtils = __webpack_require__(35);\n\tvar filterInMemoryFields = __webpack_require__(230);\n\tvar massageSelector = localUtils.massageSelector;\n\tvar massageSort = localUtils.massageSort;\n\tvar getValue = localUtils.getValue;\n\tvar validateFindRequest = localUtils.validateFindRequest;\n\tvar validateSort = localUtils.validateSort;\n\tvar reverseOptions = localUtils.reverseOptions;\n\tvar filterInclusiveStart = localUtils.filterInclusiveStart;\n\tvar Promise = utils.Promise;\n\t\n\tfunction indexToSignature(index) {\n\t  // remove '_design/'\n\t  return index.ddoc.substring(8) + '/' + index.name;\n\t}\n\t\n\tfunction doAllDocs(db, originalOpts) {\n\t  var opts = clone(originalOpts);\n\t\n\t  // CouchDB responds in weird ways when you provide a non-string to _id;\n\t  // we mimic the behavior for consistency. See issue66 tests for details.\n\t\n\t  if (opts.descending) {\n\t    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n\t      opts.endkey = '';\n\t    }\n\t    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n\t      opts.limit = 0;\n\t    }\n\t  } else {\n\t    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n\t      opts.startkey = '';\n\t    }\n\t    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n\t      opts.limit = 0;\n\t    }\n\t  }\n\t  if ('key' in opts && typeof opts.key !== 'string') {\n\t    opts.limit = 0;\n\t  }\n\t\n\t  return db.allDocs(opts);\n\t}\n\t\n\tfunction find(db, requestDef) {\n\t\n\t  if (requestDef.selector) {\n\t    requestDef.selector = massageSelector(requestDef.selector);\n\t  }\n\t  if (requestDef.sort) {\n\t    requestDef.sort = massageSort(requestDef.sort);\n\t  }\n\t\n\t  validateFindRequest(requestDef);\n\t\n\t  return getIndexes(db).then(function (getIndexesRes) {\n\t\n\t    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n\t\n\t    var indexToUse = queryPlan.index;\n\t\n\t    validateSort(requestDef, indexToUse);\n\t\n\t    var opts = utils.extend(true, {\n\t      include_docs: true,\n\t      reduce: false\n\t    }, queryPlan.queryOpts);\n\t\n\t    if ('startkey' in opts && 'endkey' in opts &&\n\t        collate(opts.startkey, opts.endkey) > 0) {\n\t      // can't possibly return any results, startkey > endkey\n\t      return {docs: []};\n\t    }\n\t\n\t    var isDescending = requestDef.sort &&\n\t      typeof requestDef.sort[0] !== 'string' &&\n\t      getValue(requestDef.sort[0]) === 'desc';\n\t\n\t    if (isDescending) {\n\t      // either all descending or all ascending\n\t      opts.descending = true;\n\t      opts = reverseOptions(opts);\n\t    }\n\t\n\t    if (!queryPlan.inMemoryFields.length) {\n\t      // no in-memory filtering necessary, so we can let the\n\t      // database do the limit/skip for us\n\t      if ('limit' in requestDef) {\n\t        opts.limit = requestDef.limit;\n\t      }\n\t      if ('skip' in requestDef) {\n\t        opts.skip = requestDef.skip;\n\t      }\n\t    }\n\t\n\t    return Promise.resolve().then(function () {\n\t      if (indexToUse.name === '_all_docs') {\n\t        return doAllDocs(db, opts);\n\t      } else {\n\t        var signature = indexToSignature(indexToUse);\n\t        return abstractMapper.query.call(db, signature, opts);\n\t      }\n\t    }).then(function (res) {\n\t\n\t      if (opts.inclusive_start === false) {\n\t        // may have to manually filter the first one,\n\t        // since couchdb has no true inclusive_start option\n\t        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n\t      }\n\t\n\t      if (queryPlan.inMemoryFields.length) {\n\t        // need to filter some stuff in-memory\n\t        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n\t      }\n\t\n\t      var resp = {\n\t        docs: res.rows.map(function (row) {\n\t          var doc = row.doc;\n\t          if (requestDef.fields) {\n\t            return utils.pick(doc, requestDef.fields);\n\t          }\n\t          return doc;\n\t        })\n\t      };\n\t\n\t      if (indexToUse.defaultUsed) {\n\t        resp.warning = 'no matching index found, create an index to optimize query time';\n\t      }\n\t\n\t      return resp;\n\t    });\n\t  });\n\t}\n\t\n\tmodule.exports = find;\n\n\n/***/ },\n/* 232 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(16);\n\tvar log = utils.log;\n\tvar localUtils = __webpack_require__(35);\n\tvar getKey = localUtils.getKey;\n\tvar getUserFields = localUtils.getUserFields;\n\t\n\t// couchdb lowest collation value\n\tvar COLLATE_LO = null;\n\t\n\t// couchdb highest collation value (TODO: well not really, but close enough amirite)\n\tvar COLLATE_HI = {\"\\uffff\": {}};\n\t\n\t// couchdb second-lowest collation value\n\t\n\tfunction checkFieldInIndex(index, field) {\n\t  var indexFields = index.def.fields.map(getKey);\n\t  for (var i = 0, len = indexFields.length; i < len; i++) {\n\t    var indexField = indexFields[i];\n\t    if (field === indexField) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n\t// but when you do e.g. $gt/$eq, the first part can be done\n\t// in the database, but the second part has to be done in-memory,\n\t// because $gt has forced us to lose precision.\n\t// so that's what this determines\n\tfunction userOperatorLosesPrecision(selector, field) {\n\t  var matcher = selector[field];\n\t  var userOperator = getKey(matcher);\n\t\n\t  return userOperator !== '$eq';\n\t}\n\t\n\t// sort the user fields by their position in the index,\n\t// if they're in the index\n\tfunction sortFieldsByIndex(userFields, index) {\n\t  var indexFields = index.def.fields.map(getKey);\n\t\n\t  return userFields.slice().sort(function (a, b) {\n\t    var aIdx = indexFields.indexOf(a);\n\t    var bIdx = indexFields.indexOf(b);\n\t    if (aIdx === -1) {\n\t      aIdx = Number.MAX_VALUE;\n\t    }\n\t    if (bIdx === -1) {\n\t      bIdx = Number.MAX_VALUE;\n\t    }\n\t    return utils.compare(aIdx, bIdx);\n\t  });\n\t}\n\t\n\t// first pass to try to find fields that will need to be sorted in-memory\n\tfunction getBasicInMemoryFields(index, selector, userFields) {\n\t\n\t  userFields = sortFieldsByIndex(userFields, index);\n\t\n\t  // check if any of the user selectors lose precision\n\t  var needToFilterInMemory = false;\n\t  for (var i = 0, len = userFields.length; i < len; i++) {\n\t    var field = userFields[i];\n\t    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n\t      return userFields.slice(i);\n\t    }\n\t    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n\t      needToFilterInMemory = true;\n\t    }\n\t  }\n\t  return [];\n\t}\n\t\n\tfunction getInMemoryFieldsFromNe(selector) {\n\t  var fields = [];\n\t  Object.keys(selector).forEach(function (field) {\n\t    var matcher = selector[field];\n\t    Object.keys(matcher).forEach(function (operator) {\n\t      if (operator === '$ne') {\n\t        fields.push(field);\n\t      }\n\t    });\n\t  });\n\t  return fields;\n\t}\n\t\n\tfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n\t  var result = utils.flatten(\n\t    // in-memory fields reported as necessary by the query planner\n\t    coreInMemoryFields,\n\t    // combine with another pass that checks for any we may have missed\n\t    getBasicInMemoryFields(index, selector, userFields),\n\t    // combine with another pass that checks for $ne's\n\t    getInMemoryFieldsFromNe(selector)\n\t  );\n\t\n\t  return sortFieldsByIndex(utils.uniq(result), index);\n\t}\n\t\n\t// check that at least one field in the user's query is represented\n\t// in the index. order matters in the case of sorts\n\tfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n\t  if (sortOrder) {\n\t    // array has to be a strict subarray of index array. furthermore,\n\t    // the sortOrder fields need to all be represented in the index\n\t    var sortMatches = utils.oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n\t    var selectorMatches = utils.oneArrayIsSubArrayOfOther(fields, indexFields);\n\t\n\t    return sortMatches && selectorMatches;\n\t  }\n\t\n\t  // all of the user's specified fields still need to be\n\t  // on the left side of the index array, although the order\n\t  // doesn't matter\n\t  return utils.oneSetIsSubArrayOfOther(fields, indexFields);\n\t}\n\t\n\tvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\n\tfunction isNonLogicalMatcher (matcher) {\n\t  return logicalMatchers.indexOf(matcher) === -1;\n\t}\n\t\n\t// check all the index fields for usages of '$ne'\n\t// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n\t// then we can neither use an index on ['foo'] nor an index on\n\t// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\n\tfunction checkFieldsLogicallySound(indexFields, selector) {\n\t  var firstField = indexFields[0];\n\t  var matcher = selector[firstField];\n\t\n\t  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n\t    return !(isNonLogicalMatcher(matcherKey));\n\t  });\n\t\n\t  if (!hasLogicalOperator) {\n\t    return false;\n\t  }\n\t\n\t  var isInvalidNe = Object.keys(matcher).length === 1 &&\n\t    getKey(matcher) === '$ne';\n\t\n\t  return !isInvalidNe;\n\t}\n\t\n\tfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\t\n\t  var indexFields = index.def.fields.map(getKey);\n\t\n\t  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\t\n\t  if (!fieldsMatch) {\n\t    return false;\n\t  }\n\t\n\t  return checkFieldsLogicallySound(indexFields, selector);\n\t}\n\t\n\t//\n\t// the algorithm is very simple:\n\t// take all the fields the user supplies, and if those fields\n\t// are a strict subset of the fields in some index,\n\t// then use that index\n\t//\n\t//\n\tfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n\t\n\t  return indexes.reduce(function (res, index) {\n\t    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n\t    if (indexMatches) {\n\t      res.push(index);\n\t    }\n\t    return res;\n\t  }, []);\n\t}\n\t\n\t// find the best index, i.e. the one that matches the most fields\n\t// in the user's query\n\tfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes) {\n\t\n\t  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\t\n\t  if (matchingIndexes.length === 0) {\n\t    //return `all_docs` as a default index;\n\t    //I'm assuming that _all_docs is always first\n\t    var defaultIndex = indexes[0];\n\t    defaultIndex.defaultUsed = true;\n\t    return defaultIndex;\n\t  }\n\t  if (matchingIndexes.length === 1) {\n\t    return matchingIndexes[0];\n\t  }\n\t\n\t  var userFieldsMap = utils.arrayToObject(userFields);\n\t\n\t  function scoreIndex(index) {\n\t    var indexFields = index.def.fields.map(getKey);\n\t    var score = 0;\n\t    for (var i = 0, len = indexFields.length; i < len; i++) {\n\t      var indexField = indexFields[i];\n\t      if (userFieldsMap[indexField]) {\n\t        score++;\n\t      }\n\t    }\n\t    return score;\n\t  }\n\t\n\t  return utils.max(matchingIndexes, scoreIndex);\n\t}\n\t\n\tfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n\t  switch (userOperator) {\n\t    case '$eq':\n\t      return {key: userValue};\n\t    case '$lte':\n\t      return {endkey: userValue};\n\t    case '$gte':\n\t      return {startkey: userValue};\n\t    case '$lt':\n\t      return {\n\t        endkey: userValue,\n\t        inclusive_end: false\n\t      };\n\t    case '$gt':\n\t      return {\n\t        startkey: userValue,\n\t        inclusive_start: false\n\t      };\n\t  }\n\t}\n\t\n\tfunction getSingleFieldCoreQueryPlan(selector, index) {\n\t  var field = getKey(index.def.fields[0]);\n\t  var matcher = selector[field];\n\t  var inMemoryFields = [];\n\t\n\t  var userOperators = Object.keys(matcher);\n\t\n\t  var combinedOpts;\n\t\n\t  userOperators.forEach(function (userOperator) {\n\t\n\t    if (isNonLogicalMatcher(userOperator)) {\n\t      inMemoryFields.push(field);\n\t      return;\n\t    }\n\t\n\t    var userValue = matcher[userOperator];\n\t\n\t    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\t\n\t    if (combinedOpts) {\n\t      combinedOpts = utils.mergeObjects([combinedOpts, newQueryOpts]);\n\t    } else {\n\t      combinedOpts = newQueryOpts;\n\t    }\n\t  });\n\t\n\t  return {\n\t    queryOpts: combinedOpts,\n\t    inMemoryFields: inMemoryFields\n\t  };\n\t}\n\t\n\tfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n\t  switch (userOperator) {\n\t    case '$eq':\n\t      return {\n\t        startkey: userValue,\n\t        endkey: userValue\n\t      };\n\t    case '$lte':\n\t      return {\n\t        endkey: userValue\n\t      };\n\t    case '$gte':\n\t      return {\n\t        startkey: userValue\n\t      };\n\t    case '$lt':\n\t      return {\n\t        endkey: userValue,\n\t        inclusive_end: false\n\t      };\n\t    case '$gt':\n\t      return {\n\t        startkey: userValue,\n\t        inclusive_start: false\n\t      };\n\t  }\n\t}\n\t\n\tfunction getMultiFieldQueryOpts(selector, index) {\n\t\n\t  var indexFields = index.def.fields.map(getKey);\n\t\n\t  var inMemoryFields = [];\n\t  var startkey = [];\n\t  var endkey = [];\n\t  var inclusiveStart;\n\t  var inclusiveEnd;\n\t\n\t\n\t  function finish(i) {\n\t\n\t    if (inclusiveStart !== false) {\n\t      startkey.push(COLLATE_LO);\n\t    }\n\t    if (inclusiveEnd !== false) {\n\t      endkey.push(COLLATE_HI);\n\t    }\n\t    // keep track of the fields where we lost specificity,\n\t    // and therefore need to filter in-memory\n\t    inMemoryFields = indexFields.slice(i);\n\t  }\n\t\n\t  for (var i = 0, len = indexFields.length; i < len; i++) {\n\t    var indexField = indexFields[i];\n\t\n\t    var matcher = selector[indexField];\n\t\n\t    if (!matcher) { // fewer fields in user query than in index\n\t      finish(i);\n\t      break;\n\t    } else if (i > 0) {\n\t      if ('$ne' in matcher) { // unusable $ne index\n\t        finish(i);\n\t        break;\n\t      }\n\t      var usingGtlt = (\n\t        '$gt' in matcher || '$gte' in matcher ||\n\t        '$lt' in matcher || '$lte' in matcher);\n\t      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n\t      var previousWasEq = utils.arrayEquals(previousKeys, ['$eq']);\n\t      var previousWasSame = utils.arrayEquals(previousKeys, Object.keys(matcher));\n\t      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n\t      if (gtltLostSpecificity) {\n\t        finish(i);\n\t        break;\n\t      }\n\t    }\n\t\n\t    var userOperators = Object.keys(matcher);\n\t\n\t    var combinedOpts = null;\n\t\n\t    for (var j = 0; j < userOperators.length; j++) {\n\t      var userOperator = userOperators[j];\n\t      var userValue = matcher[userOperator];\n\t\n\t      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\t\n\t      if (combinedOpts) {\n\t        combinedOpts = utils.mergeObjects([combinedOpts, newOpts]);\n\t      } else {\n\t        combinedOpts = newOpts;\n\t      }\n\t    }\n\t\n\t    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n\t    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n\t    if ('inclusive_start' in combinedOpts) {\n\t      inclusiveStart = combinedOpts.inclusive_start;\n\t    }\n\t    if ('inclusive_end' in combinedOpts) {\n\t      inclusiveEnd = combinedOpts.inclusive_end;\n\t    }\n\t  }\n\t\n\t  var res = {\n\t    startkey: startkey,\n\t    endkey: endkey\n\t  };\n\t\n\t  if (typeof inclusiveStart !== 'undefined') {\n\t    res.inclusive_start = inclusiveStart;\n\t  }\n\t  if (typeof inclusiveEnd !== 'undefined') {\n\t    res.inclusive_end = inclusiveEnd;\n\t  }\n\t\n\t  return {\n\t    queryOpts: res,\n\t    inMemoryFields: inMemoryFields\n\t  };\n\t}\n\t\n\tfunction getDefaultQueryPlan () {\n\t  return {\n\t    queryOpts: {startkey: null},\n\t    //getInMemoryFields will do the work here later\n\t    inMemoryFields: []\n\t  };\n\t}\n\t\n\tfunction getCoreQueryPlan(selector, index) {\n\t  if (index.defaultUsed) {\n\t    return getDefaultQueryPlan(selector, index);\n\t  }\n\t\n\t  if (index.def.fields.length === 1) {\n\t    // one field in index, so the value was indexed as a singleton\n\t    return getSingleFieldCoreQueryPlan(selector, index);\n\t  }\n\t  // else index has multiple fields, so the value was indexed as an array\n\t  return getMultiFieldQueryOpts(selector, index);\n\t}\n\t\n\tfunction planQuery(request, indexes) {\n\t\n\t  log('planning query', request);\n\t\n\t  var selector = request.selector;\n\t  var sort = request.sort;\n\t\n\t  var userFieldsRes = getUserFields(selector, sort);\n\t\n\t  var userFields = userFieldsRes.fields;\n\t  var sortOrder = userFieldsRes.sortOrder;\n\t  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes);\n\t\n\t  var coreQueryPlan = getCoreQueryPlan(selector, index);\n\t  var queryOpts = coreQueryPlan.queryOpts;\n\t  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\t\n\t  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\t\n\t  var res = {\n\t    queryOpts: queryOpts,\n\t    index: index,\n\t    inMemoryFields: inMemoryFields\n\t  };\n\t  log('query plan', res);\n\t  return res;\n\t}\n\t\n\tmodule.exports = planQuery;\n\n\n/***/ },\n/* 233 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(16);\n\tvar callbackify = utils.callbackify;\n\t\n\texports.createIndex = callbackify(__webpack_require__(228));\n\texports.find = callbackify(__webpack_require__(231));\n\texports.getIndexes = callbackify(__webpack_require__(104));\n\texports.deleteIndex = callbackify(__webpack_require__(229));\n\n/***/ },\n/* 234 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar utils = __webpack_require__(16);\n\t\n\tvar httpIndexes = __webpack_require__(227);\n\tvar localIndexes = __webpack_require__(233);\n\t\n\tvar plugin = {};\n\tplugin.createIndex = utils.toPromise(function (requestDef, callback) {\n\t\n\t  if (typeof requestDef !== 'object') {\n\t    return callback(new Error('you must provide an index to create'));\n\t  }\n\t\n\t  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\t\n\t  adapter.createIndex(this, requestDef, callback);\n\t});\n\t\n\tplugin.find = utils.toPromise(function (requestDef, callback) {\n\t\n\t  if (typeof callback === 'undefined') {\n\t    callback = requestDef;\n\t    requestDef = undefined;\n\t  }\n\t\n\t  if (typeof requestDef !== 'object') {\n\t    return callback(new Error('you must provide search parameters to find()'));\n\t  }\n\t\n\t  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\t\n\t  adapter.find(this, requestDef, callback);\n\t});\n\t\n\tplugin.getIndexes = utils.toPromise(function (callback) {\n\t\n\t  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\t\n\t  adapter.getIndexes(this, callback);\n\t});\n\t\n\tplugin.deleteIndex = utils.toPromise(function (indexDef, callback) {\n\t\n\t  if (typeof indexDef !== 'object') {\n\t    return callback(new Error('you must provide an index to delete'));\n\t  }\n\t\n\t  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\t\n\t  adapter.deleteIndex(this, indexDef, callback);\n\t});\n\t\n\tmodule.exports = plugin;\n\t\n\t/* istanbul ignore next */\n\tif (typeof window !== 'undefined' && window.PouchDB) {\n\t  window.PouchDB.plugin(plugin);\n\t}\n\n\n/***/ },\n/* 235 */\n[252, 236],\n/* 236 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(237);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t * @param {String} namespace\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor(namespace) {\n\t  var hash = 0, i;\n\t\n\t  for (i in namespace) {\n\t    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t    hash |= 0; // Convert to 32bit integer\n\t  }\n\t\n\t  return exports.colors[Math.abs(hash) % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction createDebug(namespace) {\n\t\n\t  function debug() {\n\t    // disabled?\n\t    if (!debug.enabled) return;\n\t\n\t    var self = debug;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // turn the `arguments` into a proper Array\n\t    var args = new Array(arguments.length);\n\t    for (var i = 0; i < args.length; i++) {\n\t      args[i] = arguments[i];\n\t    }\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %O\n\t      args.unshift('%O');\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    // apply env-specific formatting (colors, etc.)\n\t    exports.formatArgs.call(self, args);\n\t\n\t    var logFn = debug.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t\n\t  debug.namespace = namespace;\n\t  debug.enabled = exports.enabled(namespace);\n\t  debug.useColors = exports.useColors();\n\t  debug.color = selectColor(namespace);\n\t\n\t  // env-specific initialization logic for debug instances\n\t  if ('function' === typeof exports.init) {\n\t    exports.init(debug);\n\t  }\n\t\n\t  return debug;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  exports.names = [];\n\t  exports.skips = [];\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 237 */\n/***/ function(module, exports) {\n\n\t/**\n\t * Helpers.\n\t */\n\t\n\tvar s = 1000\n\tvar m = s * 60\n\tvar h = m * 60\n\tvar d = h * 24\n\tvar y = d * 365.25\n\t\n\t/**\n\t * Parse or format the given `val`.\n\t *\n\t * Options:\n\t *\n\t *  - `long` verbose formatting [false]\n\t *\n\t * @param {String|Number} val\n\t * @param {Object} options\n\t * @throws {Error} throw an error if val is not a non-empty string or a number\n\t * @return {String|Number}\n\t * @api public\n\t */\n\t\n\tmodule.exports = function (val, options) {\n\t  options = options || {}\n\t  var type = typeof val\n\t  if (type === 'string' && val.length > 0) {\n\t    return parse(val)\n\t  } else if (type === 'number' && isNaN(val) === false) {\n\t    return options.long ?\n\t\t\t\tfmtLong(val) :\n\t\t\t\tfmtShort(val)\n\t  }\n\t  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n\t}\n\t\n\t/**\n\t * Parse the given `str` and return milliseconds.\n\t *\n\t * @param {String} str\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction parse(str) {\n\t  str = String(str)\n\t  if (str.length > 10000) {\n\t    return\n\t  }\n\t  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n\t  if (!match) {\n\t    return\n\t  }\n\t  var n = parseFloat(match[1])\n\t  var type = (match[2] || 'ms').toLowerCase()\n\t  switch (type) {\n\t    case 'years':\n\t    case 'year':\n\t    case 'yrs':\n\t    case 'yr':\n\t    case 'y':\n\t      return n * y\n\t    case 'days':\n\t    case 'day':\n\t    case 'd':\n\t      return n * d\n\t    case 'hours':\n\t    case 'hour':\n\t    case 'hrs':\n\t    case 'hr':\n\t    case 'h':\n\t      return n * h\n\t    case 'minutes':\n\t    case 'minute':\n\t    case 'mins':\n\t    case 'min':\n\t    case 'm':\n\t      return n * m\n\t    case 'seconds':\n\t    case 'second':\n\t    case 'secs':\n\t    case 'sec':\n\t    case 's':\n\t      return n * s\n\t    case 'milliseconds':\n\t    case 'millisecond':\n\t    case 'msecs':\n\t    case 'msec':\n\t    case 'ms':\n\t      return n\n\t    default:\n\t      return undefined\n\t  }\n\t}\n\t\n\t/**\n\t * Short format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction fmtShort(ms) {\n\t  if (ms >= d) {\n\t    return Math.round(ms / d) + 'd'\n\t  }\n\t  if (ms >= h) {\n\t    return Math.round(ms / h) + 'h'\n\t  }\n\t  if (ms >= m) {\n\t    return Math.round(ms / m) + 'm'\n\t  }\n\t  if (ms >= s) {\n\t    return Math.round(ms / s) + 's'\n\t  }\n\t  return ms + 'ms'\n\t}\n\t\n\t/**\n\t * Long format for `ms`.\n\t *\n\t * @param {Number} ms\n\t * @return {String}\n\t * @api private\n\t */\n\t\n\tfunction fmtLong(ms) {\n\t  return plural(ms, d, 'day') ||\n\t    plural(ms, h, 'hour') ||\n\t    plural(ms, m, 'minute') ||\n\t    plural(ms, s, 'second') ||\n\t    ms + ' ms'\n\t}\n\t\n\t/**\n\t * Pluralization helper.\n\t */\n\t\n\tfunction plural(ms, n, name) {\n\t  if (ms < n) {\n\t    return\n\t  }\n\t  if (ms < n * 1.5) {\n\t    return Math.floor(ms / n) + ' ' + name\n\t  }\n\t  return Math.ceil(ms / n) + ' ' + name + 's'\n\t}\n\n\n/***/ },\n/* 238 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {'use strict';\n\tvar immediate = __webpack_require__(52);\n\t\n\t/* istanbul ignore next */\n\tfunction INTERNAL() {}\n\t\n\tvar handlers = {};\n\t\n\tvar REJECTED = ['REJECTED'];\n\tvar FULFILLED = ['FULFILLED'];\n\tvar PENDING = ['PENDING'];\n\t/* istanbul ignore else */\n\tif (!process.browser) {\n\t  // in which we actually take advantage of JS scoping\n\t  var UNHANDLED = ['UNHANDLED'];\n\t}\n\t\n\tmodule.exports = Promise;\n\t\n\tfunction Promise(resolver) {\n\t  if (typeof resolver !== 'function') {\n\t    throw new TypeError('resolver must be a function');\n\t  }\n\t  this.state = PENDING;\n\t  this.queue = [];\n\t  this.outcome = void 0;\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    this.handled = UNHANDLED;\n\t  }\n\t  if (resolver !== INTERNAL) {\n\t    safelyResolveThenable(this, resolver);\n\t  }\n\t}\n\t\n\tPromise.prototype.catch = function (onRejected) {\n\t  return this.then(null, onRejected);\n\t};\n\tPromise.prototype.then = function (onFulfilled, onRejected) {\n\t  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n\t    typeof onRejected !== 'function' && this.state === REJECTED) {\n\t    return this;\n\t  }\n\t  var promise = new this.constructor(INTERNAL);\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    if (this.handled === UNHANDLED) {\n\t      this.handled = null;\n\t    }\n\t  }\n\t  if (this.state !== PENDING) {\n\t    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n\t    unwrap(promise, resolver, this.outcome);\n\t  } else {\n\t    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n\t  }\n\t\n\t  return promise;\n\t};\n\tfunction QueueItem(promise, onFulfilled, onRejected) {\n\t  this.promise = promise;\n\t  if (typeof onFulfilled === 'function') {\n\t    this.onFulfilled = onFulfilled;\n\t    this.callFulfilled = this.otherCallFulfilled;\n\t  }\n\t  if (typeof onRejected === 'function') {\n\t    this.onRejected = onRejected;\n\t    this.callRejected = this.otherCallRejected;\n\t  }\n\t}\n\tQueueItem.prototype.callFulfilled = function (value) {\n\t  handlers.resolve(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallFulfilled = function (value) {\n\t  unwrap(this.promise, this.onFulfilled, value);\n\t};\n\tQueueItem.prototype.callRejected = function (value) {\n\t  handlers.reject(this.promise, value);\n\t};\n\tQueueItem.prototype.otherCallRejected = function (value) {\n\t  unwrap(this.promise, this.onRejected, value);\n\t};\n\t\n\tfunction unwrap(promise, func, value) {\n\t  immediate(function () {\n\t    var returnValue;\n\t    try {\n\t      returnValue = func(value);\n\t    } catch (e) {\n\t      return handlers.reject(promise, e);\n\t    }\n\t    if (returnValue === promise) {\n\t      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n\t    } else {\n\t      handlers.resolve(promise, returnValue);\n\t    }\n\t  });\n\t}\n\t\n\thandlers.resolve = function (self, value) {\n\t  var result = tryCatch(getThen, value);\n\t  if (result.status === 'error') {\n\t    return handlers.reject(self, result.value);\n\t  }\n\t  var thenable = result.value;\n\t\n\t  if (thenable) {\n\t    safelyResolveThenable(self, thenable);\n\t  } else {\n\t    self.state = FULFILLED;\n\t    self.outcome = value;\n\t    var i = -1;\n\t    var len = self.queue.length;\n\t    while (++i < len) {\n\t      self.queue[i].callFulfilled(value);\n\t    }\n\t  }\n\t  return self;\n\t};\n\thandlers.reject = function (self, error) {\n\t  self.state = REJECTED;\n\t  self.outcome = error;\n\t  /* istanbul ignore else */\n\t  if (!process.browser) {\n\t    if (self.handled === UNHANDLED) {\n\t      immediate(function () {\n\t        if (self.handled === UNHANDLED) {\n\t          process.emit('unhandledRejection', error, self);\n\t        }\n\t      });\n\t    }\n\t  }\n\t  var i = -1;\n\t  var len = self.queue.length;\n\t  while (++i < len) {\n\t    self.queue[i].callRejected(error);\n\t  }\n\t  return self;\n\t};\n\t\n\tfunction getThen(obj) {\n\t  // Make sure we only access the accessor once as required by the spec\n\t  var then = obj && obj.then;\n\t  if (obj && typeof obj === 'object' && typeof then === 'function') {\n\t    return function appyThen() {\n\t      then.apply(obj, arguments);\n\t    };\n\t  }\n\t}\n\t\n\tfunction safelyResolveThenable(self, thenable) {\n\t  // Either fulfill, reject or reject with error\n\t  var called = false;\n\t  function onError(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.reject(self, value);\n\t  }\n\t\n\t  function onSuccess(value) {\n\t    if (called) {\n\t      return;\n\t    }\n\t    called = true;\n\t    handlers.resolve(self, value);\n\t  }\n\t\n\t  function tryToUnwrap() {\n\t    thenable(onSuccess, onError);\n\t  }\n\t\n\t  var result = tryCatch(tryToUnwrap);\n\t  if (result.status === 'error') {\n\t    onError(result.value);\n\t  }\n\t}\n\t\n\tfunction tryCatch(func, value) {\n\t  var out = {};\n\t  try {\n\t    out.value = func(value);\n\t    out.status = 'success';\n\t  } catch (e) {\n\t    out.status = 'error';\n\t    out.value = e;\n\t  }\n\t  return out;\n\t}\n\t\n\tPromise.resolve = resolve;\n\tfunction resolve(value) {\n\t  if (value instanceof this) {\n\t    return value;\n\t  }\n\t  return handlers.resolve(new this(INTERNAL), value);\n\t}\n\t\n\tPromise.reject = reject;\n\tfunction reject(reason) {\n\t  var promise = new this(INTERNAL);\n\t  return handlers.reject(promise, reason);\n\t}\n\t\n\tPromise.all = all;\n\tfunction all(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var values = new Array(len);\n\t  var resolved = 0;\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    allResolver(iterable[i], i);\n\t  }\n\t  return promise;\n\t  function allResolver(value, i) {\n\t    self.resolve(value).then(resolveFromAll, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t    function resolveFromAll(outValue) {\n\t      values[i] = outValue;\n\t      if (++resolved === len && !called) {\n\t        called = true;\n\t        handlers.resolve(promise, values);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tPromise.race = race;\n\tfunction race(iterable) {\n\t  var self = this;\n\t  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n\t    return this.reject(new TypeError('must be an array'));\n\t  }\n\t\n\t  var len = iterable.length;\n\t  var called = false;\n\t  if (!len) {\n\t    return this.resolve([]);\n\t  }\n\t\n\t  var i = -1;\n\t  var promise = new this(INTERNAL);\n\t\n\t  while (++i < len) {\n\t    resolver(iterable[i]);\n\t  }\n\t  return promise;\n\t  function resolver(value) {\n\t    self.resolve(value).then(function (response) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.resolve(promise, response);\n\t      }\n\t    }, function (error) {\n\t      if (!called) {\n\t        called = true;\n\t        handlers.reject(promise, error);\n\t      }\n\t    });\n\t  }\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ },\n/* 239 */\n238,\n/* 240 */\n[253, 239],\n/* 241 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar lie = _interopDefault(__webpack_require__(222));\n\tvar getArguments = _interopDefault(__webpack_require__(78));\n\tvar debug = _interopDefault(__webpack_require__(242));\n\tvar events = __webpack_require__(219);\n\tvar inherits = _interopDefault(__webpack_require__(75));\n\tvar nextTick = _interopDefault(__webpack_require__(52));\n\tvar scopedEval = _interopDefault(__webpack_require__(247));\n\tvar Md5 = _interopDefault(__webpack_require__(245));\n\tvar vuvuzela = _interopDefault(__webpack_require__(248));\n\t\n\t/* istanbul ignore next */\n\tvar PouchPromise$1 = typeof Promise === 'function' ? Promise : lie;\n\t\n\tfunction isBinaryObject(object) {\n\t  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n\t    (typeof Blob !== 'undefined' && object instanceof Blob);\n\t}\n\t\n\tfunction cloneArrayBuffer(buff) {\n\t  if (typeof buff.slice === 'function') {\n\t    return buff.slice(0);\n\t  }\n\t  // IE10-11 slice() polyfill\n\t  var target = new ArrayBuffer(buff.byteLength);\n\t  var targetArray = new Uint8Array(target);\n\t  var sourceArray = new Uint8Array(buff);\n\t  targetArray.set(sourceArray);\n\t  return target;\n\t}\n\t\n\tfunction cloneBinaryObject(object) {\n\t  if (object instanceof ArrayBuffer) {\n\t    return cloneArrayBuffer(object);\n\t  }\n\t  var size = object.size;\n\t  var type = object.type;\n\t  // Blob\n\t  if (typeof object.slice === 'function') {\n\t    return object.slice(0, size, type);\n\t  }\n\t  // PhantomJS slice() replacement\n\t  return object.webkitSlice(0, size, type);\n\t}\n\t\n\t// most of this is borrowed from lodash.isPlainObject:\n\t// https://github.com/fis-components/lodash.isplainobject/\n\t// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\t\n\tvar funcToString = Function.prototype.toString;\n\tvar objectCtorString = funcToString.call(Object);\n\t\n\tfunction isPlainObject(value) {\n\t  var proto = Object.getPrototypeOf(value);\n\t  /* istanbul ignore if */\n\t  if (proto === null) { // not sure when this happens, but I guess it can\n\t    return true;\n\t  }\n\t  var Ctor = proto.constructor;\n\t  return (typeof Ctor == 'function' &&\n\t    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n\t}\n\t\n\tfunction clone(object) {\n\t  var newObject;\n\t  var i;\n\t  var len;\n\t\n\t  if (!object || typeof object !== 'object') {\n\t    return object;\n\t  }\n\t\n\t  if (Array.isArray(object)) {\n\t    newObject = [];\n\t    for (i = 0, len = object.length; i < len; i++) {\n\t      newObject[i] = clone(object[i]);\n\t    }\n\t    return newObject;\n\t  }\n\t\n\t  // special case: to avoid inconsistencies between IndexedDB\n\t  // and other backends, we automatically stringify Dates\n\t  if (object instanceof Date) {\n\t    return object.toISOString();\n\t  }\n\t\n\t  if (isBinaryObject(object)) {\n\t    return cloneBinaryObject(object);\n\t  }\n\t\n\t  if (!isPlainObject(object)) {\n\t    return object; // don't clone objects like Workers\n\t  }\n\t\n\t  newObject = {};\n\t  for (i in object) {\n\t    /* istanbul ignore else */\n\t    if (Object.prototype.hasOwnProperty.call(object, i)) {\n\t      var value = clone(object[i]);\n\t      if (typeof value !== 'undefined') {\n\t        newObject[i] = value;\n\t      }\n\t    }\n\t  }\n\t  return newObject;\n\t}\n\t\n\tfunction once(fun) {\n\t  var called = false;\n\t  return getArguments(function (args) {\n\t    /* istanbul ignore if */\n\t    if (called) {\n\t      // this is a smoke test and should never actually happen\n\t      throw new Error('once called more than once');\n\t    } else {\n\t      called = true;\n\t      fun.apply(this, args);\n\t    }\n\t  });\n\t}\n\t\n\tfunction toPromise(func) {\n\t  //create the function we will be returning\n\t  return getArguments(function (args) {\n\t    // Clone arguments\n\t    args = clone(args);\n\t    var self = this;\n\t    // if the last argument is a function, assume its a callback\n\t    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n\t    var promise = new PouchPromise$1(function (fulfill, reject) {\n\t      var resp;\n\t      try {\n\t        var callback = once(function (err, mesg) {\n\t          if (err) {\n\t            reject(err);\n\t          } else {\n\t            fulfill(mesg);\n\t          }\n\t        });\n\t        // create a callback for this invocation\n\t        // apply the function in the orig context\n\t        args.push(callback);\n\t        resp = func.apply(self, args);\n\t        if (resp && typeof resp.then === 'function') {\n\t          fulfill(resp);\n\t        }\n\t      } catch (e) {\n\t        reject(e);\n\t      }\n\t    });\n\t    // if there is a callback, call it back\n\t    if (usedCB) {\n\t      promise.then(function (result) {\n\t        usedCB(null, result);\n\t      }, usedCB);\n\t    }\n\t    return promise;\n\t  });\n\t}\n\t\n\tvar log = debug('pouchdb:api');\n\t\n\tfunction adapterFun(name, callback) {\n\t  function logApiCall(self, name, args) {\n\t    /* istanbul ignore if */\n\t    if (log.enabled) {\n\t      var logArgs = [self.name, name];\n\t      for (var i = 0; i < args.length - 1; i++) {\n\t        logArgs.push(args[i]);\n\t      }\n\t      log.apply(null, logArgs);\n\t\n\t      // override the callback itself to log the response\n\t      var origCallback = args[args.length - 1];\n\t      args[args.length - 1] = function (err, res) {\n\t        var responseArgs = [self.name, name];\n\t        responseArgs = responseArgs.concat(\n\t          err ? ['error', err] : ['success', res]\n\t        );\n\t        log.apply(null, responseArgs);\n\t        origCallback(err, res);\n\t      };\n\t    }\n\t  }\n\t\n\t  return toPromise(getArguments(function (args) {\n\t    if (this._closed) {\n\t      return PouchPromise$1.reject(new Error('database is closed'));\n\t    }\n\t    if (this._destroyed) {\n\t      return PouchPromise$1.reject(new Error('database is destroyed'));\n\t    }\n\t    var self = this;\n\t    logApiCall(self, name, args);\n\t    if (!this.taskqueue.isReady) {\n\t      return new PouchPromise$1(function (fulfill, reject) {\n\t        self.taskqueue.addTask(function (failed) {\n\t          if (failed) {\n\t            reject(failed);\n\t          } else {\n\t            fulfill(self[name].apply(self, args));\n\t          }\n\t        });\n\t      });\n\t    }\n\t    return callback.apply(this, args);\n\t  }));\n\t}\n\t\n\t// like underscore/lodash _.pick()\n\tfunction pick(obj, arr) {\n\t  var res = {};\n\t  for (var i = 0, len = arr.length; i < len; i++) {\n\t    var prop = arr[i];\n\t    if (prop in obj) {\n\t      res[prop] = obj[prop];\n\t    }\n\t  }\n\t  return res;\n\t}\n\t\n\tfunction mangle(key) {\n\t  return '$' + key;\n\t}\n\tfunction unmangle(key) {\n\t  return key.substring(1);\n\t}\n\tfunction Map$1() {\n\t  this._store = {};\n\t}\n\tMap$1.prototype.get = function (key) {\n\t  var mangled = mangle(key);\n\t  return this._store[mangled];\n\t};\n\tMap$1.prototype.set = function (key, value) {\n\t  var mangled = mangle(key);\n\t  this._store[mangled] = value;\n\t  return true;\n\t};\n\tMap$1.prototype.has = function (key) {\n\t  var mangled = mangle(key);\n\t  return mangled in this._store;\n\t};\n\tMap$1.prototype.delete = function (key) {\n\t  var mangled = mangle(key);\n\t  var res = mangled in this._store;\n\t  delete this._store[mangled];\n\t  return res;\n\t};\n\tMap$1.prototype.forEach = function (cb) {\n\t  var keys = Object.keys(this._store);\n\t  for (var i = 0, len = keys.length; i < len; i++) {\n\t    var key = keys[i];\n\t    var value = this._store[key];\n\t    key = unmangle(key);\n\t    cb(value, key);\n\t  }\n\t};\n\tObject.defineProperty(Map$1.prototype, 'size', {\n\t  get: function () {\n\t    return Object.keys(this._store).length;\n\t  }\n\t});\n\t\n\tfunction Set$1(array) {\n\t  this._store = new Map$1();\n\t\n\t  // init with an array\n\t  if (array && Array.isArray(array)) {\n\t    for (var i = 0, len = array.length; i < len; i++) {\n\t      this.add(array[i]);\n\t    }\n\t  }\n\t}\n\tSet$1.prototype.add = function (key) {\n\t  return this._store.set(key, true);\n\t};\n\tSet$1.prototype.has = function (key) {\n\t  return this._store.has(key);\n\t};\n\tSet$1.prototype.forEach = function (cb) {\n\t  this._store.forEach(function (value, key) {\n\t    cb(key);\n\t  });\n\t};\n\tObject.defineProperty(Set$1.prototype, 'size', {\n\t  get: function () {\n\t    return this._store.size;\n\t  }\n\t});\n\t\n\t/* global Map,Set,Symbol */\n\t// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n\t// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n\t// Notably they fail in IE11 and iOS 8.4, which this prevents.\n\tfunction supportsMapAndSet() {\n\t  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n\t    return false;\n\t  }\n\t  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n\t  return prop && 'get' in prop && Map[Symbol.species] === Map;\n\t}\n\t\n\t// based on https://github.com/montagejs/collections\n\t/* global Map,Set */\n\t\n\tvar ExportedSet;\n\tvar ExportedMap;\n\t\n\t{\n\t  if (supportsMapAndSet()) { // prefer built-in Map/Set\n\t    ExportedSet = Set;\n\t    ExportedMap = Map;\n\t  } else { // fall back to our polyfill\n\t    ExportedSet = Set$1;\n\t    ExportedMap = Map$1;\n\t  }\n\t}\n\t\n\t// Most browsers throttle concurrent requests at 6, so it's silly\n\t// to shim _bulk_get by trying to launch potentially hundreds of requests\n\t// and then letting the majority time out. We can handle this ourselves.\n\tvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\t\n\tfunction identityFunction(x) {\n\t  return x;\n\t}\n\t\n\tfunction formatResultForOpenRevsGet(result) {\n\t  return [{\n\t    ok: result\n\t  }];\n\t}\n\t\n\t// shim for P/CouchDB adapters that don't directly implement _bulk_get\n\tfunction bulkGet(db, opts, callback) {\n\t  var requests = opts.docs;\n\t\n\t  // consolidate into one request per doc if possible\n\t  var requestsById = new ExportedMap();\n\t  requests.forEach(function (request) {\n\t    if (requestsById.has(request.id)) {\n\t      requestsById.get(request.id).push(request);\n\t    } else {\n\t      requestsById.set(request.id, [request]);\n\t    }\n\t  });\n\t\n\t  var numDocs = requestsById.size;\n\t  var numDone = 0;\n\t  var perDocResults = new Array(numDocs);\n\t\n\t  function collapseResultsAndFinish() {\n\t    var results = [];\n\t    perDocResults.forEach(function (res) {\n\t      res.docs.forEach(function (info) {\n\t        results.push({\n\t          id: res.id,\n\t          docs: [info]\n\t        });\n\t      });\n\t    });\n\t    callback(null, {results: results});\n\t  }\n\t\n\t  function checkDone() {\n\t    if (++numDone === numDocs) {\n\t      collapseResultsAndFinish();\n\t    }\n\t  }\n\t\n\t  function gotResult(docIndex, id, docs) {\n\t    perDocResults[docIndex] = {id: id, docs: docs};\n\t    checkDone();\n\t  }\n\t\n\t  var allRequests = [];\n\t  requestsById.forEach(function (value, key) {\n\t    allRequests.push(key);\n\t  });\n\t\n\t  var i = 0;\n\t\n\t  function nextBatch() {\n\t\n\t    if (i >= allRequests.length) {\n\t      return;\n\t    }\n\t\n\t    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n\t    var batch = allRequests.slice(i, upTo);\n\t    processBatch(batch, i);\n\t    i += batch.length;\n\t  }\n\t\n\t  function processBatch(batch, offset) {\n\t    batch.forEach(function (docId, j) {\n\t      var docIdx = offset + j;\n\t      var docRequests = requestsById.get(docId);\n\t\n\t      // just use the first request as the \"template\"\n\t      // TODO: The _bulk_get API allows for more subtle use cases than this,\n\t      // but for now it is unlikely that there will be a mix of different\n\t      // \"atts_since\" or \"attachments\" in the same request, since it's just\n\t      // replicate.js that is using this for the moment.\n\t      // Also, atts_since is aspirational, since we don't support it yet.\n\t      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n\t      docOpts.open_revs = docRequests.map(function (request) {\n\t        // rev is optional, open_revs disallowed\n\t        return request.rev;\n\t      });\n\t\n\t      // remove falsey / undefined revisions\n\t      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\t\n\t      var formatResult = identityFunction;\n\t\n\t      if (docOpts.open_revs.length === 0) {\n\t        delete docOpts.open_revs;\n\t\n\t        // when fetching only the \"winning\" leaf,\n\t        // transform the result so it looks like an open_revs\n\t        // request\n\t        formatResult = formatResultForOpenRevsGet;\n\t      }\n\t\n\t      // globally-supplied options\n\t      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n\t        if (param in opts) {\n\t          docOpts[param] = opts[param];\n\t        }\n\t      });\n\t      db.get(docId, docOpts, function (err, res) {\n\t        var result;\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          result = [{error: err}];\n\t        } else {\n\t          result = formatResult(res);\n\t        }\n\t        gotResult(docIdx, docId, result);\n\t        nextBatch();\n\t      });\n\t    });\n\t  }\n\t\n\t  nextBatch();\n\t\n\t}\n\t\n\tfunction isChromeApp() {\n\t  return (typeof chrome !== \"undefined\" &&\n\t    typeof chrome.storage !== \"undefined\" &&\n\t    typeof chrome.storage.local !== \"undefined\");\n\t}\n\t\n\tvar hasLocal;\n\t\n\tif (isChromeApp()) {\n\t  hasLocal = false;\n\t} else {\n\t  try {\n\t    localStorage.setItem('_pouch_check_localstorage', 1);\n\t    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n\t  } catch (e) {\n\t    hasLocal = false;\n\t  }\n\t}\n\t\n\tfunction hasLocalStorage() {\n\t  return hasLocal;\n\t}\n\t\n\tinherits(Changes, events.EventEmitter);\n\t\n\t/* istanbul ignore next */\n\tfunction attachBrowserEvents(self) {\n\t  if (isChromeApp()) {\n\t    chrome.storage.onChanged.addListener(function (e) {\n\t      // make sure it's event addressed to us\n\t      if (e.db_name != null) {\n\t        //object only has oldValue, newValue members\n\t        self.emit(e.dbName.newValue);\n\t      }\n\t    });\n\t  } else if (hasLocalStorage()) {\n\t    if (typeof addEventListener !== 'undefined') {\n\t      addEventListener(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    } else { // old IE\n\t      window.attachEvent(\"storage\", function (e) {\n\t        self.emit(e.key);\n\t      });\n\t    }\n\t  }\n\t}\n\t\n\tfunction Changes() {\n\t  events.EventEmitter.call(this);\n\t  this._listeners = {};\n\t\n\t  attachBrowserEvents(this);\n\t}\n\tChanges.prototype.addListener = function (dbName, id, db, opts) {\n\t  /* istanbul ignore if */\n\t  if (this._listeners[id]) {\n\t    return;\n\t  }\n\t  var self = this;\n\t  var inprogress = false;\n\t  function eventFunction() {\n\t    /* istanbul ignore if */\n\t    if (!self._listeners[id]) {\n\t      return;\n\t    }\n\t    if (inprogress) {\n\t      inprogress = 'waiting';\n\t      return;\n\t    }\n\t    inprogress = true;\n\t    var changesOpts = pick(opts, [\n\t      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n\t      'doc_ids', 'view', 'since', 'query_params', 'binary'\n\t    ]);\n\t\n\t    /* istanbul ignore next */\n\t    function onError() {\n\t      inprogress = false;\n\t    }\n\t\n\t    db.changes(changesOpts).on('change', function (c) {\n\t      if (c.seq > opts.since && !opts.cancelled) {\n\t        opts.since = c.seq;\n\t        opts.onChange(c);\n\t      }\n\t    }).on('complete', function () {\n\t      if (inprogress === 'waiting') {\n\t        nextTick(eventFunction);\n\t      }\n\t      inprogress = false;\n\t    }).on('error', onError);\n\t  }\n\t  this._listeners[id] = eventFunction;\n\t  this.on(dbName, eventFunction);\n\t};\n\t\n\tChanges.prototype.removeListener = function (dbName, id) {\n\t  /* istanbul ignore if */\n\t  if (!(id in this._listeners)) {\n\t    return;\n\t  }\n\t  events.EventEmitter.prototype.removeListener.call(this, dbName,\n\t    this._listeners[id]);\n\t  delete this._listeners[id];\n\t};\n\t\n\t\n\t/* istanbul ignore next */\n\tChanges.prototype.notifyLocalWindows = function (dbName) {\n\t  //do a useless change on a storage thing\n\t  //in order to get other windows's listeners to activate\n\t  if (isChromeApp()) {\n\t    chrome.storage.local.set({dbName: dbName});\n\t  } else if (hasLocalStorage()) {\n\t    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n\t  }\n\t};\n\t\n\tChanges.prototype.notify = function (dbName) {\n\t  this.emit(dbName);\n\t  this.notifyLocalWindows(dbName);\n\t};\n\t\n\tfunction guardedConsole(method) {\n\t  /* istanbul ignore else */\n\t  if (console !== 'undefined' && method in console) {\n\t    var args = Array.prototype.slice.call(arguments, 1);\n\t    console[method].apply(console, args);\n\t  }\n\t}\n\t\n\tfunction randomNumber(min, max) {\n\t  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n\t  min = parseInt(min, 10) || 0;\n\t  max = parseInt(max, 10);\n\t  if (max !== max || max <= min) {\n\t    max = (min || 1) << 1; //doubling\n\t  } else {\n\t    max = max + 1;\n\t  }\n\t  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n\t  if(max > maxTimeout) {\n\t    min = maxTimeout >> 1; // divide by two\n\t    max = maxTimeout;\n\t  }\n\t  var ratio = Math.random();\n\t  var range = max - min;\n\t\n\t  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n\t}\n\t\n\tfunction defaultBackOff(min) {\n\t  var max = 0;\n\t  if (!min) {\n\t    max = 2000;\n\t  }\n\t  return randomNumber(min, max);\n\t}\n\t\n\t// designed to give info to browser users, who are disturbed\n\t// when they see http errors in the console\n\tfunction explainError(status, str) {\n\t  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n\t}\n\t\n\tvar assign;\n\t{\n\t  if (typeof Object.assign === 'function') {\n\t    assign = Object.assign;\n\t  } else {\n\t    // lite Object.assign polyfill based on\n\t    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n\t    assign = function (target) {\n\t      var to = Object(target);\n\t\n\t      for (var index = 1; index < arguments.length; index++) {\n\t        var nextSource = arguments[index];\n\t\n\t        if (nextSource != null) { // Skip over if undefined or null\n\t          for (var nextKey in nextSource) {\n\t            // Avoid bugs when hasOwnProperty is shadowed\n\t            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n\t              to[nextKey] = nextSource[nextKey];\n\t            }\n\t          }\n\t        }\n\t      }\n\t      return to;\n\t    };\n\t  }\n\t}\n\t\n\tvar assign$1 = assign;\n\t\n\tinherits(PouchError, Error);\n\t\n\tfunction PouchError(status, error, reason) {\n\t  Error.call(this, reason);\n\t  this.status = status;\n\t  this.name = error;\n\t  this.message = reason;\n\t  this.error = true;\n\t}\n\t\n\tPouchError.prototype.toString = function () {\n\t  return JSON.stringify({\n\t    status: this.status,\n\t    name: this.name,\n\t    message: this.message,\n\t    reason: this.reason\n\t  });\n\t};\n\t\n\tvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\n\tvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\n\tvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\n\tvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\n\tvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\n\tvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\n\tvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\n\tvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\n\tvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\n\tvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\n\tvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\n\tvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\n\tvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\n\tvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\n\tvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\n\tvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\n\tvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\n\tvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\n\tvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\n\tvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\n\tvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\n\tvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\n\tvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\n\tvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\t\n\tfunction createError(error, reason) {\n\t  function CustomPouchError(reason) {\n\t    // inherit error properties from our parent error manually\n\t    // so as to allow proper JSON parsing.\n\t    /* jshint ignore:start */\n\t    for (var p in error) {\n\t      if (typeof error[p] !== 'function') {\n\t        this[p] = error[p];\n\t      }\n\t    }\n\t    /* jshint ignore:end */\n\t    if (reason !== undefined) {\n\t      this.reason = reason;\n\t    }\n\t  }\n\t  CustomPouchError.prototype = PouchError.prototype;\n\t  return new CustomPouchError(reason);\n\t}\n\t\n\tfunction generateErrorFromResponse(err) {\n\t\n\t  if (typeof err !== 'object') {\n\t    var data = err;\n\t    err = UNKNOWN_ERROR;\n\t    err.data = data;\n\t  }\n\t\n\t  if ('error' in err && err.error === 'conflict') {\n\t    err.name = 'conflict';\n\t    err.status = 409;\n\t  }\n\t\n\t  if (!('name' in err)) {\n\t    err.name = err.error || 'unknown';\n\t  }\n\t\n\t  if (!('status' in err)) {\n\t    err.status = 500;\n\t  }\n\t\n\t  if (!('message' in err)) {\n\t    err.message = err.message || err.reason;\n\t  }\n\t\n\t  return err;\n\t}\n\t\n\tfunction tryFilter(filter, doc, req) {\n\t  try {\n\t    return !filter(doc, req);\n\t  } catch (err) {\n\t    var msg = 'Filter function threw: ' + err.toString();\n\t    return createError(BAD_REQUEST, msg);\n\t  }\n\t}\n\t\n\tfunction filterChange(opts) {\n\t  var req = {};\n\t  var hasFilter = opts.filter && typeof opts.filter === 'function';\n\t  req.query = opts.query_params;\n\t\n\t  return function filter(change) {\n\t    if (!change.doc) {\n\t      // CSG sends events on the changes feed that don't have documents,\n\t      // this hack makes a whole lot of existing code robust.\n\t      change.doc = {};\n\t    }\n\t\n\t    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\t\n\t    if (typeof filterReturn === 'object') {\n\t      return filterReturn;\n\t    }\n\t\n\t    if (filterReturn) {\n\t      return false;\n\t    }\n\t\n\t    if (!opts.include_docs) {\n\t      delete change.doc;\n\t    } else if (!opts.attachments) {\n\t      for (var att in change.doc._attachments) {\n\t        /* istanbul ignore else */\n\t        if (change.doc._attachments.hasOwnProperty(att)) {\n\t          change.doc._attachments[att].stub = true;\n\t        }\n\t      }\n\t    }\n\t    return true;\n\t  };\n\t}\n\t\n\tfunction flatten(arrs) {\n\t  var res = [];\n\t  for (var i = 0, len = arrs.length; i < len; i++) {\n\t    res = res.concat(arrs[i]);\n\t  }\n\t  return res;\n\t}\n\t\n\t// shim for Function.prototype.name,\n\t// for browsers that don't support it like IE\n\t\n\t/* istanbul ignore next */\n\tfunction f() {}\n\t\n\tvar hasName = f.name;\n\tvar res;\n\t\n\t// We dont run coverage in IE\n\t/* istanbul ignore else */\n\tif (hasName) {\n\t  res = function (fun) {\n\t    return fun.name;\n\t  };\n\t} else {\n\t  res = function (fun) {\n\t    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n\t  };\n\t}\n\t\n\t// Determine id an ID is valid\n\t//   - invalid IDs begin with an underescore that does not begin '_design' or\n\t//     '_local'\n\t//   - any other string value is a valid id\n\t// Returns the specific error object for each case\n\tfunction invalidIdError(id) {\n\t  var err;\n\t  if (!id) {\n\t    err = createError(MISSING_ID);\n\t  } else if (typeof id !== 'string') {\n\t    err = createError(INVALID_ID);\n\t  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n\t    err = createError(RESERVED_ID);\n\t  }\n\t  if (err) {\n\t    throw err;\n\t  }\n\t}\n\t\n\tfunction listenerCount(ee, type) {\n\t  return 'listenerCount' in ee ? ee.listenerCount(type) :\n\t                                 events.EventEmitter.listenerCount(ee, type);\n\t}\n\t\n\t// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n\t// avoid using process.nextTick() directly because the polyfill is very large and we don't\n\t// need all of it (see: https://github.com/defunctzombie/node-process).\n\t// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n\t// package, so it's the one we use.\n\t// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n\t// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n\t// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n\t// (least latency) option, which is \"immediate\" due to use of microtasks.\n\t// All of our nextTicks are isolated to this one function so we can easily swap out one\n\t// implementation for another.\n\t\n\tfunction parseDesignDocFunctionName(s) {\n\t  if (!s) {\n\t    return null;\n\t  }\n\t  var parts = s.split('/');\n\t  if (parts.length === 2) {\n\t    return parts;\n\t  }\n\t  if (parts.length === 1) {\n\t    return [s, s];\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction normalizeDesignDocFunctionName(s) {\n\t  var normalized = parseDesignDocFunctionName(s);\n\t  return normalized ? normalized.join('/') : null;\n\t}\n\t\n\t// originally parseUri 1.2.2, now patched by us\n\t// (c) Steven Levithan <stevenlevithan.com>\n\t// MIT License\n\tvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n\t    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\n\tvar qName =\"queryKey\";\n\tvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\t\n\t// use the \"loose\" parser\n\t/* jshint maxlen: false */\n\tvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\t\n\tfunction parseUri(str) {\n\t  var m = parser.exec(str);\n\t  var uri = {};\n\t  var i = 14;\n\t\n\t  while (i--) {\n\t    var key = keys[i];\n\t    var value = m[i] || \"\";\n\t    var encoded = ['user', 'password'].indexOf(key) !== -1;\n\t    uri[key] = encoded ? decodeURIComponent(value) : value;\n\t  }\n\t\n\t  uri[qName] = {};\n\t  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n\t    if ($1) {\n\t      uri[qName][$1] = $2;\n\t    }\n\t  });\n\t\n\t  return uri;\n\t}\n\t\n\t// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n\t// the diffFun tells us what delta to apply to the doc.  it either returns\n\t// the doc, or false if it doesn't need to do an update after all\n\tfunction upsert(db, docId, diffFun) {\n\t  return new PouchPromise$1(function (fulfill, reject) {\n\t    db.get(docId, function (err, doc) {\n\t      if (err) {\n\t        /* istanbul ignore next */\n\t        if (err.status !== 404) {\n\t          return reject(err);\n\t        }\n\t        doc = {};\n\t      }\n\t\n\t      // the user might change the _rev, so save it for posterity\n\t      var docRev = doc._rev;\n\t      var newDoc = diffFun(doc);\n\t\n\t      if (!newDoc) {\n\t        // if the diffFun returns falsy, we short-circuit as\n\t        // an optimization\n\t        return fulfill({updated: false, rev: docRev});\n\t      }\n\t\n\t      // users aren't allowed to modify these values,\n\t      // so reset them here\n\t      newDoc._id = docId;\n\t      newDoc._rev = docRev;\n\t      fulfill(tryAndPut(db, newDoc, diffFun));\n\t    });\n\t  });\n\t}\n\t\n\tfunction tryAndPut(db, doc, diffFun) {\n\t  return db.put(doc).then(function (res) {\n\t    return {\n\t      updated: true,\n\t      rev: res.rev\n\t    };\n\t  }, function (err) {\n\t    /* istanbul ignore next */\n\t    if (err.status !== 409) {\n\t      throw err;\n\t    }\n\t    return upsert(db, doc._id, diffFun);\n\t  });\n\t}\n\t\n\t// BEGIN Math.uuid.js\n\t\n\t/*!\n\tMath.uuid.js (v1.4)\n\thttp://www.broofa.com\n\tmailto:robert@broofa.com\n\t\n\tCopyright (c) 2010 Robert Kieffer\n\tDual licensed under the MIT and GPL licenses.\n\t*/\n\t\n\t/*\n\t * Generate a random uuid.\n\t *\n\t * USAGE: Math.uuid(length, radix)\n\t *   length - the desired number of characters\n\t *   radix  - the number of allowable values for each character.\n\t *\n\t * EXAMPLES:\n\t *   // No arguments  - returns RFC4122, version 4 ID\n\t *   >>> Math.uuid()\n\t *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n\t *\n\t *   // One argument - returns ID of the specified length\n\t *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n\t *   \"VcydxgltxrVZSTV\"\n\t *\n\t *   // Two arguments - returns ID of the specified length, and radix. \n\t *   // (Radix must be <= 62)\n\t *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n\t *   \"01001010\"\n\t *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n\t *   \"47473046\"\n\t *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n\t *   \"098F4D35\"\n\t */\n\tvar chars = (\n\t  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n\t  'abcdefghijklmnopqrstuvwxyz'\n\t).split('');\n\tfunction getValue(radix) {\n\t  return 0 | Math.random() * radix;\n\t}\n\tfunction uuid(len, radix) {\n\t  radix = radix || chars.length;\n\t  var out = '';\n\t  var i = -1;\n\t\n\t  if (len) {\n\t    // Compact form\n\t    while (++i < len) {\n\t      out += chars[getValue(radix)];\n\t    }\n\t    return out;\n\t  }\n\t    // rfc4122, version 4 form\n\t    // Fill in random data.  At i==19 set the high bits of clock sequence as\n\t    // per rfc4122, sec. 4.1.5\n\t  while (++i < 36) {\n\t    switch (i) {\n\t      case 8:\n\t      case 13:\n\t      case 18:\n\t      case 23:\n\t        out += '-';\n\t        break;\n\t      case 19:\n\t        out += chars[(getValue(16) & 0x3) | 0x8];\n\t        break;\n\t      default:\n\t        out += chars[getValue(16)];\n\t    }\n\t  }\n\t\n\t  return out;\n\t}\n\t\n\t// We fetch all leafs of the revision tree, and sort them based on tree length\n\t// and whether they were deleted, undeleted documents with the longest revision\n\t// tree (most edits) win\n\t// The final sort algorithm is slightly documented in a sidebar here:\n\t// http://guide.couchdb.org/draft/conflicts.html\n\tfunction winningRev(metadata) {\n\t  var winningId;\n\t  var winningPos;\n\t  var winningDeleted;\n\t  var toVisit = metadata.rev_tree.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var tree = node.ids;\n\t    var branches = tree[2];\n\t    var pos = node.pos;\n\t    if (branches.length) { // non-leaf\n\t      for (var i = 0, len = branches.length; i < len; i++) {\n\t        toVisit.push({pos: pos + 1, ids: branches[i]});\n\t      }\n\t      continue;\n\t    }\n\t    var deleted = !!tree[1].deleted;\n\t    var id = tree[0];\n\t    // sort by deleted, then pos, then id\n\t    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n\t        winningPos !== pos ? winningPos < pos : winningId < id)) {\n\t      winningId = id;\n\t      winningPos = pos;\n\t      winningDeleted = deleted;\n\t    }\n\t  }\n\t\n\t  return winningPos + '-' + winningId;\n\t}\n\t\n\t// Pretty much all below can be combined into a higher order function to\n\t// traverse revisions\n\t// The return value from the callback will be passed as context to all\n\t// children of that node\n\tfunction traverseRevTree(revs, callback) {\n\t  var toVisit = revs.slice();\n\t\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var branches = tree[2];\n\t    var newCtx =\n\t      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n\t    }\n\t  }\n\t}\n\t\n\tfunction sortByPos(a, b) {\n\t  return a.pos - b.pos;\n\t}\n\t\n\tfunction collectLeaves(revs) {\n\t  var leaves = [];\n\t  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n\t    if (isLeaf) {\n\t      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n\t    }\n\t  });\n\t  leaves.sort(sortByPos).reverse();\n\t  for (var i = 0, len = leaves.length; i < len; i++) {\n\t    delete leaves[i].pos;\n\t  }\n\t  return leaves;\n\t}\n\t\n\t// returns revs of all conflicts that is leaves such that\n\t// 1. are not deleted and\n\t// 2. are different than winning revision\n\tfunction collectConflicts(metadata) {\n\t  var win = winningRev(metadata);\n\t  var leaves = collectLeaves(metadata.rev_tree);\n\t  var conflicts = [];\n\t  for (var i = 0, len = leaves.length; i < len; i++) {\n\t    var leaf = leaves[i];\n\t    if (leaf.rev !== win && !leaf.opts.deleted) {\n\t      conflicts.push(leaf.rev);\n\t    }\n\t  }\n\t  return conflicts;\n\t}\n\t\n\t// compact a tree by marking its non-leafs as missing,\n\t// and return a list of revs to delete\n\tfunction compactTree(metadata) {\n\t  var revs = [];\n\t  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                               revHash, ctx, opts) {\n\t    if (opts.status === 'available' && !isLeaf) {\n\t      revs.push(pos + '-' + revHash);\n\t      opts.status = 'missing';\n\t    }\n\t  });\n\t  return revs;\n\t}\n\t\n\t// build up a list of all the paths to the leafs in this revision tree\n\tfunction rootToLeaf(revs) {\n\t  var paths = [];\n\t  var toVisit = revs.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var id = tree[0];\n\t    var opts = tree[1];\n\t    var branches = tree[2];\n\t    var isLeaf = branches.length === 0;\n\t\n\t    var history = node.history ? node.history.slice() : [];\n\t    history.push({id: id, opts: opts});\n\t    if (isLeaf) {\n\t      paths.push({pos: (pos + 1 - history.length), ids: history});\n\t    }\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n\t    }\n\t  }\n\t  return paths.reverse();\n\t}\n\t\n\t// for a better overview of what this is doing, read:\n\t// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n\t//\n\t// But for a quick intro, CouchDB uses a revision tree to store a documents\n\t// history, A -> B -> C, when a document has conflicts, that is a branch in the\n\t// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n\t//\n\t// KeyTree = [Path ... ]\n\t// Path = {pos: position_from_root, ids: Tree}\n\t// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\t\n\tfunction sortByPos$1(a, b) {\n\t  return a.pos - b.pos;\n\t}\n\t\n\t// classic binary search\n\tfunction binarySearch(arr, item, comparator) {\n\t  var low = 0;\n\t  var high = arr.length;\n\t  var mid;\n\t  while (low < high) {\n\t    mid = (low + high) >>> 1;\n\t    if (comparator(arr[mid], item) < 0) {\n\t      low = mid + 1;\n\t    } else {\n\t      high = mid;\n\t    }\n\t  }\n\t  return low;\n\t}\n\t\n\t// assuming the arr is sorted, insert the item in the proper place\n\tfunction insertSorted(arr, item, comparator) {\n\t  var idx = binarySearch(arr, item, comparator);\n\t  arr.splice(idx, 0, item);\n\t}\n\t\n\t// Turn a path as a flat array into a tree with a single branch.\n\t// If any should be stemmed from the beginning of the array, that's passed\n\t// in as the second argument\n\tfunction pathToTree(path, numStemmed) {\n\t  var root;\n\t  var leaf;\n\t  for (var i = numStemmed, len = path.length; i < len; i++) {\n\t    var node = path[i];\n\t    var currentLeaf = [node.id, node.opts, []];\n\t    if (leaf) {\n\t      leaf[2].push(currentLeaf);\n\t      leaf = currentLeaf;\n\t    } else {\n\t      root = leaf = currentLeaf;\n\t    }\n\t  }\n\t  return root;\n\t}\n\t\n\t// compare the IDs of two trees\n\tfunction compareTree(a, b) {\n\t  return a[0] < b[0] ? -1 : 1;\n\t}\n\t\n\t// Merge two trees together\n\t// The roots of tree1 and tree2 must be the same revision\n\tfunction mergeTree(in_tree1, in_tree2) {\n\t  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n\t  var conflicts = false;\n\t  while (queue.length > 0) {\n\t    var item = queue.pop();\n\t    var tree1 = item.tree1;\n\t    var tree2 = item.tree2;\n\t\n\t    if (tree1[1].status || tree2[1].status) {\n\t      tree1[1].status =\n\t        (tree1[1].status ===  'available' ||\n\t        tree2[1].status === 'available') ? 'available' : 'missing';\n\t    }\n\t\n\t    for (var i = 0; i < tree2[2].length; i++) {\n\t      if (!tree1[2][0]) {\n\t        conflicts = 'new_leaf';\n\t        tree1[2][0] = tree2[2][i];\n\t        continue;\n\t      }\n\t\n\t      var merged = false;\n\t      for (var j = 0; j < tree1[2].length; j++) {\n\t        if (tree1[2][j][0] === tree2[2][i][0]) {\n\t          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n\t          merged = true;\n\t        }\n\t      }\n\t      if (!merged) {\n\t        conflicts = 'new_branch';\n\t        insertSorted(tree1[2], tree2[2][i], compareTree);\n\t      }\n\t    }\n\t  }\n\t  return {conflicts: conflicts, tree: in_tree1};\n\t}\n\t\n\tfunction doMerge(tree, path, dontExpand) {\n\t  var restree = [];\n\t  var conflicts = false;\n\t  var merged = false;\n\t  var res;\n\t\n\t  if (!tree.length) {\n\t    return {tree: [path], conflicts: 'new_leaf'};\n\t  }\n\t\n\t  for (var i = 0, len = tree.length; i < len; i++) {\n\t    var branch = tree[i];\n\t    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n\t      // Paths start at the same position and have the same root, so they need\n\t      // merged\n\t      res = mergeTree(branch.ids, path.ids);\n\t      restree.push({pos: branch.pos, ids: res.tree});\n\t      conflicts = conflicts || res.conflicts;\n\t      merged = true;\n\t    } else if (dontExpand !== true) {\n\t      // The paths start at a different position, take the earliest path and\n\t      // traverse up until it as at the same point from root as the path we\n\t      // want to merge.  If the keys match we return the longer path with the\n\t      // other merged After stemming we dont want to expand the trees\n\t\n\t      var t1 = branch.pos < path.pos ? branch : path;\n\t      var t2 = branch.pos < path.pos ? path : branch;\n\t      var diff = t2.pos - t1.pos;\n\t\n\t      var candidateParents = [];\n\t\n\t      var trees = [];\n\t      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n\t      while (trees.length > 0) {\n\t        var item = trees.pop();\n\t        if (item.diff === 0) {\n\t          if (item.ids[0] === t2.ids[0]) {\n\t            candidateParents.push(item);\n\t          }\n\t          continue;\n\t        }\n\t        var elements = item.ids[2];\n\t        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n\t          trees.push({\n\t            ids: elements[j],\n\t            diff: item.diff - 1,\n\t            parent: item.ids,\n\t            parentIdx: j\n\t          });\n\t        }\n\t      }\n\t\n\t      var el = candidateParents[0];\n\t\n\t      if (!el) {\n\t        restree.push(branch);\n\t      } else {\n\t        res = mergeTree(el.ids, t2.ids);\n\t        el.parent[2][el.parentIdx] = res.tree;\n\t        restree.push({pos: t1.pos, ids: t1.ids});\n\t        conflicts = conflicts || res.conflicts;\n\t        merged = true;\n\t      }\n\t    } else {\n\t      restree.push(branch);\n\t    }\n\t  }\n\t\n\t  // We didnt find\n\t  if (!merged) {\n\t    restree.push(path);\n\t  }\n\t\n\t  restree.sort(sortByPos$1);\n\t\n\t  return {\n\t    tree: restree,\n\t    conflicts: conflicts || 'internal_node'\n\t  };\n\t}\n\t\n\t// To ensure we dont grow the revision tree infinitely, we stem old revisions\n\tfunction stem(tree, depth) {\n\t  // First we break out the tree into a complete list of root to leaf paths\n\t  var paths = rootToLeaf(tree);\n\t  var maybeStem = {};\n\t\n\t  var result;\n\t  for (var i = 0, len = paths.length; i < len; i++) {\n\t    // Then for each path, we cut off the start of the path based on the\n\t    // `depth` to stem to, and generate a new set of flat trees\n\t    var path = paths[i];\n\t    var stemmed = path.ids;\n\t    var numStemmed = Math.max(0, stemmed.length - depth);\n\t    var stemmedNode = {\n\t      pos: path.pos + numStemmed,\n\t      ids: pathToTree(stemmed, numStemmed)\n\t    };\n\t\n\t    for (var s = 0; s < numStemmed; s++) {\n\t      var rev = (path.pos + s) + '-' + stemmed[s].id;\n\t      maybeStem[rev] = true;\n\t    }\n\t\n\t    // Then we remerge all those flat trees together, ensuring that we dont\n\t    // connect trees that would go beyond the depth limit\n\t    if (result) {\n\t      result = doMerge(result, stemmedNode, true).tree;\n\t    } else {\n\t      result = [stemmedNode];\n\t    }\n\t  }\n\t\n\t  traverseRevTree(result, function (isLeaf, pos, revHash) {\n\t    // some revisions may have been removed in a branch but not in another\n\t    delete maybeStem[pos + '-' + revHash];\n\t  });\n\t\n\t  return {\n\t    tree: result,\n\t    revs: Object.keys(maybeStem)\n\t  };\n\t}\n\t\n\tfunction merge(tree, path, depth) {\n\t  var newTree = doMerge(tree, path);\n\t  var stemmed = stem(newTree.tree, depth);\n\t  return {\n\t    tree: stemmed.tree,\n\t    stemmedRevs: stemmed.revs,\n\t    conflicts: newTree.conflicts\n\t  };\n\t}\n\t\n\t// return true if a rev exists in the rev tree, false otherwise\n\tfunction revExists(revs, rev) {\n\t  var toVisit = revs.slice();\n\t  var splitRev = rev.split('-');\n\t  var targetPos = parseInt(splitRev[0], 10);\n\t  var targetId = splitRev[1];\n\t\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    if (node.pos === targetPos && node.ids[0] === targetId) {\n\t      return true;\n\t    }\n\t    var branches = node.ids[2];\n\t    for (var i = 0, len = branches.length; i < len; i++) {\n\t      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\tfunction getTrees(node) {\n\t  return node.ids;\n\t}\n\t\n\t// check if a specific revision of a doc has been deleted\n\t//  - metadata: the metadata object from the doc store\n\t//  - rev: (optional) the revision to check. defaults to winning revision\n\tfunction isDeleted(metadata, rev) {\n\t  if (!rev) {\n\t    rev = winningRev(metadata);\n\t  }\n\t  var id = rev.substring(rev.indexOf('-') + 1);\n\t  var toVisit = metadata.rev_tree.map(getTrees);\n\t\n\t  var tree;\n\t  while ((tree = toVisit.pop())) {\n\t    if (tree[0] === id) {\n\t      return !!tree[1].deleted;\n\t    }\n\t    toVisit = toVisit.concat(tree[2]);\n\t  }\n\t}\n\t\n\tfunction isLocalId(id) {\n\t  return (/^_local/).test(id);\n\t}\n\t\n\t// returns the current leaf node for a given revision\n\tfunction latest(rev, metadata) {\n\t  var toVisit = metadata.rev_tree.slice();\n\t  var node;\n\t  while ((node = toVisit.pop())) {\n\t    var pos = node.pos;\n\t    var tree = node.ids;\n\t    var id = tree[0];\n\t    var opts = tree[1];\n\t    var branches = tree[2];\n\t    var isLeaf = branches.length === 0;\n\t\n\t    var history = node.history ? node.history.slice() : [];\n\t    history.push({id: id, pos: pos, opts: opts});\n\t\n\t    if (isLeaf) {\n\t      for (var i = 0, len = history.length; i < len; i++) {\n\t        var historyNode = history[i];\n\t        var historyRev = historyNode.pos + '-' + historyNode.id;\n\t\n\t        if (historyRev === rev) {\n\t          // return the rev of this leaf\n\t          return pos + '-' + id;\n\t        }\n\t      }\n\t    }\n\t\n\t    for (var j = 0, l = branches.length; j < l; j++) {\n\t      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n\t    }\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n\t}\n\t\n\tfunction evalFilter(input) {\n\t  return scopedEval('\"use strict\";\\nreturn ' + input + ';', {});\n\t}\n\t\n\tfunction evalView(input) {\n\t  var code = [\n\t    'return function(doc) {',\n\t    '  \"use strict\";',\n\t    '  var emitted = false;',\n\t    '  var emit = function (a, b) {',\n\t    '    emitted = true;',\n\t    '  };',\n\t    '  var view = ' + input + ';',\n\t    '  view(doc);',\n\t    '  if (emitted) {',\n\t    '    return true;',\n\t    '  }',\n\t    '};'\n\t  ].join('\\n');\n\t\n\t  return scopedEval(code, {});\n\t}\n\t\n\tinherits(Changes$2, events.EventEmitter);\n\t\n\tfunction tryCatchInChangeListener(self, change) {\n\t  // isolate try/catches to avoid V8 deoptimizations\n\t  try {\n\t    self.emit('change', change);\n\t  } catch (e) {\n\t    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n\t  }\n\t}\n\t\n\tfunction Changes$2(db, opts, callback) {\n\t  events.EventEmitter.call(this);\n\t  var self = this;\n\t  this.db = db;\n\t  opts = opts ? clone(opts) : {};\n\t  var complete = opts.complete = once(function (err, resp) {\n\t    if (err) {\n\t      if (listenerCount(self, 'error') > 0) {\n\t        self.emit('error', err);\n\t      }\n\t    } else {\n\t      self.emit('complete', resp);\n\t    }\n\t    self.removeAllListeners();\n\t    db.removeListener('destroyed', onDestroy);\n\t  });\n\t  if (callback) {\n\t    self.on('complete', function (resp) {\n\t      callback(null, resp);\n\t    });\n\t    self.on('error', callback);\n\t  }\n\t  function onDestroy() {\n\t    self.cancel();\n\t  }\n\t  db.once('destroyed', onDestroy);\n\t\n\t  opts.onChange = function (change) {\n\t    /* istanbul ignore if */\n\t    if (self.isCancelled) {\n\t      return;\n\t    }\n\t    tryCatchInChangeListener(self, change);\n\t  };\n\t\n\t  var promise = new PouchPromise$1(function (fulfill, reject) {\n\t    opts.complete = function (err, res) {\n\t      if (err) {\n\t        reject(err);\n\t      } else {\n\t        fulfill(res);\n\t      }\n\t    };\n\t  });\n\t  self.once('cancel', function () {\n\t    db.removeListener('destroyed', onDestroy);\n\t    opts.complete(null, {status: 'cancelled'});\n\t  });\n\t  this.then = promise.then.bind(promise);\n\t  this['catch'] = promise['catch'].bind(promise);\n\t  this.then(function (result) {\n\t    complete(null, result);\n\t  }, complete);\n\t\n\t\n\t\n\t  if (!db.taskqueue.isReady) {\n\t    db.taskqueue.addTask(function (failed) {\n\t      if (failed) {\n\t        opts.complete(failed);\n\t      } else if (self.isCancelled) {\n\t        self.emit('cancel');\n\t      } else {\n\t        self.doChanges(opts);\n\t      }\n\t    });\n\t  } else {\n\t    self.doChanges(opts);\n\t  }\n\t}\n\tChanges$2.prototype.cancel = function () {\n\t  this.isCancelled = true;\n\t  if (this.db.taskqueue.isReady) {\n\t    this.emit('cancel');\n\t  }\n\t};\n\tfunction processChange(doc, metadata, opts) {\n\t  var changeList = [{rev: doc._rev}];\n\t  if (opts.style === 'all_docs') {\n\t    changeList = collectLeaves(metadata.rev_tree)\n\t    .map(function (x) { return {rev: x.rev}; });\n\t  }\n\t  var change = {\n\t    id: metadata.id,\n\t    changes: changeList,\n\t    doc: doc\n\t  };\n\t\n\t  if (isDeleted(metadata, doc._rev)) {\n\t    change.deleted = true;\n\t  }\n\t  if (opts.conflicts) {\n\t    change.doc._conflicts = collectConflicts(metadata);\n\t    if (!change.doc._conflicts.length) {\n\t      delete change.doc._conflicts;\n\t    }\n\t  }\n\t  return change;\n\t}\n\t\n\tChanges$2.prototype.doChanges = function (opts) {\n\t  var self = this;\n\t  var callback = opts.complete;\n\t\n\t  opts = clone(opts);\n\t  if ('live' in opts && !('continuous' in opts)) {\n\t    opts.continuous = opts.live;\n\t  }\n\t  opts.processChange = processChange;\n\t\n\t  if (opts.since === 'latest') {\n\t    opts.since = 'now';\n\t  }\n\t  if (!opts.since) {\n\t    opts.since = 0;\n\t  }\n\t  if (opts.since === 'now') {\n\t    this.db.info().then(function (info) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        callback(null, {status: 'cancelled'});\n\t        return;\n\t      }\n\t      opts.since = info.update_seq;\n\t      self.doChanges(opts);\n\t    }, callback);\n\t    return;\n\t  }\n\t\n\t\n\t  if (opts.view && !opts.filter) {\n\t    opts.filter = '_view';\n\t  }\n\t\n\t  if (opts.filter && typeof opts.filter === 'string') {\n\t    if (opts.filter === '_view') {\n\t      opts.view = normalizeDesignDocFunctionName(opts.view);\n\t    } else {\n\t      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n\t    }\n\t\n\t    if (this.db.type() !== 'http' && !opts.doc_ids) {\n\t      return this.filterChanges(opts);\n\t    }\n\t  }\n\t\n\t  if (!('descending' in opts)) {\n\t    opts.descending = false;\n\t  }\n\t\n\t  // 0 and 1 should return 1 document\n\t  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n\t  opts.complete = callback;\n\t  var newPromise = this.db._changes(opts);\n\t  /* istanbul ignore else */\n\t  if (newPromise && typeof newPromise.cancel === 'function') {\n\t    var cancel = self.cancel;\n\t    self.cancel = getArguments(function (args) {\n\t      newPromise.cancel();\n\t      cancel.apply(this, args);\n\t    });\n\t  }\n\t};\n\t\n\tChanges$2.prototype.filterChanges = function (opts) {\n\t  var self = this;\n\t  var callback = opts.complete;\n\t  if (opts.filter === '_view') {\n\t    if (!opts.view || typeof opts.view !== 'string') {\n\t      var err = createError(BAD_REQUEST,\n\t        '`view` filter parameter not found or invalid.');\n\t      return callback(err);\n\t    }\n\t    // fetch a view from a design doc, make it behave like a filter\n\t    var viewName = parseDesignDocFunctionName(opts.view);\n\t    this.db.get('_design/' + viewName[0], function (err, ddoc) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        return callback(null, {status: 'cancelled'});\n\t      }\n\t      /* istanbul ignore next */\n\t      if (err) {\n\t        return callback(generateErrorFromResponse(err));\n\t      }\n\t      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n\t        ddoc.views[viewName[1]].map;\n\t      if (!mapFun) {\n\t        return callback(createError(MISSING_DOC,\n\t          (ddoc.views ? 'missing json key: ' + viewName[1] :\n\t            'missing json key: views')));\n\t      }\n\t      opts.filter = evalView(mapFun);\n\t      self.doChanges(opts);\n\t    });\n\t  } else {\n\t    // fetch a filter from a design doc\n\t    var filterName = parseDesignDocFunctionName(opts.filter);\n\t    if (!filterName) {\n\t      return self.doChanges(opts);\n\t    }\n\t    this.db.get('_design/' + filterName[0], function (err, ddoc) {\n\t      /* istanbul ignore if */\n\t      if (self.isCancelled) {\n\t        return callback(null, {status: 'cancelled'});\n\t      }\n\t      /* istanbul ignore next */\n\t      if (err) {\n\t        return callback(generateErrorFromResponse(err));\n\t      }\n\t      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n\t      if (!filterFun) {\n\t        return callback(createError(MISSING_DOC,\n\t          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n\t            : 'missing json key: filters')));\n\t      }\n\t      opts.filter = evalFilter(filterFun);\n\t      self.doChanges(opts);\n\t    });\n\t  }\n\t};\n\t\n\t/*\n\t * A generic pouch adapter\n\t */\n\t\n\tfunction compare(left, right) {\n\t  return left < right ? -1 : left > right ? 1 : 0;\n\t}\n\t\n\t// Wrapper for functions that call the bulkdocs api with a single doc,\n\t// if the first result is an error, return an error\n\tfunction yankError(callback) {\n\t  return function (err, results) {\n\t    if (err || (results[0] && results[0].error)) {\n\t      callback(err || results[0]);\n\t    } else {\n\t      callback(null, results.length ? results[0]  : results);\n\t    }\n\t  };\n\t}\n\t\n\t// clean docs given to us by the user\n\tfunction cleanDocs(docs) {\n\t  for (var i = 0; i < docs.length; i++) {\n\t    var doc = docs[i];\n\t    if (doc._deleted) {\n\t      delete doc._attachments; // ignore atts for deleted docs\n\t    } else if (doc._attachments) {\n\t      // filter out extraneous keys from _attachments\n\t      var atts = Object.keys(doc._attachments);\n\t      for (var j = 0; j < atts.length; j++) {\n\t        var att = atts[j];\n\t        doc._attachments[att] = pick(doc._attachments[att],\n\t          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\t// compare two docs, first by _id then by _rev\n\tfunction compareByIdThenRev(a, b) {\n\t  var idCompare = compare(a._id, b._id);\n\t  if (idCompare !== 0) {\n\t    return idCompare;\n\t  }\n\t  var aStart = a._revisions ? a._revisions.start : 0;\n\t  var bStart = b._revisions ? b._revisions.start : 0;\n\t  return compare(aStart, bStart);\n\t}\n\t\n\t// for every node in a revision tree computes its distance from the closest\n\t// leaf\n\tfunction computeHeight(revs) {\n\t  var height = {};\n\t  var edges = [];\n\t  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n\t    var rev = pos + \"-\" + id;\n\t    if (isLeaf) {\n\t      height[rev] = 0;\n\t    }\n\t    if (prnt !== undefined) {\n\t      edges.push({from: prnt, to: rev});\n\t    }\n\t    return rev;\n\t  });\n\t\n\t  edges.reverse();\n\t  edges.forEach(function (edge) {\n\t    if (height[edge.from] === undefined) {\n\t      height[edge.from] = 1 + height[edge.to];\n\t    } else {\n\t      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n\t    }\n\t  });\n\t  return height;\n\t}\n\t\n\tfunction allDocsKeysQuery(api, opts, callback) {\n\t  var keys =  ('limit' in opts) ?\n\t      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n\t      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n\t  if (opts.descending) {\n\t    keys.reverse();\n\t  }\n\t  if (!keys.length) {\n\t    return api._allDocs({limit: 0}, callback);\n\t  }\n\t  var finalResults = {\n\t    offset: opts.skip\n\t  };\n\t  return PouchPromise$1.all(keys.map(function (key) {\n\t    var subOpts = assign$1({key: key, deleted: 'ok'}, opts);\n\t    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n\t      delete subOpts[optKey];\n\t    });\n\t    return new PouchPromise$1(function (resolve, reject) {\n\t      api._allDocs(subOpts, function (err, res) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        finalResults.total_rows = res.total_rows;\n\t        resolve(res.rows[0] || {key: key, error: 'not_found'});\n\t      });\n\t    });\n\t  })).then(function (results) {\n\t    finalResults.rows = results;\n\t    return finalResults;\n\t  });\n\t}\n\t\n\t// all compaction is done in a queue, to avoid attaching\n\t// too many listeners at once\n\tfunction doNextCompaction(self) {\n\t  var task = self._compactionQueue[0];\n\t  var opts = task.opts;\n\t  var callback = task.callback;\n\t  self.get('_local/compaction').catch(function () {\n\t    return false;\n\t  }).then(function (doc) {\n\t    if (doc && doc.last_seq) {\n\t      opts.last_seq = doc.last_seq;\n\t    }\n\t    self._compact(opts, function (err, res) {\n\t      /* istanbul ignore if */\n\t      if (err) {\n\t        callback(err);\n\t      } else {\n\t        callback(null, res);\n\t      }\n\t      nextTick(function () {\n\t        self._compactionQueue.shift();\n\t        if (self._compactionQueue.length) {\n\t          doNextCompaction(self);\n\t        }\n\t      });\n\t    });\n\t  });\n\t}\n\t\n\tfunction attachmentNameError(name) {\n\t  if (name.charAt(0) === '_') {\n\t    return name + 'is not a valid attachment name, attachment ' +\n\t      'names cannot start with \\'_\\'';\n\t  }\n\t  return false;\n\t}\n\t\n\tinherits(AbstractPouchDB, events.EventEmitter);\n\t\n\tfunction AbstractPouchDB() {\n\t  events.EventEmitter.call(this);\n\t}\n\t\n\tAbstractPouchDB.prototype.post =\n\t  adapterFun('post', function (doc, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof doc !== 'object' || Array.isArray(doc)) {\n\t    return callback(createError(NOT_AN_OBJECT));\n\t  }\n\t  this.bulkDocs({docs: [doc]}, opts, yankError(callback));\n\t});\n\t\n\tAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n\t  if (typeof opts === 'function') {\n\t    cb = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof doc !== 'object' || Array.isArray(doc)) {\n\t    return cb(createError(NOT_AN_OBJECT));\n\t  }\n\t  invalidIdError(doc._id);\n\t  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n\t    if (doc._deleted) {\n\t      return this._removeLocal(doc, cb);\n\t    } else {\n\t      return this._putLocal(doc, cb);\n\t    }\n\t  }\n\t  if (typeof this._put === 'function' && opts.new_edits !== false) {\n\t    this._put(doc, opts, cb);\n\t  } else {\n\t    this.bulkDocs({docs: [doc]}, opts, yankError(cb));\n\t  }\n\t});\n\t\n\tAbstractPouchDB.prototype.putAttachment =\n\t  adapterFun('putAttachment', function (docId, attachmentId, rev,\n\t                                              blob, type) {\n\t  var api = this;\n\t  if (typeof type === 'function') {\n\t    type = blob;\n\t    blob = rev;\n\t    rev = null;\n\t  }\n\t  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n\t  /* istanbul ignore if */\n\t  if (typeof type === 'undefined') {\n\t    type = blob;\n\t    blob = rev;\n\t    rev = null;\n\t  }\n\t  if (!type) {\n\t    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n\t  }\n\t\n\t  function createAttachment(doc) {\n\t    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n\t    doc._attachments = doc._attachments || {};\n\t    doc._attachments[attachmentId] = {\n\t      content_type: type,\n\t      data: blob,\n\t      revpos: ++prevrevpos\n\t    };\n\t    return api.put(doc);\n\t  }\n\t\n\t  return api.get(docId).then(function (doc) {\n\t    if (doc._rev !== rev) {\n\t      throw createError(REV_CONFLICT);\n\t    }\n\t\n\t    return createAttachment(doc);\n\t  }, function (err) {\n\t     // create new doc\n\t    /* istanbul ignore else */\n\t    if (err.reason === MISSING_DOC.message) {\n\t      return createAttachment({_id: docId});\n\t    } else {\n\t      throw err;\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.removeAttachment =\n\t  adapterFun('removeAttachment', function (docId, attachmentId, rev,\n\t                                                 callback) {\n\t  var self = this;\n\t  self.get(docId, function (err, obj) {\n\t    /* istanbul ignore if */\n\t    if (err) {\n\t      callback(err);\n\t      return;\n\t    }\n\t    if (obj._rev !== rev) {\n\t      callback(createError(REV_CONFLICT));\n\t      return;\n\t    }\n\t    /* istanbul ignore if */\n\t    if (!obj._attachments) {\n\t      return callback();\n\t    }\n\t    delete obj._attachments[attachmentId];\n\t    if (Object.keys(obj._attachments).length === 0) {\n\t      delete obj._attachments;\n\t    }\n\t    self.put(obj, callback);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.remove =\n\t  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n\t  var doc;\n\t  if (typeof optsOrRev === 'string') {\n\t    // id, rev, opts, callback style\n\t    doc = {\n\t      _id: docOrId,\n\t      _rev: optsOrRev\n\t    };\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t  } else {\n\t    // doc, opts, callback style\n\t    doc = docOrId;\n\t    if (typeof optsOrRev === 'function') {\n\t      callback = optsOrRev;\n\t      opts = {};\n\t    } else {\n\t      callback = opts;\n\t      opts = optsOrRev;\n\t    }\n\t  }\n\t  opts = opts || {};\n\t  opts.was_delete = true;\n\t  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n\t  newDoc._deleted = true;\n\t  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n\t    return this._removeLocal(doc, callback);\n\t  }\n\t  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n\t});\n\t\n\tAbstractPouchDB.prototype.revsDiff =\n\t  adapterFun('revsDiff', function (req, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  var ids = Object.keys(req);\n\t\n\t  if (!ids.length) {\n\t    return callback(null, {});\n\t  }\n\t\n\t  var count = 0;\n\t  var missing = new ExportedMap();\n\t\n\t  function addToMissing(id, revId) {\n\t    if (!missing.has(id)) {\n\t      missing.set(id, {missing: []});\n\t    }\n\t    missing.get(id).missing.push(revId);\n\t  }\n\t\n\t  function processDoc(id, rev_tree) {\n\t    // Is this fast enough? Maybe we should switch to a set simulated by a map\n\t    var missingForId = req[id].slice(0);\n\t    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n\t      opts) {\n\t        var rev = pos + '-' + revHash;\n\t        var idx = missingForId.indexOf(rev);\n\t        if (idx === -1) {\n\t          return;\n\t        }\n\t\n\t        missingForId.splice(idx, 1);\n\t        /* istanbul ignore if */\n\t        if (opts.status !== 'available') {\n\t          addToMissing(id, rev);\n\t        }\n\t      });\n\t\n\t    // Traversing the tree is synchronous, so now `missingForId` contains\n\t    // revisions that were not found in the tree\n\t    missingForId.forEach(function (rev) {\n\t      addToMissing(id, rev);\n\t    });\n\t  }\n\t\n\t  ids.map(function (id) {\n\t    this._getRevisionTree(id, function (err, rev_tree) {\n\t      if (err && err.status === 404 && err.message === 'missing') {\n\t        missing.set(id, {missing: req[id]});\n\t      } else if (err) {\n\t        /* istanbul ignore next */\n\t        return callback(err);\n\t      } else {\n\t        processDoc(id, rev_tree);\n\t      }\n\t\n\t      if (++count === ids.length) {\n\t        // convert LazyMap to object\n\t        var missingObj = {};\n\t        missing.forEach(function (value, key) {\n\t          missingObj[key] = value;\n\t        });\n\t        return callback(null, missingObj);\n\t      }\n\t    });\n\t  }, this);\n\t});\n\t\n\t// _bulk_get API for faster replication, as described in\n\t// https://github.com/apache/couchdb-chttpd/pull/33\n\t// At the \"abstract\" level, it will just run multiple get()s in\n\t// parallel, because this isn't much of a performance cost\n\t// for local databases (except the cost of multiple transactions, which is\n\t// small). The http adapter overrides this in order\n\t// to do a more efficient single HTTP request.\n\tAbstractPouchDB.prototype.bulkGet =\n\t  adapterFun('bulkGet', function (opts, callback) {\n\t  bulkGet(this, opts, callback);\n\t});\n\t\n\t// compact one document and fire callback\n\t// by compacting we mean removing all revisions which\n\t// are further from the leaf in revision tree than max_height\n\tAbstractPouchDB.prototype.compactDocument =\n\t  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n\t  var self = this;\n\t  this._getRevisionTree(docId, function (err, revTree) {\n\t    /* istanbul ignore if */\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    var height = computeHeight(revTree);\n\t    var candidates = [];\n\t    var revs = [];\n\t    Object.keys(height).forEach(function (rev) {\n\t      if (height[rev] > maxHeight) {\n\t        candidates.push(rev);\n\t      }\n\t    });\n\t\n\t    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n\t      var rev = pos + '-' + revHash;\n\t      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n\t        revs.push(rev);\n\t      }\n\t    });\n\t    self._doCompaction(docId, revs, callback);\n\t  });\n\t});\n\t\n\t// compact the whole database using single document\n\t// compaction\n\tAbstractPouchDB.prototype.compact =\n\t  adapterFun('compact', function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  var self = this;\n\t  opts = opts || {};\n\t\n\t  self._compactionQueue = self._compactionQueue || [];\n\t  self._compactionQueue.push({opts: opts, callback: callback});\n\t  if (self._compactionQueue.length === 1) {\n\t    doNextCompaction(self);\n\t  }\n\t});\n\tAbstractPouchDB.prototype._compact = function (opts, callback) {\n\t  var self = this;\n\t  var changesOpts = {\n\t    return_docs: false,\n\t    last_seq: opts.last_seq || 0\n\t  };\n\t  var promises = [];\n\t\n\t  function onChange(row) {\n\t    promises.push(self.compactDocument(row.id, 0));\n\t  }\n\t  function onComplete(resp) {\n\t    var lastSeq = resp.last_seq;\n\t    PouchPromise$1.all(promises).then(function () {\n\t      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n\t        if (!doc.last_seq || doc.last_seq < lastSeq) {\n\t          doc.last_seq = lastSeq;\n\t          return doc;\n\t        }\n\t        return false; // somebody else got here first, don't update\n\t      });\n\t    }).then(function () {\n\t      callback(null, {ok: true});\n\t    }).catch(callback);\n\t  }\n\t  self.changes(changesOpts)\n\t    .on('change', onChange)\n\t    .on('complete', onComplete)\n\t    .on('error', callback);\n\t};\n\t\n\t/* Begin api wrappers. Specific functionality to storage belongs in the\n\t   _[method] */\n\tAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n\t  if (typeof opts === 'function') {\n\t    cb = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof id !== 'string') {\n\t    return cb(createError(INVALID_ID));\n\t  }\n\t  if (isLocalId(id) && typeof this._getLocal === 'function') {\n\t    return this._getLocal(id, cb);\n\t  }\n\t  var leaves = [], self = this;\n\t\n\t  function finishOpenRevs() {\n\t    var result = [];\n\t    var count = leaves.length;\n\t    /* istanbul ignore if */\n\t    if (!count) {\n\t      return cb(null, result);\n\t    }\n\t\n\t    // order with open_revs is unspecified\n\t    leaves.forEach(function (leaf) {\n\t      self.get(id, {\n\t        rev: leaf,\n\t        revs: opts.revs,\n\t        latest: opts.latest,\n\t        attachments: opts.attachments\n\t      }, function (err, doc) {\n\t        if (!err) {\n\t          // using latest=true can produce duplicates\n\t          var existing;\n\t          for (var i = 0, l = result.length; i < l; i++) {\n\t            if (result[i].ok && result[i].ok._rev === doc._rev) {\n\t              existing = true;\n\t              break;\n\t            }\n\t          }\n\t          if (!existing) {\n\t            result.push({ok: doc});\n\t          }\n\t        } else {\n\t          result.push({missing: leaf});\n\t        }\n\t        count--;\n\t        if (!count) {\n\t          cb(null, result);\n\t        }\n\t      });\n\t    });\n\t  }\n\t\n\t  if (opts.open_revs) {\n\t    if (opts.open_revs === \"all\") {\n\t      this._getRevisionTree(id, function (err, rev_tree) {\n\t        if (err) {\n\t          return cb(err);\n\t        }\n\t        leaves = collectLeaves(rev_tree).map(function (leaf) {\n\t          return leaf.rev;\n\t        });\n\t        finishOpenRevs();\n\t      });\n\t    } else {\n\t      if (Array.isArray(opts.open_revs)) {\n\t        leaves = opts.open_revs;\n\t        for (var i = 0; i < leaves.length; i++) {\n\t          var l = leaves[i];\n\t          // looks like it's the only thing couchdb checks\n\t          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n\t            return cb(createError(INVALID_REV));\n\t          }\n\t        }\n\t        finishOpenRevs();\n\t      } else {\n\t        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n\t      }\n\t    }\n\t    return; // open_revs does not like other options\n\t  }\n\t\n\t  return this._get(id, opts, function (err, result) {\n\t    if (err) {\n\t      return cb(err);\n\t    }\n\t\n\t    var doc = result.doc;\n\t    var metadata = result.metadata;\n\t    var ctx = result.ctx;\n\t\n\t    if (opts.conflicts) {\n\t      var conflicts = collectConflicts(metadata);\n\t      if (conflicts.length) {\n\t        doc._conflicts = conflicts;\n\t      }\n\t    }\n\t\n\t    if (isDeleted(metadata, doc._rev)) {\n\t      doc._deleted = true;\n\t    }\n\t\n\t    if (opts.revs || opts.revs_info) {\n\t      var splittedRev = doc._rev.split('-');\n\t      var revNo       = parseInt(splittedRev[0], 10);\n\t      var revHash     = splittedRev[1];\n\t\n\t      var paths = rootToLeaf(metadata.rev_tree);\n\t      var path = null;\n\t\n\t      for (var i = 0; i < paths.length; i++) {\n\t        var currentPath = paths[i];\n\t        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n\t          .indexOf(revHash);\n\t        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\t\n\t        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n\t          path = currentPath;\n\t        }\n\t      }\n\t\n\t      var indexOfRev = path.ids.map(function (x) { return x.id; })\n\t        .indexOf(doc._rev.split('-')[1]) + 1;\n\t      var howMany = path.ids.length - indexOfRev;\n\t      path.ids.splice(indexOfRev, howMany);\n\t      path.ids.reverse();\n\t\n\t      if (opts.revs) {\n\t        doc._revisions = {\n\t          start: (path.pos + path.ids.length) - 1,\n\t          ids: path.ids.map(function (rev) {\n\t            return rev.id;\n\t          })\n\t        };\n\t      }\n\t      if (opts.revs_info) {\n\t        var pos =  path.pos + path.ids.length;\n\t        doc._revs_info = path.ids.map(function (rev) {\n\t          pos--;\n\t          return {\n\t            rev: pos + '-' + rev.id,\n\t            status: rev.opts.status\n\t          };\n\t        });\n\t      }\n\t    }\n\t\n\t    if (opts.attachments && doc._attachments) {\n\t      var attachments = doc._attachments;\n\t      var count = Object.keys(attachments).length;\n\t      if (count === 0) {\n\t        return cb(null, doc);\n\t      }\n\t      Object.keys(attachments).forEach(function (key) {\n\t        this._getAttachment(doc._id, key, attachments[key], {\n\t          // Previously the revision handling was done in adapter.js\n\t          // getAttachment, however since idb-next doesnt we need to\n\t          // pass the rev through\n\t          rev: doc._rev,\n\t          binary: opts.binary,\n\t          ctx: ctx\n\t        }, function (err, data) {\n\t          var att = doc._attachments[key];\n\t          att.data = data;\n\t          delete att.stub;\n\t          delete att.length;\n\t          if (!--count) {\n\t            cb(null, doc);\n\t          }\n\t        });\n\t      }, self);\n\t    } else {\n\t      if (doc._attachments) {\n\t        for (var key in doc._attachments) {\n\t          /* istanbul ignore else */\n\t          if (doc._attachments.hasOwnProperty(key)) {\n\t            doc._attachments[key].stub = true;\n\t          }\n\t        }\n\t      }\n\t      cb(null, doc);\n\t    }\n\t  });\n\t});\n\t\n\t// TODO: I dont like this, it forces an extra read for every\n\t// attachment read and enforces a confusing api between\n\t// adapter.js and the adapter implementation\n\tAbstractPouchDB.prototype.getAttachment =\n\t  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n\t  var self = this;\n\t  if (opts instanceof Function) {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  this._get(docId, opts, function (err, res) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n\t      opts.ctx = res.ctx;\n\t      opts.binary = true;\n\t      self._getAttachment(docId, attachmentId,\n\t                          res.doc._attachments[attachmentId], opts, callback);\n\t    } else {\n\t      return callback(createError(MISSING_DOC));\n\t    }\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.allDocs =\n\t  adapterFun('allDocs', function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n\t  if (opts.start_key) {\n\t    opts.startkey = opts.start_key;\n\t  }\n\t  if (opts.end_key) {\n\t    opts.endkey = opts.end_key;\n\t  }\n\t  if ('keys' in opts) {\n\t    if (!Array.isArray(opts.keys)) {\n\t      return callback(new TypeError('options.keys must be an array'));\n\t    }\n\t    var incompatibleOpt =\n\t      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n\t      return incompatibleOpt in opts;\n\t    })[0];\n\t    if (incompatibleOpt) {\n\t      callback(createError(QUERY_PARSE_ERROR,\n\t        'Query parameter `' + incompatibleOpt +\n\t        '` is not compatible with multi-get'\n\t      ));\n\t      return;\n\t    }\n\t    if (this.type() !== 'http') {\n\t      return allDocsKeysQuery(this, opts, callback);\n\t    }\n\t  }\n\t\n\t  return this._allDocs(opts, callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.changes = function (opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  return new Changes$2(this, opts, callback);\n\t};\n\t\n\tAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n\t  this._closed = true;\n\t  this.emit('closed');\n\t  return this._close(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n\t  var self = this;\n\t  this._info(function (err, info) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    // assume we know better than the adapter, unless it informs us\n\t    info.db_name = info.db_name || self.name;\n\t    info.auto_compaction = !!(self.auto_compaction && self.type() !== 'http');\n\t    info.adapter = self.type();\n\t    callback(null, info);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n\t  return this._id(callback);\n\t});\n\t\n\t/* istanbul ignore next */\n\tAbstractPouchDB.prototype.type = function () {\n\t  return (typeof this._type === 'function') ? this._type() : this.adapter;\n\t};\n\t\n\tAbstractPouchDB.prototype.bulkDocs =\n\t  adapterFun('bulkDocs', function (req, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  opts = opts || {};\n\t\n\t  if (Array.isArray(req)) {\n\t    req = {\n\t      docs: req\n\t    };\n\t  }\n\t\n\t  if (!req || !req.docs || !Array.isArray(req.docs)) {\n\t    return callback(createError(MISSING_BULK_DOCS));\n\t  }\n\t\n\t  for (var i = 0; i < req.docs.length; ++i) {\n\t    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n\t      return callback(createError(NOT_AN_OBJECT));\n\t    }\n\t  }\n\t\n\t  var attachmentError;\n\t  req.docs.forEach(function (doc) {\n\t    if (doc._attachments) {\n\t      Object.keys(doc._attachments).forEach(function (name) {\n\t        attachmentError = attachmentError || attachmentNameError(name);\n\t        if (!doc._attachments[name].content_type) {\n\t          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n\t        }\n\t      });\n\t    }\n\t  });\n\t\n\t  if (attachmentError) {\n\t    return callback(createError(BAD_REQUEST, attachmentError));\n\t  }\n\t\n\t  if (!('new_edits' in opts)) {\n\t    if ('new_edits' in req) {\n\t      opts.new_edits = req.new_edits;\n\t    } else {\n\t      opts.new_edits = true;\n\t    }\n\t  }\n\t\n\t  var adapter = this;\n\t  if (!opts.new_edits && adapter.type() !== 'http') {\n\t    // ensure revisions of the same doc are sorted, so that\n\t    // the local adapter processes them correctly (#2935)\n\t    req.docs.sort(compareByIdThenRev);\n\t  }\n\t\n\t  cleanDocs(req.docs);\n\t\n\t  // in the case of conflicts, we want to return the _ids to the user\n\t  // however, the underlying adapter may destroy the docs array, so\n\t  // create a copy here\n\t  var ids = req.docs.map(function (doc) {\n\t    return doc._id;\n\t  });\n\t\n\t  return this._bulkDocs(req, opts, function (err, res) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    if (!opts.new_edits) {\n\t      // this is what couch does when new_edits is false\n\t      res = res.filter(function (x) {\n\t        return x.error;\n\t      });\n\t    }\n\t    // add ids for error/conflict responses (not required for CouchDB)\n\t    if (adapter.type() !== 'http') {\n\t      for (var i = 0, l = res.length; i < l; i++) {\n\t        res[i].id = res[i].id || ids[i];\n\t      }\n\t    }\n\t\n\t    callback(null, res);\n\t  });\n\t});\n\t\n\tAbstractPouchDB.prototype.registerDependentDatabase =\n\t  adapterFun('registerDependentDatabase', function (dependentDb,\n\t                                                          callback) {\n\t  var depDB = new this.constructor(dependentDb, this.__opts);\n\t\n\t  function diffFun(doc) {\n\t    doc.dependentDbs = doc.dependentDbs || {};\n\t    if (doc.dependentDbs[dependentDb]) {\n\t      return false; // no update required\n\t    }\n\t    doc.dependentDbs[dependentDb] = true;\n\t    return doc;\n\t  }\n\t  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n\t    .then(function () {\n\t      callback(null, {db: depDB});\n\t    }).catch(callback);\n\t});\n\t\n\tAbstractPouchDB.prototype.destroy =\n\t  adapterFun('destroy', function (opts, callback) {\n\t\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t\n\t  var self = this;\n\t  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\t\n\t  function destroyDb() {\n\t    // call destroy method of the particular adaptor\n\t    self._destroy(opts, function (err, resp) {\n\t      if (err) {\n\t        return callback(err);\n\t      }\n\t      self._destroyed = true;\n\t      self.emit('destroyed');\n\t      callback(null, resp || { 'ok': true });\n\t    });\n\t  }\n\t\n\t  if (self.type() === 'http') {\n\t    // no need to check for dependent DBs if it's a remote DB\n\t    return destroyDb();\n\t  }\n\t\n\t  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n\t    if (err) {\n\t      /* istanbul ignore if */\n\t      if (err.status !== 404) {\n\t        return callback(err);\n\t      } else { // no dependencies\n\t        return destroyDb();\n\t      }\n\t    }\n\t    var dependentDbs = localDoc.dependentDbs;\n\t    var PouchDB = self.constructor;\n\t    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n\t      // use_prefix is only false in the browser\n\t      /* istanbul ignore next */\n\t      var trueName = usePrefix ?\n\t        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n\t      return new PouchDB(trueName, self.__opts).destroy();\n\t    });\n\t    PouchPromise$1.all(deletedMap).then(destroyDb, callback);\n\t  });\n\t});\n\t\n\tfunction TaskQueue$1() {\n\t  this.isReady = false;\n\t  this.failed = false;\n\t  this.queue = [];\n\t}\n\t\n\tTaskQueue$1.prototype.execute = function () {\n\t  var fun;\n\t  if (this.failed) {\n\t    while ((fun = this.queue.shift())) {\n\t      fun(this.failed);\n\t    }\n\t  } else {\n\t    while ((fun = this.queue.shift())) {\n\t      fun();\n\t    }\n\t  }\n\t};\n\t\n\tTaskQueue$1.prototype.fail = function (err) {\n\t  this.failed = err;\n\t  this.execute();\n\t};\n\t\n\tTaskQueue$1.prototype.ready = function (db) {\n\t  this.isReady = true;\n\t  this.db = db;\n\t  this.execute();\n\t};\n\t\n\tTaskQueue$1.prototype.addTask = function (fun) {\n\t  this.queue.push(fun);\n\t  if (this.failed) {\n\t    this.execute();\n\t  }\n\t};\n\t\n\tfunction parseAdapter(name, opts) {\n\t  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n\t  if (match) {\n\t    // the http adapter expects the fully qualified name\n\t    return {\n\t      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n\t      adapter: match[1]\n\t    };\n\t  }\n\t\n\t  var adapters = PouchDB$5.adapters;\n\t  var preferredAdapters = PouchDB$5.preferredAdapters;\n\t  var prefix = PouchDB$5.prefix;\n\t  var adapterName = opts.adapter;\n\t\n\t  if (!adapterName) { // automatically determine adapter\n\t    for (var i = 0; i < preferredAdapters.length; ++i) {\n\t      adapterName = preferredAdapters[i];\n\t      // check for browsers that have been upgraded from websql-only to websql+idb\n\t      /* istanbul ignore if */\n\t      if (adapterName === 'idb' && 'websql' in adapters &&\n\t          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n\t        // log it, because this can be confusing during development\n\t        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n\t          ' avoid data loss, because it was already opened with WebSQL.');\n\t        continue; // keep using websql to avoid user data loss\n\t      }\n\t      break;\n\t    }\n\t  }\n\t\n\t  var adapter = adapters[adapterName];\n\t\n\t  // if adapter is invalid, then an error will be thrown later\n\t  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n\t    adapter.use_prefix : true;\n\t\n\t  return {\n\t    name: usePrefix ? (prefix + name) : name,\n\t    adapter: adapterName\n\t  };\n\t}\n\t\n\t// OK, so here's the deal. Consider this code:\n\t//     var db1 = new PouchDB('foo');\n\t//     var db2 = new PouchDB('foo');\n\t//     db1.destroy();\n\t// ^ these two both need to emit 'destroyed' events,\n\t// as well as the PouchDB constructor itself.\n\t// So we have one db object (whichever one got destroy() called on it)\n\t// responsible for emitting the initial event, which then gets emitted\n\t// by the constructor, which then broadcasts it to any other dbs\n\t// that may have been created with the same name.\n\tfunction prepareForDestruction(self) {\n\t\n\t  var destructionListeners = self.constructor._destructionListeners;\n\t\n\t  function onDestroyed() {\n\t    self.removeListener('closed', onClosed);\n\t    self.constructor.emit('destroyed', self.name);\n\t  }\n\t\n\t  function onConstructorDestroyed() {\n\t    self.removeListener('destroyed', onDestroyed);\n\t    self.removeListener('closed', onClosed);\n\t    self.emit('destroyed');\n\t  }\n\t\n\t  function onClosed() {\n\t    self.removeListener('destroyed', onDestroyed);\n\t    destructionListeners.delete(self.name);\n\t  }\n\t\n\t  self.once('destroyed', onDestroyed);\n\t  self.once('closed', onClosed);\n\t\n\t  // in setup.js, the constructor is primed to listen for destroy events\n\t  if (!destructionListeners.has(self.name)) {\n\t    destructionListeners.set(self.name, []);\n\t  }\n\t  destructionListeners.get(self.name).push(onConstructorDestroyed);\n\t}\n\t\n\tinherits(PouchDB$5, AbstractPouchDB);\n\tfunction PouchDB$5(name, opts) {\n\t  // In Node our test suite only tests this for PouchAlt unfortunately\n\t  /* istanbul ignore if */\n\t  if (!(this instanceof PouchDB$5)) {\n\t    return new PouchDB$5(name, opts);\n\t  }\n\t\n\t  var self = this;\n\t  opts = opts || {};\n\t\n\t  if (name && typeof name === 'object') {\n\t    opts = name;\n\t    name = opts.name;\n\t    delete opts.name;\n\t  }\n\t\n\t  this.__opts = opts = clone(opts);\n\t\n\t  self.auto_compaction = opts.auto_compaction;\n\t  self.prefix = PouchDB$5.prefix;\n\t\n\t  if (typeof name !== 'string') {\n\t    throw new Error('Missing/invalid DB name');\n\t  }\n\t\n\t  var prefixedName = (opts.prefix || '') + name;\n\t  var backend = parseAdapter(prefixedName, opts);\n\t\n\t  opts.name = backend.name;\n\t  opts.adapter = opts.adapter || backend.adapter;\n\t\n\t  self.name = name;\n\t  self._adapter = opts.adapter;\n\t  debug('pouchdb:adapter')('Picked adapter: ' + opts.adapter);\n\t\n\t  if (!PouchDB$5.adapters[opts.adapter] ||\n\t      !PouchDB$5.adapters[opts.adapter].valid()) {\n\t    throw new Error('Invalid Adapter: ' + opts.adapter);\n\t  }\n\t\n\t  AbstractPouchDB.call(self);\n\t  self.taskqueue = new TaskQueue$1();\n\t\n\t  self.adapter = opts.adapter;\n\t\n\t  PouchDB$5.adapters[opts.adapter].call(self, opts, function (err) {\n\t    if (err) {\n\t      return self.taskqueue.fail(err);\n\t    }\n\t    prepareForDestruction(self);\n\t\n\t    self.emit('created', self);\n\t    PouchDB$5.emit('created', self.name);\n\t    self.taskqueue.ready(self);\n\t  });\n\t\n\t}\n\t\n\tPouchDB$5.debug = debug;\n\t\n\tPouchDB$5.adapters = {};\n\tPouchDB$5.preferredAdapters = [];\n\t\n\tPouchDB$5.prefix = '_pouch_';\n\t\n\tvar eventEmitter = new events.EventEmitter();\n\t\n\tfunction setUpEventEmitter(Pouch) {\n\t  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n\t    if (typeof events.EventEmitter.prototype[key] === 'function') {\n\t      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n\t    }\n\t  });\n\t\n\t  // these are created in constructor.js, and allow us to notify each DB with\n\t  // the same name that it was destroyed, via the constructor object\n\t  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n\t  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n\t    destructListeners.get(name).forEach(function (callback) {\n\t      callback();\n\t    });\n\t    destructListeners.delete(name);\n\t  });\n\t}\n\t\n\tsetUpEventEmitter(PouchDB$5);\n\t\n\tPouchDB$5.adapter = function (id, obj, addToPreferredAdapters) {\n\t  /* istanbul ignore else */\n\t  if (obj.valid()) {\n\t    PouchDB$5.adapters[id] = obj;\n\t    if (addToPreferredAdapters) {\n\t      PouchDB$5.preferredAdapters.push(id);\n\t    }\n\t  }\n\t};\n\t\n\tPouchDB$5.plugin = function (obj) {\n\t  if (typeof obj === 'function') { // function style for plugins\n\t    obj(PouchDB$5);\n\t  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0){\n\t    throw new Error('Invalid plugin: got \\\"' + obj + '\\\", expected an object or a function');\n\t  } else {\n\t    Object.keys(obj).forEach(function (id) { // object style for plugins\n\t      PouchDB$5.prototype[id] = obj[id];\n\t    });\n\t  }\n\t  return PouchDB$5;\n\t};\n\t\n\tPouchDB$5.defaults = function (defaultOpts) {\n\t  function PouchAlt(name, opts) {\n\t    if (!(this instanceof PouchAlt)) {\n\t      return new PouchAlt(name, opts);\n\t    }\n\t\n\t    opts = opts || {};\n\t\n\t    if (name && typeof name === 'object') {\n\t      opts = name;\n\t      name = opts.name;\n\t      delete opts.name;\n\t    }\n\t\n\t    opts = assign$1({}, PouchAlt.__defaults, opts);\n\t    PouchDB$5.call(this, name, opts);\n\t  }\n\t\n\t  inherits(PouchAlt, PouchDB$5);\n\t\n\t  PouchAlt.preferredAdapters = PouchDB$5.preferredAdapters.slice();\n\t  Object.keys(PouchDB$5).forEach(function (key) {\n\t    if (!(key in PouchAlt)) {\n\t      PouchAlt[key] = PouchDB$5[key];\n\t    }\n\t  });\n\t\n\t  // make default options transitive\n\t  // https://github.com/pouchdb/pouchdb/issues/5922\n\t  PouchAlt.__defaults = assign$1({}, this.__defaults, defaultOpts);\n\t\n\t  return PouchAlt;\n\t};\n\t\n\t// managed automatically by set-version.js\n\tvar version = \"6.1.1\";\n\t\n\tPouchDB$5.version = version;\n\t\n\tfunction toObject(array) {\n\t  return array.reduce(function (obj, item) {\n\t    obj[item] = true;\n\t    return obj;\n\t  }, {});\n\t}\n\t// List of top level reserved words for doc\n\tvar reservedWords = toObject([\n\t  '_id',\n\t  '_rev',\n\t  '_attachments',\n\t  '_deleted',\n\t  '_revisions',\n\t  '_revs_info',\n\t  '_conflicts',\n\t  '_deleted_conflicts',\n\t  '_local_seq',\n\t  '_rev_tree',\n\t  //replication documents\n\t  '_replication_id',\n\t  '_replication_state',\n\t  '_replication_state_time',\n\t  '_replication_state_reason',\n\t  '_replication_stats',\n\t  // Specific to Couchbase Sync Gateway\n\t  '_removed'\n\t]);\n\t\n\t// List of reserved words that should end up the document\n\tvar dataWords = toObject([\n\t  '_attachments',\n\t  //replication documents\n\t  '_replication_id',\n\t  '_replication_state',\n\t  '_replication_state_time',\n\t  '_replication_state_reason',\n\t  '_replication_stats'\n\t]);\n\t\n\tfunction parseRevisionInfo(rev) {\n\t  if (!/^\\d+\\-./.test(rev)) {\n\t    return createError(INVALID_REV);\n\t  }\n\t  var idx = rev.indexOf('-');\n\t  var left = rev.substring(0, idx);\n\t  var right = rev.substring(idx + 1);\n\t  return {\n\t    prefix: parseInt(left, 10),\n\t    id: right\n\t  };\n\t}\n\t\n\tfunction makeRevTreeFromRevisions(revisions, opts) {\n\t  var pos = revisions.start - revisions.ids.length + 1;\n\t\n\t  var revisionIds = revisions.ids;\n\t  var ids = [revisionIds[0], opts, []];\n\t\n\t  for (var i = 1, len = revisionIds.length; i < len; i++) {\n\t    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n\t  }\n\t\n\t  return [{\n\t    pos: pos,\n\t    ids: ids\n\t  }];\n\t}\n\t\n\t// Preprocess documents, parse their revisions, assign an id and a\n\t// revision for new writes that are missing them, etc\n\tfunction parseDoc(doc, newEdits) {\n\t\n\t  var nRevNum;\n\t  var newRevId;\n\t  var revInfo;\n\t  var opts = {status: 'available'};\n\t  if (doc._deleted) {\n\t    opts.deleted = true;\n\t  }\n\t\n\t  if (newEdits) {\n\t    if (!doc._id) {\n\t      doc._id = uuid();\n\t    }\n\t    newRevId = uuid(32, 16).toLowerCase();\n\t    if (doc._rev) {\n\t      revInfo = parseRevisionInfo(doc._rev);\n\t      if (revInfo.error) {\n\t        return revInfo;\n\t      }\n\t      doc._rev_tree = [{\n\t        pos: revInfo.prefix,\n\t        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n\t      }];\n\t      nRevNum = revInfo.prefix + 1;\n\t    } else {\n\t      doc._rev_tree = [{\n\t        pos: 1,\n\t        ids : [newRevId, opts, []]\n\t      }];\n\t      nRevNum = 1;\n\t    }\n\t  } else {\n\t    if (doc._revisions) {\n\t      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n\t      nRevNum = doc._revisions.start;\n\t      newRevId = doc._revisions.ids[0];\n\t    }\n\t    if (!doc._rev_tree) {\n\t      revInfo = parseRevisionInfo(doc._rev);\n\t      if (revInfo.error) {\n\t        return revInfo;\n\t      }\n\t      nRevNum = revInfo.prefix;\n\t      newRevId = revInfo.id;\n\t      doc._rev_tree = [{\n\t        pos: nRevNum,\n\t        ids: [newRevId, opts, []]\n\t      }];\n\t    }\n\t  }\n\t\n\t  invalidIdError(doc._id);\n\t\n\t  doc._rev = nRevNum + '-' + newRevId;\n\t\n\t  var result = {metadata : {}, data : {}};\n\t  for (var key in doc) {\n\t    /* istanbul ignore else */\n\t    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n\t      var specialKey = key[0] === '_';\n\t      if (specialKey && !reservedWords[key]) {\n\t        var error = createError(DOC_VALIDATION, key);\n\t        error.message = DOC_VALIDATION.message + ': ' + key;\n\t        throw error;\n\t      } else if (specialKey && !dataWords[key]) {\n\t        result.metadata[key.slice(1)] = doc[key];\n\t      } else {\n\t        result.data[key] = doc[key];\n\t      }\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tvar thisAtob = function (str) {\n\t  return atob(str);\n\t};\n\t\n\tvar thisBtoa = function (str) {\n\t  return btoa(str);\n\t};\n\t\n\t// Abstracts constructing a Blob object, so it also works in older\n\t// browsers that don't support the native Blob constructor (e.g.\n\t// old QtWebKit versions, Android < 4.4).\n\tfunction createBlob(parts, properties) {\n\t  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n\t  parts = parts || [];\n\t  properties = properties || {};\n\t  try {\n\t    return new Blob(parts, properties);\n\t  } catch (e) {\n\t    if (e.name !== \"TypeError\") {\n\t      throw e;\n\t    }\n\t    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n\t                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n\t                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n\t                  WebKitBlobBuilder;\n\t    var builder = new Builder();\n\t    for (var i = 0; i < parts.length; i += 1) {\n\t      builder.append(parts[i]);\n\t    }\n\t    return builder.getBlob(properties.type);\n\t  }\n\t}\n\t\n\t// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n\t// encode-decode-image-with-base64-breaks-image (2013-04-21)\n\tfunction binaryStringToArrayBuffer(bin) {\n\t  var length = bin.length;\n\t  var buf = new ArrayBuffer(length);\n\t  var arr = new Uint8Array(buf);\n\t  for (var i = 0; i < length; i++) {\n\t    arr[i] = bin.charCodeAt(i);\n\t  }\n\t  return buf;\n\t}\n\t\n\tfunction binStringToBluffer(binString, type) {\n\t  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n\t}\n\t\n\tfunction b64ToBluffer(b64, type) {\n\t  return binStringToBluffer(thisAtob(b64), type);\n\t}\n\t\n\t//Can't find original post, but this is close\n\t//http://stackoverflow.com/questions/6965107/ (continues on next line)\n\t//converting-between-strings-and-arraybuffers\n\tfunction arrayBufferToBinaryString(buffer) {\n\t  var binary = '';\n\t  var bytes = new Uint8Array(buffer);\n\t  var length = bytes.byteLength;\n\t  for (var i = 0; i < length; i++) {\n\t    binary += String.fromCharCode(bytes[i]);\n\t  }\n\t  return binary;\n\t}\n\t\n\t// shim for browsers that don't support it\n\tfunction readAsBinaryString(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(arrayBufferToBinaryString(\n\t      new FileReaderSync().readAsArrayBuffer(blob)));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || '';\n\t    if (hasBinaryString) {\n\t      return callback(result);\n\t    }\n\t    callback(arrayBufferToBinaryString(result));\n\t  };\n\t  if (hasBinaryString) {\n\t    reader.readAsBinaryString(blob);\n\t  } else {\n\t    reader.readAsArrayBuffer(blob);\n\t  }\n\t}\n\t\n\tfunction blobToBinaryString(blobOrBuffer, callback) {\n\t  readAsBinaryString(blobOrBuffer, function (bin) {\n\t    callback(bin);\n\t  });\n\t}\n\t\n\tfunction blobToBase64(blobOrBuffer, callback) {\n\t  blobToBinaryString(blobOrBuffer, function (base64) {\n\t    callback(thisBtoa(base64));\n\t  });\n\t}\n\t\n\t// simplified API. universal browser support is assumed\n\tfunction readAsArrayBuffer(blob, callback) {\n\t  if (typeof FileReader === 'undefined') {\n\t    // fix for Firefox in a web worker:\n\t    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n\t    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n\t  }\n\t\n\t  var reader = new FileReader();\n\t  reader.onloadend = function (e) {\n\t    var result = e.target.result || new ArrayBuffer(0);\n\t    callback(result);\n\t  };\n\t  reader.readAsArrayBuffer(blob);\n\t}\n\t\n\t// this is not used in the browser\n\t\n\tvar setImmediateShim = global.setImmediate || global.setTimeout;\n\tvar MD5_CHUNK_SIZE = 32768;\n\t\n\tfunction rawToBase64(raw) {\n\t  return thisBtoa(raw);\n\t}\n\t\n\tfunction sliceBlob(blob$$1, start, end) {\n\t  if (blob$$1.webkitSlice) {\n\t    return blob$$1.webkitSlice(start, end);\n\t  }\n\t  return blob$$1.slice(start, end);\n\t}\n\t\n\tfunction appendBlob(buffer, blob$$1, start, end, callback) {\n\t  if (start > 0 || end < blob$$1.size) {\n\t    // only slice blob if we really need to\n\t    blob$$1 = sliceBlob(blob$$1, start, end);\n\t  }\n\t  readAsArrayBuffer(blob$$1, function (arrayBuffer) {\n\t    buffer.append(arrayBuffer);\n\t    callback();\n\t  });\n\t}\n\t\n\tfunction appendString(buffer, string, start, end, callback) {\n\t  if (start > 0 || end < string.length) {\n\t    // only create a substring if we really need to\n\t    string = string.substring(start, end);\n\t  }\n\t  buffer.appendBinary(string);\n\t  callback();\n\t}\n\t\n\tfunction binaryMd5(data, callback) {\n\t  var inputIsString = typeof data === 'string';\n\t  var len = inputIsString ? data.length : data.size;\n\t  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n\t  var chunks = Math.ceil(len / chunkSize);\n\t  var currentChunk = 0;\n\t  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\t\n\t  var append = inputIsString ? appendString : appendBlob;\n\t\n\t  function next() {\n\t    setImmediateShim(loadNextChunk);\n\t  }\n\t\n\t  function done() {\n\t    var raw = buffer.end(true);\n\t    var base64 = rawToBase64(raw);\n\t    callback(base64);\n\t    buffer.destroy();\n\t  }\n\t\n\t  function loadNextChunk() {\n\t    var start = currentChunk * chunkSize;\n\t    var end = start + chunkSize;\n\t    currentChunk++;\n\t    if (currentChunk < chunks) {\n\t      append(buffer, data, start, end, next);\n\t    } else {\n\t      append(buffer, data, start, end, done);\n\t    }\n\t  }\n\t  loadNextChunk();\n\t}\n\t\n\tfunction stringMd5(string) {\n\t  return Md5.hash(string);\n\t}\n\t\n\tfunction parseBase64(data) {\n\t  try {\n\t    return thisAtob(data);\n\t  } catch (e) {\n\t    var err = createError(BAD_ARG,\n\t      'Attachment is not a valid base64 string');\n\t    return {error: err};\n\t  }\n\t}\n\t\n\tfunction preprocessString(att, blobType, callback) {\n\t  var asBinary = parseBase64(att.data);\n\t  if (asBinary.error) {\n\t    return callback(asBinary.error);\n\t  }\n\t\n\t  att.length = asBinary.length;\n\t  if (blobType === 'blob') {\n\t    att.data = binStringToBluffer(asBinary, att.content_type);\n\t  } else if (blobType === 'base64') {\n\t    att.data = thisBtoa(asBinary);\n\t  } else { // binary\n\t    att.data = asBinary;\n\t  }\n\t  binaryMd5(asBinary, function (result) {\n\t    att.digest = 'md5-' + result;\n\t    callback();\n\t  });\n\t}\n\t\n\tfunction preprocessBlob(att, blobType, callback) {\n\t  binaryMd5(att.data, function (md5) {\n\t    att.digest = 'md5-' + md5;\n\t    // size is for blobs (browser), length is for buffers (node)\n\t    att.length = att.data.size || att.data.length || 0;\n\t    if (blobType === 'binary') {\n\t      blobToBinaryString(att.data, function (binString) {\n\t        att.data = binString;\n\t        callback();\n\t      });\n\t    } else if (blobType === 'base64') {\n\t      blobToBase64(att.data, function (b64) {\n\t        att.data = b64;\n\t        callback();\n\t      });\n\t    } else {\n\t      callback();\n\t    }\n\t  });\n\t}\n\t\n\tfunction preprocessAttachment(att, blobType, callback) {\n\t  if (att.stub) {\n\t    return callback();\n\t  }\n\t  if (typeof att.data === 'string') { // input is a base64 string\n\t    preprocessString(att, blobType, callback);\n\t  } else { // input is a blob\n\t    preprocessBlob(att, blobType, callback);\n\t  }\n\t}\n\t\n\tfunction preprocessAttachments(docInfos, blobType, callback) {\n\t\n\t  if (!docInfos.length) {\n\t    return callback();\n\t  }\n\t\n\t  var docv = 0;\n\t  var overallErr;\n\t\n\t  docInfos.forEach(function (docInfo) {\n\t    var attachments = docInfo.data && docInfo.data._attachments ?\n\t      Object.keys(docInfo.data._attachments) : [];\n\t    var recv = 0;\n\t\n\t    if (!attachments.length) {\n\t      return done();\n\t    }\n\t\n\t    function processedAttachment(err) {\n\t      overallErr = err;\n\t      recv++;\n\t      if (recv === attachments.length) {\n\t        done();\n\t      }\n\t    }\n\t\n\t    for (var key in docInfo.data._attachments) {\n\t      if (docInfo.data._attachments.hasOwnProperty(key)) {\n\t        preprocessAttachment(docInfo.data._attachments[key],\n\t          blobType, processedAttachment);\n\t      }\n\t    }\n\t  });\n\t\n\t  function done() {\n\t    docv++;\n\t    if (docInfos.length === docv) {\n\t      if (overallErr) {\n\t        callback(overallErr);\n\t      } else {\n\t        callback();\n\t      }\n\t    }\n\t  }\n\t}\n\t\n\tfunction updateDoc(revLimit, prev, docInfo, results,\n\t                   i, cb, writeDoc, newEdits) {\n\t\n\t  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n\t    results[i] = docInfo;\n\t    return cb();\n\t  }\n\t\n\t  // sometimes this is pre-calculated. historically not always\n\t  var previousWinningRev = prev.winningRev || winningRev(prev);\n\t  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n\t    isDeleted(prev, previousWinningRev);\n\t  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n\t    isDeleted(docInfo.metadata);\n\t  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\t\n\t  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n\t    var newDoc = docInfo.data;\n\t    newDoc._rev = previousWinningRev;\n\t    newDoc._id = docInfo.metadata.id;\n\t    docInfo = parseDoc(newDoc, newEdits);\n\t  }\n\t\n\t  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\t\n\t  var inConflict = newEdits && (((previouslyDeleted && deleted) ||\n\t    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n\t    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\t\n\t  if (inConflict) {\n\t    var err = createError(REV_CONFLICT);\n\t    results[i] = err;\n\t    return cb();\n\t  }\n\t\n\t  var newRev = docInfo.metadata.rev;\n\t  docInfo.metadata.rev_tree = merged.tree;\n\t  docInfo.stemmedRevs = merged.stemmedRevs || [];\n\t  /* istanbul ignore else */\n\t  if (prev.rev_map) {\n\t    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n\t  }\n\t\n\t  // recalculate\n\t  var winningRev$$1 = winningRev(docInfo.metadata);\n\t  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\t\n\t  // calculate the total number of documents that were added/removed,\n\t  // from the perspective of total_rows/doc_count\n\t  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n\t    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\t\n\t  var newRevIsDeleted;\n\t  if (newRev === winningRev$$1) {\n\t    // if the new rev is the same as the winning rev, we can reuse that value\n\t    newRevIsDeleted = winningRevIsDeleted;\n\t  } else {\n\t    // if they're not the same, then we need to recalculate\n\t    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n\t  }\n\t\n\t  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n\t    true, delta, i, cb);\n\t}\n\t\n\tfunction rootIsMissing(docInfo) {\n\t  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n\t}\n\t\n\tfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n\t                     writeDoc, opts, overallCallback) {\n\t\n\t  // Default to 1000 locally\n\t  revLimit = revLimit || 1000;\n\t\n\t  function insertDoc(docInfo, resultsIdx, callback) {\n\t    // Cant insert new deleted documents\n\t    var winningRev$$1 = winningRev(docInfo.metadata);\n\t    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n\t    if ('was_delete' in opts && deleted) {\n\t      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n\t      return callback();\n\t    }\n\t\n\t    // 4712 - detect whether a new document was inserted with a _rev\n\t    var inConflict = newEdits && rootIsMissing(docInfo);\n\t\n\t    if (inConflict) {\n\t      var err = createError(REV_CONFLICT);\n\t      results[resultsIdx] = err;\n\t      return callback();\n\t    }\n\t\n\t    var delta = deleted ? 0 : 1;\n\t\n\t    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n\t      delta, resultsIdx, callback);\n\t  }\n\t\n\t  var newEdits = opts.new_edits;\n\t  var idsToDocs = new ExportedMap();\n\t\n\t  var docsDone = 0;\n\t  var docsToDo = docInfos.length;\n\t\n\t  function checkAllDocsDone() {\n\t    if (++docsDone === docsToDo && overallCallback) {\n\t      overallCallback();\n\t    }\n\t  }\n\t\n\t  docInfos.forEach(function (currentDoc, resultsIdx) {\n\t\n\t    if (currentDoc._id && isLocalId(currentDoc._id)) {\n\t      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n\t      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n\t        results[resultsIdx] = err || res;\n\t        checkAllDocsDone();\n\t      });\n\t      return;\n\t    }\n\t\n\t    var id = currentDoc.metadata.id;\n\t    if (idsToDocs.has(id)) {\n\t      docsToDo--; // duplicate\n\t      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n\t    } else {\n\t      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n\t    }\n\t  });\n\t\n\t  // in the case of new_edits, the user can provide multiple docs\n\t  // with the same id. these need to be processed sequentially\n\t  idsToDocs.forEach(function (docs, id) {\n\t    var numDone = 0;\n\t\n\t    function docWritten() {\n\t      if (++numDone < docs.length) {\n\t        nextDoc();\n\t      } else {\n\t        checkAllDocsDone();\n\t      }\n\t    }\n\t    function nextDoc() {\n\t      var value = docs[numDone];\n\t      var currentDoc = value[0];\n\t      var resultsIdx = value[1];\n\t\n\t      if (fetchedDocs.has(id)) {\n\t        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n\t          resultsIdx, docWritten, writeDoc, newEdits);\n\t      } else {\n\t        // Ensure stemming applies to new writes as well\n\t        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n\t        currentDoc.metadata.rev_tree = merged.tree;\n\t        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n\t        insertDoc(currentDoc, resultsIdx, docWritten);\n\t      }\n\t    }\n\t    nextDoc();\n\t  });\n\t}\n\t\n\t// IndexedDB requires a versioned database structure, so we use the\n\t// version here to manage migrations.\n\tvar ADAPTER_VERSION = 5;\n\t\n\t// The object stores created for each database\n\t// DOC_STORE stores the document meta data, its revision history and state\n\t// Keyed by document id\n\tvar DOC_STORE = 'document-store';\n\t// BY_SEQ_STORE stores a particular version of a document, keyed by its\n\t// sequence id\n\tvar BY_SEQ_STORE = 'by-sequence';\n\t// Where we store attachments\n\tvar ATTACH_STORE = 'attach-store';\n\t// Where we store many-to-many relations\n\t// between attachment digests and seqs\n\tvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\t\n\t// Where we store database-wide meta data in a single record\n\t// keyed by id: META_STORE\n\tvar META_STORE = 'meta-store';\n\t// Where we store local documents\n\tvar LOCAL_STORE = 'local-store';\n\t// Where we detect blob support\n\tvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\t\n\tfunction safeJsonParse(str) {\n\t  // This try/catch guards against stack overflow errors.\n\t  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n\t  // cannot overflow.\n\t  try {\n\t    return JSON.parse(str);\n\t  } catch (e) {\n\t    /* istanbul ignore next */\n\t    return vuvuzela.parse(str);\n\t  }\n\t}\n\t\n\tfunction safeJsonStringify(json) {\n\t  try {\n\t    return JSON.stringify(json);\n\t  } catch (e) {\n\t    /* istanbul ignore next */\n\t    return vuvuzela.stringify(json);\n\t  }\n\t}\n\t\n\tfunction idbError(callback) {\n\t  return function (evt) {\n\t    var message = 'unknown_error';\n\t    if (evt.target && evt.target.error) {\n\t      message = evt.target.error.name || evt.target.error.message;\n\t    }\n\t    callback(createError(IDB_ERROR, message, evt.type));\n\t  };\n\t}\n\t\n\t// Unfortunately, the metadata has to be stringified\n\t// when it is put into the database, because otherwise\n\t// IndexedDB can throw errors for deeply-nested objects.\n\t// Originally we just used JSON.parse/JSON.stringify; now\n\t// we use this custom vuvuzela library that avoids recursion.\n\t// If we could do it all over again, we'd probably use a\n\t// format for the revision trees other than JSON.\n\tfunction encodeMetadata(metadata, winningRev, deleted) {\n\t  return {\n\t    data: safeJsonStringify(metadata),\n\t    winningRev: winningRev,\n\t    deletedOrLocal: deleted ? '1' : '0',\n\t    seq: metadata.seq, // highest seq for this doc\n\t    id: metadata.id\n\t  };\n\t}\n\t\n\tfunction decodeMetadata(storedObject) {\n\t  if (!storedObject) {\n\t    return null;\n\t  }\n\t  var metadata = safeJsonParse(storedObject.data);\n\t  metadata.winningRev = storedObject.winningRev;\n\t  metadata.deleted = storedObject.deletedOrLocal === '1';\n\t  metadata.seq = storedObject.seq;\n\t  return metadata;\n\t}\n\t\n\t// read the doc back out from the database. we don't store the\n\t// _id or _rev because we already have _doc_id_rev.\n\tfunction decodeDoc(doc) {\n\t  if (!doc) {\n\t    return doc;\n\t  }\n\t  var idx = doc._doc_id_rev.lastIndexOf(':');\n\t  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n\t  doc._rev = doc._doc_id_rev.substring(idx + 1);\n\t  delete doc._doc_id_rev;\n\t  return doc;\n\t}\n\t\n\t// Read a blob from the database, encoding as necessary\n\t// and translating from base64 if the IDB doesn't support\n\t// native Blobs\n\tfunction readBlobData(body, type, asBlob, callback) {\n\t  if (asBlob) {\n\t    if (!body) {\n\t      callback(createBlob([''], {type: type}));\n\t    } else if (typeof body !== 'string') { // we have blob support\n\t      callback(body);\n\t    } else { // no blob support\n\t      callback(b64ToBluffer(body, type));\n\t    }\n\t  } else { // as base64 string\n\t    if (!body) {\n\t      callback('');\n\t    } else if (typeof body !== 'string') { // we have blob support\n\t      readAsBinaryString(body, function (binary) {\n\t        callback(thisBtoa(binary));\n\t      });\n\t    } else { // no blob support\n\t      callback(body);\n\t    }\n\t  }\n\t}\n\t\n\tfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n\t  var attachments = Object.keys(doc._attachments || {});\n\t  if (!attachments.length) {\n\t    return cb && cb();\n\t  }\n\t  var numDone = 0;\n\t\n\t  function checkDone() {\n\t    if (++numDone === attachments.length && cb) {\n\t      cb();\n\t    }\n\t  }\n\t\n\t  function fetchAttachment(doc, att) {\n\t    var attObj = doc._attachments[att];\n\t    var digest = attObj.digest;\n\t    var req = txn.objectStore(ATTACH_STORE).get(digest);\n\t    req.onsuccess = function (e) {\n\t      attObj.body = e.target.result.body;\n\t      checkDone();\n\t    };\n\t  }\n\t\n\t  attachments.forEach(function (att) {\n\t    if (opts.attachments && opts.include_docs) {\n\t      fetchAttachment(doc, att);\n\t    } else {\n\t      doc._attachments[att].stub = true;\n\t      checkDone();\n\t    }\n\t  });\n\t}\n\t\n\t// IDB-specific postprocessing necessary because\n\t// we don't know whether we stored a true Blob or\n\t// a base64-encoded string, and if it's a Blob it\n\t// needs to be read outside of the transaction context\n\tfunction postProcessAttachments(results, asBlob) {\n\t  return PouchPromise$1.all(results.map(function (row) {\n\t    if (row.doc && row.doc._attachments) {\n\t      var attNames = Object.keys(row.doc._attachments);\n\t      return PouchPromise$1.all(attNames.map(function (att) {\n\t        var attObj = row.doc._attachments[att];\n\t        if (!('body' in attObj)) { // already processed\n\t          return;\n\t        }\n\t        var body = attObj.body;\n\t        var type = attObj.content_type;\n\t        return new PouchPromise$1(function (resolve) {\n\t          readBlobData(body, type, asBlob, function (data) {\n\t            row.doc._attachments[att] = assign$1(\n\t              pick(attObj, ['digest', 'content_type']),\n\t              {data: data}\n\t            );\n\t            resolve();\n\t          });\n\t        });\n\t      }));\n\t    }\n\t  }));\n\t}\n\t\n\tfunction compactRevs(revs, docId, txn) {\n\t\n\t  var possiblyOrphanedDigests = [];\n\t  var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t  var attStore = txn.objectStore(ATTACH_STORE);\n\t  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t  var count = revs.length;\n\t\n\t  function checkDone() {\n\t    count--;\n\t    if (!count) { // done processing all revs\n\t      deleteOrphanedAttachments();\n\t    }\n\t  }\n\t\n\t  function deleteOrphanedAttachments() {\n\t    if (!possiblyOrphanedDigests.length) {\n\t      return;\n\t    }\n\t    possiblyOrphanedDigests.forEach(function (digest) {\n\t      var countReq = attAndSeqStore.index('digestSeq').count(\n\t        IDBKeyRange.bound(\n\t          digest + '::', digest + '::\\uffff', false, false));\n\t      countReq.onsuccess = function (e) {\n\t        var count = e.target.result;\n\t        if (!count) {\n\t          // orphaned\n\t          attStore.delete(digest);\n\t        }\n\t      };\n\t    });\n\t  }\n\t\n\t  revs.forEach(function (rev) {\n\t    var index = seqStore.index('_doc_id_rev');\n\t    var key = docId + \"::\" + rev;\n\t    index.getKey(key).onsuccess = function (e) {\n\t      var seq = e.target.result;\n\t      if (typeof seq !== 'number') {\n\t        return checkDone();\n\t      }\n\t      seqStore.delete(seq);\n\t\n\t      var cursor = attAndSeqStore.index('seq')\n\t        .openCursor(IDBKeyRange.only(seq));\n\t\n\t      cursor.onsuccess = function (event) {\n\t        var cursor = event.target.result;\n\t        if (cursor) {\n\t          var digest = cursor.value.digestSeq.split('::')[0];\n\t          possiblyOrphanedDigests.push(digest);\n\t          attAndSeqStore.delete(cursor.primaryKey);\n\t          cursor.continue();\n\t        } else { // done\n\t          checkDone();\n\t        }\n\t      };\n\t    };\n\t  });\n\t}\n\t\n\tfunction openTransactionSafely(idb, stores, mode) {\n\t  try {\n\t    return {\n\t      txn: idb.transaction(stores, mode)\n\t    };\n\t  } catch (err) {\n\t    return {\n\t      error: err\n\t    };\n\t  }\n\t}\n\t\n\tvar changesHandler$$1 = new Changes();\n\t\n\tfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n\t  var docInfos = req.docs;\n\t  var txn;\n\t  var docStore;\n\t  var bySeqStore;\n\t  var attachStore;\n\t  var attachAndSeqStore;\n\t  var metaStore;\n\t  var docInfoError;\n\t  var metaDoc;\n\t\n\t  for (var i = 0, len = docInfos.length; i < len; i++) {\n\t    var doc = docInfos[i];\n\t    if (doc._id && isLocalId(doc._id)) {\n\t      continue;\n\t    }\n\t    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n\t    if (doc.error && !docInfoError) {\n\t      docInfoError = doc;\n\t    }\n\t  }\n\t\n\t  if (docInfoError) {\n\t    return callback(docInfoError);\n\t  }\n\t\n\t  var allDocsProcessed = false;\n\t  var docCountDelta = 0;\n\t  var results = new Array(docInfos.length);\n\t  var fetchedDocs = new ExportedMap();\n\t  var preconditionErrored = false;\n\t  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\t\n\t  preprocessAttachments(docInfos, blobType, function (err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    startTransaction();\n\t  });\n\t\n\t  function startTransaction() {\n\t\n\t    var stores = [\n\t      DOC_STORE, BY_SEQ_STORE,\n\t      ATTACH_STORE,\n\t      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n\t      META_STORE\n\t    ];\n\t    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    txn = txnResult.txn;\n\t    txn.onabort = idbError(callback);\n\t    txn.ontimeout = idbError(callback);\n\t    txn.oncomplete = complete;\n\t    docStore = txn.objectStore(DOC_STORE);\n\t    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t    attachStore = txn.objectStore(ATTACH_STORE);\n\t    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t    metaStore = txn.objectStore(META_STORE);\n\t\n\t    metaStore.get(META_STORE).onsuccess = function (e) {\n\t      metaDoc = e.target.result;\n\t      updateDocCountIfReady();\n\t    };\n\t\n\t    verifyAttachments(function (err) {\n\t      if (err) {\n\t        preconditionErrored = true;\n\t        return callback(err);\n\t      }\n\t      fetchExistingDocs();\n\t    });\n\t  }\n\t\n\t  function onAllDocsProcessed() {\n\t    allDocsProcessed = true;\n\t    updateDocCountIfReady();\n\t  }\n\t\n\t  function idbProcessDocs() {\n\t    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n\t                txn, results, writeDoc, opts, onAllDocsProcessed);\n\t  }\n\t\n\t  function updateDocCountIfReady() {\n\t    if (!metaDoc || !allDocsProcessed) {\n\t      return;\n\t    }\n\t    // caching the docCount saves a lot of time in allDocs() and\n\t    // info(), which is why we go to all the trouble of doing this\n\t    metaDoc.docCount += docCountDelta;\n\t    metaStore.put(metaDoc);\n\t  }\n\t\n\t  function fetchExistingDocs() {\n\t\n\t    if (!docInfos.length) {\n\t      return;\n\t    }\n\t\n\t    var numFetched = 0;\n\t\n\t    function checkDone() {\n\t      if (++numFetched === docInfos.length) {\n\t        idbProcessDocs();\n\t      }\n\t    }\n\t\n\t    function readMetadata(event) {\n\t      var metadata = decodeMetadata(event.target.result);\n\t\n\t      if (metadata) {\n\t        fetchedDocs.set(metadata.id, metadata);\n\t      }\n\t      checkDone();\n\t    }\n\t\n\t    for (var i = 0, len = docInfos.length; i < len; i++) {\n\t      var docInfo = docInfos[i];\n\t      if (docInfo._id && isLocalId(docInfo._id)) {\n\t        checkDone(); // skip local docs\n\t        continue;\n\t      }\n\t      var req = docStore.get(docInfo.metadata.id);\n\t      req.onsuccess = readMetadata;\n\t    }\n\t  }\n\t\n\t  function complete() {\n\t    if (preconditionErrored) {\n\t      return;\n\t    }\n\t\n\t    changesHandler$$1.notify(api._meta.name);\n\t    callback(null, results);\n\t  }\n\t\n\t  function verifyAttachment(digest, callback) {\n\t\n\t    var req = attachStore.get(digest);\n\t    req.onsuccess = function (e) {\n\t      if (!e.target.result) {\n\t        var err = createError(MISSING_STUB,\n\t          'unknown stub attachment with digest ' +\n\t          digest);\n\t        err.status = 412;\n\t        callback(err);\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t  }\n\t\n\t  function verifyAttachments(finish) {\n\t\n\t\n\t    var digests = [];\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo.data && docInfo.data._attachments) {\n\t        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n\t          var att = docInfo.data._attachments[filename];\n\t          if (att.stub) {\n\t            digests.push(att.digest);\n\t          }\n\t        });\n\t      }\n\t    });\n\t    if (!digests.length) {\n\t      return finish();\n\t    }\n\t    var numDone = 0;\n\t    var err;\n\t\n\t    function checkDone() {\n\t      if (++numDone === digests.length) {\n\t        finish(err);\n\t      }\n\t    }\n\t    digests.forEach(function (digest) {\n\t      verifyAttachment(digest, function (attErr) {\n\t        if (attErr && !err) {\n\t          err = attErr;\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n\t                    isUpdate, delta, resultsIdx, callback) {\n\t\n\t    docInfo.metadata.winningRev = winningRev$$1;\n\t    docInfo.metadata.deleted = winningRevIsDeleted;\n\t\n\t    var doc = docInfo.data;\n\t    doc._id = docInfo.metadata.id;\n\t    doc._rev = docInfo.metadata.rev;\n\t\n\t    if (newRevIsDeleted) {\n\t      doc._deleted = true;\n\t    }\n\t\n\t    var hasAttachments = doc._attachments &&\n\t      Object.keys(doc._attachments).length;\n\t    if (hasAttachments) {\n\t      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n\t        isUpdate, resultsIdx, callback);\n\t    }\n\t\n\t    docCountDelta += delta;\n\t    updateDocCountIfReady();\n\t\n\t    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n\t      isUpdate, resultsIdx, callback);\n\t  }\n\t\n\t  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n\t                     isUpdate, resultsIdx, callback) {\n\t\n\t    var doc = docInfo.data;\n\t    var metadata = docInfo.metadata;\n\t\n\t    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n\t    delete doc._id;\n\t    delete doc._rev;\n\t\n\t    function afterPutDoc(e) {\n\t      var revsToDelete = docInfo.stemmedRevs || [];\n\t\n\t      if (isUpdate && api.auto_compaction) {\n\t        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n\t      }\n\t\n\t      if (revsToDelete && revsToDelete.length) {\n\t        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n\t      }\n\t\n\t      metadata.seq = e.target.result;\n\t      // Current _rev is calculated from _rev_tree on read\n\t      // delete metadata.rev;\n\t      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n\t        winningRevIsDeleted);\n\t      var metaDataReq = docStore.put(metadataToStore);\n\t      metaDataReq.onsuccess = afterPutMetadata;\n\t    }\n\t\n\t    function afterPutDocError(e) {\n\t      // ConstraintError, need to update, not put (see #1638 for details)\n\t      e.preventDefault(); // avoid transaction abort\n\t      e.stopPropagation(); // avoid transaction onerror\n\t      var index = bySeqStore.index('_doc_id_rev');\n\t      var getKeyReq = index.getKey(doc._doc_id_rev);\n\t      getKeyReq.onsuccess = function (e) {\n\t        var putReq = bySeqStore.put(doc, e.target.result);\n\t        putReq.onsuccess = afterPutDoc;\n\t      };\n\t    }\n\t\n\t    function afterPutMetadata() {\n\t      results[resultsIdx] = {\n\t        ok: true,\n\t        id: metadata.id,\n\t        rev: metadata.rev\n\t      };\n\t      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n\t      insertAttachmentMappings(docInfo, metadata.seq, callback);\n\t    }\n\t\n\t    var putReq = bySeqStore.put(doc);\n\t\n\t    putReq.onsuccess = afterPutDoc;\n\t    putReq.onerror = afterPutDocError;\n\t  }\n\t\n\t  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n\t                            isUpdate, resultsIdx, callback) {\n\t\n\t\n\t    var doc = docInfo.data;\n\t\n\t    var numDone = 0;\n\t    var attachments = Object.keys(doc._attachments);\n\t\n\t    function collectResults() {\n\t      if (numDone === attachments.length) {\n\t        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n\t          isUpdate, resultsIdx, callback);\n\t      }\n\t    }\n\t\n\t    function attachmentSaved() {\n\t      numDone++;\n\t      collectResults();\n\t    }\n\t\n\t    attachments.forEach(function (key) {\n\t      var att = docInfo.data._attachments[key];\n\t      if (!att.stub) {\n\t        var data = att.data;\n\t        delete att.data;\n\t        att.revpos = parseInt(winningRev$$1, 10);\n\t        var digest = att.digest;\n\t        saveAttachment(digest, data, attachmentSaved);\n\t      } else {\n\t        numDone++;\n\t        collectResults();\n\t      }\n\t    });\n\t  }\n\t\n\t  // map seqs to attachment digests, which\n\t  // we will need later during compaction\n\t  function insertAttachmentMappings(docInfo, seq, callback) {\n\t\n\t    var attsAdded = 0;\n\t    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\t\n\t    if (!attsToAdd.length) {\n\t      return callback();\n\t    }\n\t\n\t    function checkDone() {\n\t      if (++attsAdded === attsToAdd.length) {\n\t        callback();\n\t      }\n\t    }\n\t\n\t    function add(att) {\n\t      var digest = docInfo.data._attachments[att].digest;\n\t      var req = attachAndSeqStore.put({\n\t        seq: seq,\n\t        digestSeq: digest + '::' + seq\n\t      });\n\t\n\t      req.onsuccess = checkDone;\n\t      req.onerror = function (e) {\n\t        // this callback is for a constaint error, which we ignore\n\t        // because this docid/rev has already been associated with\n\t        // the digest (e.g. when new_edits == false)\n\t        e.preventDefault(); // avoid transaction abort\n\t        e.stopPropagation(); // avoid transaction onerror\n\t        checkDone();\n\t      };\n\t    }\n\t    for (var i = 0; i < attsToAdd.length; i++) {\n\t      add(attsToAdd[i]); // do in parallel\n\t    }\n\t  }\n\t\n\t  function saveAttachment(digest, data, callback) {\n\t\n\t\n\t    var getKeyReq = attachStore.count(digest);\n\t    getKeyReq.onsuccess = function (e) {\n\t      var count = e.target.result;\n\t      if (count) {\n\t        return callback(); // already exists\n\t      }\n\t      var newAtt = {\n\t        digest: digest,\n\t        body: data\n\t      };\n\t      var putReq = attachStore.put(newAtt);\n\t      putReq.onsuccess = callback;\n\t    };\n\t  }\n\t}\n\t\n\t// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n\t// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n\t// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n\t// we're not processing each document one-at-a-time.\n\tfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\t\n\t  // Bail out of getAll()/getAllKeys() in the following cases:\n\t  // 1) either method is unsupported - we need both\n\t  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n\t  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n\t  //    perhaps they are filtering on a per-doc basis)\n\t  // 3) descending â no real way to do this via getAll()/getAllKeys()\n\t\n\t  var useGetAll = typeof objectStore.getAll === 'function' &&\n\t    typeof objectStore.getAllKeys === 'function' &&\n\t    batchSize > 1 && !descending;\n\t\n\t  var keysBatch;\n\t  var valuesBatch;\n\t  var pseudoCursor;\n\t\n\t  function onGetAll(e) {\n\t    valuesBatch = e.target.result;\n\t    if (keysBatch) {\n\t      onBatch(keysBatch, valuesBatch, pseudoCursor);\n\t    }\n\t  }\n\t\n\t  function onGetAllKeys(e) {\n\t    keysBatch = e.target.result;\n\t    if (valuesBatch) {\n\t      onBatch(keysBatch, valuesBatch, pseudoCursor);\n\t    }\n\t  }\n\t\n\t  function continuePseudoCursor() {\n\t    if (!keysBatch.length) { // no more results\n\t      return onBatch();\n\t    }\n\t    // fetch next batch, exclusive start\n\t    var lastKey = keysBatch[keysBatch.length - 1];\n\t    var newKeyRange;\n\t    if (keyRange && keyRange.upper) {\n\t      try {\n\t        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n\t          true, keyRange.upperOpen);\n\t      } catch (e) {\n\t        if (e.name === \"DataError\" && e.code === 0) {\n\t          return onBatch(); // we're done, startkey and endkey are equal\n\t        }\n\t      }\n\t    } else {\n\t      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n\t    }\n\t    keyRange = newKeyRange;\n\t    keysBatch = null;\n\t    valuesBatch = null;\n\t    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n\t    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n\t  }\n\t\n\t  function onCursor(e) {\n\t    var cursor = e.target.result;\n\t    if (!cursor) { // done\n\t      return onBatch();\n\t    }\n\t    // regular IDBCursor acts like a batch where batch size is always 1\n\t    onBatch([cursor.key], [cursor.value], cursor);\n\t  }\n\t\n\t  if (useGetAll) {\n\t    pseudoCursor = {\"continue\": continuePseudoCursor};\n\t    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n\t    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n\t  } else if (descending) {\n\t    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n\t  } else {\n\t    objectStore.openCursor(keyRange).onsuccess = onCursor;\n\t  }\n\t}\n\t\n\t// simple shim for objectStore.getAll(), falling back to IDBCursor\n\tfunction getAll(objectStore, keyRange, onSuccess) {\n\t  if (typeof objectStore.getAll === 'function') {\n\t    // use native getAll\n\t    objectStore.getAll(keyRange).onsuccess = onSuccess;\n\t    return;\n\t  }\n\t  // fall back to cursors\n\t  var values = [];\n\t\n\t  function onCursor(e) {\n\t    var cursor = e.target.result;\n\t    if (cursor) {\n\t      values.push(cursor.value);\n\t      cursor.continue();\n\t    } else {\n\t      onSuccess({\n\t        target: {\n\t          result: values\n\t        }\n\t      });\n\t    }\n\t  }\n\t\n\t  objectStore.openCursor(keyRange).onsuccess = onCursor;\n\t}\n\t\n\tfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n\t  try {\n\t    if (start && end) {\n\t      if (descending) {\n\t        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n\t      } else {\n\t        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n\t      }\n\t    } else if (start) {\n\t      if (descending) {\n\t        return IDBKeyRange.upperBound(start);\n\t      } else {\n\t        return IDBKeyRange.lowerBound(start);\n\t      }\n\t    } else if (end) {\n\t      if (descending) {\n\t        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n\t      } else {\n\t        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n\t      }\n\t    } else if (key) {\n\t      return IDBKeyRange.only(key);\n\t    }\n\t  } catch (e) {\n\t    return {error: e};\n\t  }\n\t  return null;\n\t}\n\t\n\tfunction idbAllDocs(opts, idb, callback) {\n\t  var start = 'startkey' in opts ? opts.startkey : false;\n\t  var end = 'endkey' in opts ? opts.endkey : false;\n\t  var key = 'key' in opts ? opts.key : false;\n\t  var skip = opts.skip || 0;\n\t  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n\t  var inclusiveEnd = opts.inclusive_end !== false;\n\t\n\t  var keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n\t  var keyRangeError = keyRange && keyRange.error;\n\t  if (keyRangeError && !(keyRangeError.name === \"DataError\" &&\n\t      keyRangeError.code === 0)) {\n\t    // DataError with error code 0 indicates start is less than end, so\n\t    // can just do an empty query. Else need to throw\n\t    return callback(createError(IDB_ERROR,\n\t      keyRangeError.name, keyRangeError.message));\n\t  }\n\t\n\t  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\t\n\t  if (opts.attachments) {\n\t    stores.push(ATTACH_STORE);\n\t  }\n\t  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n\t  if (txnResult.error) {\n\t    return callback(txnResult.error);\n\t  }\n\t  var txn = txnResult.txn;\n\t  txn.oncomplete = onTxnComplete;\n\t  txn.onabort = idbError(callback);\n\t  var docStore = txn.objectStore(DOC_STORE);\n\t  var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t  var metaStore = txn.objectStore(META_STORE);\n\t  var docIdRevIndex = seqStore.index('_doc_id_rev');\n\t  var results = [];\n\t  var docCount;\n\t\n\t  metaStore.get(META_STORE).onsuccess = function (e) {\n\t    docCount = e.target.result.docCount;\n\t  };\n\t\n\t  // if the user specifies include_docs=true, then we don't\n\t  // want to block the main cursor while we're fetching the doc\n\t  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n\t    var key = metadata.id + \"::\" + winningRev$$1;\n\t    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n\t      row.doc = decodeDoc(e.target.result);\n\t      if (opts.conflicts) {\n\t        var conflicts = collectConflicts(metadata);\n\t        if (conflicts.length) {\n\t          row.doc._conflicts = conflicts;\n\t        }\n\t      }\n\t      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n\t    };\n\t  }\n\t\n\t  function allDocsInner(winningRev$$1, metadata) {\n\t    var row = {\n\t      id: metadata.id,\n\t      key: metadata.id,\n\t      value: {\n\t        rev: winningRev$$1\n\t      }\n\t    };\n\t    var deleted = metadata.deleted;\n\t    if (opts.deleted === 'ok') {\n\t      results.push(row);\n\t      // deleted docs are okay with \"keys\" requests\n\t      if (deleted) {\n\t        row.value.deleted = true;\n\t        row.doc = null;\n\t      } else if (opts.include_docs) {\n\t        fetchDocAsynchronously(metadata, row, winningRev$$1);\n\t      }\n\t    } else if (!deleted && skip-- <= 0) {\n\t      results.push(row);\n\t      if (opts.include_docs) {\n\t        fetchDocAsynchronously(metadata, row, winningRev$$1);\n\t      }\n\t    }\n\t  }\n\t\n\t  function processBatch(batchValues) {\n\t    for (var i = 0, len = batchValues.length; i < len; i++) {\n\t      if (results.length === limit) {\n\t        break;\n\t      }\n\t      var batchValue = batchValues[i];\n\t      var metadata = decodeMetadata(batchValue);\n\t      var winningRev$$1 = metadata.winningRev;\n\t      allDocsInner(winningRev$$1, metadata);\n\t    }\n\t  }\n\t\n\t  function onBatch(batchKeys, batchValues, cursor) {\n\t    if (!cursor) {\n\t      return;\n\t    }\n\t    processBatch(batchValues);\n\t    if (results.length < limit) {\n\t      cursor.continue();\n\t    }\n\t  }\n\t\n\t  function onGetAll(e) {\n\t    var values = e.target.result;\n\t    if (opts.descending) {\n\t      values = values.reverse();\n\t    }\n\t    processBatch(values);\n\t  }\n\t\n\t  function onResultsReady() {\n\t    callback(null, {\n\t      total_rows: docCount,\n\t      offset: opts.skip,\n\t      rows: results\n\t    });\n\t  }\n\t\n\t  function onTxnComplete() {\n\t    if (opts.attachments) {\n\t      postProcessAttachments(results, opts.binary).then(onResultsReady);\n\t    } else {\n\t      onResultsReady();\n\t    }\n\t  }\n\t\n\t  // don't bother doing any requests if start > end or limit === 0\n\t  if (keyRangeError || limit === 0) {\n\t    return;\n\t  }\n\t  if (limit === -1) { // just fetch everything\n\t    return getAll(docStore, keyRange, onGetAll);\n\t  }\n\t  // else do a cursor\n\t  // choose a batch size based on the skip, since we'll need to skip that many\n\t  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n\t}\n\t\n\t//\n\t// Blobs are not supported in all versions of IndexedDB, notably\n\t// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n\t//\n\t// Various other blob bugs exist in Chrome v37-42 (inclusive).\n\t// Detecting them is expensive and confusing to users, and Chrome 37-42\n\t// is at very low usage worldwide, so we do a hacky userAgent check instead.\n\t//\n\t// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n\t// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n\t// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n\t//\n\tfunction checkBlobSupport(txn) {\n\t  return new PouchPromise$1(function (resolve) {\n\t    var blob$$1 = createBlob(['']);\n\t    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\t\n\t    req.onsuccess = function () {\n\t      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n\t      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n\t      // MS Edge pretends to be Chrome 42:\n\t      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n\t      resolve(matchedEdge || !matchedChrome ||\n\t        parseInt(matchedChrome[1], 10) >= 43);\n\t    };\n\t\n\t    txn.onabort = function (e) {\n\t      // If the transaction aborts now its due to not being able to\n\t      // write to the database, likely due to the disk being full\n\t      e.preventDefault();\n\t      e.stopPropagation();\n\t      resolve(false);\n\t    };\n\t  }).catch(function () {\n\t    return false; // error, so assume unsupported\n\t  });\n\t}\n\t\n\tfunction countDocs(txn, cb) {\n\t  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n\t  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n\t    cb(e.target.result);\n\t  };\n\t}\n\t\n\t// This task queue ensures that IDB open calls are done in their own tick\n\t// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n\t// before calling the next one. This works around IE/Edge race conditions in IDB.\n\t\n\tvar running = false;\n\tvar queue = [];\n\t\n\tfunction tryCode(fun, err, res, PouchDB) {\n\t  try {\n\t    fun(err, res);\n\t  } catch (err) {\n\t    // Shouldn't happen, but in some odd cases\n\t    // IndexedDB implementations might throw a sync\n\t    // error, in which case this will at least log it.\n\t    PouchDB.emit('error', err);\n\t  }\n\t}\n\t\n\tfunction applyNext() {\n\t  if (running || !queue.length) {\n\t    return;\n\t  }\n\t  running = true;\n\t  queue.shift()();\n\t}\n\t\n\tfunction enqueueTask(action, callback, PouchDB) {\n\t  queue.push(function runAction() {\n\t    action(function runCallback(err, res) {\n\t      tryCode(callback, err, res, PouchDB);\n\t      running = false;\n\t      nextTick(function runNext() {\n\t        applyNext(PouchDB);\n\t      });\n\t    });\n\t  });\n\t  applyNext();\n\t}\n\t\n\tfunction changes(opts, api, dbName, idb) {\n\t  opts = clone(opts);\n\t\n\t  if (opts.continuous) {\n\t    var id = dbName + ':' + uuid();\n\t    changesHandler$$1.addListener(dbName, id, api, opts);\n\t    changesHandler$$1.notify(dbName);\n\t    return {\n\t      cancel: function () {\n\t        changesHandler$$1.removeListener(dbName, id);\n\t      }\n\t    };\n\t  }\n\t\n\t  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\t\n\t  opts.since = opts.since || 0;\n\t  var lastSeq = opts.since;\n\t\n\t  var limit = 'limit' in opts ? opts.limit : -1;\n\t  if (limit === 0) {\n\t    limit = 1; // per CouchDB _changes spec\n\t  }\n\t  var returnDocs;\n\t  if ('return_docs' in opts) {\n\t    returnDocs = opts.return_docs;\n\t  } else if ('returnDocs' in opts) {\n\t    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t    returnDocs = opts.returnDocs;\n\t  } else {\n\t    returnDocs = true;\n\t  }\n\t\n\t  var results = [];\n\t  var numResults = 0;\n\t  var filter = filterChange(opts);\n\t  var docIdsToMetadata = new ExportedMap();\n\t\n\t  var txn;\n\t  var bySeqStore;\n\t  var docStore;\n\t  var docIdRevIndex;\n\t\n\t  function onBatch(batchKeys, batchValues, cursor) {\n\t    if (!cursor || !batchKeys.length) { // done\n\t      return;\n\t    }\n\t\n\t    var winningDocs = new Array(batchKeys.length);\n\t    var metadatas = new Array(batchKeys.length);\n\t\n\t    function processMetadataAndWinningDoc(metadata, winningDoc) {\n\t      var change = opts.processChange(winningDoc, metadata, opts);\n\t      lastSeq = change.seq = metadata.seq;\n\t\n\t      var filtered = filter(change);\n\t      if (typeof filtered === 'object') { // anything but true/false indicates error\n\t        return opts.complete(filtered);\n\t      }\n\t\n\t      if (filtered) {\n\t        numResults++;\n\t        if (returnDocs) {\n\t          results.push(change);\n\t        }\n\t        // process the attachment immediately\n\t        // for the benefit of live listeners\n\t        if (opts.attachments && opts.include_docs) {\n\t          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n\t            postProcessAttachments([change], opts.binary).then(function () {\n\t              opts.onChange(change);\n\t            });\n\t          });\n\t        } else {\n\t          opts.onChange(change);\n\t        }\n\t      }\n\t    }\n\t\n\t    function onBatchDone() {\n\t      for (var i = 0, len = winningDocs.length; i < len; i++) {\n\t        if (numResults === limit) {\n\t          break;\n\t        }\n\t        var winningDoc = winningDocs[i];\n\t        if (!winningDoc) {\n\t          continue;\n\t        }\n\t        var metadata = metadatas[i];\n\t        processMetadataAndWinningDoc(metadata, winningDoc);\n\t      }\n\t\n\t      if (numResults !== limit) {\n\t        cursor.continue();\n\t      }\n\t    }\n\t\n\t    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n\t    // them all only once all data has been collected. This is done in parallel\n\t    // because it's faster than doing it one-at-a-time.\n\t    var numDone = 0;\n\t    batchValues.forEach(function (value, i) {\n\t      var doc = decodeDoc(value);\n\t      var seq = batchKeys[i];\n\t      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n\t        metadatas[i] = metadata;\n\t        winningDocs[i] = winningDoc;\n\t        if (++numDone === batchKeys.length) {\n\t          onBatchDone();\n\t        }\n\t      });\n\t    });\n\t  }\n\t\n\t  function onGetMetadata(doc, seq, metadata, cb) {\n\t    if (metadata.seq !== seq) {\n\t      // some other seq is later\n\t      return cb();\n\t    }\n\t\n\t    if (metadata.winningRev === doc._rev) {\n\t      // this is the winning doc\n\t      return cb(metadata, doc);\n\t    }\n\t\n\t    // fetch winning doc in separate request\n\t    var docIdRev = doc._id + '::' + metadata.winningRev;\n\t    var req = docIdRevIndex.get(docIdRev);\n\t    req.onsuccess = function (e) {\n\t      cb(metadata, decodeDoc(e.target.result));\n\t    };\n\t  }\n\t\n\t  function fetchWinningDocAndMetadata(doc, seq, cb) {\n\t    if (docIds && !docIds.has(doc._id)) {\n\t      return cb();\n\t    }\n\t\n\t    var metadata = docIdsToMetadata.get(doc._id);\n\t    if (metadata) { // cached\n\t      return onGetMetadata(doc, seq, metadata, cb);\n\t    }\n\t    // metadata not cached, have to go fetch it\n\t    docStore.get(doc._id).onsuccess = function (e) {\n\t      metadata = decodeMetadata(e.target.result);\n\t      docIdsToMetadata.set(doc._id, metadata);\n\t      onGetMetadata(doc, seq, metadata, cb);\n\t    };\n\t  }\n\t\n\t  function finish() {\n\t    opts.complete(null, {\n\t      results: results,\n\t      last_seq: lastSeq\n\t    });\n\t  }\n\t\n\t  function onTxnComplete() {\n\t    if (!opts.continuous && opts.attachments) {\n\t      // cannot guarantee that postProcessing was already done,\n\t      // so do it again\n\t      postProcessAttachments(results).then(finish);\n\t    } else {\n\t      finish();\n\t    }\n\t  }\n\t\n\t  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n\t  if (opts.attachments) {\n\t    objectStores.push(ATTACH_STORE);\n\t  }\n\t  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n\t  if (txnResult.error) {\n\t    return opts.complete(txnResult.error);\n\t  }\n\t  txn = txnResult.txn;\n\t  txn.onabort = idbError(opts.complete);\n\t  txn.oncomplete = onTxnComplete;\n\t\n\t  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t  docStore = txn.objectStore(DOC_STORE);\n\t  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\t\n\t  var keyRange = (opts.since && !opts.descending) ?\n\t    IDBKeyRange.lowerBound(opts.since, true) : null;\n\t\n\t  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n\t}\n\t\n\tvar cachedDBs = new ExportedMap();\n\tvar blobSupportPromise;\n\tvar openReqList = new ExportedMap();\n\t\n\tfunction IdbPouch(opts, callback) {\n\t  var api = this;\n\t\n\t  enqueueTask(function (thisCallback) {\n\t    init(api, opts, thisCallback);\n\t  }, callback, api.constructor);\n\t}\n\t\n\tfunction init(api, opts, callback) {\n\t\n\t  var dbName = opts.name;\n\t\n\t  var idb = null;\n\t  api._meta = null;\n\t\n\t  // called when creating a fresh new database\n\t  function createSchema(db) {\n\t    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n\t    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n\t      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n\t    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n\t    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n\t    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\t\n\t    // added in v2\n\t    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\t\n\t    // added in v3\n\t    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\t\n\t    // added in v4\n\t    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n\t      {autoIncrement: true});\n\t    attAndSeqStore.createIndex('seq', 'seq');\n\t    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n\t  }\n\t\n\t  // migration to version 2\n\t  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n\t  // store local docs in the main doc-store, but whaddyagonnado\n\t  function addDeletedOrLocalIndex(txn, callback) {\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\t\n\t    docStore.openCursor().onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      if (cursor) {\n\t        var metadata = cursor.value;\n\t        var deleted = isDeleted(metadata);\n\t        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n\t        docStore.put(metadata);\n\t        cursor.continue();\n\t      } else {\n\t        callback();\n\t      }\n\t    };\n\t  }\n\t\n\t  // migration to version 3 (part 1)\n\t  function createLocalStoreSchema(db) {\n\t    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n\t      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n\t  }\n\t\n\t  // migration to version 3 (part 2)\n\t  function migrateLocalStore(txn, cb) {\n\t    var localStore = txn.objectStore(LOCAL_STORE);\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t\n\t    var cursor = docStore.openCursor();\n\t    cursor.onsuccess = function (event) {\n\t      var cursor = event.target.result;\n\t      if (cursor) {\n\t        var metadata = cursor.value;\n\t        var docId = metadata.id;\n\t        var local = isLocalId(docId);\n\t        var rev = winningRev(metadata);\n\t        if (local) {\n\t          var docIdRev = docId + \"::\" + rev;\n\t          // remove all seq entries\n\t          // associated with this docId\n\t          var start = docId + \"::\";\n\t          var end = docId + \"::~\";\n\t          var index = seqStore.index('_doc_id_rev');\n\t          var range = IDBKeyRange.bound(start, end, false, false);\n\t          var seqCursor = index.openCursor(range);\n\t          seqCursor.onsuccess = function (e) {\n\t            seqCursor = e.target.result;\n\t            if (!seqCursor) {\n\t              // done\n\t              docStore.delete(cursor.primaryKey);\n\t              cursor.continue();\n\t            } else {\n\t              var data = seqCursor.value;\n\t              if (data._doc_id_rev === docIdRev) {\n\t                localStore.put(data);\n\t              }\n\t              seqStore.delete(seqCursor.primaryKey);\n\t              seqCursor.continue();\n\t            }\n\t          };\n\t        } else {\n\t          cursor.continue();\n\t        }\n\t      } else if (cb) {\n\t        cb();\n\t      }\n\t    };\n\t  }\n\t\n\t  // migration to version 4 (part 1)\n\t  function addAttachAndSeqStore(db) {\n\t    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n\t      {autoIncrement: true});\n\t    attAndSeqStore.createIndex('seq', 'seq');\n\t    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n\t  }\n\t\n\t  // migration to version 4 (part 2)\n\t  function migrateAttsAndSeqs(txn, callback) {\n\t    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var attStore = txn.objectStore(ATTACH_STORE);\n\t    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\t\n\t    // need to actually populate the table. this is the expensive part,\n\t    // so as an optimization, check first that this database even\n\t    // contains attachments\n\t    var req = attStore.count();\n\t    req.onsuccess = function (e) {\n\t      var count = e.target.result;\n\t      if (!count) {\n\t        return callback(); // done\n\t      }\n\t\n\t      seqStore.openCursor().onsuccess = function (e) {\n\t        var cursor = e.target.result;\n\t        if (!cursor) {\n\t          return callback(); // done\n\t        }\n\t        var doc = cursor.value;\n\t        var seq = cursor.primaryKey;\n\t        var atts = Object.keys(doc._attachments || {});\n\t        var digestMap = {};\n\t        for (var j = 0; j < atts.length; j++) {\n\t          var att = doc._attachments[atts[j]];\n\t          digestMap[att.digest] = true; // uniq digests, just in case\n\t        }\n\t        var digests = Object.keys(digestMap);\n\t        for (j = 0; j < digests.length; j++) {\n\t          var digest = digests[j];\n\t          attAndSeqStore.put({\n\t            seq: seq,\n\t            digestSeq: digest + '::' + seq\n\t          });\n\t        }\n\t        cursor.continue();\n\t      };\n\t    };\n\t  }\n\t\n\t  // migration to version 5\n\t  // Instead of relying on on-the-fly migration of metadata,\n\t  // this brings the doc-store to its modern form:\n\t  // - metadata.winningrev\n\t  // - metadata.seq\n\t  // - stringify the metadata when storing it\n\t  function migrateMetadata(txn) {\n\t\n\t    function decodeMetadataCompat(storedObject) {\n\t      if (!storedObject.data) {\n\t        // old format, when we didn't store it stringified\n\t        storedObject.deleted = storedObject.deletedOrLocal === '1';\n\t        return storedObject;\n\t      }\n\t      return decodeMetadata(storedObject);\n\t    }\n\t\n\t    // ensure that every metadata has a winningRev and seq,\n\t    // which was previously created on-the-fly but better to migrate\n\t    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t    var cursor = docStore.openCursor();\n\t    cursor.onsuccess = function (e) {\n\t      var cursor = e.target.result;\n\t      if (!cursor) {\n\t        return; // done\n\t      }\n\t      var metadata = decodeMetadataCompat(cursor.value);\n\t\n\t      metadata.winningRev = metadata.winningRev ||\n\t        winningRev(metadata);\n\t\n\t      function fetchMetadataSeq() {\n\t        // metadata.seq was added post-3.2.0, so if it's missing,\n\t        // we need to fetch it manually\n\t        var start = metadata.id + '::';\n\t        var end = metadata.id + '::\\uffff';\n\t        var req = bySeqStore.index('_doc_id_rev').openCursor(\n\t          IDBKeyRange.bound(start, end));\n\t\n\t        var metadataSeq = 0;\n\t        req.onsuccess = function (e) {\n\t          var cursor = e.target.result;\n\t          if (!cursor) {\n\t            metadata.seq = metadataSeq;\n\t            return onGetMetadataSeq();\n\t          }\n\t          var seq = cursor.primaryKey;\n\t          if (seq > metadataSeq) {\n\t            metadataSeq = seq;\n\t          }\n\t          cursor.continue();\n\t        };\n\t      }\n\t\n\t      function onGetMetadataSeq() {\n\t        var metadataToStore = encodeMetadata(metadata,\n\t          metadata.winningRev, metadata.deleted);\n\t\n\t        var req = docStore.put(metadataToStore);\n\t        req.onsuccess = function () {\n\t          cursor.continue();\n\t        };\n\t      }\n\t\n\t      if (metadata.seq) {\n\t        return onGetMetadataSeq();\n\t      }\n\t\n\t      fetchMetadataSeq();\n\t    };\n\t\n\t  }\n\t\n\t  api.type = function () {\n\t    return 'idb';\n\t  };\n\t\n\t  api._id = toPromise(function (callback) {\n\t    callback(null, api._meta.instanceId);\n\t  });\n\t\n\t  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n\t    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n\t  };\n\t\n\t  // First we look up the metadata in the ids database, then we fetch the\n\t  // current revision(s) from the by sequence store\n\t  api._get = function idb_get(id, opts, callback) {\n\t    var doc;\n\t    var metadata;\n\t    var err;\n\t    var txn = opts.ctx;\n\t    if (!txn) {\n\t      var txnResult = openTransactionSafely(idb,\n\t        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t    }\n\t\n\t    function finish() {\n\t      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n\t    }\n\t\n\t    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n\t      metadata = decodeMetadata(e.target.result);\n\t      // we can determine the result here if:\n\t      // 1. there is no such document\n\t      // 2. the document is deleted and we don't ask about specific rev\n\t      // When we ask with opts.rev we expect the answer to be either\n\t      // doc (possibly with _deleted=true) or missing error\n\t      if (!metadata) {\n\t        err = createError(MISSING_DOC, 'missing');\n\t        return finish();\n\t      }\n\t\n\t      var rev;\n\t      if(!opts.rev) {\n\t        rev = metadata.winningRev;\n\t        var deleted = isDeleted(metadata);\n\t        if (deleted) {\n\t          err = createError(MISSING_DOC, \"deleted\");\n\t          return finish();\n\t        }\n\t      } else {\n\t        rev = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n\t      }\n\t\n\t      var objectStore = txn.objectStore(BY_SEQ_STORE);\n\t      var key = metadata.id + '::' + rev;\n\t\n\t      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n\t        doc = e.target.result;\n\t        if (doc) {\n\t          doc = decodeDoc(doc);\n\t        }\n\t        if (!doc) {\n\t          err = createError(MISSING_DOC, 'missing');\n\t          return finish();\n\t        }\n\t        finish();\n\t      };\n\t    };\n\t  };\n\t\n\t  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n\t    var txn;\n\t    if (opts.ctx) {\n\t      txn = opts.ctx;\n\t    } else {\n\t      var txnResult = openTransactionSafely(idb,\n\t        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      txn = txnResult.txn;\n\t    }\n\t    var digest = attachment.digest;\n\t    var type = attachment.content_type;\n\t\n\t    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n\t      var body = e.target.result.body;\n\t      readBlobData(body, type, opts.binary, function (blobData) {\n\t        callback(null, blobData);\n\t      });\n\t    };\n\t  };\n\t\n\t  api._info = function idb_info(callback) {\n\t    var updateSeq;\n\t    var docCount;\n\t\n\t    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n\t      docCount = e.target.result.docCount;\n\t    };\n\t    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n\t      var cursor = e.target.result;\n\t      updateSeq = cursor ? cursor.key : 0;\n\t    };\n\t\n\t    txn.oncomplete = function () {\n\t      callback(null, {\n\t        doc_count: docCount,\n\t        update_seq: updateSeq,\n\t        // for debugging\n\t        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n\t      });\n\t    };\n\t  };\n\t\n\t  api._allDocs = function idb_allDocs(opts, callback) {\n\t    idbAllDocs(opts, idb, callback);\n\t  };\n\t\n\t  api._changes = function idbChanges(opts) {\n\t    changes(opts, api, dbName, idb);\n\t  };\n\t\n\t  api._close = function (callback) {\n\t    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n\t    // \"Returns immediately and closes the connection in a separate thread...\"\n\t    idb.close();\n\t    cachedDBs.delete(dbName);\n\t    callback();\n\t  };\n\t\n\t  api._getRevisionTree = function (docId, callback) {\n\t    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t    var req = txn.objectStore(DOC_STORE).get(docId);\n\t    req.onsuccess = function (event) {\n\t      var doc = decodeMetadata(event.target.result);\n\t      if (!doc) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        callback(null, doc.rev_tree);\n\t      }\n\t    };\n\t  };\n\t\n\t  // This function removes revisions of document docId\n\t  // which are listed in revs and sets this document\n\t  // revision to to rev_tree\n\t  api._doCompaction = function (docId, revs, callback) {\n\t    var stores = [\n\t      DOC_STORE,\n\t      BY_SEQ_STORE,\n\t      ATTACH_STORE,\n\t      ATTACH_AND_SEQ_STORE\n\t    ];\n\t    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var txn = txnResult.txn;\n\t\n\t    var docStore = txn.objectStore(DOC_STORE);\n\t\n\t    docStore.get(docId).onsuccess = function (event) {\n\t      var metadata = decodeMetadata(event.target.result);\n\t      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                                         revHash, ctx, opts) {\n\t        var rev = pos + '-' + revHash;\n\t        if (revs.indexOf(rev) !== -1) {\n\t          opts.status = 'missing';\n\t        }\n\t      });\n\t      compactRevs(revs, docId, txn);\n\t      var winningRev$$1 = metadata.winningRev;\n\t      var deleted = metadata.deleted;\n\t      txn.objectStore(DOC_STORE).put(\n\t        encodeMetadata(metadata, winningRev$$1, deleted));\n\t    };\n\t    txn.onabort = idbError(callback);\n\t    txn.oncomplete = function () {\n\t      callback();\n\t    };\n\t  };\n\t\n\t\n\t  api._getLocal = function (id, callback) {\n\t    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n\t    if (txnResult.error) {\n\t      return callback(txnResult.error);\n\t    }\n\t    var tx = txnResult.txn;\n\t    var req = tx.objectStore(LOCAL_STORE).get(id);\n\t\n\t    req.onerror = idbError(callback);\n\t    req.onsuccess = function (e) {\n\t      var doc = e.target.result;\n\t      if (!doc) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        delete doc['_doc_id_rev']; // for backwards compat\n\t        callback(null, doc);\n\t      }\n\t    };\n\t  };\n\t\n\t  api._putLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    delete doc._revisions; // ignore this, trust the rev\n\t    var oldRev = doc._rev;\n\t    var id = doc._id;\n\t    if (!oldRev) {\n\t      doc._rev = '0-1';\n\t    } else {\n\t      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n\t    }\n\t\n\t    var tx = opts.ctx;\n\t    var ret;\n\t    if (!tx) {\n\t      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      tx = txnResult.txn;\n\t      tx.onerror = idbError(callback);\n\t      tx.oncomplete = function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t\n\t    var oStore = tx.objectStore(LOCAL_STORE);\n\t    var req;\n\t    if (oldRev) {\n\t      req = oStore.get(id);\n\t      req.onsuccess = function (e) {\n\t        var oldDoc = e.target.result;\n\t        if (!oldDoc || oldDoc._rev !== oldRev) {\n\t          callback(createError(REV_CONFLICT));\n\t        } else { // update\n\t          var req = oStore.put(doc);\n\t          req.onsuccess = function () {\n\t            ret = {ok: true, id: doc._id, rev: doc._rev};\n\t            if (opts.ctx) { // return immediately\n\t              callback(null, ret);\n\t            }\n\t          };\n\t        }\n\t      };\n\t    } else { // new doc\n\t      req = oStore.add(doc);\n\t      req.onerror = function (e) {\n\t        // constraint error, already exists\n\t        callback(createError(REV_CONFLICT));\n\t        e.preventDefault(); // avoid transaction abort\n\t        e.stopPropagation(); // avoid transaction onerror\n\t      };\n\t      req.onsuccess = function () {\n\t        ret = {ok: true, id: doc._id, rev: doc._rev};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t  };\n\t\n\t  api._removeLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var tx = opts.ctx;\n\t    if (!tx) {\n\t      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n\t      if (txnResult.error) {\n\t        return callback(txnResult.error);\n\t      }\n\t      tx = txnResult.txn;\n\t      tx.oncomplete = function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      };\n\t    }\n\t    var ret;\n\t    var id = doc._id;\n\t    var oStore = tx.objectStore(LOCAL_STORE);\n\t    var req = oStore.get(id);\n\t\n\t    req.onerror = idbError(callback);\n\t    req.onsuccess = function (e) {\n\t      var oldDoc = e.target.result;\n\t      if (!oldDoc || oldDoc._rev !== doc._rev) {\n\t        callback(createError(MISSING_DOC));\n\t      } else {\n\t        oStore.delete(id);\n\t        ret = {ok: true, id: id, rev: '0-0'};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  api._destroy = function (opts, callback) {\n\t    changesHandler$$1.removeAllListeners(dbName);\n\t\n\t    //Close open request for \"dbName\" database to fix ie delay.\n\t    var openReq = openReqList.get(dbName);\n\t    if (openReq && openReq.result) {\n\t      openReq.result.close();\n\t      cachedDBs.delete(dbName);\n\t    }\n\t    var req = indexedDB.deleteDatabase(dbName);\n\t\n\t    req.onsuccess = function () {\n\t      //Remove open request from the list.\n\t      openReqList.delete(dbName);\n\t      if (hasLocalStorage() && (dbName in localStorage)) {\n\t        delete localStorage[dbName];\n\t      }\n\t      callback(null, { 'ok': true });\n\t    };\n\t\n\t    req.onerror = idbError(callback);\n\t  };\n\t\n\t  var cached = cachedDBs.get(dbName);\n\t\n\t  if (cached) {\n\t    idb = cached.idb;\n\t    api._meta = cached.global;\n\t    return nextTick(function () {\n\t      callback(null, api);\n\t    });\n\t  }\n\t\n\t  var req;\n\t  if (opts.storage) {\n\t    req = tryStorageOption(dbName, opts.storage);\n\t  } else {\n\t    req = indexedDB.open(dbName, ADAPTER_VERSION);\n\t  }\n\t\n\t  openReqList.set(dbName, req);\n\t\n\t  req.onupgradeneeded = function (e) {\n\t    var db = e.target.result;\n\t    if (e.oldVersion < 1) {\n\t      return createSchema(db); // new db, initial schema\n\t    }\n\t    // do migrations\n\t\n\t    var txn = e.currentTarget.transaction;\n\t    // these migrations have to be done in this function, before\n\t    // control is returned to the event loop, because IndexedDB\n\t\n\t    if (e.oldVersion < 3) {\n\t      createLocalStoreSchema(db); // v2 -> v3\n\t    }\n\t    if (e.oldVersion < 4) {\n\t      addAttachAndSeqStore(db); // v3 -> v4\n\t    }\n\t\n\t    var migrations = [\n\t      addDeletedOrLocalIndex, // v1 -> v2\n\t      migrateLocalStore,      // v2 -> v3\n\t      migrateAttsAndSeqs,     // v3 -> v4\n\t      migrateMetadata         // v4 -> v5\n\t    ];\n\t\n\t    var i = e.oldVersion;\n\t\n\t    function next() {\n\t      var migration = migrations[i - 1];\n\t      i++;\n\t      if (migration) {\n\t        migration(txn, next);\n\t      }\n\t    }\n\t\n\t    next();\n\t  };\n\t\n\t  req.onsuccess = function (e) {\n\t\n\t    idb = e.target.result;\n\t\n\t    idb.onversionchange = function () {\n\t      idb.close();\n\t      cachedDBs.delete(dbName);\n\t    };\n\t\n\t    idb.onabort = function (e) {\n\t      guardedConsole('error', 'Database has a global failure', e.target.error);\n\t      idb.close();\n\t      cachedDBs.delete(dbName);\n\t    };\n\t\n\t    // Do a few setup operations (in parallel as much as possible):\n\t    // 1. Fetch meta doc\n\t    // 2. Check blob support\n\t    // 3. Calculate docCount\n\t    // 4. Generate an instanceId if necessary\n\t    // 5. Store docCount and instanceId on meta doc\n\t\n\t    var txn = idb.transaction([\n\t      META_STORE,\n\t      DETECT_BLOB_SUPPORT_STORE,\n\t      DOC_STORE\n\t    ], 'readwrite');\n\t\n\t    var storedMetaDoc = false;\n\t    var metaDoc;\n\t    var docCount;\n\t    var blobSupport;\n\t    var instanceId;\n\t\n\t    function completeSetup() {\n\t      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n\t        return;\n\t      }\n\t      api._meta = {\n\t        name: dbName,\n\t        instanceId: instanceId,\n\t        blobSupport: blobSupport\n\t      };\n\t\n\t      cachedDBs.set(dbName, {\n\t        idb: idb,\n\t        global: api._meta\n\t      });\n\t      callback(null, api);\n\t    }\n\t\n\t    function storeMetaDocIfReady() {\n\t      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n\t        return;\n\t      }\n\t      var instanceKey = dbName + '_id';\n\t      if (instanceKey in metaDoc) {\n\t        instanceId = metaDoc[instanceKey];\n\t      } else {\n\t        metaDoc[instanceKey] = instanceId = uuid();\n\t      }\n\t      metaDoc.docCount = docCount;\n\t      txn.objectStore(META_STORE).put(metaDoc);\n\t    }\n\t\n\t    //\n\t    // fetch or generate the instanceId\n\t    //\n\t    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n\t      metaDoc = e.target.result || { id: META_STORE };\n\t      storeMetaDocIfReady();\n\t    };\n\t\n\t    //\n\t    // countDocs\n\t    //\n\t    countDocs(txn, function (count) {\n\t      docCount = count;\n\t      storeMetaDocIfReady();\n\t    });\n\t\n\t    //\n\t    // check blob support\n\t    //\n\t    if (!blobSupportPromise) {\n\t      // make sure blob support is only checked once\n\t      blobSupportPromise = checkBlobSupport(txn);\n\t    }\n\t\n\t    blobSupportPromise.then(function (val) {\n\t      blobSupport = val;\n\t      completeSetup();\n\t    });\n\t\n\t    // only when the metadata put transaction has completed,\n\t    // consider the setup done\n\t    txn.oncomplete = function () {\n\t      storedMetaDoc = true;\n\t      completeSetup();\n\t    };\n\t  };\n\t\n\t  req.onerror = function () {\n\t    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n\t    guardedConsole('error', msg);\n\t    callback(createError(IDB_ERROR, msg));\n\t  };\n\t}\n\t\n\tIdbPouch.valid = function () {\n\t  // Issue #2533, we finally gave up on doing bug\n\t  // detection instead of browser sniffing. Safari brought us\n\t  // to our knees.\n\t  var isSafari = typeof openDatabase !== 'undefined' &&\n\t    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n\t    !/Chrome/.test(navigator.userAgent) &&\n\t    !/BlackBerry/.test(navigator.platform);\n\t\n\t  // some outdated implementations of IDB that appear on Samsung\n\t  // and HTC Android devices <4.4 are missing IDBKeyRange\n\t  return !isSafari && typeof indexedDB !== 'undefined' &&\n\t    typeof IDBKeyRange !== 'undefined';\n\t};\n\t\n\tfunction tryStorageOption(dbName, storage) {\n\t  try { // option only available in Firefox 26+\n\t    return indexedDB.open(dbName, {\n\t      version: ADAPTER_VERSION,\n\t      storage: storage\n\t    });\n\t  } catch(err) {\n\t      return indexedDB.open(dbName, ADAPTER_VERSION);\n\t  }\n\t}\n\t\n\tvar IDBPouch = function (PouchDB) {\n\t  PouchDB.adapter('idb', IdbPouch, true);\n\t};\n\t\n\t//\n\t// Parsing hex strings. Yeah.\n\t//\n\t// So basically we need this because of a bug in WebSQL:\n\t// https://code.google.com/p/chromium/issues/detail?id=422690\n\t// https://bugs.webkit.org/show_bug.cgi?id=137637\n\t//\n\t// UTF-8 and UTF-16 are provided as separate functions\n\t// for meager performance improvements\n\t//\n\t\n\tfunction decodeUtf8(str) {\n\t  return decodeURIComponent(escape(str));\n\t}\n\t\n\tfunction hexToInt(charCode) {\n\t  // '0'-'9' is 48-57\n\t  // 'A'-'F' is 65-70\n\t  // SQLite will only give us uppercase hex\n\t  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n\t}\n\t\n\t\n\t// Example:\n\t// pragma encoding=utf8;\n\t// select hex('A');\n\t// returns '41'\n\tfunction parseHexUtf8(str, start, end) {\n\t  var result = '';\n\t  while (start < end) {\n\t    result += String.fromCharCode(\n\t      (hexToInt(str.charCodeAt(start++)) << 4) |\n\t        hexToInt(str.charCodeAt(start++)));\n\t  }\n\t  return result;\n\t}\n\t\n\t// Example:\n\t// pragma encoding=utf16;\n\t// select hex('A');\n\t// returns '4100'\n\t// notice that the 00 comes after the 41 (i.e. it's swizzled)\n\tfunction parseHexUtf16(str, start, end) {\n\t  var result = '';\n\t  while (start < end) {\n\t    // UTF-16, so swizzle the bytes\n\t    result += String.fromCharCode(\n\t      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n\t        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n\t        (hexToInt(str.charCodeAt(start)) << 4) |\n\t        hexToInt(str.charCodeAt(start + 1)));\n\t    start += 4;\n\t  }\n\t  return result;\n\t}\n\t\n\tfunction parseHexString(str, encoding) {\n\t  if (encoding === 'UTF-8') {\n\t    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n\t  } else {\n\t    return parseHexUtf16(str, 0, str.length);\n\t  }\n\t}\n\t\n\tfunction quote(str) {\n\t  return \"'\" + str + \"'\";\n\t}\n\t\n\tvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\t\n\t// The object stores created for each database\n\t// DOC_STORE stores the document meta data, its revision history and state\n\tvar DOC_STORE$1 = quote('document-store');\n\t// BY_SEQ_STORE stores a particular version of a document, keyed by its\n\t// sequence id\n\tvar BY_SEQ_STORE$1 = quote('by-sequence');\n\t// Where we store attachments\n\tvar ATTACH_STORE$1 = quote('attach-store');\n\tvar LOCAL_STORE$1 = quote('local-store');\n\tvar META_STORE$1 = quote('metadata-store');\n\t// where we store many-to-many relations between attachment\n\t// digests and seqs\n\tvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\t\n\t// escapeBlob and unescapeBlob are workarounds for a websql bug:\n\t// https://code.google.com/p/chromium/issues/detail?id=422690\n\t// https://bugs.webkit.org/show_bug.cgi?id=137637\n\t// The goal is to never actually insert the \\u0000 character\n\t// in the database.\n\tfunction escapeBlob(str) {\n\t  return str\n\t    .replace(/\\u0002/g, '\\u0002\\u0002')\n\t    .replace(/\\u0001/g, '\\u0001\\u0002')\n\t    .replace(/\\u0000/g, '\\u0001\\u0001');\n\t}\n\t\n\tfunction unescapeBlob(str) {\n\t  return str\n\t    .replace(/\\u0001\\u0001/g, '\\u0000')\n\t    .replace(/\\u0001\\u0002/g, '\\u0001')\n\t    .replace(/\\u0002\\u0002/g, '\\u0002');\n\t}\n\t\n\tfunction stringifyDoc(doc) {\n\t  // don't bother storing the id/rev. it uses lots of space,\n\t  // in persistent map/reduce especially\n\t  delete doc._id;\n\t  delete doc._rev;\n\t  return JSON.stringify(doc);\n\t}\n\t\n\tfunction unstringifyDoc(doc, id, rev) {\n\t  doc = JSON.parse(doc);\n\t  doc._id = id;\n\t  doc._rev = rev;\n\t  return doc;\n\t}\n\t\n\t// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\n\tfunction qMarks(num) {\n\t  var s = '(';\n\t  while (num--) {\n\t    s += '?';\n\t    if (num) {\n\t      s += ',';\n\t    }\n\t  }\n\t  return s + ')';\n\t}\n\t\n\tfunction select(selector, table, joiner, where, orderBy) {\n\t  return 'SELECT ' + selector + ' FROM ' +\n\t    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n\t    (joiner ? (' ON ' + joiner) : '') +\n\t    (where ? (' WHERE ' +\n\t    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n\t    (orderBy ? (' ORDER BY ' + orderBy) : '');\n\t}\n\t\n\tfunction compactRevs$1(revs, docId, tx) {\n\t\n\t  if (!revs.length) {\n\t    return;\n\t  }\n\t\n\t  var numDone = 0;\n\t  var seqs = [];\n\t\n\t  function checkDone() {\n\t    if (++numDone === revs.length) { // done\n\t      deleteOrphans();\n\t    }\n\t  }\n\t\n\t  function deleteOrphans() {\n\t    // find orphaned attachment digests\n\t\n\t    if (!seqs.length) {\n\t      return;\n\t    }\n\t\n\t    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n\t      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\t\n\t    tx.executeSql(sql, seqs, function (tx, res) {\n\t\n\t      var digestsToCheck = [];\n\t      for (var i = 0; i < res.rows.length; i++) {\n\t        digestsToCheck.push(res.rows.item(i).digest);\n\t      }\n\t      if (!digestsToCheck.length) {\n\t        return;\n\t      }\n\t\n\t      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n\t        ' WHERE seq IN (' +\n\t        seqs.map(function () { return '?'; }).join(',') +\n\t        ')';\n\t      tx.executeSql(sql, seqs, function (tx) {\n\t\n\t        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n\t          ' WHERE digest IN (' +\n\t          digestsToCheck.map(function () { return '?'; }).join(',') +\n\t          ')';\n\t        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n\t          var nonOrphanedDigests = new ExportedSet();\n\t          for (var i = 0; i < res.rows.length; i++) {\n\t            nonOrphanedDigests.add(res.rows.item(i).digest);\n\t          }\n\t          digestsToCheck.forEach(function (digest) {\n\t            if (nonOrphanedDigests.has(digest)) {\n\t              return;\n\t            }\n\t            tx.executeSql(\n\t              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n\t              [digest]);\n\t            tx.executeSql(\n\t              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // update by-seq and attach stores in parallel\n\t  revs.forEach(function (rev) {\n\t    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n\t      ' WHERE doc_id=? AND rev=?';\n\t\n\t    tx.executeSql(sql, [docId, rev], function (tx, res) {\n\t      if (!res.rows.length) { // already deleted\n\t        return checkDone();\n\t      }\n\t      var seq = res.rows.item(0).seq;\n\t      seqs.push(seq);\n\t\n\t      tx.executeSql(\n\t        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n\t    });\n\t  });\n\t}\n\t\n\tfunction websqlError(callback) {\n\t  return function (event) {\n\t    guardedConsole('error', 'WebSQL threw an error', event);\n\t    // event may actually be a SQLError object, so report is as such\n\t    var errorNameMatch = event && event.constructor.toString()\n\t        .match(/function ([^\\(]+)/);\n\t    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n\t    var errorReason = event.target || event.message;\n\t    callback(createError(WSQ_ERROR, errorReason, errorName));\n\t  };\n\t}\n\t\n\tfunction getSize(opts) {\n\t  if ('size' in opts) {\n\t    // triggers immediate popup in iOS, fixes #2347\n\t    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n\t    return opts.size * 1000000;\n\t  }\n\t  // In iOS, doesn't matter as long as it's <= 5000000.\n\t  // Except that if you request too much, our tests fail\n\t  // because of the native \"do you accept?\" popup.\n\t  // In Android <=4.3, this value is actually used as an\n\t  // honest-to-god ceiling for data, so we need to\n\t  // set it to a decently high number.\n\t  var isAndroid = typeof navigator !== 'undefined' &&\n\t    /Android/.test(navigator.userAgent);\n\t  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n\t}\n\t\n\tfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n\t  var newEdits = opts.new_edits;\n\t  var userDocs = req.docs;\n\t\n\t  // Parse the docs, give them a sequence number for the result\n\t  var docInfos = userDocs.map(function (doc) {\n\t    if (doc._id && isLocalId(doc._id)) {\n\t      return doc;\n\t    }\n\t    var newDoc = parseDoc(doc, newEdits);\n\t    return newDoc;\n\t  });\n\t\n\t  var docInfoErrors = docInfos.filter(function (docInfo) {\n\t    return docInfo.error;\n\t  });\n\t  if (docInfoErrors.length) {\n\t    return callback(docInfoErrors[0]);\n\t  }\n\t\n\t  var tx;\n\t  var results = new Array(docInfos.length);\n\t  var fetchedDocs = new ExportedMap();\n\t\n\t  var preconditionErrored;\n\t  function complete() {\n\t    if (preconditionErrored) {\n\t      return callback(preconditionErrored);\n\t    }\n\t    websqlChanges.notify(api._name);\n\t    callback(null, results);\n\t  }\n\t\n\t  function verifyAttachment(digest, callback) {\n\t    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n\t      ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      if (result.rows.item(0).cnt === 0) {\n\t        var err = createError(MISSING_STUB,\n\t          'unknown stub attachment with digest ' +\n\t          digest);\n\t        callback(err);\n\t      } else {\n\t        callback();\n\t      }\n\t    });\n\t  }\n\t\n\t  function verifyAttachments(finish) {\n\t    var digests = [];\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo.data && docInfo.data._attachments) {\n\t        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n\t          var att = docInfo.data._attachments[filename];\n\t          if (att.stub) {\n\t            digests.push(att.digest);\n\t          }\n\t        });\n\t      }\n\t    });\n\t    if (!digests.length) {\n\t      return finish();\n\t    }\n\t    var numDone = 0;\n\t    var err;\n\t\n\t    function checkDone() {\n\t      if (++numDone === digests.length) {\n\t        finish(err);\n\t      }\n\t    }\n\t    digests.forEach(function (digest) {\n\t      verifyAttachment(digest, function (attErr) {\n\t        if (attErr && !err) {\n\t          err = attErr;\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n\t                    isUpdate, delta, resultsIdx, callback) {\n\t\n\t    function finish() {\n\t      var data = docInfo.data;\n\t      var deletedInt = newRevIsDeleted ? 1 : 0;\n\t\n\t      var id = data._id;\n\t      var rev = data._rev;\n\t      var json = stringifyDoc(data);\n\t      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n\t        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n\t      var sqlArgs = [id, rev, json, deletedInt];\n\t\n\t      // map seqs to attachment digests, which\n\t      // we will need later during compaction\n\t      function insertAttachmentMappings(seq, callback) {\n\t        var attsAdded = 0;\n\t        var attsToAdd = Object.keys(data._attachments || {});\n\t\n\t        if (!attsToAdd.length) {\n\t          return callback();\n\t        }\n\t        function checkDone() {\n\t          if (++attsAdded === attsToAdd.length) {\n\t            callback();\n\t          }\n\t          return false; // ack handling a constraint error\n\t        }\n\t        function add(att) {\n\t          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n\t            ' (digest, seq) VALUES (?,?)';\n\t          var sqlArgs = [data._attachments[att].digest, seq];\n\t          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n\t          // second callback is for a constaint error, which we ignore\n\t          // because this docid/rev has already been associated with\n\t          // the digest (e.g. when new_edits == false)\n\t        }\n\t        for (var i = 0; i < attsToAdd.length; i++) {\n\t          add(attsToAdd[i]); // do in parallel\n\t        }\n\t      }\n\t\n\t      tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t        var seq = result.insertId;\n\t        insertAttachmentMappings(seq, function () {\n\t          dataWritten(tx, seq);\n\t        });\n\t      }, function () {\n\t        // constraint error, recover by updating instead (see #1638)\n\t        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n\t          'doc_id=? AND rev=?');\n\t        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n\t          var seq = res.rows.item(0).seq;\n\t          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n\t            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n\t          var sqlArgs = [json, deletedInt, id, rev];\n\t          tx.executeSql(sql, sqlArgs, function (tx) {\n\t            insertAttachmentMappings(seq, function () {\n\t              dataWritten(tx, seq);\n\t            });\n\t          });\n\t        });\n\t        return false; // ack that we've handled the error\n\t      });\n\t    }\n\t\n\t    function collectResults(attachmentErr) {\n\t      if (!err) {\n\t        if (attachmentErr) {\n\t          err = attachmentErr;\n\t          callback(err);\n\t        } else if (recv === attachments.length) {\n\t          finish();\n\t        }\n\t      }\n\t    }\n\t\n\t    var err = null;\n\t    var recv = 0;\n\t\n\t    docInfo.data._id = docInfo.metadata.id;\n\t    docInfo.data._rev = docInfo.metadata.rev;\n\t    var attachments = Object.keys(docInfo.data._attachments || {});\n\t\n\t\n\t    if (newRevIsDeleted) {\n\t      docInfo.data._deleted = true;\n\t    }\n\t\n\t    function attachmentSaved(err) {\n\t      recv++;\n\t      collectResults(err);\n\t    }\n\t\n\t    attachments.forEach(function (key) {\n\t      var att = docInfo.data._attachments[key];\n\t      if (!att.stub) {\n\t        var data = att.data;\n\t        delete att.data;\n\t        att.revpos = parseInt(winningRev$$1, 10);\n\t        var digest = att.digest;\n\t        saveAttachment(digest, data, attachmentSaved);\n\t      } else {\n\t        recv++;\n\t        collectResults();\n\t      }\n\t    });\n\t\n\t    if (!attachments.length) {\n\t      finish();\n\t    }\n\t\n\t    function dataWritten(tx, seq) {\n\t      var id = docInfo.metadata.id;\n\t\n\t      var revsToCompact = docInfo.stemmedRevs || [];\n\t      if (isUpdate && api.auto_compaction) {\n\t        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n\t      }\n\t      if (revsToCompact.length) {\n\t        compactRevs$1(revsToCompact, id, tx);\n\t      }\n\t\n\t      docInfo.metadata.seq = seq;\n\t      var rev = docInfo.metadata.rev;\n\t      delete docInfo.metadata.rev;\n\t\n\t      var sql = isUpdate ?\n\t      'UPDATE ' + DOC_STORE$1 +\n\t      ' SET json=?, max_seq=?, winningseq=' +\n\t      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n\t      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n\t        : 'INSERT INTO ' + DOC_STORE$1 +\n\t      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n\t      var metadataStr = safeJsonStringify(docInfo.metadata);\n\t      var params = isUpdate ?\n\t        [metadataStr, seq, winningRev$$1, id] :\n\t        [id, seq, seq, metadataStr];\n\t      tx.executeSql(sql, params, function () {\n\t        results[resultsIdx] = {\n\t          ok: true,\n\t          id: docInfo.metadata.id,\n\t          rev: rev\n\t        };\n\t        fetchedDocs.set(id, docInfo.metadata);\n\t        callback();\n\t      });\n\t    }\n\t  }\n\t\n\t  function websqlProcessDocs() {\n\t    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n\t                results, writeDoc, opts);\n\t  }\n\t\n\t  function fetchExistingDocs(callback) {\n\t    if (!docInfos.length) {\n\t      return callback();\n\t    }\n\t\n\t    var numFetched = 0;\n\t\n\t    function checkDone() {\n\t      if (++numFetched === docInfos.length) {\n\t        callback();\n\t      }\n\t    }\n\t\n\t    docInfos.forEach(function (docInfo) {\n\t      if (docInfo._id && isLocalId(docInfo._id)) {\n\t        return checkDone(); // skip local docs\n\t      }\n\t      var id = docInfo.metadata.id;\n\t      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n\t      ' WHERE id = ?', [id], function (tx, result) {\n\t        if (result.rows.length) {\n\t          var metadata = safeJsonParse(result.rows.item(0).json);\n\t          fetchedDocs.set(id, metadata);\n\t        }\n\t        checkDone();\n\t      });\n\t    });\n\t  }\n\t\n\t  function saveAttachment(digest, data, callback) {\n\t    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      if (result.rows.length) { // attachment already exists\n\t        return callback();\n\t      }\n\t      // we could just insert before selecting and catch the error,\n\t      // but my hunch is that it's cheaper not to serialize the blob\n\t      // from JS to C if we don't have to (TODO: confirm this)\n\t      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n\t      ' (digest, body, escaped) VALUES (?,?,1)';\n\t      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n\t        callback();\n\t      }, function () {\n\t        // ignore constaint errors, means it already exists\n\t        callback();\n\t        return false; // ack we handled the error\n\t      });\n\t    });\n\t  }\n\t\n\t  preprocessAttachments(docInfos, 'binary', function (err) {\n\t    if (err) {\n\t      return callback(err);\n\t    }\n\t    db.transaction(function (txn) {\n\t      tx = txn;\n\t      verifyAttachments(function (err) {\n\t        if (err) {\n\t          preconditionErrored = err;\n\t        } else {\n\t          fetchExistingDocs(websqlProcessDocs);\n\t        }\n\t      });\n\t    }, websqlError(callback), complete);\n\t  });\n\t}\n\t\n\tvar cachedDatabases = new ExportedMap();\n\t\n\t// openDatabase passed in through opts (e.g. for node-websql)\n\tfunction openDatabaseWithOpts(opts) {\n\t  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n\t}\n\t\n\tfunction openDBSafely(opts) {\n\t  try {\n\t    return {\n\t      db: openDatabaseWithOpts(opts)\n\t    };\n\t  } catch (err) {\n\t    return {\n\t      error: err\n\t    };\n\t  }\n\t}\n\t\n\tfunction openDB$1(opts) {\n\t  var cachedResult = cachedDatabases.get(opts.name);\n\t  if (!cachedResult) {\n\t    cachedResult = openDBSafely(opts);\n\t    cachedDatabases.set(opts.name, cachedResult);\n\t  }\n\t  return cachedResult;\n\t}\n\t\n\tvar websqlChanges = new Changes();\n\t\n\tfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n\t  var attachments = Object.keys(doc._attachments || {});\n\t  if (!attachments.length) {\n\t    return cb && cb();\n\t  }\n\t  var numDone = 0;\n\t\n\t  function checkDone() {\n\t    if (++numDone === attachments.length && cb) {\n\t      cb();\n\t    }\n\t  }\n\t\n\t  function fetchAttachment(doc, att) {\n\t    var attObj = doc._attachments[att];\n\t    var attOpts = {binary: opts.binary, ctx: txn};\n\t    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n\t      doc._attachments[att] = assign$1(\n\t        pick(attObj, ['digest', 'content_type']),\n\t        { data: data }\n\t      );\n\t      checkDone();\n\t    });\n\t  }\n\t\n\t  attachments.forEach(function (att) {\n\t    if (opts.attachments && opts.include_docs) {\n\t      fetchAttachment(doc, att);\n\t    } else {\n\t      doc._attachments[att].stub = true;\n\t      checkDone();\n\t    }\n\t  });\n\t}\n\t\n\tvar POUCH_VERSION = 1;\n\t\n\t// these indexes cover the ground for most allDocs queries\n\tvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n\t  BY_SEQ_STORE$1 + ' (seq, deleted)';\n\tvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n\t  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n\t    BY_SEQ_STORE$1 + ' (doc_id, rev)';\n\tvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n\t  DOC_STORE$1 + ' (winningseq)';\n\tvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n\t  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n\t    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\n\tvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n\t  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n\t    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\t\n\tvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n\t  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\t\n\tvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n\t  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n\t  BY_SEQ_STORE$1 + '.json AS data, ' +\n\t  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n\t  DOC_STORE$1 + '.json AS metadata';\n\t\n\tfunction WebSqlPouch$1(opts, callback) {\n\t  var api = this;\n\t  var instanceId = null;\n\t  var size = getSize(opts);\n\t  var idRequests = [];\n\t  var encoding;\n\t\n\t  api._name = opts.name;\n\t\n\t  // extend the options here, because sqlite plugin has a ton of options\n\t  // and they are constantly changing, so it's more prudent to allow anything\n\t  var websqlOpts = assign$1({}, opts, {\n\t    version: POUCH_VERSION,\n\t    description: opts.name,\n\t    size: size\n\t  });\n\t  var openDBResult = openDB$1(websqlOpts);\n\t  if (openDBResult.error) {\n\t    return websqlError(callback)(openDBResult.error);\n\t  }\n\t  var db = openDBResult.db;\n\t  if (typeof db.readTransaction !== 'function') {\n\t    // doesn't exist in sqlite plugin\n\t    db.readTransaction = db.transaction;\n\t  }\n\t\n\t  function dbCreated() {\n\t    // note the db name in case the browser upgrades to idb\n\t    if (hasLocalStorage()) {\n\t      window.localStorage['_pouch__websqldb_' + api._name] = true;\n\t    }\n\t    callback(null, api);\n\t  }\n\t\n\t  // In this migration, we added the 'deleted' and 'local' columns to the\n\t  // by-seq and doc store tables.\n\t  // To preserve existing user data, we re-process all the existing JSON\n\t  // and add these values.\n\t  // Called migration2 because it corresponds to adapter version (db_version) #2\n\t  function runMigration2(tx, callback) {\n\t    // index used for the join in the allDocs query\n\t    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\t\n\t    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n\t      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n\t      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n\t      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n\t        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n\t        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n\t          DOC_STORE$1 + ' (local, id)');\n\t\n\t        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n\t          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n\t          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\t\n\t        tx.executeSql(sql, [], function (tx, result) {\n\t\n\t          var deleted = [];\n\t          var local = [];\n\t\n\t          for (var i = 0; i < result.rows.length; i++) {\n\t            var item = result.rows.item(i);\n\t            var seq = item.seq;\n\t            var metadata = JSON.parse(item.metadata);\n\t            if (isDeleted(metadata)) {\n\t              deleted.push(seq);\n\t            }\n\t            if (isLocalId(metadata.id)) {\n\t              local.push(metadata.id);\n\t            }\n\t          }\n\t          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n\t            qMarks(local.length), local, function () {\n\t            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n\t              ' SET deleted = 1 WHERE seq IN ' +\n\t              qMarks(deleted.length), deleted, callback);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we make all the local docs unversioned\n\t  function runMigration3(tx, callback) {\n\t    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n\t      ' (id UNIQUE, rev, json)';\n\t    tx.executeSql(local, [], function () {\n\t      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n\t        BY_SEQ_STORE$1 + '.json AS data ' +\n\t        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n\t        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n\t        DOC_STORE$1 + '.winningseq WHERE local = 1';\n\t      tx.executeSql(sql, [], function (tx, res) {\n\t        var rows = [];\n\t        for (var i = 0; i < res.rows.length; i++) {\n\t          rows.push(res.rows.item(i));\n\t        }\n\t        function doNext() {\n\t          if (!rows.length) {\n\t            return callback(tx);\n\t          }\n\t          var row = rows.shift();\n\t          var rev = JSON.parse(row.data)._rev;\n\t          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n\t              ' (id, rev, json) VALUES (?,?,?)',\n\t              [row.id, rev, row.data], function (tx) {\n\t            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n\t                [row.id], function (tx) {\n\t              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n\t                  [row.seq], function () {\n\t                doNext();\n\t              });\n\t            });\n\t          });\n\t        }\n\t        doNext();\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we remove doc_id_rev and just use rev\n\t  function runMigration4(tx, callback) {\n\t\n\t    function updateRows(rows) {\n\t      function doNext() {\n\t        if (!rows.length) {\n\t          return callback(tx);\n\t        }\n\t        var row = rows.shift();\n\t        var doc_id_rev = parseHexString(row.hex, encoding);\n\t        var idx = doc_id_rev.lastIndexOf('::');\n\t        var doc_id = doc_id_rev.substring(0, idx);\n\t        var rev = doc_id_rev.substring(idx + 2);\n\t        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n\t          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n\t        tx.executeSql(sql, [doc_id, rev, doc_id_rev], function () {\n\t          doNext();\n\t        });\n\t      }\n\t      doNext();\n\t    }\n\t\n\t    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n\t    tx.executeSql(sql, [], function (tx) {\n\t      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n\t      tx.executeSql(sql, [], function (tx) {\n\t        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n\t          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n\t          tx.executeSql(sql, [], function (tx, res) {\n\t            var rows = [];\n\t            for (var i = 0; i < res.rows.length; i++) {\n\t              rows.push(res.rows.item(i));\n\t            }\n\t            updateRows(rows);\n\t          });\n\t        });\n\t      });\n\t    });\n\t  }\n\t\n\t  // in this migration, we add the attach_and_seq table\n\t  // for issue #2818\n\t  function runMigration5(tx, callback) {\n\t\n\t    function migrateAttsAndSeqs(tx) {\n\t      // need to actually populate the table. this is the expensive part,\n\t      // so as an optimization, check first that this database even\n\t      // contains attachments\n\t      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n\t      tx.executeSql(sql, [], function (tx, res) {\n\t        var count = res.rows.item(0).cnt;\n\t        if (!count) {\n\t          return callback(tx);\n\t        }\n\t\n\t        var offset = 0;\n\t        var pageSize = 10;\n\t        function nextPage() {\n\t          var sql = select(\n\t            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n\t            [DOC_STORE$1, BY_SEQ_STORE$1],\n\t            DOC_STORE_AND_BY_SEQ_JOINER,\n\t            null,\n\t            DOC_STORE$1 + '.id '\n\t          );\n\t          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n\t          offset += pageSize;\n\t          tx.executeSql(sql, [], function (tx, res) {\n\t            if (!res.rows.length) {\n\t              return callback(tx);\n\t            }\n\t            var digestSeqs = {};\n\t            function addDigestSeq(digest, seq) {\n\t              // uniq digest/seq pairs, just in case there are dups\n\t              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n\t              if (seqs.indexOf(seq) === -1) {\n\t                seqs.push(seq);\n\t              }\n\t            }\n\t            for (var i = 0; i < res.rows.length; i++) {\n\t              var row = res.rows.item(i);\n\t              var doc = unstringifyDoc(row.data, row.id, row.rev);\n\t              var atts = Object.keys(doc._attachments || {});\n\t              for (var j = 0; j < atts.length; j++) {\n\t                var att = doc._attachments[atts[j]];\n\t                addDigestSeq(att.digest, row.seq);\n\t              }\n\t            }\n\t            var digestSeqPairs = [];\n\t            Object.keys(digestSeqs).forEach(function (digest) {\n\t              var seqs = digestSeqs[digest];\n\t              seqs.forEach(function (seq) {\n\t                digestSeqPairs.push([digest, seq]);\n\t              });\n\t            });\n\t            if (!digestSeqPairs.length) {\n\t              return nextPage();\n\t            }\n\t            var numDone = 0;\n\t            digestSeqPairs.forEach(function (pair) {\n\t              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n\t                ' (digest, seq) VALUES (?,?)';\n\t              tx.executeSql(sql, pair, function () {\n\t                if (++numDone === digestSeqPairs.length) {\n\t                  nextPage();\n\t                }\n\t              });\n\t            });\n\t          });\n\t        }\n\t        nextPage();\n\t      });\n\t    }\n\t\n\t    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n\t      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n\t    tx.executeSql(attachAndRev, [], function (tx) {\n\t      tx.executeSql(\n\t        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n\t          tx.executeSql(\n\t            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n\t            migrateAttsAndSeqs);\n\t        });\n\t    });\n\t  }\n\t\n\t  // in this migration, we use escapeBlob() and unescapeBlob()\n\t  // instead of reading out the binary as HEX, which is slow\n\t  function runMigration6(tx, callback) {\n\t    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n\t      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n\t    tx.executeSql(sql, [], callback);\n\t  }\n\t\n\t  // issue #3136, in this migration we need a \"latest seq\" as well\n\t  // as the \"winning seq\" in the doc store\n\t  function runMigration7(tx, callback) {\n\t    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n\t      ' ADD COLUMN max_seq INTEGER';\n\t    tx.executeSql(sql, [], function (tx) {\n\t      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n\t        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n\t      tx.executeSql(sql, [], function (tx) {\n\t        // add unique index after filling, else we'll get a constraint\n\t        // error when we do the ALTER TABLE\n\t        var sql =\n\t          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n\t          DOC_STORE$1 + ' (max_seq)';\n\t        tx.executeSql(sql, [], callback);\n\t      });\n\t    });\n\t  }\n\t\n\t  function checkEncoding(tx, cb) {\n\t    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n\t    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n\t        var hex = res.rows.item(0).hex;\n\t        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n\t        cb();\n\t      }\n\t    );\n\t  }\n\t\n\t  function onGetInstanceId() {\n\t    while (idRequests.length > 0) {\n\t      var idCallback = idRequests.pop();\n\t      idCallback(null, instanceId);\n\t    }\n\t  }\n\t\n\t  function onGetVersion(tx, dbVersion) {\n\t    if (dbVersion === 0) {\n\t      // initial schema\n\t\n\t      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n\t        ' (dbid, db_version INTEGER)';\n\t      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n\t        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n\t      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n\t        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n\t      // TODO: migrate winningseq to INTEGER\n\t      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n\t        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n\t      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n\t        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n\t        'json, deleted TINYINT(1), doc_id, rev)';\n\t      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n\t        ' (id UNIQUE, rev, json)';\n\t\n\t      // creates\n\t      tx.executeSql(attach);\n\t      tx.executeSql(local);\n\t      tx.executeSql(attachAndRev, [], function () {\n\t        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n\t        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n\t      });\n\t      tx.executeSql(doc, [], function () {\n\t        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\t        tx.executeSql(seq, [], function () {\n\t          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n\t          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n\t          tx.executeSql(meta, [], function () {\n\t            // mark the db version, and new dbid\n\t            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n\t              ' (db_version, dbid) VALUES (?,?)';\n\t            instanceId = uuid();\n\t            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n\t            tx.executeSql(initSeq, initSeqArgs, function () {\n\t              onGetInstanceId();\n\t            });\n\t          });\n\t        });\n\t      });\n\t    } else { // version > 0\n\t\n\t      var setupDone = function () {\n\t        var migrated = dbVersion < ADAPTER_VERSION$1;\n\t        if (migrated) {\n\t          // update the db version within this transaction\n\t          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n\t            ADAPTER_VERSION$1);\n\t        }\n\t        // notify db.id() callers\n\t        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n\t        tx.executeSql(sql, [], function (tx, result) {\n\t          instanceId = result.rows.item(0).dbid;\n\t          onGetInstanceId();\n\t        });\n\t      };\n\t\n\t      // would love to use promises here, but then websql\n\t      // ends the transaction early\n\t      var tasks = [\n\t        runMigration2,\n\t        runMigration3,\n\t        runMigration4,\n\t        runMigration5,\n\t        runMigration6,\n\t        runMigration7,\n\t        setupDone\n\t      ];\n\t\n\t      // run each migration sequentially\n\t      var i = dbVersion;\n\t      var nextMigration = function (tx) {\n\t        tasks[i - 1](tx, nextMigration);\n\t        i++;\n\t      };\n\t      nextMigration(tx);\n\t    }\n\t  }\n\t\n\t  function setup() {\n\t    db.transaction(function (tx) {\n\t      // first check the encoding\n\t      checkEncoding(tx, function () {\n\t        // then get the version\n\t        fetchVersion(tx);\n\t      });\n\t    }, websqlError(callback), dbCreated);\n\t  }\n\t\n\t  function fetchVersion(tx) {\n\t    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n\t    tx.executeSql(sql, [], function (tx, result) {\n\t      if (!result.rows.length) {\n\t        // database hasn't even been created yet (version 0)\n\t        onGetVersion(tx, 0);\n\t      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n\t        // table was created, but without the new db_version column,\n\t        // so add it.\n\t        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n\t          ' ADD COLUMN db_version INTEGER', [], function () {\n\t          // before version 2, this column didn't even exist\n\t          onGetVersion(tx, 1);\n\t        });\n\t      } else { // column exists, we can safely get it\n\t        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n\t          [], function (tx, result) {\n\t          var dbVersion = result.rows.item(0).db_version;\n\t          onGetVersion(tx, dbVersion);\n\t        });\n\t      }\n\t    });\n\t  }\n\t\n\t  setup();\n\t\n\t  function getMaxSeq(tx, callback) {\n\t    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n\t    tx.executeSql(sql, [], function (tx, res) {\n\t      var updateSeq = res.rows.item(0).seq || 0;\n\t      callback(updateSeq);\n\t    });\n\t  }\n\t\n\t  function countDocs(tx, callback) {\n\t    // count the total rows\n\t    var sql = select(\n\t      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n\t      [DOC_STORE$1, BY_SEQ_STORE$1],\n\t      DOC_STORE_AND_BY_SEQ_JOINER,\n\t      BY_SEQ_STORE$1 + '.deleted=0');\n\t\n\t    tx.executeSql(sql, [], function (tx, result) {\n\t      callback(result.rows.item(0).num);\n\t    });\n\t  }\n\t\n\t  api.type = function () {\n\t    return 'websql';\n\t  };\n\t\n\t  api._id = toPromise(function (callback) {\n\t    callback(null, instanceId);\n\t  });\n\t\n\t  api._info = function (callback) {\n\t    var seq;\n\t    var docCount;\n\t    db.readTransaction(function (tx) {\n\t      getMaxSeq(tx, function (theSeq) {\n\t        seq = theSeq;\n\t      });\n\t      countDocs(tx, function (theDocCount) {\n\t        docCount = theDocCount;\n\t      });\n\t    }, websqlError(callback), function () {\n\t      callback(null, {\n\t        doc_count: docCount,\n\t        update_seq: seq,\n\t        websql_encoding: encoding\n\t      });\n\t    });\n\t  };\n\t\n\t  api._bulkDocs = function (req, reqOpts, callback) {\n\t    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n\t  };\n\t\n\t  function latest$$1(tx, id, rev, callback, finish) {\n\t    var sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        DOC_STORE$1 + '.id=?');\n\t    var sqlArgs = [id];\n\t\n\t    tx.executeSql(sql, sqlArgs, function (a, results) {\n\t      if (!results.rows.length) {\n\t        var err = createError(MISSING_DOC, 'missing');\n\t        return finish(err);\n\t      }\n\t      var item = results.rows.item(0);\n\t      var metadata = safeJsonParse(item.metadata);\n\t      callback(latest(rev, metadata));\n\t    });\n\t  }\n\t\n\t  api._get = function (id, opts, callback) {\n\t    var doc;\n\t    var metadata;\n\t    var tx = opts.ctx;\n\t    if (!tx) {\n\t      return db.readTransaction(function (txn) {\n\t        api._get(id, assign$1({ctx: txn}, opts), callback);\n\t      });\n\t    }\n\t\n\t    function finish(err) {\n\t      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n\t    }\n\t\n\t    var sql;\n\t    var sqlArgs;\n\t\n\t    if(!opts.rev) {\n\t      sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        DOC_STORE$1 + '.id=?');\n\t      sqlArgs = [id];\n\t    } else if (opts.latest) {\n\t      latest$$1(tx, id, opts.rev, function (latestRev) {\n\t        opts.latest = false;\n\t        opts.rev = latestRev;\n\t        api._get(id, opts, callback);\n\t      }, finish);\n\t      return;\n\t    } else {\n\t      sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n\t        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n\t      sqlArgs = [id, opts.rev];\n\t    }\n\t\n\t    tx.executeSql(sql, sqlArgs, function (a, results) {\n\t      if (!results.rows.length) {\n\t        var missingErr = createError(MISSING_DOC, 'missing');\n\t        return finish(missingErr);\n\t      }\n\t      var item = results.rows.item(0);\n\t      metadata = safeJsonParse(item.metadata);\n\t      if (item.deleted && !opts.rev) {\n\t        var deletedErr = createError(MISSING_DOC, 'deleted');\n\t        return finish(deletedErr);\n\t      }\n\t      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n\t      finish();\n\t    });\n\t  };\n\t\n\t  api._allDocs = function (opts, callback) {\n\t    var results = [];\n\t    var totalRows;\n\t\n\t    var start = 'startkey' in opts ? opts.startkey : false;\n\t    var end = 'endkey' in opts ? opts.endkey : false;\n\t    var key = 'key' in opts ? opts.key : false;\n\t    var descending = 'descending' in opts ? opts.descending : false;\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    var offset = 'skip' in opts ? opts.skip : 0;\n\t    var inclusiveEnd = opts.inclusive_end !== false;\n\t\n\t    var sqlArgs = [];\n\t    var criteria = [];\n\t\n\t    if (key !== false) {\n\t      criteria.push(DOC_STORE$1 + '.id = ?');\n\t      sqlArgs.push(key);\n\t    } else if (start !== false || end !== false) {\n\t      if (start !== false) {\n\t        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n\t        sqlArgs.push(start);\n\t      }\n\t      if (end !== false) {\n\t        var comparator = descending ? '>' : '<';\n\t        if (inclusiveEnd) {\n\t          comparator += '=';\n\t        }\n\t        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n\t        sqlArgs.push(end);\n\t      }\n\t      if (key !== false) {\n\t        criteria.push(DOC_STORE$1 + '.id = ?');\n\t        sqlArgs.push(key);\n\t      }\n\t    }\n\t\n\t    if (opts.deleted !== 'ok') {\n\t      // report deleted if keys are specified\n\t      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n\t    }\n\t\n\t    db.readTransaction(function (tx) {\n\t      // count the docs in parallel to other operations\n\t      countDocs(tx, function (docCount) {\n\t        totalRows = docCount;\n\t      });\n\t\n\t      if (limit === 0) {\n\t        return;\n\t      }\n\t\n\t      // do a single query to fetch the documents\n\t      var sql = select(\n\t        SELECT_DOCS,\n\t        [DOC_STORE$1, BY_SEQ_STORE$1],\n\t        DOC_STORE_AND_BY_SEQ_JOINER,\n\t        criteria,\n\t        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n\t        );\n\t      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\t\n\t      tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t        for (var i = 0, l = result.rows.length; i < l; i++) {\n\t          var item = result.rows.item(i);\n\t          var metadata = safeJsonParse(item.metadata);\n\t          var id = metadata.id;\n\t          var data = unstringifyDoc(item.data, id, item.rev);\n\t          var winningRev$$1 = data._rev;\n\t          var doc = {\n\t            id: id,\n\t            key: id,\n\t            value: {rev: winningRev$$1}\n\t          };\n\t          if (opts.include_docs) {\n\t            doc.doc = data;\n\t            doc.doc._rev = winningRev$$1;\n\t            if (opts.conflicts) {\n\t              var conflicts = collectConflicts(metadata);\n\t              if (conflicts.length) {\n\t                doc.doc._conflicts = conflicts;\n\t              }\n\t            }\n\t            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n\t          }\n\t          if (item.deleted) {\n\t            if (opts.deleted === 'ok') {\n\t              doc.value.deleted = true;\n\t              doc.doc = null;\n\t            } else {\n\t              continue;\n\t            }\n\t          }\n\t          results.push(doc);\n\t        }\n\t      });\n\t    }, websqlError(callback), function () {\n\t      callback(null, {\n\t        total_rows: totalRows,\n\t        offset: opts.skip,\n\t        rows: results\n\t      });\n\t    });\n\t  };\n\t\n\t  api._changes = function (opts) {\n\t    opts = clone(opts);\n\t\n\t    if (opts.continuous) {\n\t      var id = api._name + ':' + uuid();\n\t      websqlChanges.addListener(api._name, id, api, opts);\n\t      websqlChanges.notify(api._name);\n\t      return {\n\t        cancel: function () {\n\t          websqlChanges.removeListener(api._name, id);\n\t        }\n\t      };\n\t    }\n\t\n\t    var descending = opts.descending;\n\t\n\t    // Ignore the `since` parameter when `descending` is true\n\t    opts.since = opts.since && !descending ? opts.since : 0;\n\t\n\t    var limit = 'limit' in opts ? opts.limit : -1;\n\t    if (limit === 0) {\n\t      limit = 1; // per CouchDB _changes spec\n\t    }\n\t\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t    var results = [];\n\t    var numResults = 0;\n\t\n\t    function fetchChanges() {\n\t\n\t      var selectStmt =\n\t        DOC_STORE$1 + '.json AS metadata, ' +\n\t        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n\t        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n\t        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\t\n\t      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\t\n\t      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n\t        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\t\n\t      var criteria = ['maxSeq > ?'];\n\t      var sqlArgs = [opts.since];\n\t\n\t      if (opts.doc_ids) {\n\t        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n\t        sqlArgs = sqlArgs.concat(opts.doc_ids);\n\t      }\n\t\n\t      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\t\n\t      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\t\n\t      var filter = filterChange(opts);\n\t      if (!opts.view && !opts.filter) {\n\t        // we can just limit in the query\n\t        sql += ' LIMIT ' + limit;\n\t      }\n\t\n\t      var lastSeq = opts.since || 0;\n\t      db.readTransaction(function (tx) {\n\t        tx.executeSql(sql, sqlArgs, function (tx, result) {\n\t          function reportChange(change) {\n\t            return function () {\n\t              opts.onChange(change);\n\t            };\n\t          }\n\t          for (var i = 0, l = result.rows.length; i < l; i++) {\n\t            var item = result.rows.item(i);\n\t            var metadata = safeJsonParse(item.metadata);\n\t            lastSeq = item.maxSeq;\n\t\n\t            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n\t              item.winningRev);\n\t            var change = opts.processChange(doc, metadata, opts);\n\t            change.seq = item.maxSeq;\n\t\n\t            var filtered = filter(change);\n\t            if (typeof filtered === 'object') {\n\t              return opts.complete(filtered);\n\t            }\n\t\n\t            if (filtered) {\n\t              numResults++;\n\t              if (returnDocs) {\n\t                results.push(change);\n\t              }\n\t              // process the attachment immediately\n\t              // for the benefit of live listeners\n\t              if (opts.attachments && opts.include_docs) {\n\t                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n\t                  reportChange(change));\n\t              } else {\n\t                reportChange(change)();\n\t              }\n\t            }\n\t            if (numResults === limit) {\n\t              break;\n\t            }\n\t          }\n\t        });\n\t      }, websqlError(opts.complete), function () {\n\t        if (!opts.continuous) {\n\t          opts.complete(null, {\n\t            results: results,\n\t            last_seq: lastSeq\n\t          });\n\t        }\n\t      });\n\t    }\n\t\n\t    fetchChanges();\n\t  };\n\t\n\t  api._close = function (callback) {\n\t    //WebSQL databases do not need to be closed\n\t    callback();\n\t  };\n\t\n\t  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n\t    var res;\n\t    var tx = opts.ctx;\n\t    var digest = attachment.digest;\n\t    var type = attachment.content_type;\n\t    var sql = 'SELECT escaped, ' +\n\t      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n\t      ATTACH_STORE$1 + ' WHERE digest=?';\n\t    tx.executeSql(sql, [digest], function (tx, result) {\n\t      // websql has a bug where \\u0000 causes early truncation in strings\n\t      // and blobs. to work around this, we used to use the hex() function,\n\t      // but that's not performant. after migration 6, we remove \\u0000\n\t      // and add it back in afterwards\n\t      var item = result.rows.item(0);\n\t      var data = item.escaped ? unescapeBlob(item.body) :\n\t        parseHexString(item.body, encoding);\n\t      if (opts.binary) {\n\t        res = binStringToBluffer(data, type);\n\t      } else {\n\t        res = thisBtoa(data);\n\t      }\n\t      callback(null, res);\n\t    });\n\t  };\n\t\n\t  api._getRevisionTree = function (docId, callback) {\n\t    db.readTransaction(function (tx) {\n\t      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n\t      tx.executeSql(sql, [docId], function (tx, result) {\n\t        if (!result.rows.length) {\n\t          callback(createError(MISSING_DOC));\n\t        } else {\n\t          var data = safeJsonParse(result.rows.item(0).metadata);\n\t          callback(null, data.rev_tree);\n\t        }\n\t      });\n\t    });\n\t  };\n\t\n\t  api._doCompaction = function (docId, revs, callback) {\n\t    if (!revs.length) {\n\t      return callback();\n\t    }\n\t    db.transaction(function (tx) {\n\t\n\t      // update doc store\n\t      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n\t      tx.executeSql(sql, [docId], function (tx, result) {\n\t        var metadata = safeJsonParse(result.rows.item(0).metadata);\n\t        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n\t                                                           revHash, ctx, opts) {\n\t          var rev = pos + '-' + revHash;\n\t          if (revs.indexOf(rev) !== -1) {\n\t            opts.status = 'missing';\n\t          }\n\t        });\n\t\n\t        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n\t        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n\t      });\n\t\n\t      compactRevs$1(revs, docId, tx);\n\t    }, websqlError(callback), function () {\n\t      callback();\n\t    });\n\t  };\n\t\n\t  api._getLocal = function (id, callback) {\n\t    db.readTransaction(function (tx) {\n\t      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n\t      tx.executeSql(sql, [id], function (tx, res) {\n\t        if (res.rows.length) {\n\t          var item = res.rows.item(0);\n\t          var doc = unstringifyDoc(item.json, id, item.rev);\n\t          callback(null, doc);\n\t        } else {\n\t          callback(createError(MISSING_DOC));\n\t        }\n\t      });\n\t    });\n\t  };\n\t\n\t  api._putLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    delete doc._revisions; // ignore this, trust the rev\n\t    var oldRev = doc._rev;\n\t    var id = doc._id;\n\t    var newRev;\n\t    if (!oldRev) {\n\t      newRev = doc._rev = '0-1';\n\t    } else {\n\t      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n\t    }\n\t    var json = stringifyDoc(doc);\n\t\n\t    var ret;\n\t    function putLocal(tx) {\n\t      var sql;\n\t      var values;\n\t      if (oldRev) {\n\t        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n\t          'WHERE id=? AND rev=?';\n\t        values = [newRev, json, id, oldRev];\n\t      } else {\n\t        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n\t        values = [id, newRev, json];\n\t      }\n\t      tx.executeSql(sql, values, function (tx, res) {\n\t        if (res.rowsAffected) {\n\t          ret = {ok: true, id: id, rev: newRev};\n\t          if (opts.ctx) { // return immediately\n\t            callback(null, ret);\n\t          }\n\t        } else {\n\t          callback(createError(REV_CONFLICT));\n\t        }\n\t      }, function () {\n\t        callback(createError(REV_CONFLICT));\n\t        return false; // ack that we handled the error\n\t      });\n\t    }\n\t\n\t    if (opts.ctx) {\n\t      putLocal(opts.ctx);\n\t    } else {\n\t      db.transaction(putLocal, websqlError(callback), function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  api._removeLocal = function (doc, opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var ret;\n\t\n\t    function removeLocal(tx) {\n\t      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n\t      var params = [doc._id, doc._rev];\n\t      tx.executeSql(sql, params, function (tx, res) {\n\t        if (!res.rowsAffected) {\n\t          return callback(createError(MISSING_DOC));\n\t        }\n\t        ret = {ok: true, id: doc._id, rev: '0-0'};\n\t        if (opts.ctx) { // return immediately\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t\n\t    if (opts.ctx) {\n\t      removeLocal(opts.ctx);\n\t    } else {\n\t      db.transaction(removeLocal, websqlError(callback), function () {\n\t        if (ret) {\n\t          callback(null, ret);\n\t        }\n\t      });\n\t    }\n\t  };\n\t\n\t  api._destroy = function (opts, callback) {\n\t    websqlChanges.removeAllListeners(api._name);\n\t    db.transaction(function (tx) {\n\t      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n\t        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n\t      stores.forEach(function (store) {\n\t        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n\t      });\n\t    }, websqlError(callback), function () {\n\t      if (hasLocalStorage()) {\n\t        delete window.localStorage['_pouch__websqldb_' + api._name];\n\t        delete window.localStorage[api._name];\n\t      }\n\t      callback(null, {'ok': true});\n\t    });\n\t  };\n\t}\n\t\n\tfunction canOpenTestDB() {\n\t  try {\n\t    openDatabase('_pouch_validate_websql', 1, '', 1);\n\t    return true;\n\t  } catch (err) {\n\t    return false;\n\t  }\n\t}\n\t\n\t// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n\t// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n\t// https://github.com/pouchdb/pouchdb/issues/5079)\n\t// This has been fixed in latest WebKit, so we try to detect it here.\n\tfunction isValidWebSQL() {\n\t  // WKWebView UA:\n\t  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n\t  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n\t  // Chrome for iOS UA:\n\t  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n\t  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n\t  //   Mobile/9B206 Safari/7534.48.3\n\t  // Firefox for iOS UA:\n\t  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n\t  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\t\n\t  // indexedDB is null on some UIWebViews and undefined in others\n\t  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n\t  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n\t      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n\t    // definitely not WKWebView, avoid creating an unnecessary database\n\t    return true;\n\t  }\n\t  // Cache the result in LocalStorage. Reason we do this is because if we\n\t  // call openDatabase() too many times, Safari craps out in SauceLabs and\n\t  // starts throwing DOM Exception 14s.\n\t  var hasLS = hasLocalStorage();\n\t  // Include user agent in the hash, so that if Safari is upgraded, we don't\n\t  // continually think it's broken.\n\t  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n\t  if (hasLS && localStorage[localStorageKey]) {\n\t    return localStorage[localStorageKey] === '1';\n\t  }\n\t  var openedTestDB = canOpenTestDB();\n\t  if (hasLS) {\n\t    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n\t  }\n\t  return openedTestDB;\n\t}\n\t\n\tfunction valid() {\n\t  if (typeof openDatabase !== 'function') {\n\t    return false;\n\t  }\n\t  return isValidWebSQL();\n\t}\n\t\n\tfunction openDB(name, version, description, size) {\n\t  // Traditional WebSQL API\n\t  return openDatabase(name, version, description, size);\n\t}\n\t\n\tfunction WebSQLPouch(opts, callback) {\n\t  var _opts = assign$1({\n\t    websql: openDB\n\t  }, opts);\n\t\n\t  WebSqlPouch$1.call(this, _opts, callback);\n\t}\n\t\n\tWebSQLPouch.valid = valid;\n\t\n\tWebSQLPouch.use_prefix = true;\n\t\n\tvar WebSqlPouch = function (PouchDB) {\n\t  PouchDB.adapter('websql', WebSQLPouch, true);\n\t};\n\t\n\t/* global fetch */\n\t/* global Headers */\n\tfunction wrappedFetch() {\n\t  var wrappedPromise = {};\n\t\n\t  var promise = new PouchPromise$1(function (resolve, reject) {\n\t    wrappedPromise.resolve = resolve;\n\t    wrappedPromise.reject = reject;\n\t  });\n\t\n\t  var args = new Array(arguments.length);\n\t\n\t  for (var i = 0; i < args.length; i++) {\n\t    args[i] = arguments[i];\n\t  }\n\t\n\t  wrappedPromise.promise = promise;\n\t\n\t  PouchPromise$1.resolve().then(function () {\n\t    return fetch.apply(null, args);\n\t  }).then(function (response) {\n\t    wrappedPromise.resolve(response);\n\t  }).catch(function (error) {\n\t    wrappedPromise.reject(error);\n\t  });\n\t\n\t  return wrappedPromise;\n\t}\n\t\n\tfunction fetchRequest(options, callback) {\n\t  var wrappedPromise, timer, response;\n\t\n\t  var headers = new Headers();\n\t\n\t  var fetchOptions = {\n\t    method: options.method,\n\t    credentials: 'include',\n\t    headers: headers\n\t  };\n\t\n\t  if (options.json) {\n\t    headers.set('Accept', 'application/json');\n\t    headers.set('Content-Type', options.headers['Content-Type'] ||\n\t      'application/json');\n\t  }\n\t\n\t  if (options.body &&\n\t      options.processData &&\n\t      typeof options.body !== 'string') {\n\t    fetchOptions.body = JSON.stringify(options.body);\n\t  } else if ('body' in options) {\n\t    fetchOptions.body = options.body;\n\t  } else {\n\t    fetchOptions.body = null;\n\t  }\n\t\n\t  Object.keys(options.headers).forEach(function (key) {\n\t    if (options.headers.hasOwnProperty(key)) {\n\t      headers.set(key, options.headers[key]);\n\t    }\n\t  });\n\t\n\t  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\t\n\t  if (options.timeout > 0) {\n\t    timer = setTimeout(function () {\n\t      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n\t        options.url));\n\t    }, options.timeout);\n\t  }\n\t\n\t  wrappedPromise.promise.then(function (fetchResponse) {\n\t    response = {\n\t      statusCode: fetchResponse.status\n\t    };\n\t\n\t    if (options.timeout > 0) {\n\t      clearTimeout(timer);\n\t    }\n\t\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n\t    }\n\t\n\t    return fetchResponse.json();\n\t  }).then(function (result) {\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      callback(null, response, result);\n\t    } else {\n\t      result.status = response.statusCode;\n\t      callback(result);\n\t    }\n\t  }).catch(function (error) {\n\t    if (!error) {\n\t      // this happens when the listener is canceled\n\t      error = new Error('canceled');\n\t    }\n\t    callback(error);\n\t  });\n\t\n\t  return {abort: wrappedPromise.reject};\n\t}\n\t\n\tfunction xhRequest(options, callback) {\n\t\n\t  var xhr, timer;\n\t  var timedout = false;\n\t\n\t  var abortReq = function () {\n\t    xhr.abort();\n\t    cleanUp();\n\t  };\n\t\n\t  var timeoutReq = function () {\n\t    timedout = true;\n\t    xhr.abort();\n\t    cleanUp();\n\t  };\n\t\n\t  var ret = {abort: abortReq};\n\t\n\t  var cleanUp = function () {\n\t    clearTimeout(timer);\n\t    ret.abort = function () {};\n\t    if (xhr) {\n\t      xhr.onprogress = undefined;\n\t      if (xhr.upload) {\n\t        xhr.upload.onprogress = undefined;\n\t      }\n\t      xhr.onreadystatechange = undefined;\n\t      xhr = undefined;\n\t    }\n\t  };\n\t\n\t  if (options.xhr) {\n\t    xhr = new options.xhr();\n\t  } else {\n\t    xhr = new XMLHttpRequest();\n\t  }\n\t\n\t  try {\n\t    xhr.open(options.method, options.url);\n\t  } catch (exception) {\n\t    return callback(new Error(exception.name || 'Url is invalid'));\n\t  }\n\t\n\t  xhr.withCredentials = ('withCredentials' in options) ?\n\t    options.withCredentials : true;\n\t\n\t  if (options.method === 'GET') {\n\t    delete options.headers['Content-Type'];\n\t  } else if (options.json) {\n\t    options.headers.Accept = 'application/json';\n\t    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n\t      'application/json';\n\t    if (options.body &&\n\t        options.processData &&\n\t        typeof options.body !== \"string\") {\n\t      options.body = JSON.stringify(options.body);\n\t    }\n\t  }\n\t\n\t  if (options.binary) {\n\t    xhr.responseType = 'arraybuffer';\n\t  }\n\t\n\t  if (!('body' in options)) {\n\t    options.body = null;\n\t  }\n\t\n\t  for (var key in options.headers) {\n\t    if (options.headers.hasOwnProperty(key)) {\n\t      xhr.setRequestHeader(key, options.headers[key]);\n\t    }\n\t  }\n\t\n\t  if (options.timeout > 0) {\n\t    timer = setTimeout(timeoutReq, options.timeout);\n\t    xhr.onprogress = function () {\n\t      clearTimeout(timer);\n\t      if(xhr.readyState !== 4) {\n\t        timer = setTimeout(timeoutReq, options.timeout);\n\t      }\n\t    };\n\t    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n\t      xhr.upload.onprogress = xhr.onprogress;\n\t    }\n\t  }\n\t\n\t  xhr.onreadystatechange = function () {\n\t    if (xhr.readyState !== 4) {\n\t      return;\n\t    }\n\t\n\t    var response = {\n\t      statusCode: xhr.status\n\t    };\n\t\n\t    if (xhr.status >= 200 && xhr.status < 300) {\n\t      var data;\n\t      if (options.binary) {\n\t        data = createBlob([xhr.response || ''], {\n\t          type: xhr.getResponseHeader('Content-Type')\n\t        });\n\t      } else {\n\t        data = xhr.responseText;\n\t      }\n\t      callback(null, response, data);\n\t    } else {\n\t      var err = {};\n\t      if (timedout) {\n\t        err = new Error('ETIMEDOUT');\n\t        err.code = 'ETIMEDOUT';\n\t      } else if (typeof xhr.response === 'string') {\n\t        try {\n\t          err = JSON.parse(xhr.response);\n\t        } catch(e) {}\n\t      }\n\t      err.status = xhr.status;\n\t      callback(err);\n\t    }\n\t    cleanUp();\n\t  };\n\t\n\t  if (options.body && (options.body instanceof Blob)) {\n\t    readAsArrayBuffer(options.body, function (arrayBuffer) {\n\t      xhr.send(arrayBuffer);\n\t    });\n\t  } else {\n\t    xhr.send(options.body);\n\t  }\n\t\n\t  return ret;\n\t}\n\t\n\tfunction testXhr() {\n\t  try {\n\t    new XMLHttpRequest();\n\t    return true;\n\t  } catch (err) {\n\t    return false;\n\t  }\n\t}\n\t\n\tvar hasXhr = testXhr();\n\t\n\tfunction ajax$1(options, callback) {\n\t  if (!false && (hasXhr || options.xhr)) {\n\t    return xhRequest(options, callback);\n\t  } else {\n\t    return fetchRequest(options, callback);\n\t  }\n\t}\n\t\n\t// the blob already has a type; do nothing\n\tvar res$2 = function () {};\n\t\n\tfunction defaultBody() {\n\t  return '';\n\t}\n\t\n\tfunction ajaxCore$1(options, callback) {\n\t\n\t  options = clone(options);\n\t\n\t  var defaultOptions = {\n\t    method : \"GET\",\n\t    headers: {},\n\t    json: true,\n\t    processData: true,\n\t    timeout: 10000,\n\t    cache: false\n\t  };\n\t\n\t  options = assign$1(defaultOptions, options);\n\t\n\t  function onSuccess(obj, resp, cb) {\n\t    if (!options.binary && options.json && typeof obj === 'string') {\n\t      /* istanbul ignore next */\n\t      try {\n\t        obj = JSON.parse(obj);\n\t      } catch (e) {\n\t        // Probably a malformed JSON from server\n\t        return cb(e);\n\t      }\n\t    }\n\t    if (Array.isArray(obj)) {\n\t      obj = obj.map(function (v) {\n\t        if (v.error || v.missing) {\n\t          return generateErrorFromResponse(v);\n\t        } else {\n\t          return v;\n\t        }\n\t      });\n\t    }\n\t    if (options.binary) {\n\t      res$2(obj, resp);\n\t    }\n\t    cb(null, obj, resp);\n\t  }\n\t\n\t  if (options.json) {\n\t    if (!options.binary) {\n\t      options.headers.Accept = 'application/json';\n\t    }\n\t    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n\t      'application/json';\n\t  }\n\t\n\t  if (options.binary) {\n\t    options.encoding = null;\n\t    options.json = false;\n\t  }\n\t\n\t  if (!options.processData) {\n\t    options.json = false;\n\t  }\n\t\n\t  return ajax$1(options, function (err, response, body) {\n\t\n\t    if (err) {\n\t      return callback(generateErrorFromResponse(err));\n\t    }\n\t\n\t    var error;\n\t    var content_type = response.headers && response.headers['content-type'];\n\t    var data = body || defaultBody();\n\t\n\t    // CouchDB doesn't always return the right content-type for JSON data, so\n\t    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n\t    if (!options.binary && (options.json || !options.processData) &&\n\t        typeof data !== 'object' &&\n\t        (/json/.test(content_type) ||\n\t         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n\t      try {\n\t        data = JSON.parse(data.toString());\n\t      } catch (e) {}\n\t    }\n\t\n\t    if (response.statusCode >= 200 && response.statusCode < 300) {\n\t      onSuccess(data, response, callback);\n\t    } else {\n\t      error = generateErrorFromResponse(data);\n\t      error.status = response.statusCode;\n\t      callback(error);\n\t    }\n\t  });\n\t}\n\t\n\tfunction ajax(opts, callback) {\n\t\n\t  // cache-buster, specifically designed to work around IE's aggressive caching\n\t  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n\t  // Also Safari caches POSTs, so we need to cache-bust those too.\n\t  var ua = (navigator && navigator.userAgent) ?\n\t    navigator.userAgent.toLowerCase() : '';\n\t\n\t  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n\t  var isIE = ua.indexOf('msie') !== -1;\n\t  var isEdge = ua.indexOf('edge') !== -1;\n\t\n\t  // it appears the new version of safari also caches GETs,\n\t  // see https://github.com/pouchdb/pouchdb/issues/5010\n\t  var shouldCacheBust = (isSafari ||\n\t    ((isIE || isEdge) && opts.method === 'GET'));\n\t\n\t  var cache = 'cache' in opts ? opts.cache : true;\n\t\n\t  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\t\n\t  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n\t    var hasArgs = opts.url.indexOf('?') !== -1;\n\t    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n\t  }\n\t\n\t  return ajaxCore$1(opts, callback);\n\t}\n\t\n\t// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n\t// but much smaller in code size. limits the number of concurrent promises that are executed\n\t\n\tfunction pool(promiseFactories, limit) {\n\t  return new PouchPromise$1(function (resolve, reject) {\n\t    var running = 0;\n\t    var current = 0;\n\t    var done = 0;\n\t    var len = promiseFactories.length;\n\t    var err;\n\t\n\t    function runNext() {\n\t      running++;\n\t      promiseFactories[current++]().then(onSuccess, onError);\n\t    }\n\t\n\t    function doNext() {\n\t      if (++done === len) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          reject(err);\n\t        } else {\n\t          resolve();\n\t        }\n\t      } else {\n\t        runNextBatch();\n\t      }\n\t    }\n\t\n\t    function onSuccess() {\n\t      running--;\n\t      doNext();\n\t    }\n\t\n\t    /* istanbul ignore next */\n\t    function onError(thisErr) {\n\t      running--;\n\t      err = err || thisErr;\n\t      doNext();\n\t    }\n\t\n\t    function runNextBatch() {\n\t      while (running < limit && current < len) {\n\t        runNext();\n\t      }\n\t    }\n\t\n\t    runNextBatch();\n\t  });\n\t}\n\t\n\tvar CHANGES_BATCH_SIZE = 25;\n\tvar MAX_SIMULTANEOUS_REVS = 50;\n\t\n\tvar supportsBulkGetMap = {};\n\t\n\tvar log$1 = debug('pouchdb:http');\n\t\n\tfunction readAttachmentsAsBlobOrBuffer(row) {\n\t  var atts = row.doc && row.doc._attachments;\n\t  if (!atts) {\n\t    return;\n\t  }\n\t  Object.keys(atts).forEach(function (filename) {\n\t    var att = atts[filename];\n\t    att.data = b64ToBluffer(att.data, att.content_type);\n\t  });\n\t}\n\t\n\tfunction encodeDocId(id) {\n\t  if (/^_design/.test(id)) {\n\t    return '_design/' + encodeURIComponent(id.slice(8));\n\t  }\n\t  if (/^_local/.test(id)) {\n\t    return '_local/' + encodeURIComponent(id.slice(7));\n\t  }\n\t  return encodeURIComponent(id);\n\t}\n\t\n\tfunction preprocessAttachments$2(doc) {\n\t  if (!doc._attachments || !Object.keys(doc._attachments)) {\n\t    return PouchPromise$1.resolve();\n\t  }\n\t\n\t  return PouchPromise$1.all(Object.keys(doc._attachments).map(function (key) {\n\t    var attachment = doc._attachments[key];\n\t    if (attachment.data && typeof attachment.data !== 'string') {\n\t      return new PouchPromise$1(function (resolve) {\n\t        blobToBase64(attachment.data, resolve);\n\t      }).then(function (b64) {\n\t        attachment.data = b64;\n\t      });\n\t    }\n\t  }));\n\t}\n\t\n\tfunction hasUrlPrefix(opts) {\n\t  if (!opts.prefix) {\n\t    return false;\n\t  }\n\t\n\t  var protocol = parseUri(opts.prefix).protocol;\n\t\n\t  return protocol === 'http' || protocol === 'https';\n\t}\n\t\n\t// Get all the information you possibly can about the URI given by name and\n\t// return it as a suitable object.\n\tfunction getHost(name, opts) {\n\t\n\t  // encode db name if opts.prefix is a url (#5574)\n\t  if (hasUrlPrefix(opts)) {\n\t    var dbName = opts.name.substr(opts.prefix.length);\n\t    name = opts.prefix + encodeURIComponent(dbName);\n\t  }\n\t\n\t  // Prase the URI into all its little bits\n\t  var uri = parseUri(name);\n\t\n\t  // Store the user and password as a separate auth object\n\t  if (uri.user || uri.password) {\n\t    uri.auth = {username: uri.user, password: uri.password};\n\t  }\n\t\n\t  // Split the path part of the URI into parts using '/' as the delimiter\n\t  // after removing any leading '/' and any trailing '/'\n\t  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\t\n\t  // Store the first part as the database name and remove it from the parts\n\t  // array\n\t  uri.db = parts.pop();\n\t  // Prevent double encoding of URI component\n\t  if (uri.db.indexOf('%') === -1) {\n\t    uri.db = encodeURIComponent(uri.db);\n\t  }\n\t\n\t  // Restore the path by joining all the remaining parts (all the parts\n\t  // except for the database name) with '/'s\n\t  uri.path = parts.join('/');\n\t\n\t  return uri;\n\t}\n\t\n\t// Generate a URL with the host data given by opts and the given path\n\tfunction genDBUrl(opts, path) {\n\t  return genUrl(opts, opts.db + '/' + path);\n\t}\n\t\n\t// Generate a URL with the host data given by opts and the given path\n\tfunction genUrl(opts, path) {\n\t  // If the host already has a path, then we need to have a path delimiter\n\t  // Otherwise, the path delimiter is the empty string\n\t  var pathDel = !opts.path ? '' : '/';\n\t\n\t  // If the host already has a path, then we need to have a path delimiter\n\t  // Otherwise, the path delimiter is the empty string\n\t  return opts.protocol + '://' + opts.host +\n\t         (opts.port ? (':' + opts.port) : '') +\n\t         '/' + opts.path + pathDel + path;\n\t}\n\t\n\tfunction paramsToStr(params) {\n\t  return '?' + Object.keys(params).map(function (k) {\n\t    return k + '=' + encodeURIComponent(params[k]);\n\t  }).join('&');\n\t}\n\t\n\t// Implements the PouchDB API for dealing with CouchDB instances over HTTP\n\tfunction HttpPouch(opts, callback) {\n\t\n\t  // The functions that will be publicly available for HttpPouch\n\t  var api = this;\n\t\n\t  var host = getHost(opts.name, opts);\n\t  var dbUrl = genDBUrl(host, '');\n\t\n\t  opts = clone(opts);\n\t  var ajaxOpts = opts.ajax || {};\n\t\n\t  if (opts.auth || host.auth) {\n\t    var nAuth = opts.auth || host.auth;\n\t    var str = nAuth.username + ':' + nAuth.password;\n\t    var token = thisBtoa(unescape(encodeURIComponent(str)));\n\t    ajaxOpts.headers = ajaxOpts.headers || {};\n\t    ajaxOpts.headers.Authorization = 'Basic ' + token;\n\t  }\n\t\n\t  // Not strictly necessary, but we do this because numerous tests\n\t  // rely on swapping ajax in and out.\n\t  api._ajax = ajax;\n\t\n\t  function ajax$$1(userOpts, options, callback) {\n\t    var reqAjax = userOpts.ajax || {};\n\t    var reqOpts = assign$1(clone(ajaxOpts), reqAjax, options);\n\t    log$1(reqOpts.method + ' ' + reqOpts.url);\n\t    return api._ajax(reqOpts, callback);\n\t  }\n\t\n\t  function ajaxPromise(userOpts, opts) {\n\t    return new PouchPromise$1(function (resolve, reject) {\n\t      ajax$$1(userOpts, opts, function (err, res) {\n\t        /* istanbul ignore if */\n\t        if (err) {\n\t          return reject(err);\n\t        }\n\t        resolve(res);\n\t      });\n\t    });\n\t  }\n\t\n\t  function adapterFun$$1(name, fun) {\n\t    return adapterFun(name, getArguments(function (args) {\n\t      setup().then(function () {\n\t        return fun.apply(this, args);\n\t      }).catch(function (e) {\n\t        var callback = args.pop();\n\t        callback(e);\n\t      });\n\t    }));\n\t  }\n\t\n\t  var setupPromise;\n\t\n\t  function setup() {\n\t    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n\t    if (opts.skipSetup || opts.skip_setup) {\n\t      return PouchPromise$1.resolve();\n\t    }\n\t\n\t    // If there is a setup in process or previous successful setup\n\t    // done then we will use that\n\t    // If previous setups have been rejected we will try again\n\t    if (setupPromise) {\n\t      return setupPromise;\n\t    }\n\t\n\t    var checkExists = {method: 'GET', url: dbUrl};\n\t    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n\t      if (err && err.status && err.status === 404) {\n\t        // Doesnt exist, create it\n\t        explainError(404, 'PouchDB is just detecting if the remote exists.');\n\t        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n\t      } else {\n\t        return PouchPromise$1.reject(err);\n\t      }\n\t    }).catch(function (err) {\n\t      // If we try to create a database that already exists, skipped in\n\t      // istanbul since its catching a race condition.\n\t      /* istanbul ignore if */\n\t      if (err && err.status && err.status === 412) {\n\t        return true;\n\t      }\n\t      return PouchPromise$1.reject(err);\n\t    });\n\t\n\t    setupPromise.catch(function () {\n\t      setupPromise = null;\n\t    });\n\t\n\t    return setupPromise;\n\t  }\n\t\n\t  nextTick(function () {\n\t    callback(null, api);\n\t  });\n\t\n\t  api.type = function () {\n\t    return 'http';\n\t  };\n\t\n\t  api.id = adapterFun$$1('id', function (callback) {\n\t    ajax$$1({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n\t      var uuid$$1 = (result && result.uuid) ?\n\t        (result.uuid + host.db) : genDBUrl(host, '');\n\t      callback(null, uuid$$1);\n\t    });\n\t  });\n\t\n\t  api.request = adapterFun$$1('request', function (options, callback) {\n\t    options.url = genDBUrl(host, options.url);\n\t    ajax$$1({}, options, callback);\n\t  });\n\t\n\t  // Sends a POST request to the host calling the couchdb _compact function\n\t  //    version: The version of CouchDB it is running\n\t  api.compact = adapterFun$$1('compact', function (opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t    ajax$$1(opts, {\n\t      url: genDBUrl(host, '_compact'),\n\t      method: 'POST'\n\t    }, function () {\n\t      function ping() {\n\t        api.info(function (err, res) {\n\t          if (res && !res.compact_running) {\n\t            callback(null, {ok: true});\n\t          } else {\n\t            setTimeout(ping, opts.interval || 200);\n\t          }\n\t        });\n\t      }\n\t      // Ping the http if it's finished compaction\n\t      ping();\n\t    });\n\t  });\n\t\n\t  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n\t    var self = this;\n\t\n\t    function doBulkGet(cb) {\n\t      var params = {};\n\t      if (opts.revs) {\n\t        params.revs = true;\n\t      }\n\t      if (opts.attachments) {\n\t        /* istanbul ignore next */\n\t        params.attachments = true;\n\t      }\n\t      if (opts.latest) {\n\t        params.latest = true;\n\t      }\n\t      ajax$$1(opts, {\n\t        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n\t        method: 'POST',\n\t        body: { docs: opts.docs}\n\t      }, cb);\n\t    }\n\t\n\t    function doBulkGetShim() {\n\t      // avoid \"url too long error\" by splitting up into multiple requests\n\t      var batchSize = MAX_SIMULTANEOUS_REVS;\n\t      var numBatches = Math.ceil(opts.docs.length / batchSize);\n\t      var numDone = 0;\n\t      var results = new Array(numBatches);\n\t\n\t      function onResult(batchNum) {\n\t        return function (err, res) {\n\t          // err is impossible because shim returns a list of errs in that case\n\t          results[batchNum] = res.results;\n\t          if (++numDone === numBatches) {\n\t            callback(null, {results: flatten(results)});\n\t          }\n\t        };\n\t      }\n\t\n\t      for (var i = 0; i < numBatches; i++) {\n\t        var subOpts = pick(opts, ['revs', 'attachments', 'latest']);\n\t        subOpts.ajax = ajaxOpts;\n\t        subOpts.docs = opts.docs.slice(i * batchSize,\n\t          Math.min(opts.docs.length, (i + 1) * batchSize));\n\t        bulkGet(self, subOpts, onResult(i));\n\t      }\n\t    }\n\t\n\t    // mark the whole database as either supporting or not supporting _bulk_get\n\t    var dbUrl = genUrl(host, '');\n\t    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\t\n\t    if (typeof supportsBulkGet !== 'boolean') {\n\t      // check if this database supports _bulk_get\n\t      doBulkGet(function (err, res) {\n\t        /* istanbul ignore else */\n\t        if (err) {\n\t          supportsBulkGetMap[dbUrl] = false;\n\t          explainError(\n\t            err.status,\n\t            'PouchDB is just detecting if the remote ' +\n\t            'supports the _bulk_get API.'\n\t          );\n\t          doBulkGetShim();\n\t        } else {\n\t          supportsBulkGetMap[dbUrl] = true;\n\t          callback(null, res);\n\t        }\n\t      });\n\t    } else if (supportsBulkGet) {\n\t      /* istanbul ignore next */\n\t      doBulkGet(callback);\n\t    } else {\n\t      doBulkGetShim();\n\t    }\n\t  });\n\t\n\t  // Calls GET on the host, which gets back a JSON string containing\n\t  //    couchdb: A welcome string\n\t  //    version: The version of CouchDB it is running\n\t  api._info = function (callback) {\n\t    setup().then(function () {\n\t      ajax$$1({}, {\n\t        method: 'GET',\n\t        url: genDBUrl(host, '')\n\t      }, function (err, res) {\n\t        /* istanbul ignore next */\n\t        if (err) {\n\t        return callback(err);\n\t        }\n\t        res.host = genDBUrl(host, '');\n\t        callback(null, res);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t  // Get the document with the given id from the database given by host.\n\t  // The id could be solely the _id in the database, or it may be a\n\t  // _design/ID or _local/ID path\n\t  api.get = adapterFun$$1('get', function (id, opts, callback) {\n\t    // If no options were given, set the callback to the second parameter\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t\n\t    // List of parameters to add to the GET request\n\t    var params = {};\n\t\n\t    if (opts.revs) {\n\t      params.revs = true;\n\t    }\n\t\n\t    if (opts.revs_info) {\n\t      params.revs_info = true;\n\t    }\n\t\n\t    if (opts.latest) {\n\t      params.latest = true;\n\t    }\n\t\n\t    if (opts.open_revs) {\n\t      if (opts.open_revs !== \"all\") {\n\t        opts.open_revs = JSON.stringify(opts.open_revs);\n\t      }\n\t      params.open_revs = opts.open_revs;\n\t    }\n\t\n\t    if (opts.rev) {\n\t      params.rev = opts.rev;\n\t    }\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = opts.conflicts;\n\t    }\n\t\n\t    id = encodeDocId(id);\n\t\n\t    // Set the options for the ajax call\n\t    var options = {\n\t      method: 'GET',\n\t      url: genDBUrl(host, id + paramsToStr(params))\n\t    };\n\t\n\t    function fetchAttachments(doc) {\n\t      var atts = doc._attachments;\n\t      var filenames = atts && Object.keys(atts);\n\t      if (!atts || !filenames.length) {\n\t        return;\n\t      }\n\t      // we fetch these manually in separate XHRs, because\n\t      // Sync Gateway would normally send it back as multipart/mixed,\n\t      // which we cannot parse. Also, this is more efficient than\n\t      // receiving attachments as base64-encoded strings.\n\t      function fetch(filename) {\n\t        var att = atts[filename];\n\t        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n\t          '?rev=' + doc._rev;\n\t        return ajaxPromise(opts, {\n\t          method: 'GET',\n\t          url: genDBUrl(host, path),\n\t          binary: true\n\t        }).then(function (blob$$1) {\n\t          if (opts.binary) {\n\t            return blob$$1;\n\t          }\n\t          return new PouchPromise$1(function (resolve) {\n\t            blobToBase64(blob$$1, resolve);\n\t          });\n\t        }).then(function (data) {\n\t          delete att.stub;\n\t          delete att.length;\n\t          att.data = data;\n\t        });\n\t      }\n\t\n\t      var promiseFactories = filenames.map(function (filename) {\n\t        return function () {\n\t          return fetch(filename);\n\t        };\n\t      });\n\t\n\t      // This limits the number of parallel xhr requests to 5 any time\n\t      // to avoid issues with maximum browser request limits\n\t      return pool(promiseFactories, 5);\n\t    }\n\t\n\t    function fetchAllAttachments(docOrDocs) {\n\t      if (Array.isArray(docOrDocs)) {\n\t        return PouchPromise$1.all(docOrDocs.map(function (doc) {\n\t          if (doc.ok) {\n\t            return fetchAttachments(doc.ok);\n\t          }\n\t        }));\n\t      }\n\t      return fetchAttachments(docOrDocs);\n\t    }\n\t\n\t    ajaxPromise(opts, options).then(function (res) {\n\t      return PouchPromise$1.resolve().then(function () {\n\t        if (opts.attachments) {\n\t          return fetchAllAttachments(res);\n\t        }\n\t      }).then(function () {\n\t        callback(null, res);\n\t      });\n\t    }).catch(callback);\n\t  });\n\t\n\t  // Delete the document given by doc from the database given by host.\n\t  api.remove = adapterFun$$1('remove',\n\t      function (docOrId, optsOrRev, opts, callback) {\n\t    var doc;\n\t    if (typeof optsOrRev === 'string') {\n\t      // id, rev, opts, callback style\n\t      doc = {\n\t        _id: docOrId,\n\t        _rev: optsOrRev\n\t      };\n\t      if (typeof opts === 'function') {\n\t        callback = opts;\n\t        opts = {};\n\t      }\n\t    } else {\n\t      // doc, opts, callback style\n\t      doc = docOrId;\n\t      if (typeof optsOrRev === 'function') {\n\t        callback = optsOrRev;\n\t        opts = {};\n\t      } else {\n\t        callback = opts;\n\t        opts = optsOrRev;\n\t      }\n\t    }\n\t\n\t    var rev = (doc._rev || opts.rev);\n\t\n\t    // Delete the document\n\t    ajax$$1(opts, {\n\t      method: 'DELETE',\n\t      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev\n\t    }, callback);\n\t  });\n\t\n\t  function encodeAttachmentId(attachmentId) {\n\t    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n\t  }\n\t\n\t  // Get the attachment\n\t  api.getAttachment =\n\t    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n\t                                                callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n\t    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n\t      encodeAttachmentId(attachmentId) + params;\n\t    ajax$$1(opts, {\n\t      method: 'GET',\n\t      url: url,\n\t      binary: true\n\t    }, callback);\n\t  });\n\t\n\t  // Remove the attachment given by the id and rev\n\t  api.removeAttachment =\n\t    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev,\n\t                                                   callback) {\n\t\n\t    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n\t      encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n\t\n\t    ajax$$1({}, {\n\t      method: 'DELETE',\n\t      url: url\n\t    }, callback);\n\t  });\n\t\n\t  // Add the attachment given by blob and its contentType property\n\t  // to the document with the given id, the revision given by rev, and\n\t  // add it to the database given by host.\n\t  api.putAttachment =\n\t    adapterFun$$1('putAttachment', function (docId, attachmentId, rev, blob$$1,\n\t                                                type, callback) {\n\t    if (typeof type === 'function') {\n\t      callback = type;\n\t      type = blob$$1;\n\t      blob$$1 = rev;\n\t      rev = null;\n\t    }\n\t    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n\t    var url = genDBUrl(host, id);\n\t    if (rev) {\n\t      url += '?rev=' + rev;\n\t    }\n\t\n\t    if (typeof blob$$1 === 'string') {\n\t      // input is assumed to be a base64 string\n\t      var binary;\n\t      try {\n\t        binary = thisAtob(blob$$1);\n\t      } catch (err) {\n\t        return callback(createError(BAD_ARG,\n\t                        'Attachment is not a valid base64 string'));\n\t      }\n\t      blob$$1 = binary ? binStringToBluffer(binary, type) : '';\n\t    }\n\t\n\t    var opts = {\n\t      headers: {'Content-Type': type},\n\t      method: 'PUT',\n\t      url: url,\n\t      processData: false,\n\t      body: blob$$1,\n\t      timeout: ajaxOpts.timeout || 60000\n\t    };\n\t    // Add the attachment\n\t    ajax$$1({}, opts, callback);\n\t  });\n\t\n\t  // Update/create multiple documents given by req in the database\n\t  // given by host.\n\t  api._bulkDocs = function (req, opts, callback) {\n\t    // If new_edits=false then it prevents the database from creating\n\t    // new revision numbers for the documents. Instead it just uses\n\t    // the old ones. This is used in database replication.\n\t    req.new_edits = opts.new_edits;\n\t\n\t    setup().then(function () {\n\t      return PouchPromise$1.all(req.docs.map(preprocessAttachments$2));\n\t    }).then(function () {\n\t      // Update/create the documents\n\t      ajax$$1(opts, {\n\t        method: 'POST',\n\t        url: genDBUrl(host, '_bulk_docs'),\n\t        timeout: opts.timeout,\n\t        body: req\n\t      }, function (err, results) {\n\t        if (err) {\n\t          return callback(err);\n\t        }\n\t        results.forEach(function (result) {\n\t          result.ok = true; // smooths out cloudant not adding this\n\t        });\n\t        callback(null, results);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t\n\t  // Update/create document\n\t  api._put = function (doc, opts, callback) {\n\t    setup().then(function () {\n\t      return preprocessAttachments$2(doc);\n\t    }).then(function () {\n\t      // Update/create the document\n\t      ajax$$1(opts, {\n\t        method: 'PUT',\n\t        url: genDBUrl(host, encodeDocId(doc._id)),\n\t        body: doc\n\t      }, function (err, result) {\n\t        if (err) {\n\t          return callback(err);\n\t        }\n\t        callback(null, result);\n\t      });\n\t    }).catch(callback);\n\t  };\n\t\n\t\n\t  // Get a listing of the documents in the database given\n\t  // by host and ordered by increasing id.\n\t  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t    opts = clone(opts);\n\t\n\t    // List of parameters to add to the GET request\n\t    var params = {};\n\t    var body;\n\t    var method = 'GET';\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = true;\n\t    }\n\t\n\t    if (opts.descending) {\n\t      params.descending = true;\n\t    }\n\t\n\t    if (opts.include_docs) {\n\t      params.include_docs = true;\n\t    }\n\t\n\t    // added in CouchDB 1.6.0\n\t    if (opts.attachments) {\n\t      params.attachments = true;\n\t    }\n\t\n\t    if (opts.key) {\n\t      params.key = JSON.stringify(opts.key);\n\t    }\n\t\n\t    if (opts.start_key) {\n\t      opts.startkey = opts.start_key;\n\t    }\n\t\n\t    if (opts.startkey) {\n\t      params.startkey = JSON.stringify(opts.startkey);\n\t    }\n\t\n\t    if (opts.end_key) {\n\t      opts.endkey = opts.end_key;\n\t    }\n\t\n\t    if (opts.endkey) {\n\t      params.endkey = JSON.stringify(opts.endkey);\n\t    }\n\t\n\t    if (typeof opts.inclusive_end !== 'undefined') {\n\t      params.inclusive_end = !!opts.inclusive_end;\n\t    }\n\t\n\t    if (typeof opts.limit !== 'undefined') {\n\t      params.limit = opts.limit;\n\t    }\n\t\n\t    if (typeof opts.skip !== 'undefined') {\n\t      params.skip = opts.skip;\n\t    }\n\t\n\t    var paramStr = paramsToStr(params);\n\t\n\t    if (typeof opts.keys !== 'undefined') {\n\t      method = 'POST';\n\t      body = {keys: opts.keys};\n\t    }\n\t\n\t    // Get the document listing\n\t    ajaxPromise(opts, {\n\t      method: method,\n\t      url: genDBUrl(host, '_all_docs' + paramStr),\n\t      body: body\n\t    }).then(function (res) {\n\t      if (opts.include_docs && opts.attachments && opts.binary) {\n\t        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n\t      }\n\t      callback(null, res);\n\t    }).catch(callback);\n\t  });\n\t\n\t  // Get a list of changes made to documents in the database given by host.\n\t  // TODO According to the README, there should be two other methods here,\n\t  // api.changes.addListener and api.changes.removeListener.\n\t  api._changes = function (opts) {\n\t\n\t    // We internally page the results of a changes request, this means\n\t    // if there is a large set of changes to be returned we can start\n\t    // processing them quicker instead of waiting on the entire\n\t    // set of changes to return and attempting to process them at once\n\t    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\t\n\t    opts = clone(opts);\n\t    opts.timeout = ('timeout' in opts) ? opts.timeout :\n\t      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n\t      30 * 1000;\n\t\n\t    // We give a 5 second buffer for CouchDB changes to respond with\n\t    // an ok timeout (if a timeout it set)\n\t    var params = opts.timeout ? {timeout: opts.timeout - (5 * 1000)} : {};\n\t    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n\t    var returnDocs;\n\t    if ('return_docs' in opts) {\n\t      returnDocs = opts.return_docs;\n\t    } else if ('returnDocs' in opts) {\n\t      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n\t      returnDocs = opts.returnDocs;\n\t    } else {\n\t      returnDocs = true;\n\t    }\n\t    //\n\t    var leftToFetch = limit;\n\t\n\t    if (opts.style) {\n\t      params.style = opts.style;\n\t    }\n\t\n\t    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n\t      params.include_docs = true;\n\t    }\n\t\n\t    if (opts.attachments) {\n\t      params.attachments = true;\n\t    }\n\t\n\t    if (opts.continuous) {\n\t      params.feed = 'longpoll';\n\t    }\n\t\n\t    if (opts.conflicts) {\n\t      params.conflicts = true;\n\t    }\n\t\n\t    if (opts.descending) {\n\t      params.descending = true;\n\t    }\n\t\n\t    if ('heartbeat' in opts) {\n\t      // If the heartbeat value is false, it disables the default heartbeat\n\t      if (opts.heartbeat) {\n\t        params.heartbeat = opts.heartbeat;\n\t      }\n\t    } else if (opts.continuous) {\n\t      // Default heartbeat to 10 seconds\n\t      params.heartbeat = 10000;\n\t    }\n\t\n\t    if (opts.filter && typeof opts.filter === 'string') {\n\t      params.filter = opts.filter;\n\t    }\n\t\n\t    if (opts.view && typeof opts.view === 'string') {\n\t      params.filter = '_view';\n\t      params.view = opts.view;\n\t    }\n\t\n\t    // If opts.query_params exists, pass it through to the changes request.\n\t    // These parameters may be used by the filter on the source database.\n\t    if (opts.query_params && typeof opts.query_params === 'object') {\n\t      for (var param_name in opts.query_params) {\n\t        /* istanbul ignore else */\n\t        if (opts.query_params.hasOwnProperty(param_name)) {\n\t          params[param_name] = opts.query_params[param_name];\n\t        }\n\t      }\n\t    }\n\t\n\t    var method = 'GET';\n\t    var body;\n\t\n\t    if (opts.doc_ids) {\n\t      // set this automagically for the user; it's annoying that couchdb\n\t      // requires both a \"filter\" and a \"doc_ids\" param.\n\t      params.filter = '_doc_ids';\n\t      method = 'POST';\n\t      body = {doc_ids: opts.doc_ids };\n\t    }\n\t\n\t    var xhr;\n\t    var lastFetchedSeq;\n\t\n\t    // Get all the changes starting wtih the one immediately after the\n\t    // sequence number given by since.\n\t    var fetch = function (since, callback) {\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t      params.since = since;\n\t      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n\t      /* istanbul ignore next */\n\t      if (typeof params.since === \"object\") {\n\t        params.since = JSON.stringify(params.since);\n\t      }\n\t\n\t      if (opts.descending) {\n\t        if (limit) {\n\t          params.limit = leftToFetch;\n\t        }\n\t      } else {\n\t        params.limit = (!limit || leftToFetch > batchSize) ?\n\t          batchSize : leftToFetch;\n\t      }\n\t\n\t      // Set the options for the ajax call\n\t      var xhrOpts = {\n\t        method: method,\n\t        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n\t        timeout: opts.timeout,\n\t        body: body\n\t      };\n\t      lastFetchedSeq = since;\n\t\n\t      /* istanbul ignore if */\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t\n\t      // Get the changes\n\t      setup().then(function () {\n\t        xhr = ajax$$1(opts, xhrOpts, callback);\n\t      }).catch(callback);\n\t    };\n\t\n\t    // If opts.since exists, get all the changes from the sequence\n\t    // number given by opts.since. Otherwise, get all the changes\n\t    // from the sequence number 0.\n\t    var results = {results: []};\n\t\n\t    var fetched = function (err, res) {\n\t      if (opts.aborted) {\n\t        return;\n\t      }\n\t      var raw_results_length = 0;\n\t      // If the result of the ajax call (res) contains changes (res.results)\n\t      if (res && res.results) {\n\t        raw_results_length = res.results.length;\n\t        results.last_seq = res.last_seq;\n\t        // For each change\n\t        var req = {};\n\t        req.query = opts.query_params;\n\t        res.results = res.results.filter(function (c) {\n\t          leftToFetch--;\n\t          var ret = filterChange(opts)(c);\n\t          if (ret) {\n\t            if (opts.include_docs && opts.attachments && opts.binary) {\n\t              readAttachmentsAsBlobOrBuffer(c);\n\t            }\n\t            if (returnDocs) {\n\t              results.results.push(c);\n\t            }\n\t            opts.onChange(c);\n\t          }\n\t          return ret;\n\t        });\n\t      } else if (err) {\n\t        // In case of an error, stop listening for changes and call\n\t        // opts.complete\n\t        opts.aborted = true;\n\t        opts.complete(err);\n\t        return;\n\t      }\n\t\n\t      // The changes feed may have timed out with no results\n\t      // if so reuse last update sequence\n\t      if (res && res.last_seq) {\n\t        lastFetchedSeq = res.last_seq;\n\t      }\n\t\n\t      var finished = (limit && leftToFetch <= 0) ||\n\t        (res && raw_results_length < batchSize) ||\n\t        (opts.descending);\n\t\n\t      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n\t        // Queue a call to fetch again with the newest sequence number\n\t        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n\t      } else {\n\t        // We're done, call the callback\n\t        opts.complete(null, results);\n\t      }\n\t    };\n\t\n\t    fetch(opts.since || 0, fetched);\n\t\n\t    // Return a method to cancel this method from processing any more\n\t    return {\n\t      cancel: function () {\n\t        opts.aborted = true;\n\t        if (xhr) {\n\t          xhr.abort();\n\t        }\n\t      }\n\t    };\n\t  };\n\t\n\t  // Given a set of document/revision IDs (given by req), tets the subset of\n\t  // those that do NOT correspond to revisions stored in the database.\n\t  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n\t  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n\t    // If no options were given, set the callback to be the second parameter\n\t    if (typeof opts === 'function') {\n\t      callback = opts;\n\t      opts = {};\n\t    }\n\t\n\t    // Get the missing document/revision IDs\n\t    ajax$$1(opts, {\n\t      method: 'POST',\n\t      url: genDBUrl(host, '_revs_diff'),\n\t      body: req\n\t    }, callback);\n\t  });\n\t\n\t  api._close = function (callback) {\n\t    callback();\n\t  };\n\t\n\t  api._destroy = function (options, callback) {\n\t    ajax$$1(options, {\n\t      url: genDBUrl(host, ''),\n\t      method: 'DELETE'\n\t    }, function (err, resp) {\n\t      if (err && err.status && err.status !== 404) {\n\t        return callback(err);\n\t      }\n\t      callback(null, resp);\n\t    });\n\t  };\n\t}\n\t\n\t// HttpPouch is a valid adapter.\n\tHttpPouch.valid = function () {\n\t  return true;\n\t};\n\t\n\tvar HttpPouch$1 = function (PouchDB) {\n\t  PouchDB.adapter('http', HttpPouch, false);\n\t  PouchDB.adapter('https', HttpPouch, false);\n\t};\n\t\n\tfunction pad(str, padWith, upToLength) {\n\t  var padding = '';\n\t  var targetLength = upToLength - str.length;\n\t  /* istanbul ignore next */\n\t  while (padding.length < targetLength) {\n\t    padding += padWith;\n\t  }\n\t  return padding;\n\t}\n\t\n\tfunction padLeft(str, padWith, upToLength) {\n\t  var padding = pad(str, padWith, upToLength);\n\t  return padding + str;\n\t}\n\t\n\tvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\n\tvar MAGNITUDE_DIGITS = 3; // ditto\n\tvar SEP = ''; // set to '_' for easier debugging \n\t\n\tfunction collate(a, b) {\n\t\n\t  if (a === b) {\n\t    return 0;\n\t  }\n\t\n\t  a = normalizeKey(a);\n\t  b = normalizeKey(b);\n\t\n\t  var ai = collationIndex(a);\n\t  var bi = collationIndex(b);\n\t  if ((ai - bi) !== 0) {\n\t    return ai - bi;\n\t  }\n\t  switch (typeof a) {\n\t    case 'number':\n\t      return a - b;\n\t    case 'boolean':\n\t      return a < b ? -1 : 1;\n\t    case 'string':\n\t      return stringCollate(a, b);\n\t  }\n\t  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n\t}\n\t\n\t// couch considers null/NaN/Infinity/-Infinity === undefined,\n\t// for the purposes of mapreduce indexes. also, dates get stringified.\n\tfunction normalizeKey(key) {\n\t  switch (typeof key) {\n\t    case 'undefined':\n\t      return null;\n\t    case 'number':\n\t      if (key === Infinity || key === -Infinity || isNaN(key)) {\n\t        return null;\n\t      }\n\t      return key;\n\t    case 'object':\n\t      var origKey = key;\n\t      if (Array.isArray(key)) {\n\t        var len = key.length;\n\t        key = new Array(len);\n\t        for (var i = 0; i < len; i++) {\n\t          key[i] = normalizeKey(origKey[i]);\n\t        }\n\t      /* istanbul ignore next */\n\t      } else if (key instanceof Date) {\n\t        return key.toJSON();\n\t      } else if (key !== null) { // generic object\n\t        key = {};\n\t        for (var k in origKey) {\n\t          if (origKey.hasOwnProperty(k)) {\n\t            var val = origKey[k];\n\t            if (typeof val !== 'undefined') {\n\t              key[k] = normalizeKey(val);\n\t            }\n\t          }\n\t        }\n\t      }\n\t  }\n\t  return key;\n\t}\n\t\n\tfunction indexify(key) {\n\t  if (key !== null) {\n\t    switch (typeof key) {\n\t      case 'boolean':\n\t        return key ? 1 : 0;\n\t      case 'number':\n\t        return numToIndexableString(key);\n\t      case 'string':\n\t        // We've to be sure that key does not contain \\u0000\n\t        // Do order-preserving replacements:\n\t        // 0 -> 1, 1\n\t        // 1 -> 1, 2\n\t        // 2 -> 2, 2\n\t        return key\n\t          .replace(/\\u0002/g, '\\u0002\\u0002')\n\t          .replace(/\\u0001/g, '\\u0001\\u0002')\n\t          .replace(/\\u0000/g, '\\u0001\\u0001');\n\t      case 'object':\n\t        var isArray = Array.isArray(key);\n\t        var arr = isArray ? key : Object.keys(key);\n\t        var i = -1;\n\t        var len = arr.length;\n\t        var result = '';\n\t        if (isArray) {\n\t          while (++i < len) {\n\t            result += toIndexableString(arr[i]);\n\t          }\n\t        } else {\n\t          while (++i < len) {\n\t            var objKey = arr[i];\n\t            result += toIndexableString(objKey) +\n\t                toIndexableString(key[objKey]);\n\t          }\n\t        }\n\t        return result;\n\t    }\n\t  }\n\t  return '';\n\t}\n\t\n\t// convert the given key to a string that would be appropriate\n\t// for lexical sorting, e.g. within a database, where the\n\t// sorting is the same given by the collate() function.\n\tfunction toIndexableString(key) {\n\t  var zero = '\\u0000';\n\t  key = normalizeKey(key);\n\t  return collationIndex(key) + SEP + indexify(key) + zero;\n\t}\n\t\n\tfunction parseNumber(str, i) {\n\t  var originalIdx = i;\n\t  var num;\n\t  var zero = str[i] === '1';\n\t  if (zero) {\n\t    num = 0;\n\t    i++;\n\t  } else {\n\t    var neg = str[i] === '0';\n\t    i++;\n\t    var numAsString = '';\n\t    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n\t    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n\t    /* istanbul ignore next */\n\t    if (neg) {\n\t      magnitude = -magnitude;\n\t    }\n\t    i += MAGNITUDE_DIGITS;\n\t    while (true) {\n\t      var ch = str[i];\n\t      if (ch === '\\u0000') {\n\t        break;\n\t      } else {\n\t        numAsString += ch;\n\t      }\n\t      i++;\n\t    }\n\t    numAsString = numAsString.split('.');\n\t    if (numAsString.length === 1) {\n\t      num = parseInt(numAsString, 10);\n\t    } else {\n\t      /* istanbul ignore next */\n\t      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n\t    }\n\t    /* istanbul ignore next */\n\t    if (neg) {\n\t      num = num - 10;\n\t    }\n\t    /* istanbul ignore next */\n\t    if (magnitude !== 0) {\n\t      // parseFloat is more reliable than pow due to rounding errors\n\t      // e.g. Number.MAX_VALUE would return Infinity if we did\n\t      // num * Math.pow(10, magnitude);\n\t      num = parseFloat(num + 'e' + magnitude);\n\t    }\n\t  }\n\t  return {num: num, length : i - originalIdx};\n\t}\n\t\n\t// move up the stack while parsing\n\t// this function moved outside of parseIndexableString for performance\n\tfunction pop(stack, metaStack) {\n\t  var obj = stack.pop();\n\t\n\t  if (metaStack.length) {\n\t    var lastMetaElement = metaStack[metaStack.length - 1];\n\t    if (obj === lastMetaElement.element) {\n\t      // popping a meta-element, e.g. an object whose value is another object\n\t      metaStack.pop();\n\t      lastMetaElement = metaStack[metaStack.length - 1];\n\t    }\n\t    var element = lastMetaElement.element;\n\t    var lastElementIndex = lastMetaElement.index;\n\t    if (Array.isArray(element)) {\n\t      element.push(obj);\n\t    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t      var key = stack.pop();\n\t      element[key] = obj;\n\t    } else {\n\t      stack.push(obj); // obj with key only\n\t    }\n\t  }\n\t}\n\t\n\tfunction parseIndexableString(str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t\n\t  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\t  while (true) {\n\t    var collationIndex = str[i++];\n\t    if (collationIndex === '\\u0000') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case '1':\n\t        stack.push(null);\n\t        break;\n\t      case '2':\n\t        stack.push(str[i] === '1');\n\t        i++;\n\t        break;\n\t      case '3':\n\t        var parsedNum = parseNumber(str, i);\n\t        stack.push(parsedNum.num);\n\t        i += parsedNum.length;\n\t        break;\n\t      case '4':\n\t        var parsedStr = '';\n\t        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n\t        while (true) {\n\t          var ch = str[i];\n\t          if (ch === '\\u0000') {\n\t            break;\n\t          }\n\t          parsedStr += ch;\n\t          i++;\n\t        }\n\t        // perform the reverse of the order-preserving replacement\n\t        // algorithm (see above)\n\t        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n\t          .replace(/\\u0001\\u0002/g, '\\u0001')\n\t          .replace(/\\u0002\\u0002/g, '\\u0002');\n\t        stack.push(parsedStr);\n\t        break;\n\t      case '5':\n\t        var arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '6':\n\t        var objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      /* istanbul ignore next */\n\t      default:\n\t        throw new Error(\n\t          'bad collationIndex or unexpectedly reached end of input: ' +\n\t            collationIndex);\n\t    }\n\t  }\n\t}\n\t\n\tfunction arrayCollate(a, b) {\n\t  var len = Math.min(a.length, b.length);\n\t  for (var i = 0; i < len; i++) {\n\t    var sort = collate(a[i], b[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t  }\n\t  return (a.length === b.length) ? 0 :\n\t    (a.length > b.length) ? 1 : -1;\n\t}\n\tfunction stringCollate(a, b) {\n\t  // See: https://github.com/daleharvey/pouchdb/issues/40\n\t  // This is incompatible with the CouchDB implementation, but its the\n\t  // best we can do for now\n\t  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n\t}\n\tfunction objectCollate(a, b) {\n\t  var ak = Object.keys(a), bk = Object.keys(b);\n\t  var len = Math.min(ak.length, bk.length);\n\t  for (var i = 0; i < len; i++) {\n\t    // First sort the keys\n\t    var sort = collate(ak[i], bk[i]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t    // if the keys are equal sort the values\n\t    sort = collate(a[ak[i]], b[bk[i]]);\n\t    if (sort !== 0) {\n\t      return sort;\n\t    }\n\t\n\t  }\n\t  return (ak.length === bk.length) ? 0 :\n\t    (ak.length > bk.length) ? 1 : -1;\n\t}\n\t// The collation is defined by erlangs ordered terms\n\t// the atoms null, true, false come first, then numbers, strings,\n\t// arrays, then objects\n\t// null/undefined/NaN/Infinity/-Infinity are all considered null\n\tfunction collationIndex(x) {\n\t  var id = ['boolean', 'number', 'string', 'object'];\n\t  var idx = id.indexOf(typeof x);\n\t  //false if -1 otherwise true, but fast!!!!1\n\t  if (~idx) {\n\t    if (x === null) {\n\t      return 1;\n\t    }\n\t    if (Array.isArray(x)) {\n\t      return 5;\n\t    }\n\t    return idx < 3 ? (idx + 2) : (idx + 3);\n\t  }\n\t  /* istanbul ignore next */\n\t  if (Array.isArray(x)) {\n\t    return 5;\n\t  }\n\t}\n\t\n\t// conversion:\n\t// x yyy zz...zz\n\t// x = 0 for negative, 1 for 0, 2 for positive\n\t// y = exponent (for negative numbers negated) moved so that it's >= 0\n\t// z = mantisse\n\tfunction numToIndexableString(num) {\n\t\n\t  if (num === 0) {\n\t    return '1';\n\t  }\n\t\n\t  // convert number to exponential format for easier and\n\t  // more succinct string sorting\n\t  var expFormat = num.toExponential().split(/e\\+?/);\n\t  var magnitude = parseInt(expFormat[1], 10);\n\t\n\t  var neg = num < 0;\n\t\n\t  var result = neg ? '0' : '2';\n\t\n\t  // first sort by magnitude\n\t  // it's easier if all magnitudes are positive\n\t  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n\t  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\t\n\t  result += SEP + magString;\n\t\n\t  // then sort by the factor\n\t  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n\t  /* istanbul ignore next */\n\t  if (neg) { // for negative reverse ordering\n\t    factor = 10 - factor;\n\t  }\n\t\n\t  var factorStr = factor.toFixed(20);\n\t\n\t  // strip zeros from the end\n\t  factorStr = factorStr.replace(/\\.?0+$/, '');\n\t\n\t  result += SEP + factorStr;\n\t\n\t  return result;\n\t}\n\t\n\t/*\n\t * Simple task queue to sequentialize actions. Assumes\n\t * callbacks will eventually fire (once).\n\t */\n\t\n\tfunction TaskQueue$2() {\n\t  this.promise = new PouchPromise$1(function (fulfill) {fulfill(); });\n\t}\n\tTaskQueue$2.prototype.add = function (promiseFactory) {\n\t  this.promise = this.promise.catch(function () {\n\t    // just recover\n\t  }).then(function () {\n\t    return promiseFactory();\n\t  });\n\t  return this.promise;\n\t};\n\tTaskQueue$2.prototype.finish = function () {\n\t  return this.promise;\n\t};\n\t\n\tfunction createView(opts) {\n\t  var sourceDB = opts.db;\n\t  var viewName = opts.viewName;\n\t  var mapFun = opts.map;\n\t  var reduceFun = opts.reduce;\n\t  var temporary = opts.temporary;\n\t\n\t  // the \"undefined\" part is for backwards compatibility\n\t  var viewSignature = mapFun.toString() + (reduceFun && reduceFun.toString()) +\n\t    'undefined';\n\t\n\t  var cachedViews;\n\t  if (!temporary) {\n\t    // cache this to ensure we don't try to update the same view twice\n\t    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n\t    if (cachedViews[viewSignature]) {\n\t      return cachedViews[viewSignature];\n\t    }\n\t  }\n\t\n\t  var promiseForView = sourceDB.info().then(function (info) {\n\t\n\t    var depDbName = info.db_name + '-mrview-' +\n\t      (temporary ? 'temp' : stringMd5(viewSignature));\n\t\n\t    // save the view name in the source db so it can be cleaned up if necessary\n\t    // (e.g. when the _design doc is deleted, remove all associated view data)\n\t    function diffFunction(doc) {\n\t      doc.views = doc.views || {};\n\t      var fullViewName = viewName;\n\t      if (fullViewName.indexOf('/') === -1) {\n\t        fullViewName = viewName + '/' + viewName;\n\t      }\n\t      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n\t      /* istanbul ignore if */\n\t      if (depDbs[depDbName]) {\n\t        return; // no update necessary\n\t      }\n\t      depDbs[depDbName] = true;\n\t      return doc;\n\t    }\n\t    return upsert(sourceDB, '_local/mrviews', diffFunction).then(function () {\n\t      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n\t        var db = res.db;\n\t        db.auto_compaction = true;\n\t        var view = {\n\t          name: depDbName,\n\t          db: db,\n\t          sourceDB: sourceDB,\n\t          adapter: sourceDB.adapter,\n\t          mapFun: mapFun,\n\t          reduceFun: reduceFun\n\t        };\n\t        return view.db.get('_local/lastSeq').catch(function (err) {\n\t          /* istanbul ignore if */\n\t          if (err.status !== 404) {\n\t            throw err;\n\t          }\n\t        }).then(function (lastSeqDoc) {\n\t          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n\t          if (cachedViews) {\n\t            view.db.once('destroyed', function () {\n\t              delete cachedViews[viewSignature];\n\t            });\n\t          }\n\t          return view;\n\t        });\n\t      });\n\t    });\n\t  });\n\t\n\t  if (cachedViews) {\n\t    cachedViews[viewSignature] = promiseForView;\n\t  }\n\t  return promiseForView;\n\t}\n\t\n\tfunction QueryParseError(message) {\n\t  this.status = 400;\n\t  this.name = 'query_parse_error';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, QueryParseError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(QueryParseError, Error);\n\t\n\tfunction NotFoundError(message) {\n\t  this.status = 404;\n\t  this.name = 'not_found';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, NotFoundError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(NotFoundError, Error);\n\t\n\tfunction BuiltInError(message) {\n\t  this.status = 500;\n\t  this.name = 'invalid_value';\n\t  this.message = message;\n\t  this.error = true;\n\t  try {\n\t    Error.captureStackTrace(this, BuiltInError);\n\t  } catch (e) {}\n\t}\n\t\n\tinherits(BuiltInError, Error);\n\t\n\tfunction createBuiltInError(name) {\n\t  var message = 'builtin ' + name +\n\t    ' function requires map values to be numbers' +\n\t    ' or number arrays';\n\t  return new BuiltInError(message);\n\t}\n\t\n\tfunction sum(values) {\n\t  var result = 0;\n\t  for (var i = 0, len = values.length; i < len; i++) {\n\t    var num = values[i];\n\t    if (typeof num !== 'number') {\n\t      if (Array.isArray(num)) {\n\t        // lists of numbers are also allowed, sum them separately\n\t        result = typeof result === 'number' ? [result] : result;\n\t        for (var j = 0, jLen = num.length; j < jLen; j++) {\n\t          var jNum = num[j];\n\t          if (typeof jNum !== 'number') {\n\t            throw createBuiltInError('_sum');\n\t          } else if (typeof result[j] === 'undefined') {\n\t            result.push(jNum);\n\t          } else {\n\t            result[j] += jNum;\n\t          }\n\t        }\n\t      } else { // not array/number\n\t        throw createBuiltInError('_sum');\n\t      }\n\t    } else if (typeof result === 'number') {\n\t      result += num;\n\t    } else { // add number to array\n\t      result[0] += num;\n\t    }\n\t  }\n\t  return result;\n\t}\n\t\n\tvar log$2 = guardedConsole.bind(null, 'log');\n\tvar isArray = Array.isArray;\n\tvar toJSON = JSON.parse;\n\t\n\tfunction evalFunctionWithEval(func, emit) {\n\t  return scopedEval(\n\t    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n\t    {\n\t      emit: emit,\n\t      sum: sum,\n\t      log: log$2,\n\t      isArray: isArray,\n\t      toJSON: toJSON\n\t    }\n\t  );\n\t}\n\t\n\tfunction promisedCallback(promise, callback) {\n\t  if (callback) {\n\t    promise.then(function (res) {\n\t      nextTick(function () {\n\t        callback(null, res);\n\t      });\n\t    }, function (reason) {\n\t      nextTick(function () {\n\t        callback(reason);\n\t      });\n\t    });\n\t  }\n\t  return promise;\n\t}\n\t\n\tfunction callbackify(fun) {\n\t  return getArguments(function (args) {\n\t    var cb = args.pop();\n\t    var promise = fun.apply(this, args);\n\t    if (typeof cb === 'function') {\n\t      promisedCallback(promise, cb);\n\t    }\n\t    return promise;\n\t  });\n\t}\n\t\n\t// Promise finally util similar to Q.finally\n\tfunction fin(promise, finalPromiseFactory) {\n\t  return promise.then(function (res) {\n\t    return finalPromiseFactory().then(function () {\n\t      return res;\n\t    });\n\t  }, function (reason) {\n\t    return finalPromiseFactory().then(function () {\n\t      throw reason;\n\t    });\n\t  });\n\t}\n\t\n\tfunction sequentialize(queue, promiseFactory) {\n\t  return function () {\n\t    var args = arguments;\n\t    var that = this;\n\t    return queue.add(function () {\n\t      return promiseFactory.apply(that, args);\n\t    });\n\t  };\n\t}\n\t\n\t// uniq an array of strings, order not guaranteed\n\t// similar to underscore/lodash _.uniq\n\tfunction uniq(arr) {\n\t  var theSet = new ExportedSet(arr);\n\t  var result = new Array(theSet.size);\n\t  var index = -1;\n\t  theSet.forEach(function (value) {\n\t    result[++index] = value;\n\t  });\n\t  return result;\n\t}\n\t\n\tfunction mapToKeysArray(map) {\n\t  var result = new Array(map.size);\n\t  var index = -1;\n\t  map.forEach(function (value, key) {\n\t    result[++index] = key;\n\t  });\n\t  return result;\n\t}\n\t\n\tvar persistentQueues = {};\n\tvar tempViewQueue = new TaskQueue$2();\n\tvar CHANGES_BATCH_SIZE$1 = 50;\n\t\n\tfunction parseViewName(name) {\n\t  // can be either 'ddocname/viewname' or just 'viewname'\n\t  // (where the ddoc name is the same)\n\t  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n\t}\n\t\n\tfunction isGenOne(changes) {\n\t  // only return true if the current change is 1-\n\t  // and there are no other leafs\n\t  return changes.length === 1 && /^1-/.test(changes[0].rev);\n\t}\n\t\n\tfunction emitError(db, e) {\n\t  try {\n\t    db.emit('error', e);\n\t  } catch (err) {\n\t    guardedConsole('error',\n\t      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n\t      'You can debug this error by doing:\\n' +\n\t      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n\t      'Please double-check your map/reduce function.');\n\t    guardedConsole('error', e);\n\t  }\n\t}\n\tfunction tryMap(db, fun, doc) {\n\t  // emit an event if there was an error thrown by a map function.\n\t  // putting try/catches in a single function also avoids deoptimizations.\n\t  try {\n\t    fun(doc);\n\t  } catch (e) {\n\t    emitError(db, e);\n\t  }\n\t}\n\t\n\tfunction tryReduce(db, fun, keys, values, rereduce) {\n\t  // same as above, but returning the result or an error. there are two separate\n\t  // functions to avoid extra memory allocations since the tryCode() case is used\n\t  // for custom map functions (common) vs this function, which is only used for\n\t  // custom reduce functions (rare)\n\t  try {\n\t    return {output : fun(keys, values, rereduce)};\n\t  } catch (e) {\n\t    emitError(db, e);\n\t    return {error: e};\n\t  }\n\t}\n\t\n\tfunction sortByKeyThenValue(x, y) {\n\t  var keyCompare = collate(x.key, y.key);\n\t  return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n\t}\n\t\n\tfunction sliceResults(results, limit, skip) {\n\t  skip = skip || 0;\n\t  if (typeof limit === 'number') {\n\t    return results.slice(skip, limit + skip);\n\t  } else if (skip > 0) {\n\t    return results.slice(skip);\n\t  }\n\t  return results;\n\t}\n\t\n\tfunction rowToDocId(row) {\n\t  var val = row.value;\n\t  // Users can explicitly specify a joined doc _id, or it\n\t  // defaults to the doc _id that emitted the key/value.\n\t  var docId = (val && typeof val === 'object' && val._id) || row.id;\n\t  return docId;\n\t}\n\t\n\tfunction readAttachmentsAsBlobOrBuffer$1(res) {\n\t  res.rows.forEach(function (row) {\n\t    var atts = row.doc && row.doc._attachments;\n\t    if (!atts) {\n\t      return;\n\t    }\n\t    Object.keys(atts).forEach(function (filename) {\n\t      var att = atts[filename];\n\t      atts[filename].data = b64ToBluffer(att.data, att.content_type);\n\t    });\n\t  });\n\t}\n\t\n\tfunction postprocessAttachments(opts) {\n\t  return function (res) {\n\t    if (opts.include_docs && opts.attachments && opts.binary) {\n\t      readAttachmentsAsBlobOrBuffer$1(res);\n\t    }\n\t    return res;\n\t  };\n\t}\n\t\n\tvar builtInReduce = {\n\t  _sum: function (keys, values) {\n\t    return sum(values);\n\t  },\n\t\n\t  _count: function (keys, values) {\n\t    return values.length;\n\t  },\n\t\n\t  _stats: function (keys, values) {\n\t    // no need to implement rereduce=true, because Pouch\n\t    // will never call it\n\t    function sumsqr(values) {\n\t      var _sumsqr = 0;\n\t      for (var i = 0, len = values.length; i < len; i++) {\n\t        var num = values[i];\n\t        _sumsqr += (num * num);\n\t      }\n\t      return _sumsqr;\n\t    }\n\t    return {\n\t      sum     : sum(values),\n\t      min     : Math.min.apply(null, values),\n\t      max     : Math.max.apply(null, values),\n\t      count   : values.length,\n\t      sumsqr : sumsqr(values)\n\t    };\n\t  }\n\t};\n\t\n\tfunction addHttpParam(paramName, opts, params, asJson) {\n\t  // add an http param from opts to params, optionally json-encoded\n\t  var val = opts[paramName];\n\t  if (typeof val !== 'undefined') {\n\t    if (asJson) {\n\t      val = encodeURIComponent(JSON.stringify(val));\n\t    }\n\t    params.push(paramName + '=' + val);\n\t  }\n\t}\n\t\n\tfunction coerceInteger(integerCandidate) {\n\t  if (typeof integerCandidate !== 'undefined') {\n\t    var asNumber = Number(integerCandidate);\n\t    // prevents e.g. '1foo' or '1.1' being coerced to 1\n\t    if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n\t      return asNumber;\n\t    } else {\n\t      return integerCandidate;\n\t    }\n\t  }\n\t}\n\t\n\tfunction coerceOptions(opts) {\n\t  opts.group_level = coerceInteger(opts.group_level);\n\t  opts.limit = coerceInteger(opts.limit);\n\t  opts.skip = coerceInteger(opts.skip);\n\t  return opts;\n\t}\n\t\n\tfunction checkPositiveInteger(number) {\n\t  if (number) {\n\t    if (typeof number !== 'number') {\n\t      return  new QueryParseError('Invalid value for integer: \"' +\n\t      number + '\"');\n\t    }\n\t    if (number < 0) {\n\t      return new QueryParseError('Invalid value for positive integer: ' +\n\t        '\"' + number + '\"');\n\t    }\n\t  }\n\t}\n\t\n\tfunction checkQueryParseError(options, fun) {\n\t  var startkeyName = options.descending ? 'endkey' : 'startkey';\n\t  var endkeyName = options.descending ? 'startkey' : 'endkey';\n\t\n\t  if (typeof options[startkeyName] !== 'undefined' &&\n\t    typeof options[endkeyName] !== 'undefined' &&\n\t    collate(options[startkeyName], options[endkeyName]) > 0) {\n\t    throw new QueryParseError('No rows can match your key range, ' +\n\t    'reverse your start_key and end_key or set {descending : true}');\n\t  } else if (fun.reduce && options.reduce !== false) {\n\t    if (options.include_docs) {\n\t      throw new QueryParseError('{include_docs:true} is invalid for reduce');\n\t    } else if (options.keys && options.keys.length > 1 &&\n\t        !options.group && !options.group_level) {\n\t      throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n\t      '{group: true}');\n\t    }\n\t  }\n\t  ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n\t    var error = checkPositiveInteger(options[optionName]);\n\t    if (error) {\n\t      throw error;\n\t    }\n\t  });\n\t}\n\t\n\tfunction httpQuery(db, fun, opts) {\n\t  // List of parameters to add to the PUT request\n\t  var params = [];\n\t  var body;\n\t  var method = 'GET';\n\t\n\t  // If opts.reduce exists and is defined, then add it to the list\n\t  // of parameters.\n\t  // If reduce=false then the results are that of only the map function\n\t  // not the final result of map and reduce.\n\t  addHttpParam('reduce', opts, params);\n\t  addHttpParam('include_docs', opts, params);\n\t  addHttpParam('attachments', opts, params);\n\t  addHttpParam('limit', opts, params);\n\t  addHttpParam('descending', opts, params);\n\t  addHttpParam('group', opts, params);\n\t  addHttpParam('group_level', opts, params);\n\t  addHttpParam('skip', opts, params);\n\t  addHttpParam('stale', opts, params);\n\t  addHttpParam('conflicts', opts, params);\n\t  addHttpParam('startkey', opts, params, true);\n\t  addHttpParam('start_key', opts, params, true);\n\t  addHttpParam('endkey', opts, params, true);\n\t  addHttpParam('end_key', opts, params, true);\n\t  addHttpParam('inclusive_end', opts, params);\n\t  addHttpParam('key', opts, params, true);\n\t\n\t  // Format the list of parameters into a valid URI query string\n\t  params = params.join('&');\n\t  params = params === '' ? '' : '?' + params;\n\t\n\t  // If keys are supplied, issue a POST to circumvent GET query string limits\n\t  // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n\t  if (typeof opts.keys !== 'undefined') {\n\t    var MAX_URL_LENGTH = 2000;\n\t    // according to http://stackoverflow.com/a/417184/680742,\n\t    // the de facto URL length limit is 2000 characters\n\t\n\t    var keysAsString =\n\t      'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n\t    if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n\t      // If the keys are short enough, do a GET. we do this to work around\n\t      // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n\t      params += (params[0] === '?' ? '&' : '?') + keysAsString;\n\t    } else {\n\t      method = 'POST';\n\t      if (typeof fun === 'string') {\n\t        body = {keys: opts.keys};\n\t      } else { // fun is {map : mapfun}, so append to this\n\t        fun.keys = opts.keys;\n\t      }\n\t    }\n\t  }\n\t\n\t  // We are referencing a query defined in the design doc\n\t  if (typeof fun === 'string') {\n\t    var parts = parseViewName(fun);\n\t    return db.request({\n\t      method: method,\n\t      url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n\t      body: body\n\t    }).then(postprocessAttachments(opts));\n\t  }\n\t\n\t  // We are using a temporary view, terrible for performance, good for testing\n\t  body = body || {};\n\t  Object.keys(fun).forEach(function (key) {\n\t    if (Array.isArray(fun[key])) {\n\t      body[key] = fun[key];\n\t    } else {\n\t      body[key] = fun[key].toString();\n\t    }\n\t  });\n\t  return db.request({\n\t    method: 'POST',\n\t    url: '_temp_view' + params,\n\t    body: body\n\t  }).then(postprocessAttachments(opts));\n\t}\n\t\n\t// custom adapters can define their own api._query\n\t// and override the default behavior\n\t/* istanbul ignore next */\n\tfunction customQuery(db, fun, opts) {\n\t  return new PouchPromise$1(function (resolve, reject) {\n\t    db._query(fun, opts, function (err, res) {\n\t      if (err) {\n\t        return reject(err);\n\t      }\n\t      resolve(res);\n\t    });\n\t  });\n\t}\n\t\n\t// custom adapters can define their own api._viewCleanup\n\t// and override the default behavior\n\t/* istanbul ignore next */\n\tfunction customViewCleanup(db) {\n\t  return new PouchPromise$1(function (resolve, reject) {\n\t    db._viewCleanup(function (err, res) {\n\t      if (err) {\n\t        return reject(err);\n\t      }\n\t      resolve(res);\n\t    });\n\t  });\n\t}\n\t\n\tfunction defaultsTo(value) {\n\t  return function (reason) {\n\t    /* istanbul ignore else */\n\t    if (reason.status === 404) {\n\t      return value;\n\t    } else {\n\t      throw reason;\n\t    }\n\t  };\n\t}\n\t\n\t// returns a promise for a list of docs to update, based on the input docId.\n\t// the order doesn't matter, because post-3.2.0, bulkDocs\n\t// is an atomic operation in all three adapters.\n\tfunction getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n\t  var metaDocId = '_local/doc_' + docId;\n\t  var defaultMetaDoc = {_id: metaDocId, keys: []};\n\t  var docData = docIdsToChangesAndEmits.get(docId);\n\t  var indexableKeysToKeyValues = docData[0];\n\t  var changes = docData[1];\n\t\n\t  function getMetaDoc() {\n\t    if (isGenOne(changes)) {\n\t      // generation 1, so we can safely assume initial state\n\t      // for performance reasons (avoids unnecessary GETs)\n\t      return PouchPromise$1.resolve(defaultMetaDoc);\n\t    }\n\t    return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n\t  }\n\t\n\t  function getKeyValueDocs(metaDoc) {\n\t    if (!metaDoc.keys.length) {\n\t      // no keys, no need for a lookup\n\t      return PouchPromise$1.resolve({rows: []});\n\t    }\n\t    return view.db.allDocs({\n\t      keys: metaDoc.keys,\n\t      include_docs: true\n\t    });\n\t  }\n\t\n\t  function processKeyValueDocs(metaDoc, kvDocsRes) {\n\t    var kvDocs = [];\n\t    var oldKeys = new ExportedSet();\n\t\n\t    for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n\t      var row = kvDocsRes.rows[i];\n\t      var doc = row.doc;\n\t      if (!doc) { // deleted\n\t        continue;\n\t      }\n\t      kvDocs.push(doc);\n\t      oldKeys.add(doc._id);\n\t      doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n\t      if (!doc._deleted) {\n\t        var keyValue = indexableKeysToKeyValues.get(doc._id);\n\t        if ('value' in keyValue) {\n\t          doc.value = keyValue.value;\n\t        }\n\t      }\n\t    }\n\t    var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n\t    newKeys.forEach(function (key) {\n\t      if (!oldKeys.has(key)) {\n\t        // new doc\n\t        var kvDoc = {\n\t          _id: key\n\t        };\n\t        var keyValue = indexableKeysToKeyValues.get(key);\n\t        if ('value' in keyValue) {\n\t          kvDoc.value = keyValue.value;\n\t        }\n\t        kvDocs.push(kvDoc);\n\t      }\n\t    });\n\t    metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n\t    kvDocs.push(metaDoc);\n\t\n\t    return kvDocs;\n\t  }\n\t\n\t  return getMetaDoc().then(function (metaDoc) {\n\t    return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n\t      return processKeyValueDocs(metaDoc, kvDocsRes);\n\t    });\n\t  });\n\t}\n\t\n\t// updates all emitted key/value docs and metaDocs in the mrview database\n\t// for the given batch of documents from the source database\n\tfunction saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n\t  var seqDocId = '_local/lastSeq';\n\t  return view.db.get(seqDocId)\n\t  .catch(defaultsTo({_id: seqDocId, seq: 0}))\n\t  .then(function (lastSeqDoc) {\n\t    var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n\t    return PouchPromise$1.all(docIds.map(function (docId) {\n\t      return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n\t    })).then(function (listOfDocsToPersist) {\n\t      var docsToPersist = flatten(listOfDocsToPersist);\n\t      lastSeqDoc.seq = seq;\n\t      docsToPersist.push(lastSeqDoc);\n\t      // write all docs in a single operation, update the seq once\n\t      return view.db.bulkDocs({docs : docsToPersist});\n\t    });\n\t  });\n\t}\n\t\n\tfunction getQueue(view) {\n\t  var viewName = typeof view === 'string' ? view : view.name;\n\t  var queue = persistentQueues[viewName];\n\t  if (!queue) {\n\t    queue = persistentQueues[viewName] = new TaskQueue$2();\n\t  }\n\t  return queue;\n\t}\n\t\n\tfunction updateView(view) {\n\t  return sequentialize(getQueue(view), function () {\n\t    return updateViewInQueue(view);\n\t  })();\n\t}\n\t\n\tfunction updateViewInQueue(view) {\n\t  // bind the emit function once\n\t  var mapResults;\n\t  var doc;\n\t\n\t  function emit(key, value) {\n\t    var output = {id: doc._id, key: normalizeKey(key)};\n\t    // Don't explicitly store the value unless it's defined and non-null.\n\t    // This saves on storage space, because often people don't use it.\n\t    if (typeof value !== 'undefined' && value !== null) {\n\t      output.value = normalizeKey(value);\n\t    }\n\t    mapResults.push(output);\n\t  }\n\t\n\t  var mapFun;\n\t  // for temp_views one can use emit(doc, emit), see #38\n\t  if (typeof view.mapFun === \"function\" && view.mapFun.length === 2) {\n\t    var origMap = view.mapFun;\n\t    mapFun = function (doc) {\n\t      return origMap(doc, emit);\n\t    };\n\t  } else {\n\t    mapFun = evalFunctionWithEval(view.mapFun.toString(), emit);\n\t  }\n\t\n\t  var currentSeq = view.seq || 0;\n\t\n\t  function processChange(docIdsToChangesAndEmits, seq) {\n\t    return function () {\n\t      return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n\t    };\n\t  }\n\t\n\t  var queue = new TaskQueue$2();\n\t\n\t  function processNextBatch() {\n\t    return view.sourceDB.changes({\n\t      conflicts: true,\n\t      include_docs: true,\n\t      style: 'all_docs',\n\t      since: currentSeq,\n\t      limit: CHANGES_BATCH_SIZE$1\n\t    }).then(processBatch);\n\t  }\n\t\n\t  function processBatch(response) {\n\t    var results = response.results;\n\t    if (!results.length) {\n\t      return;\n\t    }\n\t    var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n\t    queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n\t    if (results.length < CHANGES_BATCH_SIZE$1) {\n\t      return;\n\t    }\n\t    return processNextBatch();\n\t  }\n\t\n\t  function createDocIdsToChangesAndEmits(results) {\n\t    var docIdsToChangesAndEmits = new ExportedMap();\n\t    for (var i = 0, len = results.length; i < len; i++) {\n\t      var change = results[i];\n\t      if (change.doc._id[0] !== '_') {\n\t        mapResults = [];\n\t        doc = change.doc;\n\t\n\t        if (!doc._deleted) {\n\t          tryMap(view.sourceDB, mapFun, doc);\n\t        }\n\t        mapResults.sort(sortByKeyThenValue);\n\t\n\t        var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n\t        docIdsToChangesAndEmits.set(change.doc._id, [\n\t          indexableKeysToKeyValues,\n\t          change.changes\n\t        ]);\n\t      }\n\t      currentSeq = change.seq;\n\t    }\n\t    return docIdsToChangesAndEmits;\n\t  }\n\t\n\t  function createIndexableKeysToKeyValues(mapResults) {\n\t    var indexableKeysToKeyValues = new ExportedMap();\n\t    var lastKey;\n\t    for (var i = 0, len = mapResults.length; i < len; i++) {\n\t      var emittedKeyValue = mapResults[i];\n\t      var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n\t      if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n\t        complexKey.push(i); // dup key+id, so make it unique\n\t      }\n\t      indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n\t      lastKey = emittedKeyValue.key;\n\t    }\n\t    return indexableKeysToKeyValues;\n\t  }\n\t\n\t  return processNextBatch().then(function () {\n\t    return queue.finish();\n\t  }).then(function () {\n\t    view.seq = currentSeq;\n\t  });\n\t}\n\t\n\tfunction reduceView(view, results, options) {\n\t  if (options.group_level === 0) {\n\t    delete options.group_level;\n\t  }\n\t\n\t  var shouldGroup = options.group || options.group_level;\n\t\n\t  var reduceFun;\n\t  if (builtInReduce[view.reduceFun]) {\n\t    reduceFun = builtInReduce[view.reduceFun];\n\t  } else {\n\t    reduceFun = evalFunctionWithEval(view.reduceFun.toString());\n\t  }\n\t\n\t  var groups = [];\n\t  var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n\t    options.group_level;\n\t  results.forEach(function (e) {\n\t    var last = groups[groups.length - 1];\n\t    var groupKey = shouldGroup ? e.key : null;\n\t\n\t    // only set group_level for array keys\n\t    if (shouldGroup && Array.isArray(groupKey)) {\n\t      groupKey = groupKey.slice(0, lvl);\n\t    }\n\t\n\t    if (last && collate(last.groupKey, groupKey) === 0) {\n\t      last.keys.push([e.key, e.id]);\n\t      last.values.push(e.value);\n\t      return;\n\t    }\n\t    groups.push({\n\t      keys: [[e.key, e.id]],\n\t      values: [e.value],\n\t      groupKey: groupKey\n\t    });\n\t  });\n\t  results = [];\n\t  for (var i = 0, len = groups.length; i < len; i++) {\n\t    var e = groups[i];\n\t    var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n\t    if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n\t      // CouchDB returns an error if a built-in errors out\n\t      throw reduceTry.error;\n\t    }\n\t    results.push({\n\t      // CouchDB just sets the value to null if a non-built-in errors out\n\t      value: reduceTry.error ? null : reduceTry.output,\n\t      key: e.groupKey\n\t    });\n\t  }\n\t  // no total_rows/offset when reducing\n\t  return {rows: sliceResults(results, options.limit, options.skip)};\n\t}\n\t\n\tfunction queryView(view, opts) {\n\t  return sequentialize(getQueue(view), function () {\n\t    return queryViewInQueue(view, opts);\n\t  })();\n\t}\n\t\n\tfunction queryViewInQueue(view, opts) {\n\t  var totalRows;\n\t  var shouldReduce = view.reduceFun && opts.reduce !== false;\n\t  var skip = opts.skip || 0;\n\t  if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n\t    // equivalent query\n\t    opts.limit = 0;\n\t    delete opts.keys;\n\t  }\n\t\n\t  function fetchFromView(viewOpts) {\n\t    viewOpts.include_docs = true;\n\t    return view.db.allDocs(viewOpts).then(function (res) {\n\t      totalRows = res.total_rows;\n\t      return res.rows.map(function (result) {\n\t\n\t        // implicit migration - in older versions of PouchDB,\n\t        // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n\t        // this is tested in a migration test\n\t        /* istanbul ignore next */\n\t        if ('value' in result.doc && typeof result.doc.value === 'object' &&\n\t            result.doc.value !== null) {\n\t          var keys = Object.keys(result.doc.value).sort();\n\t          // this detection method is not perfect, but it's unlikely the user\n\t          // emitted a value which was an object with these 3 exact keys\n\t          var expectedKeys = ['id', 'key', 'value'];\n\t          if (!(keys < expectedKeys || keys > expectedKeys)) {\n\t            return result.doc.value;\n\t          }\n\t        }\n\t\n\t        var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n\t        return {\n\t          key: parsedKeyAndDocId[0],\n\t          id: parsedKeyAndDocId[1],\n\t          value: ('value' in result.doc ? result.doc.value : null)\n\t        };\n\t      });\n\t    });\n\t  }\n\t\n\t  function onMapResultsReady(rows) {\n\t    var finalResults;\n\t    if (shouldReduce) {\n\t      finalResults = reduceView(view, rows, opts);\n\t    } else {\n\t      finalResults = {\n\t        total_rows: totalRows,\n\t        offset: skip,\n\t        rows: rows\n\t      };\n\t    }\n\t    if (opts.include_docs) {\n\t      var docIds = uniq(rows.map(rowToDocId));\n\t\n\t      return view.sourceDB.allDocs({\n\t        keys: docIds,\n\t        include_docs: true,\n\t        conflicts: opts.conflicts,\n\t        attachments: opts.attachments,\n\t        binary: opts.binary\n\t      }).then(function (allDocsRes) {\n\t        var docIdsToDocs = new ExportedMap();\n\t        allDocsRes.rows.forEach(function (row) {\n\t          docIdsToDocs.set(row.id, row.doc);\n\t        });\n\t        rows.forEach(function (row) {\n\t          var docId = rowToDocId(row);\n\t          var doc = docIdsToDocs.get(docId);\n\t          if (doc) {\n\t            row.doc = doc;\n\t          }\n\t        });\n\t        return finalResults;\n\t      });\n\t    } else {\n\t      return finalResults;\n\t    }\n\t  }\n\t\n\t  if (typeof opts.keys !== 'undefined') {\n\t    var keys = opts.keys;\n\t    var fetchPromises = keys.map(function (key) {\n\t      var viewOpts = {\n\t        startkey : toIndexableString([key]),\n\t        endkey   : toIndexableString([key, {}])\n\t      };\n\t      return fetchFromView(viewOpts);\n\t    });\n\t    return PouchPromise$1.all(fetchPromises).then(flatten).then(onMapResultsReady);\n\t  } else { // normal query, no 'keys'\n\t    var viewOpts = {\n\t      descending : opts.descending\n\t    };\n\t    if (opts.start_key) {\n\t        opts.startkey = opts.start_key;\n\t    }\n\t    if (opts.end_key) {\n\t        opts.endkey = opts.end_key;\n\t    }\n\t    if (typeof opts.startkey !== 'undefined') {\n\t      viewOpts.startkey = opts.descending ?\n\t        toIndexableString([opts.startkey, {}]) :\n\t        toIndexableString([opts.startkey]);\n\t    }\n\t    if (typeof opts.endkey !== 'undefined') {\n\t      var inclusiveEnd = opts.inclusive_end !== false;\n\t      if (opts.descending) {\n\t        inclusiveEnd = !inclusiveEnd;\n\t      }\n\t\n\t      viewOpts.endkey = toIndexableString(\n\t        inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);\n\t    }\n\t    if (typeof opts.key !== 'undefined') {\n\t      var keyStart = toIndexableString([opts.key]);\n\t      var keyEnd = toIndexableString([opts.key, {}]);\n\t      if (viewOpts.descending) {\n\t        viewOpts.endkey = keyStart;\n\t        viewOpts.startkey = keyEnd;\n\t      } else {\n\t        viewOpts.startkey = keyStart;\n\t        viewOpts.endkey = keyEnd;\n\t      }\n\t    }\n\t    if (!shouldReduce) {\n\t      if (typeof opts.limit === 'number') {\n\t        viewOpts.limit = opts.limit;\n\t      }\n\t      viewOpts.skip = skip;\n\t    }\n\t    return fetchFromView(viewOpts).then(onMapResultsReady);\n\t  }\n\t}\n\t\n\tfunction httpViewCleanup(db) {\n\t  return db.request({\n\t    method: 'POST',\n\t    url: '_view_cleanup'\n\t  });\n\t}\n\t\n\tfunction localViewCleanup(db) {\n\t  return db.get('_local/mrviews').then(function (metaDoc) {\n\t    var docsToViews = new ExportedMap();\n\t    Object.keys(metaDoc.views).forEach(function (fullViewName) {\n\t      var parts = parseViewName(fullViewName);\n\t      var designDocName = '_design/' + parts[0];\n\t      var viewName = parts[1];\n\t      var views = docsToViews.get(designDocName);\n\t      if (!views) {\n\t        views = new ExportedSet();\n\t        docsToViews.set(designDocName, views);\n\t      }\n\t      views.add(viewName);\n\t    });\n\t    var opts = {\n\t      keys : mapToKeysArray(docsToViews),\n\t      include_docs : true\n\t    };\n\t    return db.allDocs(opts).then(function (res) {\n\t      var viewsToStatus = {};\n\t      res.rows.forEach(function (row) {\n\t        var ddocName = row.key.substring(8); // cuts off '_design/'\n\t        docsToViews.get(row.key).forEach(function (viewName) {\n\t          var fullViewName = ddocName + '/' + viewName;\n\t          /* istanbul ignore if */\n\t          if (!metaDoc.views[fullViewName]) {\n\t            // new format, without slashes, to support PouchDB 2.2.0\n\t            // migration test in pouchdb's browser.migration.js verifies this\n\t            fullViewName = viewName;\n\t          }\n\t          var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n\t          // design doc deleted, or view function nonexistent\n\t          var statusIsGood = row.doc && row.doc.views &&\n\t            row.doc.views[viewName];\n\t          viewDBNames.forEach(function (viewDBName) {\n\t            viewsToStatus[viewDBName] =\n\t              viewsToStatus[viewDBName] || statusIsGood;\n\t          });\n\t        });\n\t      });\n\t      var dbsToDelete = Object.keys(viewsToStatus).filter(\n\t        function (viewDBName) { return !viewsToStatus[viewDBName]; });\n\t      var destroyPromises = dbsToDelete.map(function (viewDBName) {\n\t        return sequentialize(getQueue(viewDBName), function () {\n\t          return new db.constructor(viewDBName, db.__opts).destroy();\n\t        })();\n\t      });\n\t      return PouchPromise$1.all(destroyPromises).then(function () {\n\t        return {ok: true};\n\t      });\n\t    });\n\t  }, defaultsTo({ok: true}));\n\t}\n\t\n\tvar viewCleanup = callbackify(function () {\n\t  var db = this;\n\t  if (db.type() === 'http') {\n\t    return httpViewCleanup(db);\n\t  }\n\t  /* istanbul ignore next */\n\t  if (typeof db._viewCleanup === 'function') {\n\t    return customViewCleanup(db);\n\t  }\n\t  return localViewCleanup(db);\n\t});\n\t\n\tfunction queryPromised(db, fun, opts) {\n\t  if (db.type() === 'http') {\n\t    return httpQuery(db, fun, opts);\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  if (typeof db._query === 'function') {\n\t    return customQuery(db, fun, opts);\n\t  }\n\t\n\t  if (typeof fun !== 'string') {\n\t    // temp_view\n\t    checkQueryParseError(opts, fun);\n\t\n\t    var createViewOpts = {\n\t      db : db,\n\t      viewName : 'temp_view/temp_view',\n\t      map : fun.map,\n\t      reduce : fun.reduce,\n\t      temporary : true\n\t    };\n\t    tempViewQueue.add(function () {\n\t      return createView(createViewOpts).then(function (view) {\n\t        function cleanup() {\n\t          return view.db.destroy();\n\t        }\n\t        return fin(updateView(view).then(function () {\n\t          return queryView(view, opts);\n\t        }), cleanup);\n\t      });\n\t    });\n\t    return tempViewQueue.finish();\n\t  } else {\n\t    // persistent view\n\t    var fullViewName = fun;\n\t    var parts = parseViewName(fullViewName);\n\t    var designDocName = parts[0];\n\t    var viewName = parts[1];\n\t    return db.get('_design/' + designDocName).then(function (doc) {\n\t      var fun = doc.views && doc.views[viewName];\n\t\n\t      if (!fun || typeof fun.map !== 'string') {\n\t        throw new NotFoundError('ddoc ' + designDocName +\n\t        ' has no view named ' + viewName);\n\t      }\n\t      checkQueryParseError(opts, fun);\n\t\n\t      var createViewOpts = {\n\t        db : db,\n\t        viewName : fullViewName,\n\t        map : fun.map,\n\t        reduce : fun.reduce\n\t      };\n\t      return createView(createViewOpts).then(function (view) {\n\t        if (opts.stale === 'ok' || opts.stale === 'update_after') {\n\t          if (opts.stale === 'update_after') {\n\t            nextTick(function () {\n\t              updateView(view);\n\t            });\n\t          }\n\t          return queryView(view, opts);\n\t        } else { // stale not ok\n\t          return updateView(view).then(function () {\n\t            return queryView(view, opts);\n\t          });\n\t        }\n\t      });\n\t    });\n\t  }\n\t}\n\t\n\tvar query = function (fun, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  opts = opts ? coerceOptions(opts) : {};\n\t\n\t  if (typeof fun === 'function') {\n\t    fun = {map : fun};\n\t  }\n\t\n\t  var db = this;\n\t  var promise = PouchPromise$1.resolve().then(function () {\n\t    return queryPromised(db, fun, opts);\n\t  });\n\t  promisedCallback(promise, callback);\n\t  return promise;\n\t};\n\t\n\t\n\tvar mapreduce = {\n\t  query: query,\n\t  viewCleanup: viewCleanup\n\t};\n\t\n\tfunction isGenOne$1(rev) {\n\t  return /^1-/.test(rev);\n\t}\n\t\n\tfunction fileHasChanged(localDoc, remoteDoc, filename) {\n\t  return !localDoc._attachments ||\n\t         !localDoc._attachments[filename] ||\n\t         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n\t}\n\t\n\tfunction getDocAttachments(db, doc) {\n\t  var filenames = Object.keys(doc._attachments);\n\t  return PouchPromise$1.all(filenames.map(function (filename) {\n\t    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n\t  }));\n\t}\n\t\n\tfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n\t  var doCheckForLocalAttachments = src.type() === 'http' && target.type() !== 'http';\n\t  var filenames = Object.keys(doc._attachments);\n\t\n\t  if (!doCheckForLocalAttachments) {\n\t    return getDocAttachments(src, doc);\n\t  }\n\t\n\t  return target.get(doc._id).then(function (localDoc) {\n\t    return PouchPromise$1.all(filenames.map(function (filename) {\n\t      if (fileHasChanged(localDoc, doc, filename)) {\n\t        return src.getAttachment(doc._id, filename);\n\t      }\n\t\n\t      return target.getAttachment(localDoc._id, filename);\n\t    }));\n\t  }).catch(function (error) {\n\t    /* istanbul ignore if */\n\t    if (error.status !== 404) {\n\t      throw error;\n\t    }\n\t\n\t    return getDocAttachments(src, doc);\n\t  });\n\t}\n\t\n\tfunction createBulkGetOpts(diffs) {\n\t  var requests = [];\n\t  Object.keys(diffs).forEach(function (id) {\n\t    var missingRevs = diffs[id].missing;\n\t    missingRevs.forEach(function (missingRev) {\n\t      requests.push({\n\t        id: id,\n\t        rev: missingRev\n\t      });\n\t    });\n\t  });\n\t\n\t  return {\n\t    docs: requests,\n\t    revs: true,\n\t    latest: true\n\t  };\n\t}\n\t\n\t//\n\t// Fetch all the documents from the src as described in the \"diffs\",\n\t// which is a mapping of docs IDs to revisions. If the state ever\n\t// changes to \"cancelled\", then the returned promise will be rejected.\n\t// Else it will be resolved with a list of fetched documents.\n\t//\n\tfunction getDocs(src, target, diffs, state) {\n\t  diffs = clone(diffs); // we do not need to modify this\n\t\n\t  var resultDocs = [],\n\t      ok = true;\n\t\n\t  function getAllDocs() {\n\t\n\t    var bulkGetOpts = createBulkGetOpts(diffs);\n\t\n\t    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n\t      return;\n\t    }\n\t\n\t    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n\t      /* istanbul ignore if */\n\t      if (state.cancelled) {\n\t        throw new Error('cancelled');\n\t      }\n\t      return PouchPromise$1.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n\t        return PouchPromise$1.all(bulkGetInfo.docs.map(function (doc) {\n\t          var remoteDoc = doc.ok;\n\t\n\t          if (doc.error) {\n\t            // when AUTO_COMPACTION is set, docs can be returned which look\n\t            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n\t            ok = false;\n\t          }\n\t\n\t          if (!remoteDoc || !remoteDoc._attachments) {\n\t            return remoteDoc;\n\t          }\n\t\n\t          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc).then(function (attachments) {\n\t            var filenames = Object.keys(remoteDoc._attachments);\n\t            attachments.forEach(function (attachment, i) {\n\t              var att = remoteDoc._attachments[filenames[i]];\n\t              delete att.stub;\n\t              delete att.length;\n\t              att.data = attachment;\n\t            });\n\t\n\t            return remoteDoc;\n\t          });\n\t        }));\n\t      }))\n\t\n\t      .then(function (results) {\n\t        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n\t      });\n\t    });\n\t  }\n\t\n\t  function hasAttachments(doc) {\n\t    return doc._attachments && Object.keys(doc._attachments).length > 0;\n\t  }\n\t\n\t  function hasConflicts(doc) {\n\t    return doc._conflicts && doc._conflicts.length > 0;\n\t  }\n\t\n\t  function fetchRevisionOneDocs(ids) {\n\t    // Optimization: fetch gen-1 docs and attachments in\n\t    // a single request using _all_docs\n\t    return src.allDocs({\n\t      keys: ids,\n\t      include_docs: true,\n\t      conflicts: true\n\t    }).then(function (res) {\n\t      if (state.cancelled) {\n\t        throw new Error('cancelled');\n\t      }\n\t      res.rows.forEach(function (row) {\n\t        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n\t            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n\t          // if any of these conditions apply, we need to fetch using get()\n\t          return;\n\t        }\n\t\n\t        // strip _conflicts array to appease CSG (#5793)\n\t        /* istanbul ignore if */\n\t        if (row.doc._conflicts) {\n\t          delete row.doc._conflicts;\n\t        }\n\t\n\t        // the doc we got back from allDocs() is sufficient\n\t        resultDocs.push(row.doc);\n\t        delete diffs[row.id];\n\t      });\n\t    });\n\t  }\n\t\n\t  function getRevisionOneDocs() {\n\t    // filter out the generation 1 docs and get them\n\t    // leaving the non-generation one docs to be got otherwise\n\t    var ids = Object.keys(diffs).filter(function (id) {\n\t      var missing = diffs[id].missing;\n\t      return missing.length === 1 && isGenOne$1(missing[0]);\n\t    });\n\t    if (ids.length > 0) {\n\t      return fetchRevisionOneDocs(ids);\n\t    }\n\t  }\n\t\n\t  function returnResult() {\n\t    return { ok:ok, docs:resultDocs };\n\t  }\n\t\n\t  return PouchPromise$1.resolve()\n\t    .then(getRevisionOneDocs)\n\t    .then(getAllDocs)\n\t    .then(returnResult);\n\t}\n\t\n\tvar CHECKPOINT_VERSION = 1;\n\tvar REPLICATOR = \"pouchdb\";\n\t// This is an arbitrary number to limit the\n\t// amount of replication history we save in the checkpoint.\n\t// If we save too much, the checkpoing docs will become very big,\n\t// if we save fewer, we'll run a greater risk of having to\n\t// read all the changes from 0 when checkpoint PUTs fail\n\t// CouchDB 2.0 has a more involved history pruning,\n\t// but let's go for the simple version for now.\n\tvar CHECKPOINT_HISTORY_SIZE = 5;\n\tvar LOWEST_SEQ = 0;\n\t\n\tfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n\t  return db.get(id).catch(function (err) {\n\t    if (err.status === 404) {\n\t      if (db.type() === 'http') {\n\t        explainError(\n\t          404, 'PouchDB is just checking if a remote checkpoint exists.'\n\t        );\n\t      }\n\t      return {\n\t        session_id: session,\n\t        _id: id,\n\t        history: [],\n\t        replicator: REPLICATOR,\n\t        version: CHECKPOINT_VERSION\n\t      };\n\t    }\n\t    throw err;\n\t  }).then(function (doc) {\n\t    if (returnValue.cancelled) {\n\t      return;\n\t    }\n\t\n\t    // if the checkpoint has not changed, do not update\n\t    if (doc.last_seq === checkpoint) {\n\t      return;\n\t    }\n\t\n\t    // Filter out current entry for this replication\n\t    doc.history = (doc.history || []).filter(function (item) {\n\t      return item.session_id !== session;\n\t    });\n\t\n\t    // Add the latest checkpoint to history\n\t    doc.history.unshift({\n\t      last_seq: checkpoint,\n\t      session_id: session\n\t    });\n\t\n\t    // Just take the last pieces in history, to\n\t    // avoid really big checkpoint docs.\n\t    // see comment on history size above\n\t    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\t\n\t    doc.version = CHECKPOINT_VERSION;\n\t    doc.replicator = REPLICATOR;\n\t\n\t    doc.session_id = session;\n\t    doc.last_seq = checkpoint;\n\t\n\t    return db.put(doc).catch(function (err) {\n\t      if (err.status === 409) {\n\t        // retry; someone is trying to write a checkpoint simultaneously\n\t        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n\t      }\n\t      throw err;\n\t    });\n\t  });\n\t}\n\t\n\tfunction Checkpointer(src, target, id, returnValue) {\n\t  this.src = src;\n\t  this.target = target;\n\t  this.id = id;\n\t  this.returnValue = returnValue;\n\t}\n\t\n\tCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n\t  var self = this;\n\t  return this.updateTarget(checkpoint, session).then(function () {\n\t    return self.updateSource(checkpoint, session);\n\t  });\n\t};\n\t\n\tCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n\t  return updateCheckpoint(this.target, this.id, checkpoint,\n\t    session, this.returnValue);\n\t};\n\t\n\tCheckpointer.prototype.updateSource = function (checkpoint, session) {\n\t  var self = this;\n\t  if (this.readOnlySource) {\n\t    return PouchPromise$1.resolve(true);\n\t  }\n\t  return updateCheckpoint(this.src, this.id, checkpoint,\n\t    session, this.returnValue)\n\t    .catch(function (err) {\n\t      if (isForbiddenError(err)) {\n\t        self.readOnlySource = true;\n\t        return true;\n\t      }\n\t      throw err;\n\t    });\n\t};\n\t\n\tvar comparisons = {\n\t  \"undefined\": function (targetDoc, sourceDoc) {\n\t    // This is the previous comparison function\n\t    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n\t      return sourceDoc.last_seq;\n\t    }\n\t    /* istanbul ignore next */\n\t    return 0;\n\t  },\n\t  \"1\": function (targetDoc, sourceDoc) {\n\t    // This is the comparison function ported from CouchDB\n\t    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n\t  }\n\t};\n\t\n\tCheckpointer.prototype.getCheckpoint = function () {\n\t  var self = this;\n\t  return self.target.get(self.id).then(function (targetDoc) {\n\t    if (self.readOnlySource) {\n\t      return PouchPromise$1.resolve(targetDoc.last_seq);\n\t    }\n\t\n\t    return self.src.get(self.id).then(function (sourceDoc) {\n\t      // Since we can't migrate an old version doc to a new one\n\t      // (no session id), we just go with the lowest seq in this case\n\t      /* istanbul ignore if */\n\t      if (targetDoc.version !== sourceDoc.version) {\n\t        return LOWEST_SEQ;\n\t      }\n\t\n\t      var version;\n\t      if (targetDoc.version) {\n\t        version = targetDoc.version.toString();\n\t      } else {\n\t        version = \"undefined\";\n\t      }\n\t\n\t      if (version in comparisons) {\n\t        return comparisons[version](targetDoc, sourceDoc);\n\t      }\n\t      /* istanbul ignore next */\n\t      return LOWEST_SEQ;\n\t    }, function (err) {\n\t      if (err.status === 404 && targetDoc.last_seq) {\n\t        return self.src.put({\n\t          _id: self.id,\n\t          last_seq: LOWEST_SEQ\n\t        }).then(function () {\n\t          return LOWEST_SEQ;\n\t        }, function (err) {\n\t          if (isForbiddenError(err)) {\n\t            self.readOnlySource = true;\n\t            return targetDoc.last_seq;\n\t          }\n\t          /* istanbul ignore next */\n\t          return LOWEST_SEQ;\n\t        });\n\t      }\n\t      throw err;\n\t    });\n\t  }).catch(function (err) {\n\t    if (err.status !== 404) {\n\t      throw err;\n\t    }\n\t    return LOWEST_SEQ;\n\t  });\n\t};\n\t// This checkpoint comparison is ported from CouchDBs source\n\t// they come from here:\n\t// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\t\n\tfunction compareReplicationLogs(srcDoc, tgtDoc) {\n\t  if (srcDoc.session_id === tgtDoc.session_id) {\n\t    return {\n\t      last_seq: srcDoc.last_seq,\n\t      history: srcDoc.history\n\t    };\n\t  }\n\t\n\t  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n\t}\n\t\n\tfunction compareReplicationHistory(sourceHistory, targetHistory) {\n\t  // the erlang loop via function arguments is not so easy to repeat in JS\n\t  // therefore, doing this as recursion\n\t  var S = sourceHistory[0];\n\t  var sourceRest = sourceHistory.slice(1);\n\t  var T = targetHistory[0];\n\t  var targetRest = targetHistory.slice(1);\n\t\n\t  if (!S || targetHistory.length === 0) {\n\t    return {\n\t      last_seq: LOWEST_SEQ,\n\t      history: []\n\t    };\n\t  }\n\t\n\t  var sourceId = S.session_id;\n\t  /* istanbul ignore if */\n\t  if (hasSessionId(sourceId, targetHistory)) {\n\t    return {\n\t      last_seq: S.last_seq,\n\t      history: sourceHistory\n\t    };\n\t  }\n\t\n\t  var targetId = T.session_id;\n\t  if (hasSessionId(targetId, sourceRest)) {\n\t    return {\n\t      last_seq: T.last_seq,\n\t      history: targetRest\n\t    };\n\t  }\n\t\n\t  return compareReplicationHistory(sourceRest, targetRest);\n\t}\n\t\n\tfunction hasSessionId(sessionId, history) {\n\t  var props = history[0];\n\t  var rest = history.slice(1);\n\t\n\t  if (!sessionId || history.length === 0) {\n\t    return false;\n\t  }\n\t\n\t  if (sessionId === props.session_id) {\n\t    return true;\n\t  }\n\t\n\t  return hasSessionId(sessionId, rest);\n\t}\n\t\n\tfunction isForbiddenError(err) {\n\t  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n\t}\n\t\n\tvar STARTING_BACK_OFF = 0;\n\t\n\tfunction backOff(opts, returnValue, error, callback) {\n\t  if (opts.retry === false) {\n\t    returnValue.emit('error', error);\n\t    returnValue.removeAllListeners();\n\t    return;\n\t  }\n\t  if (typeof opts.back_off_function !== 'function') {\n\t    opts.back_off_function = defaultBackOff;\n\t  }\n\t  returnValue.emit('requestError', error);\n\t  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n\t    returnValue.emit('paused', error);\n\t    returnValue.state = 'stopped';\n\t    var backOffSet = function backoffTimeSet() {\n\t      opts.current_back_off = STARTING_BACK_OFF;\n\t    };\n\t    var removeBackOffSetter = function removeBackOffTimeSet() {\n\t      returnValue.removeListener('active', backOffSet);\n\t    };\n\t    returnValue.once('paused', removeBackOffSetter);\n\t    returnValue.once('active', backOffSet);\n\t  }\n\t\n\t  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n\t  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n\t  setTimeout(callback, opts.current_back_off);\n\t}\n\t\n\tfunction sortObjectPropertiesByKey(queryParams) {\n\t  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n\t    result[key] = queryParams[key];\n\t    return result;\n\t  }, {});\n\t}\n\t\n\t// Generate a unique id particular to this replication.\n\t// Not guaranteed to align perfectly with CouchDB's rep ids.\n\tfunction generateReplicationId(src, target, opts) {\n\t  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n\t  var filterFun = opts.filter ? opts.filter.toString() : '';\n\t  var queryParams = '';\n\t  var filterViewName =  '';\n\t\n\t  if (opts.filter && opts.query_params) {\n\t    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n\t  }\n\t\n\t  if (opts.filter && opts.filter === '_view') {\n\t    filterViewName = opts.view.toString();\n\t  }\n\t\n\t  return PouchPromise$1.all([src.id(), target.id()]).then(function (res) {\n\t    var queryData = res[0] + res[1] + filterFun + filterViewName +\n\t      queryParams + docIds;\n\t    return new PouchPromise$1(function (resolve) {\n\t      binaryMd5(queryData, resolve);\n\t    });\n\t  }).then(function (md5sum) {\n\t    // can't use straight-up md5 alphabet, because\n\t    // the char '/' is interpreted as being for attachments,\n\t    // and + is also not url-safe\n\t    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n\t    return '_local/' + md5sum;\n\t  });\n\t}\n\t\n\tfunction replicate(src, target, opts, returnValue, result) {\n\t  var batches = [];               // list of batches to be processed\n\t  var currentBatch;               // the batch currently being processed\n\t  var pendingBatch = {\n\t    seq: 0,\n\t    changes: [],\n\t    docs: []\n\t  }; // next batch, not yet ready to be processed\n\t  var writingCheckpoint = false;  // true while checkpoint is being written\n\t  var changesCompleted = false;   // true when all changes received\n\t  var replicationCompleted = false; // true when replication has completed\n\t  var last_seq = 0;\n\t  var continuous = opts.continuous || opts.live || false;\n\t  var batch_size = opts.batch_size || 100;\n\t  var batches_limit = opts.batches_limit || 10;\n\t  var changesPending = false;     // true while src.changes is running\n\t  var doc_ids = opts.doc_ids;\n\t  var repId;\n\t  var checkpointer;\n\t  var changedDocs = [];\n\t  // Like couchdb, every replication gets a unique session id\n\t  var session = uuid();\n\t\n\t  result = result || {\n\t    ok: true,\n\t    start_time: new Date(),\n\t    docs_read: 0,\n\t    docs_written: 0,\n\t    doc_write_failures: 0,\n\t    errors: []\n\t  };\n\t\n\t  var changesOpts = {};\n\t  returnValue.ready(src, target);\n\t\n\t  function initCheckpointer() {\n\t    if (checkpointer) {\n\t      return PouchPromise$1.resolve();\n\t    }\n\t    return generateReplicationId(src, target, opts).then(function (res) {\n\t      repId = res;\n\t      checkpointer = new Checkpointer(src, target, repId, returnValue);\n\t    });\n\t  }\n\t\n\t  function writeDocs() {\n\t    changedDocs = [];\n\t\n\t    if (currentBatch.docs.length === 0) {\n\t      return;\n\t    }\n\t    var docs = currentBatch.docs;\n\t    var bulkOpts = {timeout: opts.timeout};\n\t    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t\n\t      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n\t      // (id -> error), and check for errors while iterating over `docs`\n\t      var errorsById = Object.create(null);\n\t      res.forEach(function (res) {\n\t        if (res.error) {\n\t          errorsById[res.id] = res;\n\t        }\n\t      });\n\t\n\t      var errorsNo = Object.keys(errorsById).length;\n\t      result.doc_write_failures += errorsNo;\n\t      result.docs_written += docs.length - errorsNo;\n\t\n\t      docs.forEach(function (doc) {\n\t        var error = errorsById[doc._id];\n\t        if (error) {\n\t          result.errors.push(error);\n\t          if (error.name === 'unauthorized' || error.name === 'forbidden') {\n\t            returnValue.emit('denied', clone(error));\n\t          } else {\n\t            throw error;\n\t          }\n\t        } else {\n\t          changedDocs.push(doc);\n\t        }\n\t      });\n\t\n\t    }, function (err) {\n\t      result.doc_write_failures += docs.length;\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  function finishBatch() {\n\t    if (currentBatch.error) {\n\t      throw new Error('There was a problem getting docs.');\n\t    }\n\t    result.last_seq = last_seq = currentBatch.seq;\n\t    var outResult = clone(result);\n\t    if (changedDocs.length) {\n\t      outResult.docs = changedDocs;\n\t      returnValue.emit('change', outResult);\n\t    }\n\t    writingCheckpoint = true;\n\t    return checkpointer.writeCheckpoint(currentBatch.seq,\n\t        session).then(function () {\n\t      writingCheckpoint = false;\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      currentBatch = undefined;\n\t      getChanges();\n\t    }).catch(function (err) {\n\t      onCheckpointError(err);\n\t      throw err;\n\t    });\n\t  }\n\t\n\t  function getDiffs() {\n\t    var diff = {};\n\t    currentBatch.changes.forEach(function (change) {\n\t      // Couchbase Sync Gateway emits these, but we can ignore them\n\t      /* istanbul ignore if */\n\t      if (change.id === \"_user/\") {\n\t        return;\n\t      }\n\t      diff[change.id] = change.changes.map(function (x) {\n\t        return x.rev;\n\t      });\n\t    });\n\t    return target.revsDiff(diff).then(function (diffs) {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        throw new Error('cancelled');\n\t      }\n\t      // currentBatch.diffs elements are deleted as the documents are written\n\t      currentBatch.diffs = diffs;\n\t    });\n\t  }\n\t\n\t  function getBatchDocs() {\n\t    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n\t      currentBatch.error = !got.ok;\n\t      got.docs.forEach(function (doc) {\n\t        delete currentBatch.diffs[doc._id];\n\t        result.docs_read++;\n\t        currentBatch.docs.push(doc);\n\t      });\n\t    });\n\t  }\n\t\n\t  function startNextBatch() {\n\t    if (returnValue.cancelled || currentBatch) {\n\t      return;\n\t    }\n\t    if (batches.length === 0) {\n\t      processPendingBatch(true);\n\t      return;\n\t    }\n\t    currentBatch = batches.shift();\n\t    getDiffs()\n\t      .then(getBatchDocs)\n\t      .then(writeDocs)\n\t      .then(finishBatch)\n\t      .then(startNextBatch)\n\t      .catch(function (err) {\n\t        abortReplication('batch processing terminated with error', err);\n\t      });\n\t  }\n\t\n\t\n\t  function processPendingBatch(immediate) {\n\t    if (pendingBatch.changes.length === 0) {\n\t      if (batches.length === 0 && !currentBatch) {\n\t        if ((continuous && changesOpts.live) || changesCompleted) {\n\t          returnValue.state = 'pending';\n\t          returnValue.emit('paused');\n\t        }\n\t        if (changesCompleted) {\n\t          completeReplication();\n\t        }\n\t      }\n\t      return;\n\t    }\n\t    if (\n\t      immediate ||\n\t      changesCompleted ||\n\t      pendingBatch.changes.length >= batch_size\n\t    ) {\n\t      batches.push(pendingBatch);\n\t      pendingBatch = {\n\t        seq: 0,\n\t        changes: [],\n\t        docs: []\n\t      };\n\t      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n\t        returnValue.state = 'active';\n\t        returnValue.emit('active');\n\t      }\n\t      startNextBatch();\n\t    }\n\t  }\n\t\n\t\n\t  function abortReplication(reason, err) {\n\t    if (replicationCompleted) {\n\t      return;\n\t    }\n\t    if (!err.message) {\n\t      err.message = reason;\n\t    }\n\t    result.ok = false;\n\t    result.status = 'aborting';\n\t    batches = [];\n\t    pendingBatch = {\n\t      seq: 0,\n\t      changes: [],\n\t      docs: []\n\t    };\n\t    completeReplication(err);\n\t  }\n\t\n\t\n\t  function completeReplication(fatalError) {\n\t    if (replicationCompleted) {\n\t      return;\n\t    }\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      result.status = 'cancelled';\n\t      if (writingCheckpoint) {\n\t        return;\n\t      }\n\t    }\n\t    result.status = result.status || 'complete';\n\t    result.end_time = new Date();\n\t    result.last_seq = last_seq;\n\t    replicationCompleted = true;\n\t\n\t    if (fatalError) {\n\t      fatalError.result = result;\n\t\n\t      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {\n\t        returnValue.emit('error', fatalError);\n\t        returnValue.removeAllListeners();\n\t      } else {\n\t        backOff(opts, returnValue, fatalError, function () {\n\t          replicate(src, target, opts, returnValue);\n\t        });\n\t      }\n\t    } else {\n\t      returnValue.emit('complete', result);\n\t      returnValue.removeAllListeners();\n\t    }\n\t  }\n\t\n\t\n\t  function onChange(change) {\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t    var filter = filterChange(opts)(change);\n\t    if (!filter) {\n\t      return;\n\t    }\n\t    pendingBatch.seq = change.seq;\n\t    pendingBatch.changes.push(change);\n\t    processPendingBatch(batches.length === 0 && changesOpts.live);\n\t  }\n\t\n\t\n\t  function onChangesComplete(changes) {\n\t    changesPending = false;\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t\n\t    // if no results were returned then we're done,\n\t    // else fetch more\n\t    if (changes.results.length > 0) {\n\t      changesOpts.since = changes.last_seq;\n\t      getChanges();\n\t      processPendingBatch(true);\n\t    } else {\n\t\n\t      var complete = function () {\n\t        if (continuous) {\n\t          changesOpts.live = true;\n\t          getChanges();\n\t        } else {\n\t          changesCompleted = true;\n\t        }\n\t        processPendingBatch(true);\n\t      };\n\t\n\t      // update the checkpoint so we start from the right seq next time\n\t      if (!currentBatch && changes.results.length === 0) {\n\t        writingCheckpoint = true;\n\t        checkpointer.writeCheckpoint(changes.last_seq,\n\t            session).then(function () {\n\t          writingCheckpoint = false;\n\t          result.last_seq = last_seq = changes.last_seq;\n\t          complete();\n\t        })\n\t        .catch(onCheckpointError);\n\t      } else {\n\t        complete();\n\t      }\n\t    }\n\t  }\n\t\n\t\n\t  function onChangesError(err) {\n\t    changesPending = false;\n\t    /* istanbul ignore if */\n\t    if (returnValue.cancelled) {\n\t      return completeReplication();\n\t    }\n\t    abortReplication('changes rejected', err);\n\t  }\n\t\n\t\n\t  function getChanges() {\n\t    if (!(\n\t      !changesPending &&\n\t      !changesCompleted &&\n\t      batches.length < batches_limit\n\t      )) {\n\t      return;\n\t    }\n\t    changesPending = true;\n\t    function abortChanges() {\n\t      changes.cancel();\n\t    }\n\t    function removeListener() {\n\t      returnValue.removeListener('cancel', abortChanges);\n\t    }\n\t\n\t    if (returnValue._changes) { // remove old changes() and listeners\n\t      returnValue.removeListener('cancel', returnValue._abortChanges);\n\t      returnValue._changes.cancel();\n\t    }\n\t    returnValue.once('cancel', abortChanges);\n\t\n\t    var changes = src.changes(changesOpts)\n\t      .on('change', onChange);\n\t    changes.then(removeListener, removeListener);\n\t    changes.then(onChangesComplete)\n\t      .catch(onChangesError);\n\t\n\t    if (opts.retry) {\n\t      // save for later so we can cancel if necessary\n\t      returnValue._changes = changes;\n\t      returnValue._abortChanges = abortChanges;\n\t    }\n\t  }\n\t\n\t\n\t  function startChanges() {\n\t    initCheckpointer().then(function () {\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        return;\n\t      }\n\t      return checkpointer.getCheckpoint().then(function (checkpoint) {\n\t        last_seq = checkpoint;\n\t        changesOpts = {\n\t          since: last_seq,\n\t          limit: batch_size,\n\t          batch_size: batch_size,\n\t          style: 'all_docs',\n\t          doc_ids: doc_ids,\n\t          return_docs: true // required so we know when we're done\n\t        };\n\t        if (opts.filter) {\n\t          if (typeof opts.filter !== 'string') {\n\t            // required for the client-side filter in onChange\n\t            changesOpts.include_docs = true;\n\t          } else { // ddoc filter\n\t            changesOpts.filter = opts.filter;\n\t          }\n\t        }\n\t        if ('heartbeat' in opts) {\n\t          changesOpts.heartbeat = opts.heartbeat;\n\t        }\n\t        if ('timeout' in opts) {\n\t          changesOpts.timeout = opts.timeout;\n\t        }\n\t        if (opts.query_params) {\n\t          changesOpts.query_params = opts.query_params;\n\t        }\n\t        if (opts.view) {\n\t          changesOpts.view = opts.view;\n\t        }\n\t        getChanges();\n\t      });\n\t    }).catch(function (err) {\n\t      abortReplication('getCheckpoint rejected with ', err);\n\t    });\n\t  }\n\t\n\t  /* istanbul ignore next */\n\t  function onCheckpointError(err) {\n\t    writingCheckpoint = false;\n\t    abortReplication('writeCheckpoint completed with error', err);\n\t  }\n\t\n\t  /* istanbul ignore if */\n\t  if (returnValue.cancelled) { // cancelled immediately\n\t    completeReplication();\n\t    return;\n\t  }\n\t\n\t  if (!returnValue._addedListeners) {\n\t    returnValue.once('cancel', completeReplication);\n\t\n\t    if (typeof opts.complete === 'function') {\n\t      returnValue.once('error', opts.complete);\n\t      returnValue.once('complete', function (result) {\n\t        opts.complete(null, result);\n\t      });\n\t    }\n\t    returnValue._addedListeners = true;\n\t  }\n\t\n\t  if (typeof opts.since === 'undefined') {\n\t    startChanges();\n\t  } else {\n\t    initCheckpointer().then(function () {\n\t      writingCheckpoint = true;\n\t      return checkpointer.writeCheckpoint(opts.since, session);\n\t    }).then(function () {\n\t      writingCheckpoint = false;\n\t      /* istanbul ignore if */\n\t      if (returnValue.cancelled) {\n\t        completeReplication();\n\t        return;\n\t      }\n\t      last_seq = opts.since;\n\t      startChanges();\n\t    }).catch(onCheckpointError);\n\t  }\n\t}\n\t\n\t// We create a basic promise so the caller can cancel the replication possibly\n\t// before we have actually started listening to changes etc\n\tinherits(Replication, events.EventEmitter);\n\tfunction Replication() {\n\t  events.EventEmitter.call(this);\n\t  this.cancelled = false;\n\t  this.state = 'pending';\n\t  var self = this;\n\t  var promise = new PouchPromise$1(function (fulfill, reject) {\n\t    self.once('complete', fulfill);\n\t    self.once('error', reject);\n\t  });\n\t  self.then = function (resolve, reject) {\n\t    return promise.then(resolve, reject);\n\t  };\n\t  self.catch = function (reject) {\n\t    return promise.catch(reject);\n\t  };\n\t  // As we allow error handling via \"error\" event as well,\n\t  // put a stub in here so that rejecting never throws UnhandledError.\n\t  self.catch(function () {});\n\t}\n\t\n\tReplication.prototype.cancel = function () {\n\t  this.cancelled = true;\n\t  this.state = 'cancelled';\n\t  this.emit('cancel');\n\t};\n\t\n\tReplication.prototype.ready = function (src, target) {\n\t  var self = this;\n\t  if (self._readyCalled) {\n\t    return;\n\t  }\n\t  self._readyCalled = true;\n\t\n\t  function onDestroy() {\n\t    self.cancel();\n\t  }\n\t  src.once('destroyed', onDestroy);\n\t  target.once('destroyed', onDestroy);\n\t  function cleanup() {\n\t    src.removeListener('destroyed', onDestroy);\n\t    target.removeListener('destroyed', onDestroy);\n\t  }\n\t  self.once('complete', cleanup);\n\t};\n\t\n\tfunction toPouch(db, opts) {\n\t  var PouchConstructor = opts.PouchConstructor;\n\t  if (typeof db === 'string') {\n\t    return new PouchConstructor(db, opts);\n\t  } else {\n\t    return db;\n\t  }\n\t}\n\t\n\tfunction replicateWrapper(src, target, opts, callback) {\n\t\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof opts === 'undefined') {\n\t    opts = {};\n\t  }\n\t\n\t  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n\t    throw createError(BAD_REQUEST,\n\t                       \"`doc_ids` filter parameter is not a list.\");\n\t  }\n\t\n\t  opts.complete = callback;\n\t  opts = clone(opts);\n\t  opts.continuous = opts.continuous || opts.live;\n\t  opts.retry = ('retry' in opts) ? opts.retry : false;\n\t  /*jshint validthis:true */\n\t  opts.PouchConstructor = opts.PouchConstructor || this;\n\t  var replicateRet = new Replication(opts);\n\t  var srcPouch = toPouch(src, opts);\n\t  var targetPouch = toPouch(target, opts);\n\t  replicate(srcPouch, targetPouch, opts, replicateRet);\n\t  return replicateRet;\n\t}\n\t\n\tinherits(Sync, events.EventEmitter);\n\tfunction sync$1(src, target, opts, callback) {\n\t  if (typeof opts === 'function') {\n\t    callback = opts;\n\t    opts = {};\n\t  }\n\t  if (typeof opts === 'undefined') {\n\t    opts = {};\n\t  }\n\t  opts = clone(opts);\n\t  /*jshint validthis:true */\n\t  opts.PouchConstructor = opts.PouchConstructor || this;\n\t  src = toPouch(src, opts);\n\t  target = toPouch(target, opts);\n\t  return new Sync(src, target, opts, callback);\n\t}\n\t\n\tfunction Sync(src, target, opts, callback) {\n\t  var self = this;\n\t  this.canceled = false;\n\t\n\t  var optsPush = opts.push ? assign$1({}, opts, opts.push) : opts;\n\t  var optsPull = opts.pull ? assign$1({}, opts, opts.pull) : opts;\n\t\n\t  this.push = replicateWrapper(src, target, optsPush);\n\t  this.pull = replicateWrapper(target, src, optsPull);\n\t\n\t  this.pushPaused = true;\n\t  this.pullPaused = true;\n\t\n\t  function pullChange(change) {\n\t    self.emit('change', {\n\t      direction: 'pull',\n\t      change: change\n\t    });\n\t  }\n\t  function pushChange(change) {\n\t    self.emit('change', {\n\t      direction: 'push',\n\t      change: change\n\t    });\n\t  }\n\t  function pushDenied(doc) {\n\t    self.emit('denied', {\n\t      direction: 'push',\n\t      doc: doc\n\t    });\n\t  }\n\t  function pullDenied(doc) {\n\t    self.emit('denied', {\n\t      direction: 'pull',\n\t      doc: doc\n\t    });\n\t  }\n\t  function pushPaused() {\n\t    self.pushPaused = true;\n\t    /* istanbul ignore if */\n\t    if (self.pullPaused) {\n\t      self.emit('paused');\n\t    }\n\t  }\n\t  function pullPaused() {\n\t    self.pullPaused = true;\n\t    /* istanbul ignore if */\n\t    if (self.pushPaused) {\n\t      self.emit('paused');\n\t    }\n\t  }\n\t  function pushActive() {\n\t    self.pushPaused = false;\n\t    /* istanbul ignore if */\n\t    if (self.pullPaused) {\n\t      self.emit('active', {\n\t        direction: 'push'\n\t      });\n\t    }\n\t  }\n\t  function pullActive() {\n\t    self.pullPaused = false;\n\t    /* istanbul ignore if */\n\t    if (self.pushPaused) {\n\t      self.emit('active', {\n\t        direction: 'pull'\n\t      });\n\t    }\n\t  }\n\t\n\t  var removed = {};\n\t\n\t  function removeAll(type) { // type is 'push' or 'pull'\n\t    return function (event, func) {\n\t      var isChange = event === 'change' &&\n\t        (func === pullChange || func === pushChange);\n\t      var isDenied = event === 'denied' &&\n\t        (func === pullDenied || func === pushDenied);\n\t      var isPaused = event === 'paused' &&\n\t        (func === pullPaused || func === pushPaused);\n\t      var isActive = event === 'active' &&\n\t        (func === pullActive || func === pushActive);\n\t\n\t      if (isChange || isDenied || isPaused || isActive) {\n\t        if (!(event in removed)) {\n\t          removed[event] = {};\n\t        }\n\t        removed[event][type] = true;\n\t        if (Object.keys(removed[event]).length === 2) {\n\t          // both push and pull have asked to be removed\n\t          self.removeAllListeners(event);\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  if (opts.live) {\n\t    this.push.on('complete', self.pull.cancel.bind(self.pull));\n\t    this.pull.on('complete', self.push.cancel.bind(self.push));\n\t  }\n\t\n\t  function addOneListener(ee, event, listener) {\n\t    if (ee.listeners(event).indexOf(listener) == -1) {\n\t      ee.on(event, listener);\n\t    }\n\t  }\n\t\n\t  this.on('newListener', function (event) {\n\t    if (event === 'change') {\n\t      addOneListener(self.pull, 'change', pullChange);\n\t      addOneListener(self.push, 'change', pushChange);\n\t    } else if (event === 'denied') {\n\t      addOneListener(self.pull, 'denied', pullDenied);\n\t      addOneListener(self.push, 'denied', pushDenied);\n\t    } else if (event === 'active') {\n\t      addOneListener(self.pull, 'active', pullActive);\n\t      addOneListener(self.push, 'active', pushActive);\n\t    } else if (event === 'paused') {\n\t      addOneListener(self.pull, 'paused', pullPaused);\n\t      addOneListener(self.push, 'paused', pushPaused);\n\t    }\n\t  });\n\t\n\t  this.on('removeListener', function (event) {\n\t    if (event === 'change') {\n\t      self.pull.removeListener('change', pullChange);\n\t      self.push.removeListener('change', pushChange);\n\t    } else if (event === 'denied') {\n\t      self.pull.removeListener('denied', pullDenied);\n\t      self.push.removeListener('denied', pushDenied);\n\t    } else if (event === 'active') {\n\t      self.pull.removeListener('active', pullActive);\n\t      self.push.removeListener('active', pushActive);\n\t    } else if (event === 'paused') {\n\t      self.pull.removeListener('paused', pullPaused);\n\t      self.push.removeListener('paused', pushPaused);\n\t    }\n\t  });\n\t\n\t  this.pull.on('removeListener', removeAll('pull'));\n\t  this.push.on('removeListener', removeAll('push'));\n\t\n\t  var promise = PouchPromise$1.all([\n\t    this.push,\n\t    this.pull\n\t  ]).then(function (resp) {\n\t    var out = {\n\t      push: resp[0],\n\t      pull: resp[1]\n\t    };\n\t    self.emit('complete', out);\n\t    if (callback) {\n\t      callback(null, out);\n\t    }\n\t    self.removeAllListeners();\n\t    return out;\n\t  }, function (err) {\n\t    self.cancel();\n\t    if (callback) {\n\t      // if there's a callback, then the callback can receive\n\t      // the error event\n\t      callback(err);\n\t    } else {\n\t      // if there's no callback, then we're safe to emit an error\n\t      // event, which would otherwise throw an unhandled error\n\t      // due to 'error' being a special event in EventEmitters\n\t      self.emit('error', err);\n\t    }\n\t    self.removeAllListeners();\n\t    if (callback) {\n\t      // no sense throwing if we're already emitting an 'error' event\n\t      throw err;\n\t    }\n\t  });\n\t\n\t  this.then = function (success, err) {\n\t    return promise.then(success, err);\n\t  };\n\t\n\t  this.catch = function (err) {\n\t    return promise.catch(err);\n\t  };\n\t}\n\t\n\tSync.prototype.cancel = function () {\n\t  if (!this.canceled) {\n\t    this.canceled = true;\n\t    this.push.cancel();\n\t    this.pull.cancel();\n\t  }\n\t};\n\t\n\tfunction replication(PouchDB) {\n\t  PouchDB.replicate = replicateWrapper;\n\t  PouchDB.sync = sync$1;\n\t\n\t  Object.defineProperty(PouchDB.prototype, 'replicate', {\n\t    get: function () {\n\t      var self = this;\n\t      return {\n\t        from: function (other, opts, callback) {\n\t          return self.constructor.replicate(other, self, opts, callback);\n\t        },\n\t        to: function (other, opts, callback) {\n\t          return self.constructor.replicate(self, other, opts, callback);\n\t        }\n\t      };\n\t    }\n\t  });\n\t\n\t  PouchDB.prototype.sync = function (dbName, opts, callback) {\n\t    return this.constructor.sync(this, dbName, opts, callback);\n\t  };\n\t}\n\t\n\tPouchDB$5.plugin(IDBPouch)\n\t  .plugin(WebSqlPouch)\n\t  .plugin(HttpPouch$1)\n\t  .plugin(mapreduce)\n\t  .plugin(replication);\n\t\n\t// Pull from src because pouchdb-node/pouchdb-browser themselves\n\t// are aggressively optimized and jsnext:main would normally give us this\n\t// aggressive bundle.\n\t\n\tmodule.exports = PouchDB$5;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ },\n/* 242 */\n[252, 243],\n/* 243 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t/**\n\t * This is the common logic for both the Node.js and web browser\n\t * implementations of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = createDebug.debug = createDebug.default = createDebug;\n\texports.coerce = coerce;\n\texports.disable = disable;\n\texports.enable = enable;\n\texports.enabled = enabled;\n\texports.humanize = __webpack_require__(244);\n\t\n\t/**\n\t * The currently active debug mode names, and names to skip.\n\t */\n\t\n\texports.names = [];\n\texports.skips = [];\n\t\n\t/**\n\t * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n\t *\n\t * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n\t */\n\t\n\texports.formatters = {};\n\t\n\t/**\n\t * Previous log timestamp.\n\t */\n\t\n\tvar prevTime;\n\t\n\t/**\n\t * Select a color.\n\t * @param {String} namespace\n\t * @return {Number}\n\t * @api private\n\t */\n\t\n\tfunction selectColor(namespace) {\n\t  var hash = 0, i;\n\t\n\t  for (i in namespace) {\n\t    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n\t    hash |= 0; // Convert to 32bit integer\n\t  }\n\t\n\t  return exports.colors[Math.abs(hash) % exports.colors.length];\n\t}\n\t\n\t/**\n\t * Create a debugger with the given `namespace`.\n\t *\n\t * @param {String} namespace\n\t * @return {Function}\n\t * @api public\n\t */\n\t\n\tfunction createDebug(namespace) {\n\t\n\t  function debug() {\n\t    // disabled?\n\t    if (!debug.enabled) return;\n\t\n\t    var self = debug;\n\t\n\t    // set `diff` timestamp\n\t    var curr = +new Date();\n\t    var ms = curr - (prevTime || curr);\n\t    self.diff = ms;\n\t    self.prev = prevTime;\n\t    self.curr = curr;\n\t    prevTime = curr;\n\t\n\t    // turn the `arguments` into a proper Array\n\t    var args = new Array(arguments.length);\n\t    for (var i = 0; i < args.length; i++) {\n\t      args[i] = arguments[i];\n\t    }\n\t\n\t    args[0] = exports.coerce(args[0]);\n\t\n\t    if ('string' !== typeof args[0]) {\n\t      // anything else let's inspect with %O\n\t      args.unshift('%O');\n\t    }\n\t\n\t    // apply any `formatters` transformations\n\t    var index = 0;\n\t    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n\t      // if we encounter an escaped % then don't increase the array index\n\t      if (match === '%%') return match;\n\t      index++;\n\t      var formatter = exports.formatters[format];\n\t      if ('function' === typeof formatter) {\n\t        var val = args[index];\n\t        match = formatter.call(self, val);\n\t\n\t        // now we need to remove `args[index]` since it's inlined in the `format`\n\t        args.splice(index, 1);\n\t        index--;\n\t      }\n\t      return match;\n\t    });\n\t\n\t    // apply env-specific formatting (colors, etc.)\n\t    exports.formatArgs.call(self, args);\n\t\n\t    var logFn = debug.log || exports.log || console.log.bind(console);\n\t    logFn.apply(self, args);\n\t  }\n\t\n\t  debug.namespace = namespace;\n\t  debug.enabled = exports.enabled(namespace);\n\t  debug.useColors = exports.useColors();\n\t  debug.color = selectColor(namespace);\n\t\n\t  // env-specific initialization logic for debug instances\n\t  if ('function' === typeof exports.init) {\n\t    exports.init(debug);\n\t  }\n\t\n\t  return debug;\n\t}\n\t\n\t/**\n\t * Enables a debug mode by namespaces. This can include modes\n\t * separated by a colon and wildcards.\n\t *\n\t * @param {String} namespaces\n\t * @api public\n\t */\n\t\n\tfunction enable(namespaces) {\n\t  exports.save(namespaces);\n\t\n\t  var split = (namespaces || '').split(/[\\s,]+/);\n\t  var len = split.length;\n\t\n\t  for (var i = 0; i < len; i++) {\n\t    if (!split[i]) continue; // ignore empty strings\n\t    namespaces = split[i].replace(/\\*/g, '.*?');\n\t    if (namespaces[0] === '-') {\n\t      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n\t    } else {\n\t      exports.names.push(new RegExp('^' + namespaces + '$'));\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Disable debug output.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction disable() {\n\t  exports.enable('');\n\t}\n\t\n\t/**\n\t * Returns true if the given mode name is enabled, false otherwise.\n\t *\n\t * @param {String} name\n\t * @return {Boolean}\n\t * @api public\n\t */\n\t\n\tfunction enabled(name) {\n\t  var i, len;\n\t  for (i = 0, len = exports.skips.length; i < len; i++) {\n\t    if (exports.skips[i].test(name)) {\n\t      return false;\n\t    }\n\t  }\n\t  for (i = 0, len = exports.names.length; i < len; i++) {\n\t    if (exports.names[i].test(name)) {\n\t      return true;\n\t    }\n\t  }\n\t  return false;\n\t}\n\t\n\t/**\n\t * Coerce `val`.\n\t *\n\t * @param {Mixed} val\n\t * @return {Mixed}\n\t * @api private\n\t */\n\t\n\tfunction coerce(val) {\n\t  if (val instanceof Error) return val.stack || val.message;\n\t  return val;\n\t}\n\n\n/***/ },\n/* 244 */\n237,\n/* 245 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function (factory) {\n\t    if (true) {\n\t        // Node/CommonJS\n\t        module.exports = factory();\n\t    } else if (typeof define === 'function' && define.amd) {\n\t        // AMD\n\t        define(factory);\n\t    } else {\n\t        // Browser globals (with support for web workers)\n\t        var glob;\n\t\n\t        try {\n\t            glob = window;\n\t        } catch (e) {\n\t            glob = self;\n\t        }\n\t\n\t        glob.SparkMD5 = factory();\n\t    }\n\t}(function (undefined) {\n\t\n\t    'use strict';\n\t\n\t    /*\n\t     * Fastest md5 implementation around (JKM md5).\n\t     * Credits: Joseph Myers\n\t     *\n\t     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n\t     * @see http://jsperf.com/md5-shootout/7\n\t     */\n\t\n\t    /* this function is much faster,\n\t      so if possible we use it. Some IEs\n\t      are the only ones I know of that\n\t      need the idiotic second function,\n\t      generated by an if clause.  */\n\t    var add32 = function (a, b) {\n\t        return (a + b) & 0xFFFFFFFF;\n\t    },\n\t        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\t\n\t\n\t    function cmn(q, a, b, x, s, t) {\n\t        a = add32(add32(a, q), add32(x, t));\n\t        return add32((a << s) | (a >>> (32 - s)), b);\n\t    }\n\t\n\t    function md5cycle(x, k) {\n\t        var a = x[0],\n\t            b = x[1],\n\t            c = x[2],\n\t            d = x[3];\n\t\n\t        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n\t        a  = (a << 7 | a >>> 25) + b | 0;\n\t        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n\t        d  = (d << 12 | d >>> 20) + a | 0;\n\t        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n\t        c  = (c << 17 | c >>> 15) + d | 0;\n\t        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n\t        b  = (b << 22 | b >>> 10) + c | 0;\n\t\n\t        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n\t        a  = (a << 5 | a >>> 27) + b | 0;\n\t        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n\t        d  = (d << 9 | d >>> 23) + a | 0;\n\t        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n\t        c  = (c << 14 | c >>> 18) + d | 0;\n\t        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n\t        b  = (b << 20 | b >>> 12) + c | 0;\n\t\n\t        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n\t        a  = (a << 4 | a >>> 28) + b | 0;\n\t        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n\t        d  = (d << 11 | d >>> 21) + a | 0;\n\t        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n\t        c  = (c << 16 | c >>> 16) + d | 0;\n\t        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n\t        b  = (b << 23 | b >>> 9) + c | 0;\n\t\n\t        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n\t        b  = (b << 21 |b >>> 11) + c | 0;\n\t        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n\t        a  = (a << 6 | a >>> 26) + b | 0;\n\t        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n\t        d  = (d << 10 | d >>> 22) + a | 0;\n\t        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n\t        c  = (c << 15 | c >>> 17) + d | 0;\n\t        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n\t        b  = (b << 21 | b >>> 11) + c | 0;\n\t\n\t        x[0] = a + x[0] | 0;\n\t        x[1] = b + x[1] | 0;\n\t        x[2] = c + x[2] | 0;\n\t        x[3] = d + x[3] | 0;\n\t    }\n\t\n\t    function md5blk(s) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\t\n\t    function md5blk_array(a) {\n\t        var md5blks = [],\n\t            i; /* Andy King said do it this way. */\n\t\n\t        for (i = 0; i < 64; i += 4) {\n\t            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n\t        }\n\t        return md5blks;\n\t    }\n\t\n\t    function md51(s) {\n\t        var n = s.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk(s.substring(i - 64, i)));\n\t        }\n\t        s = s.substring(i - 64);\n\t        length = s.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t        return state;\n\t    }\n\t\n\t    function md51_array(a) {\n\t        var n = a.length,\n\t            state = [1732584193, -271733879, -1732584194, 271733878],\n\t            i,\n\t            length,\n\t            tail,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        for (i = 64; i <= n; i += 64) {\n\t            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n\t        }\n\t\n\t        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n\t        // containing the last element of the parent array if the sub array specified starts\n\t        // beyond the length of the parent array - weird.\n\t        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n\t        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\t\n\t        length = a.length;\n\t        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(state, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Beware that the final length might not fit in 32 bits so we take care of that\n\t        tmp = n * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t\n\t        md5cycle(state, tail);\n\t\n\t        return state;\n\t    }\n\t\n\t    function rhex(n) {\n\t        var s = '',\n\t            j;\n\t        for (j = 0; j < 4; j += 1) {\n\t            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n\t        }\n\t        return s;\n\t    }\n\t\n\t    function hex(x) {\n\t        var i;\n\t        for (i = 0; i < x.length; i += 1) {\n\t            x[i] = rhex(x[i]);\n\t        }\n\t        return x.join('');\n\t    }\n\t\n\t    // In some cases the fast add32 function cannot be used..\n\t    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n\t        add32 = function (x, y) {\n\t            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n\t                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n\t            return (msw << 16) | (lsw & 0xFFFF);\n\t        };\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * ArrayBuffer slice polyfill.\n\t     *\n\t     * @see https://github.com/ttaubert/node-arraybuffer-slice\n\t     */\n\t\n\t    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n\t        (function () {\n\t            function clamp(val, length) {\n\t                val = (val | 0) || 0;\n\t\n\t                if (val < 0) {\n\t                    return Math.max(val + length, 0);\n\t                }\n\t\n\t                return Math.min(val, length);\n\t            }\n\t\n\t            ArrayBuffer.prototype.slice = function (from, to) {\n\t                var length = this.byteLength,\n\t                    begin = clamp(from, length),\n\t                    end = length,\n\t                    num,\n\t                    target,\n\t                    targetArray,\n\t                    sourceArray;\n\t\n\t                if (to !== undefined) {\n\t                    end = clamp(to, length);\n\t                }\n\t\n\t                if (begin > end) {\n\t                    return new ArrayBuffer(0);\n\t                }\n\t\n\t                num = end - begin;\n\t                target = new ArrayBuffer(num);\n\t                targetArray = new Uint8Array(target);\n\t\n\t                sourceArray = new Uint8Array(this, begin, num);\n\t                targetArray.set(sourceArray);\n\t\n\t                return target;\n\t            };\n\t        })();\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * Helpers.\n\t     */\n\t\n\t    function toUtf8(str) {\n\t        if (/[\\u0080-\\uFFFF]/.test(str)) {\n\t            str = unescape(encodeURIComponent(str));\n\t        }\n\t\n\t        return str;\n\t    }\n\t\n\t    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n\t        var length = str.length,\n\t           buff = new ArrayBuffer(length),\n\t           arr = new Uint8Array(buff),\n\t           i;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            arr[i] = str.charCodeAt(i);\n\t        }\n\t\n\t        return returnUInt8Array ? arr : buff;\n\t    }\n\t\n\t    function arrayBuffer2Utf8Str(buff) {\n\t        return String.fromCharCode.apply(null, new Uint8Array(buff));\n\t    }\n\t\n\t    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n\t        var result = new Uint8Array(first.byteLength + second.byteLength);\n\t\n\t        result.set(new Uint8Array(first));\n\t        result.set(new Uint8Array(second), first.byteLength);\n\t\n\t        return returnUInt8Array ? result : result.buffer;\n\t    }\n\t\n\t    function hexToBinaryString(hex) {\n\t        var bytes = [],\n\t            length = hex.length,\n\t            x;\n\t\n\t        for (x = 0; x < length - 1; x += 2) {\n\t            bytes.push(parseInt(hex.substr(x, 2), 16));\n\t        }\n\t\n\t        return String.fromCharCode.apply(String, bytes);\n\t    }\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation.\n\t     *\n\t     * Use this class to perform an incremental md5, otherwise use the\n\t     * static methods instead.\n\t     */\n\t\n\t    function SparkMD5() {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    }\n\t\n\t    /**\n\t     * Appends a string.\n\t     * A conversion will be applied if an utf8 string is detected.\n\t     *\n\t     * @param {String} str The string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.append = function (str) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then append as binary\n\t        this.appendBinary(toUtf8(str));\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Appends a binary string.\n\t     *\n\t     * @param {String} contents The binary string to be appended\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.appendBinary = function (contents) {\n\t        this._buff += contents;\n\t        this._length += contents.length;\n\t\n\t        var length = this._buff.length,\n\t            i;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n\t        }\n\t\n\t        this._buff = this._buff.substring(i - 64);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            i,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\t\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.reset = function () {\n\t        this._buff = '';\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.prototype.getState = function () {\n\t        return {\n\t            buff: this._buff,\n\t            length: this._length,\n\t            hash: this._hash\n\t        };\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5} The instance itself\n\t     */\n\t    SparkMD5.prototype.setState = function (state) {\n\t        this._buff = state.buff;\n\t        this._length = state.length;\n\t        this._hash = state.hash;\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Releases memory used by the incremental buffer and other additional\n\t     * resources. If you plan to use the instance again, use reset instead.\n\t     */\n\t    SparkMD5.prototype.destroy = function () {\n\t        delete this._hash;\n\t        delete this._buff;\n\t        delete this._length;\n\t    };\n\t\n\t    /**\n\t     * Finish the final calculation based on the tail.\n\t     *\n\t     * @param {Array}  tail   The tail (will be modified)\n\t     * @param {Number} length The length of the remaining buffer\n\t     */\n\t    SparkMD5.prototype._finish = function (tail, length) {\n\t        var i = length,\n\t            tmp,\n\t            lo,\n\t            hi;\n\t\n\t        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n\t        if (i > 55) {\n\t            md5cycle(this._hash, tail);\n\t            for (i = 0; i < 16; i += 1) {\n\t                tail[i] = 0;\n\t            }\n\t        }\n\t\n\t        // Do the final computation based on the tail and length\n\t        // Beware that the final length may not fit in 32 bits so we take care of that\n\t        tmp = this._length * 8;\n\t        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n\t        lo = parseInt(tmp[2], 16);\n\t        hi = parseInt(tmp[1], 16) || 0;\n\t\n\t        tail[14] = lo;\n\t        tail[15] = hi;\n\t        md5cycle(this._hash, tail);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a string.\n\t     * A conversion will be applied if utf8 string is detected.\n\t     *\n\t     * @param {String}  str The string\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hash = function (str, raw) {\n\t        // Converts the string to utf8 bytes if necessary\n\t        // Then compute it using the binary function\n\t        return SparkMD5.hashBinary(toUtf8(str), raw);\n\t    };\n\t\n\t    /**\n\t     * Performs the md5 hash on a binary string.\n\t     *\n\t     * @param {String}  content The binary string\n\t     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.hashBinary = function (content, raw) {\n\t        var hash = md51(content),\n\t            ret = hex(hash);\n\t\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\t\n\t    // ---------------------------------------------------\n\t\n\t    /**\n\t     * SparkMD5 OOP implementation for array buffers.\n\t     *\n\t     * Use this class to perform an incremental md5 ONLY for array buffers.\n\t     */\n\t    SparkMD5.ArrayBuffer = function () {\n\t        // call reset to init the instance\n\t        this.reset();\n\t    };\n\t\n\t    /**\n\t     * Appends an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array to be appended\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n\t        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n\t            length = buff.length,\n\t            i;\n\t\n\t        this._length += arr.byteLength;\n\t\n\t        for (i = 64; i <= length; i += 64) {\n\t            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n\t        }\n\t\n\t        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Finishes the incremental computation, reseting the internal state and\n\t     * returning the result.\n\t     *\n\t     * @param {Boolean} raw True to get the raw string, false to get the hex string\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n\t        var buff = this._buff,\n\t            length = buff.length,\n\t            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n\t            i,\n\t            ret;\n\t\n\t        for (i = 0; i < length; i += 1) {\n\t            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n\t        }\n\t\n\t        this._finish(tail, length);\n\t        ret = hex(this._hash);\n\t\n\t        if (raw) {\n\t            ret = hexToBinaryString(ret);\n\t        }\n\t\n\t        this.reset();\n\t\n\t        return ret;\n\t    };\n\t\n\t    /**\n\t     * Resets the internal state of the computation.\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.reset = function () {\n\t        this._buff = new Uint8Array(0);\n\t        this._length = 0;\n\t        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\t\n\t        return this;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @return {Object} The state\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.getState = function () {\n\t        var state = SparkMD5.prototype.getState.call(this);\n\t\n\t        // Convert buffer to a string\n\t        state.buff = arrayBuffer2Utf8Str(state.buff);\n\t\n\t        return state;\n\t    };\n\t\n\t    /**\n\t     * Gets the internal state of the computation.\n\t     *\n\t     * @param {Object} state The state\n\t     *\n\t     * @return {SparkMD5.ArrayBuffer} The instance itself\n\t     */\n\t    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n\t        // Convert string to buffer\n\t        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\t\n\t        return SparkMD5.prototype.setState.call(this, state);\n\t    };\n\t\n\t    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\t\n\t    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\t\n\t    /**\n\t     * Performs the md5 hash on an array buffer.\n\t     *\n\t     * @param {ArrayBuffer} arr The array buffer\n\t     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n\t     *\n\t     * @return {String} The result\n\t     */\n\t    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n\t        var hash = md51_array(new Uint8Array(arr)),\n\t            ret = hex(hash);\n\t\n\t        return raw ? hexToBinaryString(ret) : ret;\n\t    };\n\t\n\t    return SparkMD5;\n\t}));\n\n\n/***/ },\n/* 246 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(global, process) {/**\n\t * Copyright (c) 2014, Facebook, Inc.\n\t * All rights reserved.\n\t *\n\t * This source code is licensed under the BSD-style license found in the\n\t * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n\t * additional grant of patent rights can be found in the PATENTS file in\n\t * the same directory.\n\t */\n\t\n\t!(function(global) {\n\t  \"use strict\";\n\t\n\t  var Op = Object.prototype;\n\t  var hasOwn = Op.hasOwnProperty;\n\t  var undefined; // More compressible than void 0.\n\t  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n\t  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n\t  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\t\n\t  var inModule = typeof module === \"object\";\n\t  var runtime = global.regeneratorRuntime;\n\t  if (runtime) {\n\t    if (inModule) {\n\t      // If regeneratorRuntime is defined globally and we're in a module,\n\t      // make the exports object identical to regeneratorRuntime.\n\t      module.exports = runtime;\n\t    }\n\t    // Don't bother evaluating the rest of this file if the runtime was\n\t    // already defined globally.\n\t    return;\n\t  }\n\t\n\t  // Define the runtime globally (as expected by generated code) as either\n\t  // module.exports (if we're in a module) or a new, empty object.\n\t  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\t\n\t  function wrap(innerFn, outerFn, self, tryLocsList) {\n\t    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n\t    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n\t    var generator = Object.create(protoGenerator.prototype);\n\t    var context = new Context(tryLocsList || []);\n\t\n\t    // The ._invoke method unifies the implementations of the .next,\n\t    // .throw, and .return methods.\n\t    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\t\n\t    return generator;\n\t  }\n\t  runtime.wrap = wrap;\n\t\n\t  // Try/catch helper to minimize deoptimizations. Returns a completion\n\t  // record like context.tryEntries[i].completion. This interface could\n\t  // have been (and was previously) designed to take a closure to be\n\t  // invoked without arguments, but in all the cases we care about we\n\t  // already have an existing method we want to call, so there's no need\n\t  // to create a new function object. We can even get away with assuming\n\t  // the method takes exactly one argument, since that happens to be true\n\t  // in every case, so we don't have to touch the arguments object. The\n\t  // only additional allocation required is the completion record, which\n\t  // has a stable shape and so hopefully should be cheap to allocate.\n\t  function tryCatch(fn, obj, arg) {\n\t    try {\n\t      return { type: \"normal\", arg: fn.call(obj, arg) };\n\t    } catch (err) {\n\t      return { type: \"throw\", arg: err };\n\t    }\n\t  }\n\t\n\t  var GenStateSuspendedStart = \"suspendedStart\";\n\t  var GenStateSuspendedYield = \"suspendedYield\";\n\t  var GenStateExecuting = \"executing\";\n\t  var GenStateCompleted = \"completed\";\n\t\n\t  // Returning this object from the innerFn has the same effect as\n\t  // breaking out of the dispatch switch statement.\n\t  var ContinueSentinel = {};\n\t\n\t  // Dummy constructor functions that we use as the .constructor and\n\t  // .constructor.prototype properties for functions that return Generator\n\t  // objects. For full spec compliance, you may wish to configure your\n\t  // minifier not to mangle the names of these two functions.\n\t  function Generator() {}\n\t  function GeneratorFunction() {}\n\t  function GeneratorFunctionPrototype() {}\n\t\n\t  // This is a polyfill for %IteratorPrototype% for environments that\n\t  // don't natively support it.\n\t  var IteratorPrototype = {};\n\t  IteratorPrototype[iteratorSymbol] = function () {\n\t    return this;\n\t  };\n\t\n\t  var getProto = Object.getPrototypeOf;\n\t  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n\t  if (NativeIteratorPrototype &&\n\t      NativeIteratorPrototype !== Op &&\n\t      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n\t    // This environment has a native %IteratorPrototype%; use it instead\n\t    // of the polyfill.\n\t    IteratorPrototype = NativeIteratorPrototype;\n\t  }\n\t\n\t  var Gp = GeneratorFunctionPrototype.prototype =\n\t    Generator.prototype = Object.create(IteratorPrototype);\n\t  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n\t  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n\t  GeneratorFunctionPrototype[toStringTagSymbol] =\n\t    GeneratorFunction.displayName = \"GeneratorFunction\";\n\t\n\t  // Helper for defining the .next, .throw, and .return methods of the\n\t  // Iterator interface in terms of a single ._invoke method.\n\t  function defineIteratorMethods(prototype) {\n\t    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n\t      prototype[method] = function(arg) {\n\t        return this._invoke(method, arg);\n\t      };\n\t    });\n\t  }\n\t\n\t  runtime.isGeneratorFunction = function(genFun) {\n\t    var ctor = typeof genFun === \"function\" && genFun.constructor;\n\t    return ctor\n\t      ? ctor === GeneratorFunction ||\n\t        // For the native GeneratorFunction constructor, the best we can\n\t        // do is to check its .name property.\n\t        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n\t      : false;\n\t  };\n\t\n\t  runtime.mark = function(genFun) {\n\t    if (Object.setPrototypeOf) {\n\t      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n\t    } else {\n\t      genFun.__proto__ = GeneratorFunctionPrototype;\n\t      if (!(toStringTagSymbol in genFun)) {\n\t        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n\t      }\n\t    }\n\t    genFun.prototype = Object.create(Gp);\n\t    return genFun;\n\t  };\n\t\n\t  // Within the body of any async function, `await x` is transformed to\n\t  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n\t  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n\t  // meant to be awaited.\n\t  runtime.awrap = function(arg) {\n\t    return { __await: arg };\n\t  };\n\t\n\t  function AsyncIterator(generator) {\n\t    function invoke(method, arg, resolve, reject) {\n\t      var record = tryCatch(generator[method], generator, arg);\n\t      if (record.type === \"throw\") {\n\t        reject(record.arg);\n\t      } else {\n\t        var result = record.arg;\n\t        var value = result.value;\n\t        if (value &&\n\t            typeof value === \"object\" &&\n\t            hasOwn.call(value, \"__await\")) {\n\t          return Promise.resolve(value.__await).then(function(value) {\n\t            invoke(\"next\", value, resolve, reject);\n\t          }, function(err) {\n\t            invoke(\"throw\", err, resolve, reject);\n\t          });\n\t        }\n\t\n\t        return Promise.resolve(value).then(function(unwrapped) {\n\t          // When a yielded Promise is resolved, its final value becomes\n\t          // the .value of the Promise<{value,done}> result for the\n\t          // current iteration. If the Promise is rejected, however, the\n\t          // result for this iteration will be rejected with the same\n\t          // reason. Note that rejections of yielded Promises are not\n\t          // thrown back into the generator function, as is the case\n\t          // when an awaited Promise is rejected. This difference in\n\t          // behavior between yield and await is important, because it\n\t          // allows the consumer to decide what to do with the yielded\n\t          // rejection (swallow it and continue, manually .throw it back\n\t          // into the generator, abandon iteration, whatever). With\n\t          // await, by contrast, there is no opportunity to examine the\n\t          // rejection reason outside the generator function, so the\n\t          // only option is to throw it from the await expression, and\n\t          // let the generator function handle the exception.\n\t          result.value = unwrapped;\n\t          resolve(result);\n\t        }, reject);\n\t      }\n\t    }\n\t\n\t    if (typeof process === \"object\" && process.domain) {\n\t      invoke = process.domain.bind(invoke);\n\t    }\n\t\n\t    var previousPromise;\n\t\n\t    function enqueue(method, arg) {\n\t      function callInvokeWithMethodAndArg() {\n\t        return new Promise(function(resolve, reject) {\n\t          invoke(method, arg, resolve, reject);\n\t        });\n\t      }\n\t\n\t      return previousPromise =\n\t        // If enqueue has been called before, then we want to wait until\n\t        // all previous Promises have been resolved before calling invoke,\n\t        // so that results are always delivered in the correct order. If\n\t        // enqueue has not been called before, then it is important to\n\t        // call invoke immediately, without waiting on a callback to fire,\n\t        // so that the async generator function has the opportunity to do\n\t        // any necessary setup in a predictable way. This predictability\n\t        // is why the Promise constructor synchronously invokes its\n\t        // executor callback, and why async functions synchronously\n\t        // execute code before the first await. Since we implement simple\n\t        // async functions in terms of async generators, it is especially\n\t        // important to get this right, even though it requires care.\n\t        previousPromise ? previousPromise.then(\n\t          callInvokeWithMethodAndArg,\n\t          // Avoid propagating failures to Promises returned by later\n\t          // invocations of the iterator.\n\t          callInvokeWithMethodAndArg\n\t        ) : callInvokeWithMethodAndArg();\n\t    }\n\t\n\t    // Define the unified helper method that is used to implement .next,\n\t    // .throw, and .return (see defineIteratorMethods).\n\t    this._invoke = enqueue;\n\t  }\n\t\n\t  defineIteratorMethods(AsyncIterator.prototype);\n\t  runtime.AsyncIterator = AsyncIterator;\n\t\n\t  // Note that simple async functions are implemented on top of\n\t  // AsyncIterator objects; they just return a Promise for the value of\n\t  // the final result produced by the iterator.\n\t  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n\t    var iter = new AsyncIterator(\n\t      wrap(innerFn, outerFn, self, tryLocsList)\n\t    );\n\t\n\t    return runtime.isGeneratorFunction(outerFn)\n\t      ? iter // If outerFn is a generator, return the full iterator.\n\t      : iter.next().then(function(result) {\n\t          return result.done ? result.value : iter.next();\n\t        });\n\t  };\n\t\n\t  function makeInvokeMethod(innerFn, self, context) {\n\t    var state = GenStateSuspendedStart;\n\t\n\t    return function invoke(method, arg) {\n\t      if (state === GenStateExecuting) {\n\t        throw new Error(\"Generator is already running\");\n\t      }\n\t\n\t      if (state === GenStateCompleted) {\n\t        if (method === \"throw\") {\n\t          throw arg;\n\t        }\n\t\n\t        // Be forgiving, per 25.3.3.3.3 of the spec:\n\t        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n\t        return doneResult();\n\t      }\n\t\n\t      context.method = method;\n\t      context.arg = arg;\n\t\n\t      while (true) {\n\t        var delegate = context.delegate;\n\t        if (delegate) {\n\t          var delegateResult = maybeInvokeDelegate(delegate, context);\n\t          if (delegateResult) {\n\t            if (delegateResult === ContinueSentinel) continue;\n\t            return delegateResult;\n\t          }\n\t        }\n\t\n\t        if (context.method === \"next\") {\n\t          // Setting context._sent for legacy support of Babel's\n\t          // function.sent implementation.\n\t          context.sent = context._sent = context.arg;\n\t\n\t        } else if (context.method === \"throw\") {\n\t          if (state === GenStateSuspendedStart) {\n\t            state = GenStateCompleted;\n\t            throw context.arg;\n\t          }\n\t\n\t          context.dispatchException(context.arg);\n\t\n\t        } else if (context.method === \"return\") {\n\t          context.abrupt(\"return\", context.arg);\n\t        }\n\t\n\t        state = GenStateExecuting;\n\t\n\t        var record = tryCatch(innerFn, self, context);\n\t        if (record.type === \"normal\") {\n\t          // If an exception is thrown from innerFn, we leave state ===\n\t          // GenStateExecuting and loop back for another invocation.\n\t          state = context.done\n\t            ? GenStateCompleted\n\t            : GenStateSuspendedYield;\n\t\n\t          if (record.arg === ContinueSentinel) {\n\t            continue;\n\t          }\n\t\n\t          return {\n\t            value: record.arg,\n\t            done: context.done\n\t          };\n\t\n\t        } else if (record.type === \"throw\") {\n\t          state = GenStateCompleted;\n\t          // Dispatch the exception by looping back around to the\n\t          // context.dispatchException(context.arg) call above.\n\t          context.method = \"throw\";\n\t          context.arg = record.arg;\n\t        }\n\t      }\n\t    };\n\t  }\n\t\n\t  // Call delegate.iterator[context.method](context.arg) and handle the\n\t  // result, either by returning a { value, done } result from the\n\t  // delegate iterator, or by modifying context.method and context.arg,\n\t  // setting context.delegate to null, and returning the ContinueSentinel.\n\t  function maybeInvokeDelegate(delegate, context) {\n\t    var method = delegate.iterator[context.method];\n\t    if (method === undefined) {\n\t      // A .throw or .return when the delegate iterator has no .throw\n\t      // method always terminates the yield* loop.\n\t      context.delegate = null;\n\t\n\t      if (context.method === \"throw\") {\n\t        if (delegate.iterator.return) {\n\t          // If the delegate iterator has a return method, give it a\n\t          // chance to clean up.\n\t          context.method = \"return\";\n\t          context.arg = undefined;\n\t          maybeInvokeDelegate(delegate, context);\n\t\n\t          if (context.method === \"throw\") {\n\t            // If maybeInvokeDelegate(context) changed context.method from\n\t            // \"return\" to \"throw\", let that override the TypeError below.\n\t            return ContinueSentinel;\n\t          }\n\t        }\n\t\n\t        context.method = \"throw\";\n\t        context.arg = new TypeError(\n\t          \"The iterator does not provide a 'throw' method\");\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    var record = tryCatch(method, delegate.iterator, context.arg);\n\t\n\t    if (record.type === \"throw\") {\n\t      context.method = \"throw\";\n\t      context.arg = record.arg;\n\t      context.delegate = null;\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    var info = record.arg;\n\t\n\t    if (! info) {\n\t      context.method = \"throw\";\n\t      context.arg = new TypeError(\"iterator result is not an object\");\n\t      context.delegate = null;\n\t      return ContinueSentinel;\n\t    }\n\t\n\t    if (info.done) {\n\t      // Assign the result of the finished delegate to the temporary\n\t      // variable specified by delegate.resultName (see delegateYield).\n\t      context[delegate.resultName] = info.value;\n\t\n\t      // Resume execution at the desired location (see delegateYield).\n\t      context.next = delegate.nextLoc;\n\t\n\t      // If context.method was \"throw\" but the delegate handled the\n\t      // exception, let the outer generator proceed normally. If\n\t      // context.method was \"next\", forget context.arg since it has been\n\t      // \"consumed\" by the delegate iterator. If context.method was\n\t      // \"return\", allow the original .return call to continue in the\n\t      // outer generator.\n\t      if (context.method !== \"return\") {\n\t        context.method = \"next\";\n\t        context.arg = undefined;\n\t      }\n\t\n\t    } else {\n\t      // Re-yield the result returned by the delegate method.\n\t      return info;\n\t    }\n\t\n\t    // The delegate iterator is finished, so forget it and continue with\n\t    // the outer generator.\n\t    context.delegate = null;\n\t    return ContinueSentinel;\n\t  }\n\t\n\t  // Define Generator.prototype.{next,throw,return} in terms of the\n\t  // unified ._invoke helper method.\n\t  defineIteratorMethods(Gp);\n\t\n\t  Gp[toStringTagSymbol] = \"Generator\";\n\t\n\t  Gp.toString = function() {\n\t    return \"[object Generator]\";\n\t  };\n\t\n\t  function pushTryEntry(locs) {\n\t    var entry = { tryLoc: locs[0] };\n\t\n\t    if (1 in locs) {\n\t      entry.catchLoc = locs[1];\n\t    }\n\t\n\t    if (2 in locs) {\n\t      entry.finallyLoc = locs[2];\n\t      entry.afterLoc = locs[3];\n\t    }\n\t\n\t    this.tryEntries.push(entry);\n\t  }\n\t\n\t  function resetTryEntry(entry) {\n\t    var record = entry.completion || {};\n\t    record.type = \"normal\";\n\t    delete record.arg;\n\t    entry.completion = record;\n\t  }\n\t\n\t  function Context(tryLocsList) {\n\t    // The root entry object (effectively a try statement without a catch\n\t    // or a finally block) gives us a place to store values thrown from\n\t    // locations where there is no enclosing try statement.\n\t    this.tryEntries = [{ tryLoc: \"root\" }];\n\t    tryLocsList.forEach(pushTryEntry, this);\n\t    this.reset(true);\n\t  }\n\t\n\t  runtime.keys = function(object) {\n\t    var keys = [];\n\t    for (var key in object) {\n\t      keys.push(key);\n\t    }\n\t    keys.reverse();\n\t\n\t    // Rather than returning an object with a next method, we keep\n\t    // things simple and return the next function itself.\n\t    return function next() {\n\t      while (keys.length) {\n\t        var key = keys.pop();\n\t        if (key in object) {\n\t          next.value = key;\n\t          next.done = false;\n\t          return next;\n\t        }\n\t      }\n\t\n\t      // To avoid creating an additional object, we just hang the .value\n\t      // and .done properties off the next function object itself. This\n\t      // also ensures that the minifier will not anonymize the function.\n\t      next.done = true;\n\t      return next;\n\t    };\n\t  };\n\t\n\t  function values(iterable) {\n\t    if (iterable) {\n\t      var iteratorMethod = iterable[iteratorSymbol];\n\t      if (iteratorMethod) {\n\t        return iteratorMethod.call(iterable);\n\t      }\n\t\n\t      if (typeof iterable.next === \"function\") {\n\t        return iterable;\n\t      }\n\t\n\t      if (!isNaN(iterable.length)) {\n\t        var i = -1, next = function next() {\n\t          while (++i < iterable.length) {\n\t            if (hasOwn.call(iterable, i)) {\n\t              next.value = iterable[i];\n\t              next.done = false;\n\t              return next;\n\t            }\n\t          }\n\t\n\t          next.value = undefined;\n\t          next.done = true;\n\t\n\t          return next;\n\t        };\n\t\n\t        return next.next = next;\n\t      }\n\t    }\n\t\n\t    // Return an iterator with no values.\n\t    return { next: doneResult };\n\t  }\n\t  runtime.values = values;\n\t\n\t  function doneResult() {\n\t    return { value: undefined, done: true };\n\t  }\n\t\n\t  Context.prototype = {\n\t    constructor: Context,\n\t\n\t    reset: function(skipTempReset) {\n\t      this.prev = 0;\n\t      this.next = 0;\n\t      // Resetting context._sent for legacy support of Babel's\n\t      // function.sent implementation.\n\t      this.sent = this._sent = undefined;\n\t      this.done = false;\n\t      this.delegate = null;\n\t\n\t      this.method = \"next\";\n\t      this.arg = undefined;\n\t\n\t      this.tryEntries.forEach(resetTryEntry);\n\t\n\t      if (!skipTempReset) {\n\t        for (var name in this) {\n\t          // Not sure about the optimal order of these conditions:\n\t          if (name.charAt(0) === \"t\" &&\n\t              hasOwn.call(this, name) &&\n\t              !isNaN(+name.slice(1))) {\n\t            this[name] = undefined;\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    stop: function() {\n\t      this.done = true;\n\t\n\t      var rootEntry = this.tryEntries[0];\n\t      var rootRecord = rootEntry.completion;\n\t      if (rootRecord.type === \"throw\") {\n\t        throw rootRecord.arg;\n\t      }\n\t\n\t      return this.rval;\n\t    },\n\t\n\t    dispatchException: function(exception) {\n\t      if (this.done) {\n\t        throw exception;\n\t      }\n\t\n\t      var context = this;\n\t      function handle(loc, caught) {\n\t        record.type = \"throw\";\n\t        record.arg = exception;\n\t        context.next = loc;\n\t\n\t        if (caught) {\n\t          // If the dispatched exception was caught by a catch block,\n\t          // then let that catch block handle the exception normally.\n\t          context.method = \"next\";\n\t          context.arg = undefined;\n\t        }\n\t\n\t        return !! caught;\n\t      }\n\t\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        var record = entry.completion;\n\t\n\t        if (entry.tryLoc === \"root\") {\n\t          // Exception thrown outside of any try block that could handle\n\t          // it, so set the completion value of the entire function to\n\t          // throw the exception.\n\t          return handle(\"end\");\n\t        }\n\t\n\t        if (entry.tryLoc <= this.prev) {\n\t          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n\t          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\t\n\t          if (hasCatch && hasFinally) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            } else if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else if (hasCatch) {\n\t            if (this.prev < entry.catchLoc) {\n\t              return handle(entry.catchLoc, true);\n\t            }\n\t\n\t          } else if (hasFinally) {\n\t            if (this.prev < entry.finallyLoc) {\n\t              return handle(entry.finallyLoc);\n\t            }\n\t\n\t          } else {\n\t            throw new Error(\"try statement without catch or finally\");\n\t          }\n\t        }\n\t      }\n\t    },\n\t\n\t    abrupt: function(type, arg) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc <= this.prev &&\n\t            hasOwn.call(entry, \"finallyLoc\") &&\n\t            this.prev < entry.finallyLoc) {\n\t          var finallyEntry = entry;\n\t          break;\n\t        }\n\t      }\n\t\n\t      if (finallyEntry &&\n\t          (type === \"break\" ||\n\t           type === \"continue\") &&\n\t          finallyEntry.tryLoc <= arg &&\n\t          arg <= finallyEntry.finallyLoc) {\n\t        // Ignore the finally entry if control is not jumping to a\n\t        // location outside the try/catch block.\n\t        finallyEntry = null;\n\t      }\n\t\n\t      var record = finallyEntry ? finallyEntry.completion : {};\n\t      record.type = type;\n\t      record.arg = arg;\n\t\n\t      if (finallyEntry) {\n\t        this.method = \"next\";\n\t        this.next = finallyEntry.finallyLoc;\n\t        return ContinueSentinel;\n\t      }\n\t\n\t      return this.complete(record);\n\t    },\n\t\n\t    complete: function(record, afterLoc) {\n\t      if (record.type === \"throw\") {\n\t        throw record.arg;\n\t      }\n\t\n\t      if (record.type === \"break\" ||\n\t          record.type === \"continue\") {\n\t        this.next = record.arg;\n\t      } else if (record.type === \"return\") {\n\t        this.rval = this.arg = record.arg;\n\t        this.method = \"return\";\n\t        this.next = \"end\";\n\t      } else if (record.type === \"normal\" && afterLoc) {\n\t        this.next = afterLoc;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    },\n\t\n\t    finish: function(finallyLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.finallyLoc === finallyLoc) {\n\t          this.complete(entry.completion, entry.afterLoc);\n\t          resetTryEntry(entry);\n\t          return ContinueSentinel;\n\t        }\n\t      }\n\t    },\n\t\n\t    \"catch\": function(tryLoc) {\n\t      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n\t        var entry = this.tryEntries[i];\n\t        if (entry.tryLoc === tryLoc) {\n\t          var record = entry.completion;\n\t          if (record.type === \"throw\") {\n\t            var thrown = record.arg;\n\t            resetTryEntry(entry);\n\t          }\n\t          return thrown;\n\t        }\n\t      }\n\t\n\t      // The context.catch method must only be called with a location\n\t      // argument that corresponds to a known catch block.\n\t      throw new Error(\"illegal catch attempt\");\n\t    },\n\t\n\t    delegateYield: function(iterable, resultName, nextLoc) {\n\t      this.delegate = {\n\t        iterator: values(iterable),\n\t        resultName: resultName,\n\t        nextLoc: nextLoc\n\t      };\n\t\n\t      if (this.method === \"next\") {\n\t        // Deliberately forget the last sent value so that we don't\n\t        // accidentally pass it on to the delegate.\n\t        this.arg = undefined;\n\t      }\n\t\n\t      return ContinueSentinel;\n\t    }\n\t  };\n\t})(\n\t  // Among the various tricks for obtaining a reference to the global\n\t  // object, this seems to be the most reliable technique that does not\n\t  // use indirect eval (which violates Content Security Policy).\n\t  typeof global === \"object\" ? global :\n\t  typeof window === \"object\" ? window :\n\t  typeof self === \"object\" ? self : this\n\t);\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(21)))\n\n/***/ },\n/* 247 */\n/***/ function(module, exports) {\n\n\t// Generated by CoffeeScript 1.9.2\n\t(function() {\n\t  var hasProp = {}.hasOwnProperty,\n\t    slice = [].slice;\n\t\n\t  module.exports = function(source, scope) {\n\t    var key, keys, value, values;\n\t    keys = [];\n\t    values = [];\n\t    for (key in scope) {\n\t      if (!hasProp.call(scope, key)) continue;\n\t      value = scope[key];\n\t      if (key === 'this') {\n\t        continue;\n\t      }\n\t      keys.push(key);\n\t      values.push(value);\n\t    }\n\t    return Function.apply(null, slice.call(keys).concat([source])).apply(scope[\"this\"], values);\n\t  };\n\t\n\t}).call(this);\n\n\n/***/ },\n/* 248 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Stringify/parse functions that don't operate\n\t * recursively, so they avoid call stack exceeded\n\t * errors.\n\t */\n\texports.stringify = function stringify(input) {\n\t  var queue = [];\n\t  queue.push({obj: input});\n\t\n\t  var res = '';\n\t  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n\t  while ((next = queue.pop())) {\n\t    obj = next.obj;\n\t    prefix = next.prefix || '';\n\t    val = next.val || '';\n\t    res += prefix;\n\t    if (val) {\n\t      res += val;\n\t    } else if (typeof obj !== 'object') {\n\t      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n\t    } else if (obj === null) {\n\t      res += 'null';\n\t    } else if (Array.isArray(obj)) {\n\t      queue.push({val: ']'});\n\t      for (i = obj.length - 1; i >= 0; i--) {\n\t        arrayPrefix = i === 0 ? '' : ',';\n\t        queue.push({obj: obj[i], prefix: arrayPrefix});\n\t      }\n\t      queue.push({val: '['});\n\t    } else { // object\n\t      keys = [];\n\t      for (k in obj) {\n\t        if (obj.hasOwnProperty(k)) {\n\t          keys.push(k);\n\t        }\n\t      }\n\t      queue.push({val: '}'});\n\t      for (i = keys.length - 1; i >= 0; i--) {\n\t        key = keys[i];\n\t        value = obj[key];\n\t        objPrefix = (i > 0 ? ',' : '');\n\t        objPrefix += JSON.stringify(key) + ':';\n\t        queue.push({obj: value, prefix: objPrefix});\n\t      }\n\t      queue.push({val: '{'});\n\t    }\n\t  }\n\t  return res;\n\t};\n\t\n\t// Convenience function for the parse function.\n\t// This pop function is basically copied from\n\t// pouchCollate.parseIndexableString\n\tfunction pop(obj, stack, metaStack) {\n\t  var lastMetaElement = metaStack[metaStack.length - 1];\n\t  if (obj === lastMetaElement.element) {\n\t    // popping a meta-element, e.g. an object whose value is another object\n\t    metaStack.pop();\n\t    lastMetaElement = metaStack[metaStack.length - 1];\n\t  }\n\t  var element = lastMetaElement.element;\n\t  var lastElementIndex = lastMetaElement.index;\n\t  if (Array.isArray(element)) {\n\t    element.push(obj);\n\t  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n\t    var key = stack.pop();\n\t    element[key] = obj;\n\t  } else {\n\t    stack.push(obj); // obj with key only\n\t  }\n\t}\n\t\n\texports.parse = function (str) {\n\t  var stack = [];\n\t  var metaStack = []; // stack for arrays and objects\n\t  var i = 0;\n\t  var collationIndex,parsedNum,numChar;\n\t  var parsedString,lastCh,numConsecutiveSlashes,ch;\n\t  var arrayElement, objElement;\n\t  while (true) {\n\t    collationIndex = str[i++];\n\t    if (collationIndex === '}' ||\n\t        collationIndex === ']' ||\n\t        typeof collationIndex === 'undefined') {\n\t      if (stack.length === 1) {\n\t        return stack.pop();\n\t      } else {\n\t        pop(stack.pop(), stack, metaStack);\n\t        continue;\n\t      }\n\t    }\n\t    switch (collationIndex) {\n\t      case ' ':\n\t      case '\\t':\n\t      case '\\n':\n\t      case ':':\n\t      case ',':\n\t        break;\n\t      case 'n':\n\t        i += 3; // 'ull'\n\t        pop(null, stack, metaStack);\n\t        break;\n\t      case 't':\n\t        i += 3; // 'rue'\n\t        pop(true, stack, metaStack);\n\t        break;\n\t      case 'f':\n\t        i += 4; // 'alse'\n\t        pop(false, stack, metaStack);\n\t        break;\n\t      case '0':\n\t      case '1':\n\t      case '2':\n\t      case '3':\n\t      case '4':\n\t      case '5':\n\t      case '6':\n\t      case '7':\n\t      case '8':\n\t      case '9':\n\t      case '-':\n\t        parsedNum = '';\n\t        i--;\n\t        while (true) {\n\t          numChar = str[i++];\n\t          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n\t            parsedNum += numChar;\n\t          } else {\n\t            i--;\n\t            break;\n\t          }\n\t        }\n\t        pop(parseFloat(parsedNum), stack, metaStack);\n\t        break;\n\t      case '\"':\n\t        parsedString = '';\n\t        lastCh = void 0;\n\t        numConsecutiveSlashes = 0;\n\t        while (true) {\n\t          ch = str[i++];\n\t          if (ch !== '\"' || (lastCh === '\\\\' &&\n\t              numConsecutiveSlashes % 2 === 1)) {\n\t            parsedString += ch;\n\t            lastCh = ch;\n\t            if (lastCh === '\\\\') {\n\t              numConsecutiveSlashes++;\n\t            } else {\n\t              numConsecutiveSlashes = 0;\n\t            }\n\t          } else {\n\t            break;\n\t          }\n\t        }\n\t        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n\t        break;\n\t      case '[':\n\t        arrayElement = { element: [], index: stack.length };\n\t        stack.push(arrayElement.element);\n\t        metaStack.push(arrayElement);\n\t        break;\n\t      case '{':\n\t        objElement = { element: {}, index: stack.length };\n\t        stack.push(objElement.element);\n\t        metaStack.push(objElement);\n\t        break;\n\t      default:\n\t        throw new Error(\n\t          'unexpectedly reached end of input: ' + collationIndex);\n\t    }\n\t  }\n\t};\n\n\n/***/ },\n/* 249 */\n/***/ function(module, exports) {\n\n\t(function(self) {\n\t  'use strict';\n\t\n\t  if (self.fetch) {\n\t    return\n\t  }\n\t\n\t  var support = {\n\t    searchParams: 'URLSearchParams' in self,\n\t    iterable: 'Symbol' in self && 'iterator' in Symbol,\n\t    blob: 'FileReader' in self && 'Blob' in self && (function() {\n\t      try {\n\t        new Blob()\n\t        return true\n\t      } catch(e) {\n\t        return false\n\t      }\n\t    })(),\n\t    formData: 'FormData' in self,\n\t    arrayBuffer: 'ArrayBuffer' in self\n\t  }\n\t\n\t  if (support.arrayBuffer) {\n\t    var viewClasses = [\n\t      '[object Int8Array]',\n\t      '[object Uint8Array]',\n\t      '[object Uint8ClampedArray]',\n\t      '[object Int16Array]',\n\t      '[object Uint16Array]',\n\t      '[object Int32Array]',\n\t      '[object Uint32Array]',\n\t      '[object Float32Array]',\n\t      '[object Float64Array]'\n\t    ]\n\t\n\t    var isDataView = function(obj) {\n\t      return obj && DataView.prototype.isPrototypeOf(obj)\n\t    }\n\t\n\t    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n\t      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n\t    }\n\t  }\n\t\n\t  function normalizeName(name) {\n\t    if (typeof name !== 'string') {\n\t      name = String(name)\n\t    }\n\t    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n\t      throw new TypeError('Invalid character in header field name')\n\t    }\n\t    return name.toLowerCase()\n\t  }\n\t\n\t  function normalizeValue(value) {\n\t    if (typeof value !== 'string') {\n\t      value = String(value)\n\t    }\n\t    return value\n\t  }\n\t\n\t  // Build a destructive iterator for the value list\n\t  function iteratorFor(items) {\n\t    var iterator = {\n\t      next: function() {\n\t        var value = items.shift()\n\t        return {done: value === undefined, value: value}\n\t      }\n\t    }\n\t\n\t    if (support.iterable) {\n\t      iterator[Symbol.iterator] = function() {\n\t        return iterator\n\t      }\n\t    }\n\t\n\t    return iterator\n\t  }\n\t\n\t  function Headers(headers) {\n\t    this.map = {}\n\t\n\t    if (headers instanceof Headers) {\n\t      headers.forEach(function(value, name) {\n\t        this.append(name, value)\n\t      }, this)\n\t    } else if (Array.isArray(headers)) {\n\t      headers.forEach(function(header) {\n\t        this.append(header[0], header[1])\n\t      }, this)\n\t    } else if (headers) {\n\t      Object.getOwnPropertyNames(headers).forEach(function(name) {\n\t        this.append(name, headers[name])\n\t      }, this)\n\t    }\n\t  }\n\t\n\t  Headers.prototype.append = function(name, value) {\n\t    name = normalizeName(name)\n\t    value = normalizeValue(value)\n\t    var oldValue = this.map[name]\n\t    this.map[name] = oldValue ? oldValue+','+value : value\n\t  }\n\t\n\t  Headers.prototype['delete'] = function(name) {\n\t    delete this.map[normalizeName(name)]\n\t  }\n\t\n\t  Headers.prototype.get = function(name) {\n\t    name = normalizeName(name)\n\t    return this.has(name) ? this.map[name] : null\n\t  }\n\t\n\t  Headers.prototype.has = function(name) {\n\t    return this.map.hasOwnProperty(normalizeName(name))\n\t  }\n\t\n\t  Headers.prototype.set = function(name, value) {\n\t    this.map[normalizeName(name)] = normalizeValue(value)\n\t  }\n\t\n\t  Headers.prototype.forEach = function(callback, thisArg) {\n\t    for (var name in this.map) {\n\t      if (this.map.hasOwnProperty(name)) {\n\t        callback.call(thisArg, this.map[name], name, this)\n\t      }\n\t    }\n\t  }\n\t\n\t  Headers.prototype.keys = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push(name) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.values = function() {\n\t    var items = []\n\t    this.forEach(function(value) { items.push(value) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  Headers.prototype.entries = function() {\n\t    var items = []\n\t    this.forEach(function(value, name) { items.push([name, value]) })\n\t    return iteratorFor(items)\n\t  }\n\t\n\t  if (support.iterable) {\n\t    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n\t  }\n\t\n\t  function consumed(body) {\n\t    if (body.bodyUsed) {\n\t      return Promise.reject(new TypeError('Already read'))\n\t    }\n\t    body.bodyUsed = true\n\t  }\n\t\n\t  function fileReaderReady(reader) {\n\t    return new Promise(function(resolve, reject) {\n\t      reader.onload = function() {\n\t        resolve(reader.result)\n\t      }\n\t      reader.onerror = function() {\n\t        reject(reader.error)\n\t      }\n\t    })\n\t  }\n\t\n\t  function readBlobAsArrayBuffer(blob) {\n\t    var reader = new FileReader()\n\t    var promise = fileReaderReady(reader)\n\t    reader.readAsArrayBuffer(blob)\n\t    return promise\n\t  }\n\t\n\t  function readBlobAsText(blob) {\n\t    var reader = new FileReader()\n\t    var promise = fileReaderReady(reader)\n\t    reader.readAsText(blob)\n\t    return promise\n\t  }\n\t\n\t  function readArrayBufferAsText(buf) {\n\t    var view = new Uint8Array(buf)\n\t    var chars = new Array(view.length)\n\t\n\t    for (var i = 0; i < view.length; i++) {\n\t      chars[i] = String.fromCharCode(view[i])\n\t    }\n\t    return chars.join('')\n\t  }\n\t\n\t  function bufferClone(buf) {\n\t    if (buf.slice) {\n\t      return buf.slice(0)\n\t    } else {\n\t      var view = new Uint8Array(buf.byteLength)\n\t      view.set(new Uint8Array(buf))\n\t      return view.buffer\n\t    }\n\t  }\n\t\n\t  function Body() {\n\t    this.bodyUsed = false\n\t\n\t    this._initBody = function(body) {\n\t      this._bodyInit = body\n\t      if (!body) {\n\t        this._bodyText = ''\n\t      } else if (typeof body === 'string') {\n\t        this._bodyText = body\n\t      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n\t        this._bodyBlob = body\n\t      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n\t        this._bodyFormData = body\n\t      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t        this._bodyText = body.toString()\n\t      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n\t        this._bodyArrayBuffer = bufferClone(body.buffer)\n\t        // IE 10-11 can't handle a DataView body.\n\t        this._bodyInit = new Blob([this._bodyArrayBuffer])\n\t      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n\t        this._bodyArrayBuffer = bufferClone(body)\n\t      } else {\n\t        throw new Error('unsupported BodyInit type')\n\t      }\n\t\n\t      if (!this.headers.get('content-type')) {\n\t        if (typeof body === 'string') {\n\t          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n\t        } else if (this._bodyBlob && this._bodyBlob.type) {\n\t          this.headers.set('content-type', this._bodyBlob.type)\n\t        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n\t          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n\t        }\n\t      }\n\t    }\n\t\n\t    if (support.blob) {\n\t      this.blob = function() {\n\t        var rejected = consumed(this)\n\t        if (rejected) {\n\t          return rejected\n\t        }\n\t\n\t        if (this._bodyBlob) {\n\t          return Promise.resolve(this._bodyBlob)\n\t        } else if (this._bodyArrayBuffer) {\n\t          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n\t        } else if (this._bodyFormData) {\n\t          throw new Error('could not read FormData body as blob')\n\t        } else {\n\t          return Promise.resolve(new Blob([this._bodyText]))\n\t        }\n\t      }\n\t\n\t      this.arrayBuffer = function() {\n\t        if (this._bodyArrayBuffer) {\n\t          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n\t        } else {\n\t          return this.blob().then(readBlobAsArrayBuffer)\n\t        }\n\t      }\n\t    }\n\t\n\t    this.text = function() {\n\t      var rejected = consumed(this)\n\t      if (rejected) {\n\t        return rejected\n\t      }\n\t\n\t      if (this._bodyBlob) {\n\t        return readBlobAsText(this._bodyBlob)\n\t      } else if (this._bodyArrayBuffer) {\n\t        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n\t      } else if (this._bodyFormData) {\n\t        throw new Error('could not read FormData body as text')\n\t      } else {\n\t        return Promise.resolve(this._bodyText)\n\t      }\n\t    }\n\t\n\t    if (support.formData) {\n\t      this.formData = function() {\n\t        return this.text().then(decode)\n\t      }\n\t    }\n\t\n\t    this.json = function() {\n\t      return this.text().then(JSON.parse)\n\t    }\n\t\n\t    return this\n\t  }\n\t\n\t  // HTTP methods whose capitalization should be normalized\n\t  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\t\n\t  function normalizeMethod(method) {\n\t    var upcased = method.toUpperCase()\n\t    return (methods.indexOf(upcased) > -1) ? upcased : method\n\t  }\n\t\n\t  function Request(input, options) {\n\t    options = options || {}\n\t    var body = options.body\n\t\n\t    if (input instanceof Request) {\n\t      if (input.bodyUsed) {\n\t        throw new TypeError('Already read')\n\t      }\n\t      this.url = input.url\n\t      this.credentials = input.credentials\n\t      if (!options.headers) {\n\t        this.headers = new Headers(input.headers)\n\t      }\n\t      this.method = input.method\n\t      this.mode = input.mode\n\t      if (!body && input._bodyInit != null) {\n\t        body = input._bodyInit\n\t        input.bodyUsed = true\n\t      }\n\t    } else {\n\t      this.url = String(input)\n\t    }\n\t\n\t    this.credentials = options.credentials || this.credentials || 'omit'\n\t    if (options.headers || !this.headers) {\n\t      this.headers = new Headers(options.headers)\n\t    }\n\t    this.method = normalizeMethod(options.method || this.method || 'GET')\n\t    this.mode = options.mode || this.mode || null\n\t    this.referrer = null\n\t\n\t    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n\t      throw new TypeError('Body not allowed for GET or HEAD requests')\n\t    }\n\t    this._initBody(body)\n\t  }\n\t\n\t  Request.prototype.clone = function() {\n\t    return new Request(this, { body: this._bodyInit })\n\t  }\n\t\n\t  function decode(body) {\n\t    var form = new FormData()\n\t    body.trim().split('&').forEach(function(bytes) {\n\t      if (bytes) {\n\t        var split = bytes.split('=')\n\t        var name = split.shift().replace(/\\+/g, ' ')\n\t        var value = split.join('=').replace(/\\+/g, ' ')\n\t        form.append(decodeURIComponent(name), decodeURIComponent(value))\n\t      }\n\t    })\n\t    return form\n\t  }\n\t\n\t  function parseHeaders(rawHeaders) {\n\t    var headers = new Headers()\n\t    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n\t      var parts = line.split(':')\n\t      var key = parts.shift().trim()\n\t      if (key) {\n\t        var value = parts.join(':').trim()\n\t        headers.append(key, value)\n\t      }\n\t    })\n\t    return headers\n\t  }\n\t\n\t  Body.call(Request.prototype)\n\t\n\t  function Response(bodyInit, options) {\n\t    if (!options) {\n\t      options = {}\n\t    }\n\t\n\t    this.type = 'default'\n\t    this.status = 'status' in options ? options.status : 200\n\t    this.ok = this.status >= 200 && this.status < 300\n\t    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n\t    this.headers = new Headers(options.headers)\n\t    this.url = options.url || ''\n\t    this._initBody(bodyInit)\n\t  }\n\t\n\t  Body.call(Response.prototype)\n\t\n\t  Response.prototype.clone = function() {\n\t    return new Response(this._bodyInit, {\n\t      status: this.status,\n\t      statusText: this.statusText,\n\t      headers: new Headers(this.headers),\n\t      url: this.url\n\t    })\n\t  }\n\t\n\t  Response.error = function() {\n\t    var response = new Response(null, {status: 0, statusText: ''})\n\t    response.type = 'error'\n\t    return response\n\t  }\n\t\n\t  var redirectStatuses = [301, 302, 303, 307, 308]\n\t\n\t  Response.redirect = function(url, status) {\n\t    if (redirectStatuses.indexOf(status) === -1) {\n\t      throw new RangeError('Invalid status code')\n\t    }\n\t\n\t    return new Response(null, {status: status, headers: {location: url}})\n\t  }\n\t\n\t  self.Headers = Headers\n\t  self.Request = Request\n\t  self.Response = Response\n\t\n\t  self.fetch = function(input, init) {\n\t    return new Promise(function(resolve, reject) {\n\t      var request = new Request(input, init)\n\t      var xhr = new XMLHttpRequest()\n\t\n\t      xhr.onload = function() {\n\t        var options = {\n\t          status: xhr.status,\n\t          statusText: xhr.statusText,\n\t          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n\t        }\n\t        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n\t        var body = 'response' in xhr ? xhr.response : xhr.responseText\n\t        resolve(new Response(body, options))\n\t      }\n\t\n\t      xhr.onerror = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.ontimeout = function() {\n\t        reject(new TypeError('Network request failed'))\n\t      }\n\t\n\t      xhr.open(request.method, request.url, true)\n\t\n\t      if (request.credentials === 'include') {\n\t        xhr.withCredentials = true\n\t      }\n\t\n\t      if ('responseType' in xhr && support.blob) {\n\t        xhr.responseType = 'blob'\n\t      }\n\t\n\t      request.headers.forEach(function(value, name) {\n\t        xhr.setRequestHeader(name, value)\n\t      })\n\t\n\t      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n\t    })\n\t  }\n\t  self.fetch.polyfill = true\n\t})(typeof self !== 'undefined' ? self : this);\n\n\n/***/ },\n/* 250 */\n/***/ function(module, exports) {\n\n\t/* (ignored) */\n\n/***/ },\n/* 251 */\n250,\n/* 252 */\n/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {/**\n\t * This is the web browser implementation of `debug()`.\n\t *\n\t * Expose `debug()` as the module.\n\t */\n\t\n\texports = module.exports = __webpack_require__(__webpack_module_template_argument_0__);\n\texports.log = log;\n\texports.formatArgs = formatArgs;\n\texports.save = save;\n\texports.load = load;\n\texports.useColors = useColors;\n\texports.storage = 'undefined' != typeof chrome\n\t               && 'undefined' != typeof chrome.storage\n\t                  ? chrome.storage.local\n\t                  : localstorage();\n\t\n\t/**\n\t * Colors.\n\t */\n\t\n\texports.colors = [\n\t  'lightseagreen',\n\t  'forestgreen',\n\t  'goldenrod',\n\t  'dodgerblue',\n\t  'darkorchid',\n\t  'crimson'\n\t];\n\t\n\t/**\n\t * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n\t * and the Firebug extension (any Firefox version) are known\n\t * to support \"%c\" CSS customizations.\n\t *\n\t * TODO: add a `localStorage` variable to explicitly enable/disable colors\n\t */\n\t\n\tfunction useColors() {\n\t  // NB: In an Electron preload script, document will be defined but not fully\n\t  // initialized. Since we know we're in Chrome, we'll just detect this case\n\t  // explicitly\n\t  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n\t    return true;\n\t  }\n\t\n\t  // is webkit? http://stackoverflow.com/a/16459606/376773\n\t  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n\t  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\n\t    // is firebug? http://stackoverflow.com/a/398120/376773\n\t    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\n\t    // is firefox >= v31?\n\t    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n\t    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n\t    // double check webkit in userAgent just in case we are in a worker\n\t    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n\t}\n\t\n\t/**\n\t * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n\t */\n\t\n\texports.formatters.j = function(v) {\n\t  try {\n\t    return JSON.stringify(v);\n\t  } catch (err) {\n\t    return '[UnexpectedJSONParseError]: ' + err.message;\n\t  }\n\t};\n\t\n\t\n\t/**\n\t * Colorize log arguments if enabled.\n\t *\n\t * @api public\n\t */\n\t\n\tfunction formatArgs(args) {\n\t  var useColors = this.useColors;\n\t\n\t  args[0] = (useColors ? '%c' : '')\n\t    + this.namespace\n\t    + (useColors ? ' %c' : ' ')\n\t    + args[0]\n\t    + (useColors ? '%c ' : ' ')\n\t    + '+' + exports.humanize(this.diff);\n\t\n\t  if (!useColors) return;\n\t\n\t  var c = 'color: ' + this.color;\n\t  args.splice(1, 0, c, 'color: inherit')\n\t\n\t  // the final \"%c\" is somewhat tricky, because there could be other\n\t  // arguments passed either before or after the %c, so we need to\n\t  // figure out the correct index to insert the CSS into\n\t  var index = 0;\n\t  var lastC = 0;\n\t  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n\t    if ('%%' === match) return;\n\t    index++;\n\t    if ('%c' === match) {\n\t      // we only are interested in the *last* %c\n\t      // (the user may have provided their own)\n\t      lastC = index;\n\t    }\n\t  });\n\t\n\t  args.splice(lastC, 0, c);\n\t}\n\t\n\t/**\n\t * Invokes `console.log()` when available.\n\t * No-op when `console.log` is not a \"function\".\n\t *\n\t * @api public\n\t */\n\t\n\tfunction log() {\n\t  // this hackery is required for IE8/9, where\n\t  // the `console.log` function doesn't have 'apply'\n\t  return 'object' === typeof console\n\t    && console.log\n\t    && Function.prototype.apply.call(console.log, console, arguments);\n\t}\n\t\n\t/**\n\t * Save `namespaces`.\n\t *\n\t * @param {String} namespaces\n\t * @api private\n\t */\n\t\n\tfunction save(namespaces) {\n\t  try {\n\t    if (null == namespaces) {\n\t      exports.storage.removeItem('debug');\n\t    } else {\n\t      exports.storage.debug = namespaces;\n\t    }\n\t  } catch(e) {}\n\t}\n\t\n\t/**\n\t * Load `namespaces`.\n\t *\n\t * @return {String} returns the previously persisted debug modes\n\t * @api private\n\t */\n\t\n\tfunction load() {\n\t  try {\n\t    return exports.storage.debug;\n\t  } catch(e) {}\n\t\n\t  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n\t  if (typeof process !== 'undefined' && 'env' in process) {\n\t    return process.env.DEBUG;\n\t  }\n\t}\n\t\n\t/**\n\t * Enable namespaces listed in `localStorage.debug` initially.\n\t */\n\t\n\texports.enable(load());\n\t\n\t/**\n\t * Localstorage attempts to return the localstorage.\n\t *\n\t * This is necessary because safari throws\n\t * when a user disables cookies/localstorage\n\t * and you attempt to access it.\n\t *\n\t * @return {LocalStorage}\n\t * @api private\n\t */\n\t\n\tfunction localstorage() {\n\t  try {\n\t    return window.localStorage;\n\t  } catch (e) {}\n\t}\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(21)))\n\n/***/ },\n/* 253 */\n/***/ function(module, exports, __webpack_require__, __webpack_module_template_argument_0__) {\n\n\t'use strict';\n\t\n\tfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\t\n\tvar lie = _interopDefault(__webpack_require__(__webpack_module_template_argument_0__));\n\t\n\t/* istanbul ignore next */\n\tvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\t\n\tmodule.exports = PouchPromise;\n\n/***/ }\n/******/ ])))\n});\n;\n\n\n// WEBPACK FOOTER //\n// cozy-client.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap df176c5bf46a37c88d76","var global    = require('./_global')\n  , core      = require('./_core')\n  , hide      = require('./_hide')\n  , redefine  = require('./_redefine')\n  , ctx       = require('./_ctx')\n  , PROTOTYPE = 'prototype';\n\nvar $export = function(type, name, source){\n  var IS_FORCED = type & $export.F\n    , IS_GLOBAL = type & $export.G\n    , IS_STATIC = type & $export.S\n    , IS_PROTO  = type & $export.P\n    , IS_BIND   = type & $export.B\n    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]\n    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})\n    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})\n    , key, own, out, exp;\n  if(IS_GLOBAL)source = name;\n  for(key in source){\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if(target)redefine(target, key, out, type & $export.U);\n    // export\n    if(exports[key] != out)hide(exports, key, exp);\n    if(IS_PROTO && expProto[key] != out)expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library` \nmodule.exports = $export;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_export.js\n// module id = 1\n// module chunks = 0","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();\nif(typeof __g == 'number')__g = global; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_global.js\n// module id = 2\n// module chunks = 0","var isObject = require('./_is-object');\nmodule.exports = function(it){\n  if(!isObject(it))throw TypeError(it + ' is not an object!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_an-object.js\n// module id = 3\n// module chunks = 0","var store      = require('./_shared')('wks')\n  , uid        = require('./_uid')\n  , Symbol     = require('./_global').Symbol\n  , USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function(name){\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_wks.js\n// module id = 4\n// module chunks = 0","module.exports = function(it){\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_is-object.js\n// module id = 5\n// module chunks = 0","module.exports = function(exec){\n  try {\n    return !!exec();\n  } catch(e){\n    return true;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_fails.js\n// module id = 6\n// module chunks = 0","var anObject       = require('./_an-object')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , toPrimitive    = require('./_to-primitive')\n  , dP             = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes){\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if(IE8_DOM_DEFINE)try {\n    return dP(O, P, Attributes);\n  } catch(e){ /* empty */ }\n  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');\n  if('value' in Attributes)O[P] = Attributes.value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-dp.js\n// module id = 7\n// module chunks = 0","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function(it, key){\n  return hasOwnProperty.call(it, key);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_has.js\n// module id = 8\n// module chunks = 0","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function(){\n  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_descriptors.js\n// module id = 9\n// module chunks = 0","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer')\n  , min       = Math.min;\nmodule.exports = function(it){\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-length.js\n// module id = 10\n// module chunks = 0","var dP         = require('./_object-dp')\n  , createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function(object, key, value){\n  return dP.f(object, key, createDesc(1, value));\n} : function(object, key, value){\n  object[key] = value;\n  return object;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_hide.js\n// module id = 11\n// module chunks = 0","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject')\n  , defined = require('./_defined');\nmodule.exports = function(it){\n  return IObject(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-iobject.js\n// module id = 12\n// module chunks = 0","/* global fetch */\nimport {refreshToken, AccessToken} from './auth_v3'\nimport {retry} from './utils'\nimport jsonapi from './jsonapi'\n\nexport function cozyFetch (cozy, path, options = {}) {\n  return cozy.fullpath(path).then((fullpath) => {\n    let resp\n    if (options.disableAuth) {\n      resp = fetch(fullpath, options)\n    } else if (options.manualAuthCredentials) {\n      resp = cozyFetchWithAuth(cozy, fullpath, options, options.manualAuthCredentials)\n    } else {\n      resp = cozy.authorize().then((credentials) =>\n        cozyFetchWithAuth(cozy, fullpath, options, credentials))\n    }\n    return resp.then(handleResponse)\n  })\n}\n\nfunction cozyFetchWithAuth (cozy, fullpath, options, credentials) {\n  if (credentials) {\n    options.headers = options.headers || {}\n    options.headers['Authorization'] = credentials.token.toAuthHeader()\n  }\n\n  // the option credentials:include tells fetch to include the cookies in the\n  // request even for cross-origin requests\n  options.credentials = 'include'\n\n  return Promise.all([\n    cozy.isV2(),\n    fetch(fullpath, options)\n  ]).then(([isV2, res]) => {\n    if ((res.status !== 400 && res.status !== 401) || isV2 || !credentials || options.dontRetry) {\n      return res\n    }\n    // we try to refresh the token only for OAuth, ie, the client defined\n    // and the token is an instance of AccessToken.\n    const { client, token } = credentials\n    if (!client || !(token instanceof AccessToken)) {\n      return res\n    }\n    options.dontRetry = true\n    return retry(() => refreshToken(cozy, client, token), 3)()\n      .then((newToken) => cozy.saveCredentials(client, newToken))\n      .then((credentials) => cozyFetchWithAuth(cozy, fullpath, options, credentials))\n  })\n}\n\nexport function cozyFetchJSON (cozy, method, path, body, options = {}) {\n  const processJSONAPI = typeof options.processJSONAPI === 'undefined' || options.processJSONAPI\n  return fetchJSON(cozy, method, path, body, options)\n    .then(response => handleJSONResponse(response, processJSONAPI))\n}\n\nexport function cozyFetchRawJSON (cozy, method, path, body, options = {}) {\n  return fetchJSON(cozy, method, path, body, options)\n    .then(response => handleJSONResponse(response, false))\n}\n\nfunction fetchJSON (cozy, method, path, body, options = {}) {\n  options.method = method\n\n  const headers = options.headers = options.headers || {}\n\n  headers['Accept'] = 'application/json'\n\n  if (method !== 'GET' && method !== 'HEAD' && body !== undefined) {\n    if (headers['Content-Type']) {\n      options.body = body\n    } else {\n      headers['Content-Type'] = 'application/json'\n      options.body = JSON.stringify(body)\n    }\n  }\n\n  return cozyFetch(cozy, path, options)\n}\n\nfunction handleResponse (res) {\n  if (res.ok) {\n    return res\n  }\n  let data\n  const contentType = res.headers.get('content-type')\n  if (contentType && contentType.indexOf('json') >= 0) {\n    data = res.json()\n  } else {\n    data = res.text()\n  }\n  return data.then(err => {\n    throw new FetchError(res, err)\n  })\n}\n\nfunction handleJSONResponse (res, processJSONAPI = true) {\n  const contentType = res.headers.get('content-type')\n  if (!contentType || contentType.indexOf('json') < 0) {\n    return res.text((data) => {\n      throw new FetchError(res, new Error('Response is not JSON: ' + data))\n    })\n  }\n\n  const json = res.json()\n  if (contentType.indexOf('application/vnd.api+json') === 0 && processJSONAPI) {\n    return json.then(jsonapi)\n  } else {\n    return json\n  }\n}\n\nexport class FetchError extends Error {\n  constructor (res, reason) {\n    super()\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n    // XXX We have to hardcode this because babel doesn't play nice when extending Error\n    this.name = 'FetchError'\n    this.response = res\n    this.url = res.url\n    this.status = res.status\n    this.reason = reason\n\n    Object.defineProperty(this, 'message', {\n      value: reason.message ||\n        (typeof reason === 'string' ? reason : JSON.stringify(reason))\n    })\n  }\n}\n\nFetchError.isUnauthorized = function (err) {\n  // XXX We can't use err instanceof FetchError because of the caveats of babel\n  return err.name === 'FetchError' && err.status === 401\n}\n\nFetchError.isNotFound = function (err) {\n  // XXX We can't use err instanceof FetchError because of the caveats of babel\n  return err.name === 'FetchError' && err.status === 404\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/fetch.js","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function(fn, that, length){\n  aFunction(fn);\n  if(that === undefined)return fn;\n  switch(length){\n    case 1: return function(a){\n      return fn.call(that, a);\n    };\n    case 2: return function(a, b){\n      return fn.call(that, a, b);\n    };\n    case 3: return function(a, b, c){\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function(/* ...args */){\n    return fn.apply(that, arguments);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_ctx.js\n// module id = 14\n// module chunks = 0","'use strict';\nif(require('./_descriptors')){\n  var LIBRARY             = require('./_library')\n    , global              = require('./_global')\n    , fails               = require('./_fails')\n    , $export             = require('./_export')\n    , $typed              = require('./_typed')\n    , $buffer             = require('./_typed-buffer')\n    , ctx                 = require('./_ctx')\n    , anInstance          = require('./_an-instance')\n    , propertyDesc        = require('./_property-desc')\n    , hide                = require('./_hide')\n    , redefineAll         = require('./_redefine-all')\n    , toInteger           = require('./_to-integer')\n    , toLength            = require('./_to-length')\n    , toIndex             = require('./_to-index')\n    , toPrimitive         = require('./_to-primitive')\n    , has                 = require('./_has')\n    , same                = require('./_same-value')\n    , classof             = require('./_classof')\n    , isObject            = require('./_is-object')\n    , toObject            = require('./_to-object')\n    , isArrayIter         = require('./_is-array-iter')\n    , create              = require('./_object-create')\n    , getPrototypeOf      = require('./_object-gpo')\n    , gOPN                = require('./_object-gopn').f\n    , getIterFn           = require('./core.get-iterator-method')\n    , uid                 = require('./_uid')\n    , wks                 = require('./_wks')\n    , createArrayMethod   = require('./_array-methods')\n    , createArrayIncludes = require('./_array-includes')\n    , speciesConstructor  = require('./_species-constructor')\n    , ArrayIterators      = require('./es6.array.iterator')\n    , Iterators           = require('./_iterators')\n    , $iterDetect         = require('./_iter-detect')\n    , setSpecies          = require('./_set-species')\n    , arrayFill           = require('./_array-fill')\n    , arrayCopyWithin     = require('./_array-copy-within')\n    , $DP                 = require('./_object-dp')\n    , $GOPD               = require('./_object-gopd')\n    , dP                  = $DP.f\n    , gOPD                = $GOPD.f\n    , RangeError          = global.RangeError\n    , TypeError           = global.TypeError\n    , Uint8Array          = global.Uint8Array\n    , ARRAY_BUFFER        = 'ArrayBuffer'\n    , SHARED_BUFFER       = 'Shared' + ARRAY_BUFFER\n    , BYTES_PER_ELEMENT   = 'BYTES_PER_ELEMENT'\n    , PROTOTYPE           = 'prototype'\n    , ArrayProto          = Array[PROTOTYPE]\n    , $ArrayBuffer        = $buffer.ArrayBuffer\n    , $DataView           = $buffer.DataView\n    , arrayForEach        = createArrayMethod(0)\n    , arrayFilter         = createArrayMethod(2)\n    , arraySome           = createArrayMethod(3)\n    , arrayEvery          = createArrayMethod(4)\n    , arrayFind           = createArrayMethod(5)\n    , arrayFindIndex      = createArrayMethod(6)\n    , arrayIncludes       = createArrayIncludes(true)\n    , arrayIndexOf        = createArrayIncludes(false)\n    , arrayValues         = ArrayIterators.values\n    , arrayKeys           = ArrayIterators.keys\n    , arrayEntries        = ArrayIterators.entries\n    , arrayLastIndexOf    = ArrayProto.lastIndexOf\n    , arrayReduce         = ArrayProto.reduce\n    , arrayReduceRight    = ArrayProto.reduceRight\n    , arrayJoin           = ArrayProto.join\n    , arraySort           = ArrayProto.sort\n    , arraySlice          = ArrayProto.slice\n    , arrayToString       = ArrayProto.toString\n    , arrayToLocaleString = ArrayProto.toLocaleString\n    , ITERATOR            = wks('iterator')\n    , TAG                 = wks('toStringTag')\n    , TYPED_CONSTRUCTOR   = uid('typed_constructor')\n    , DEF_CONSTRUCTOR     = uid('def_constructor')\n    , ALL_CONSTRUCTORS    = $typed.CONSTR\n    , TYPED_ARRAY         = $typed.TYPED\n    , VIEW                = $typed.VIEW\n    , WRONG_LENGTH        = 'Wrong length!';\n\n  var $map = createArrayMethod(1, function(O, length){\n    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n  });\n\n  var LITTLE_ENDIAN = fails(function(){\n    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  });\n\n  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function(){\n    new Uint8Array(1).set({});\n  });\n\n  var strictToLength = function(it, SAME){\n    if(it === undefined)throw TypeError(WRONG_LENGTH);\n    var number = +it\n      , length = toLength(it);\n    if(SAME && !same(number, length))throw RangeError(WRONG_LENGTH);\n    return length;\n  };\n\n  var toOffset = function(it, BYTES){\n    var offset = toInteger(it);\n    if(offset < 0 || offset % BYTES)throw RangeError('Wrong offset!');\n    return offset;\n  };\n\n  var validate = function(it){\n    if(isObject(it) && TYPED_ARRAY in it)return it;\n    throw TypeError(it + ' is not a typed array!');\n  };\n\n  var allocate = function(C, length){\n    if(!(isObject(C) && TYPED_CONSTRUCTOR in C)){\n      throw TypeError('It is not a typed array constructor!');\n    } return new C(length);\n  };\n\n  var speciesFromList = function(O, list){\n    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n  };\n\n  var fromList = function(C, list){\n    var index  = 0\n      , length = list.length\n      , result = allocate(C, length);\n    while(length > index)result[index] = list[index++];\n    return result;\n  };\n\n  var addGetter = function(it, key, internal){\n    dP(it, key, {get: function(){ return this._d[internal]; }});\n  };\n\n  var $from = function from(source /*, mapfn, thisArg */){\n    var O       = toObject(source)\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , iterFn  = getIterFn(O)\n      , i, length, values, result, step, iterator;\n    if(iterFn != undefined && !isArrayIter(iterFn)){\n      for(iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++){\n        values.push(step.value);\n      } O = values;\n    }\n    if(mapping && aLen > 2)mapfn = ctx(mapfn, arguments[2], 2);\n    for(i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++){\n      result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n  };\n\n  var $of = function of(/*...items*/){\n    var index  = 0\n      , length = arguments.length\n      , result = allocate(this, length);\n    while(length > index)result[index] = arguments[index++];\n    return result;\n  };\n\n  // iOS Safari 6.x fails here\n  var TO_LOCALE_BUG = !!Uint8Array && fails(function(){ arrayToLocaleString.call(new Uint8Array(1)); });\n\n  var $toLocaleString = function toLocaleString(){\n    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n  };\n\n  var proto = {\n    copyWithin: function copyWithin(target, start /*, end */){\n      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    every: function every(callbackfn /*, thisArg */){\n      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    fill: function fill(value /*, start, end */){ // eslint-disable-line no-unused-vars\n      return arrayFill.apply(validate(this), arguments);\n    },\n    filter: function filter(callbackfn /*, thisArg */){\n      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n        arguments.length > 1 ? arguments[1] : undefined));\n    },\n    find: function find(predicate /*, thisArg */){\n      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    findIndex: function findIndex(predicate /*, thisArg */){\n      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    forEach: function forEach(callbackfn /*, thisArg */){\n      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    indexOf: function indexOf(searchElement /*, fromIndex */){\n      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    includes: function includes(searchElement /*, fromIndex */){\n      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    join: function join(separator){ // eslint-disable-line no-unused-vars\n      return arrayJoin.apply(validate(this), arguments);\n    },\n    lastIndexOf: function lastIndexOf(searchElement /*, fromIndex */){ // eslint-disable-line no-unused-vars\n      return arrayLastIndexOf.apply(validate(this), arguments);\n    },\n    map: function map(mapfn /*, thisArg */){\n      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    reduce: function reduce(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars\n      return arrayReduce.apply(validate(this), arguments);\n    },\n    reduceRight: function reduceRight(callbackfn /*, initialValue */){ // eslint-disable-line no-unused-vars\n      return arrayReduceRight.apply(validate(this), arguments);\n    },\n    reverse: function reverse(){\n      var that   = this\n        , length = validate(that).length\n        , middle = Math.floor(length / 2)\n        , index  = 0\n        , value;\n      while(index < middle){\n        value         = that[index];\n        that[index++] = that[--length];\n        that[length]  = value;\n      } return that;\n    },\n    some: function some(callbackfn /*, thisArg */){\n      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    sort: function sort(comparefn){\n      return arraySort.call(validate(this), comparefn);\n    },\n    subarray: function subarray(begin, end){\n      var O      = validate(this)\n        , length = O.length\n        , $begin = toIndex(begin, length);\n      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n        O.buffer,\n        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n        toLength((end === undefined ? length : toIndex(end, length)) - $begin)\n      );\n    }\n  };\n\n  var $slice = function slice(start, end){\n    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n  };\n\n  var $set = function set(arrayLike /*, offset */){\n    validate(this);\n    var offset = toOffset(arguments[1], 1)\n      , length = this.length\n      , src    = toObject(arrayLike)\n      , len    = toLength(src.length)\n      , index  = 0;\n    if(len + offset > length)throw RangeError(WRONG_LENGTH);\n    while(index < len)this[offset + index] = src[index++];\n  };\n\n  var $iterators = {\n    entries: function entries(){\n      return arrayEntries.call(validate(this));\n    },\n    keys: function keys(){\n      return arrayKeys.call(validate(this));\n    },\n    values: function values(){\n      return arrayValues.call(validate(this));\n    }\n  };\n\n  var isTAIndex = function(target, key){\n    return isObject(target)\n      && target[TYPED_ARRAY]\n      && typeof key != 'symbol'\n      && key in target\n      && String(+key) == String(key);\n  };\n  var $getDesc = function getOwnPropertyDescriptor(target, key){\n    return isTAIndex(target, key = toPrimitive(key, true))\n      ? propertyDesc(2, target[key])\n      : gOPD(target, key);\n  };\n  var $setDesc = function defineProperty(target, key, desc){\n    if(isTAIndex(target, key = toPrimitive(key, true))\n      && isObject(desc)\n      && has(desc, 'value')\n      && !has(desc, 'get')\n      && !has(desc, 'set')\n      // TODO: add validation descriptor w/o calling accessors\n      && !desc.configurable\n      && (!has(desc, 'writable') || desc.writable)\n      && (!has(desc, 'enumerable') || desc.enumerable)\n    ){\n      target[key] = desc.value;\n      return target;\n    } else return dP(target, key, desc);\n  };\n\n  if(!ALL_CONSTRUCTORS){\n    $GOPD.f = $getDesc;\n    $DP.f   = $setDesc;\n  }\n\n  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n    getOwnPropertyDescriptor: $getDesc,\n    defineProperty:           $setDesc\n  });\n\n  if(fails(function(){ arrayToString.call({}); })){\n    arrayToString = arrayToLocaleString = function toString(){\n      return arrayJoin.call(this);\n    }\n  }\n\n  var $TypedArrayPrototype$ = redefineAll({}, proto);\n  redefineAll($TypedArrayPrototype$, $iterators);\n  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n  redefineAll($TypedArrayPrototype$, {\n    slice:          $slice,\n    set:            $set,\n    constructor:    function(){ /* noop */ },\n    toString:       arrayToString,\n    toLocaleString: $toLocaleString\n  });\n  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n  addGetter($TypedArrayPrototype$, 'length', 'e');\n  dP($TypedArrayPrototype$, TAG, {\n    get: function(){ return this[TYPED_ARRAY]; }\n  });\n\n  module.exports = function(KEY, BYTES, wrapper, CLAMPED){\n    CLAMPED = !!CLAMPED;\n    var NAME       = KEY + (CLAMPED ? 'Clamped' : '') + 'Array'\n      , ISNT_UINT8 = NAME != 'Uint8Array'\n      , GETTER     = 'get' + KEY\n      , SETTER     = 'set' + KEY\n      , TypedArray = global[NAME]\n      , Base       = TypedArray || {}\n      , TAC        = TypedArray && getPrototypeOf(TypedArray)\n      , FORCED     = !TypedArray || !$typed.ABV\n      , O          = {}\n      , TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n    var getter = function(that, index){\n      var data = that._d;\n      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n    };\n    var setter = function(that, index, value){\n      var data = that._d;\n      if(CLAMPED)value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n    };\n    var addElement = function(that, index){\n      dP(that, index, {\n        get: function(){\n          return getter(this, index);\n        },\n        set: function(value){\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n    if(FORCED){\n      TypedArray = wrapper(function(that, data, $offset, $length){\n        anInstance(that, TypedArray, NAME, '_d');\n        var index  = 0\n          , offset = 0\n          , buffer, byteLength, length, klass;\n        if(!isObject(data)){\n          length     = strictToLength(data, true)\n          byteLength = length * BYTES;\n          buffer     = new $ArrayBuffer(byteLength);\n        } else if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){\n          buffer = data;\n          offset = toOffset($offset, BYTES);\n          var $len = data.byteLength;\n          if($length === undefined){\n            if($len % BYTES)throw RangeError(WRONG_LENGTH);\n            byteLength = $len - offset;\n            if(byteLength < 0)throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if(byteLength + offset > $len)throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if(TYPED_ARRAY in data){\n          return fromList(TypedArray, data);\n        } else {\n          return $from.call(TypedArray, data);\n        }\n        hide(that, '_d', {\n          b: buffer,\n          o: offset,\n          l: byteLength,\n          e: length,\n          v: new $DataView(buffer)\n        });\n        while(index < length)addElement(that, index++);\n      });\n      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n      hide(TypedArrayPrototype, 'constructor', TypedArray);\n    } else if(!$iterDetect(function(iter){\n      // V8 works with iterators, but fails in many other cases\n      // https://code.google.com/p/v8/issues/detail?id=4552\n      new TypedArray(null); // eslint-disable-line no-new\n      new TypedArray(iter); // eslint-disable-line no-new\n    }, true)){\n      TypedArray = wrapper(function(that, data, $offset, $length){\n        anInstance(that, TypedArray, NAME);\n        var klass;\n        // `ws` module bug, temporarily remove validation length for Uint8Array\n        // https://github.com/websockets/ws/pull/645\n        if(!isObject(data))return new Base(strictToLength(data, ISNT_UINT8));\n        if(data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER){\n          return $length !== undefined\n            ? new Base(data, toOffset($offset, BYTES), $length)\n            : $offset !== undefined\n              ? new Base(data, toOffset($offset, BYTES))\n              : new Base(data);\n        }\n        if(TYPED_ARRAY in data)return fromList(TypedArray, data);\n        return $from.call(TypedArray, data);\n      });\n      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function(key){\n        if(!(key in TypedArray))hide(TypedArray, key, Base[key]);\n      });\n      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n      if(!LIBRARY)TypedArrayPrototype.constructor = TypedArray;\n    }\n    var $nativeIterator   = TypedArrayPrototype[ITERATOR]\n      , CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined)\n      , $iterator         = $iterators.values;\n    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n    hide(TypedArrayPrototype, VIEW, true);\n    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n    if(CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)){\n      dP(TypedArrayPrototype, TAG, {\n        get: function(){ return NAME; }\n      });\n    }\n\n    O[NAME] = TypedArray;\n\n    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\n    $export($export.S, NAME, {\n      BYTES_PER_ELEMENT: BYTES,\n      from: $from,\n      of: $of\n    });\n\n    if(!(BYTES_PER_ELEMENT in TypedArrayPrototype))hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\n    $export($export.P, NAME, proto);\n\n    setSpecies(NAME);\n\n    $export($export.P + $export.F * FORCED_SET, NAME, {set: $set});\n\n    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\n    $export($export.P + $export.F * (TypedArrayPrototype.toString != arrayToString), NAME, {toString: arrayToString});\n\n    $export($export.P + $export.F * fails(function(){\n      new TypedArray(1).slice();\n    }), NAME, {slice: $slice});\n\n    $export($export.P + $export.F * (fails(function(){\n      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString()\n    }) || !fails(function(){\n      TypedArrayPrototype.toLocaleString.call([1, 2]);\n    })), NAME, {toLocaleString: $toLocaleString});\n\n    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n    if(!LIBRARY && !CORRECT_ITER_NAME)hide(TypedArrayPrototype, ITERATOR, $iterator);\n  };\n} else module.exports = function(){ /* empty */ };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_typed-array.js\n// module id = 15\n// module chunks = 0","'use strict';\n\nvar Promise = require('pouchdb-promise');\n\n/* istanbul ignore next */\nexports.once = function (fun) {\n  var called = false;\n  return exports.getArguments(function (args) {\n    if (called) {\n      console.trace();\n      throw new Error('once called  more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n};\n/* istanbul ignore next */\nexports.getArguments = function (fun) {\n  return function () {\n    var len = arguments.length;\n    var args = new Array(len);\n    var i = -1;\n    while (++i < len) {\n      args[i] = arguments[i];\n    }\n    return fun.call(this, args);\n  };\n};\n/* istanbul ignore next */\nexports.toPromise = function (func) {\n  //create the function we will be returning\n  return exports.getArguments(function (args) {\n    var self = this;\n    var tempCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    // if the last argument is a function, assume its a callback\n    var usedCB;\n    if (tempCB) {\n      // if it was a callback, create a new callback which calls it,\n      // but do so async so we don't trap any errors\n      usedCB = function (err, resp) {\n        process.nextTick(function () {\n          tempCB(err, resp);\n        });\n      };\n    }\n    var promise = new Promise(function (fulfill, reject) {\n      try {\n        var callback = exports.once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        func.apply(self, args);\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    promise.cancel = function () {\n      return this;\n    };\n    return promise;\n  });\n};\n\nexports.inherits = require('inherits');\nexports.Promise = Promise;\n\nexports.clone = function (obj) {\n  return exports.extend(true, {}, obj);\n};\n\nexports.extend = require('pouchdb-extend');\n\nexports.callbackify = function (fun) {\n  return exports.getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    exports.promisedCallback(promise, cb);\n    return promise;\n  });\n};\n\nexports.promisedCallback = function (promise, callback) {\n  promise.then(function (res) {\n    process.nextTick(function () {\n      callback(null, res);\n    });\n  }, function (reason) {\n    process.nextTick(function () {\n      callback(reason);\n    });\n  });\n  return promise;\n};\n\nvar crypto = require('crypto');\nvar Md5 = require('spark-md5');\n\nexports.MD5 = function (string) {\n  /* istanbul ignore else */\n  if (!process.browser) {\n    return crypto.createHash('md5').update(string).digest('hex');\n  } else {\n    return Md5.hash(string);\n  }\n};\n\nexports.flatten = exports.getArguments(function (args) {\n  var res = [];\n  for (var i = 0, len = args.length; i < len; i++) {\n    var subArr = args[i];\n    if (Array.isArray(subArr)) {\n      res = res.concat(exports.flatten.apply(null, subArr));\n    } else {\n      res.push(subArr);\n    }\n  }\n  return res;\n});\n\nexports.mergeObjects = function (arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res = exports.extend(true, res, arr[i]);\n  }\n  return res;\n};\n\n// this would just be \"return doc[field]\", but fields\n// can be \"deep\" due to dot notation\nexports.getFieldFromDoc = function (doc, parsedField) {\n  var value = doc;\n  for (var i = 0, len = parsedField.length; i < len; i++) {\n    var key = parsedField[i];\n    value = value[key];\n    if (!value) {\n      break;\n    }\n  }\n  return value;\n};\n\nexports.setFieldInDoc = function (doc, parsedField, value) {\n  for (var i = 0, len = parsedField.length; i < len-1; i++) {\n    var elem = parsedField[i];\n    doc = doc[elem] = {};\n  }\n  doc[parsedField[len-1]] = value;\n};\n\n// Converts a string in dot notation to an array of its components, with backslash escaping\nexports.parseField = function (fieldName) {\n  // fields may be deep (e.g. \"foo.bar.baz\"), so parse\n  var fields = [];\n  var current = '';\n  for (var i = 0, len = fieldName.length; i < len; i++) {\n    var ch = fieldName[i];\n    if (ch === '.') {\n      if (i > 0 && fieldName[i - 1] === '\\\\') { // escaped delimiter\n        current = current.substring(0, current.length - 1) + '.';\n      } else { // not escaped, so delimiter\n        fields.push(current);\n        current = '';\n      }\n    } else { // normal character\n      current += ch;\n    }\n  }\n  fields.push(current);\n  return fields;\n};\n\n// Selects a list of fields defined in dot notation from one doc\n// and copies them to a new doc. Like underscore _.pick but supports nesting.\nexports.pick = function (obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var parsedField = exports.parseField(arr[i]);\n    var value = exports.getFieldFromDoc(obj, parsedField);\n    if(typeof value !== 'undefined') {\n      exports.setFieldInDoc(res, parsedField, value);\n    }\n  }\n  return res;\n};\n\n// e.g. ['a'], ['a', 'b'] is true, but ['b'], ['a', 'b'] is false\nexports.oneArrayIsSubArrayOfOther = function (left, right) {\n\n  for (var i = 0, len = Math.min(left.length, right.length); i < len; i++) {\n    if (left[i] !== right[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\n// e.g.['a', 'b', 'c'], ['a', 'b'] is false\nexports.oneArrayIsStrictSubArrayOfOther = function (left, right) {\n\n  if (left.length > right.length) {\n    return false;\n  }\n\n  return exports.oneArrayIsSubArrayOfOther(left, right);\n};\n\n// same as above, but treat the left array as an unordered set\n// e.g. ['b', 'a'], ['a', 'b', 'c'] is true, but ['c'], ['a', 'b', 'c'] is false\nexports.oneSetIsSubArrayOfOther = function (left, right) {\n  left = left.slice();\n  for (var i = 0, len = right.length; i < len; i++) {\n    var field = right[i];\n    if (!left.length) {\n      break;\n    }\n    var leftIdx = left.indexOf(field);\n    if (leftIdx === -1) {\n      return false;\n    } else {\n      left.splice(leftIdx, 1);\n    }\n  }\n  return true;\n};\n\nexports.compare = function (left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n};\n\nexports.arrayToObject = function (arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res[arr[i]] = true;\n  }\n  return res;\n};\n\nexports.max = function (arr, fun) {\n  var max = null;\n  var maxScore = -1;\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var element = arr[i];\n    var score = fun(element);\n    if (score > maxScore) {\n      maxScore = score;\n      max = element;\n    }\n  }\n  return max;\n};\n\nexports.arrayEquals = function (arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (var i = 0, len = arr1.length; i < len; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.uniq = function(arr) {\n  var obj = {};\n  for (var i = 0; i < arr.length; i++) {\n    obj['$' + arr[i]] = true;\n  }\n  return Object.keys(obj).map(function (key) {\n    return key.substring(1);\n  });\n};\n\nexports.log = require('debug')('pouchdb:find');\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/utils.js\n// module id = 16\n// module chunks = 0","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function(it){\n  if(it == undefined)throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_defined.js\n// module id = 17\n// module chunks = 0","var pIE            = require('./_object-pie')\n  , createDesc     = require('./_property-desc')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , has            = require('./_has')\n  , IE8_DOM_DEFINE = require('./_ie8-dom-define')\n  , gOPD           = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P){\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if(IE8_DOM_DEFINE)try {\n    return gOPD(O, P);\n  } catch(e){ /* empty */ }\n  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-gopd.js\n// module id = 18\n// module chunks = 0","module.exports = function(bitmap, value){\n  return {\n    enumerable  : !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable    : !(bitmap & 4),\n    value       : value\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_property-desc.js\n// module id = 19\n// module chunks = 0","var global    = require('./_global')\n  , hide      = require('./_hide')\n  , has       = require('./_has')\n  , SRC       = require('./_uid')('src')\n  , TO_STRING = 'toString'\n  , $toString = Function[TO_STRING]\n  , TPL       = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function(it){\n  return $toString.call(it);\n};\n\n(module.exports = function(O, key, val, safe){\n  var isFunction = typeof val == 'function';\n  if(isFunction)has(val, 'name') || hide(val, 'name', key);\n  if(O[key] === val)return;\n  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if(O === global){\n    O[key] = val;\n  } else {\n    if(!safe){\n      delete O[key];\n      hide(O, key, val);\n    } else {\n      if(O[key])O[key] = val;\n      else hide(O, key, val);\n    }\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString(){\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_redefine.js\n// module id = 20\n// module chunks = 0","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/process/browser.js\n// module id = 21\n// module chunks = 0","/* global navigator */\nconst FuzzFactor = 0.3\n\nexport function unpromiser (fn) {\n  return function (...args) {\n    const value = fn.apply(this, args)\n    if (!isPromise(value)) {\n      return value\n    }\n    const l = args.length\n    if (l === 0 || typeof args[l - 1] !== 'function') {\n      return\n    }\n    const cb = args[l - 1]\n    value.then(\n      (res) => cb(null, res),\n      (err) => cb(err, null)\n    )\n  }\n}\n\nexport function isPromise (value) {\n  return !!value && typeof value.then === 'function'\n}\n\nexport function isOnline () {\n  return typeof navigator !== 'undefined' ? navigator.onLine : true\n}\n\nexport function isOffline () {\n  return !isOnline()\n}\n\nexport function sleep (time, args) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, time, args)\n  })\n}\n\nexport function retry (fn, count, delay = 300) {\n  return function doTry (...args) {\n    return fn(...args).catch((err) => {\n      if (--count < 0) {\n        throw err\n      }\n      return sleep(getBackedoffDelay(delay, count))\n        .then(() => doTry(...args))\n    })\n  }\n}\n\nexport function getFuzzedDelay (retryDelay) {\n  const fuzzingFactor = ((Math.random() * 2) - 1) * FuzzFactor\n  return retryDelay * (1.0 + fuzzingFactor)\n}\n\nexport function getBackedoffDelay (retryDelay, retryCount = 1) {\n  return getFuzzedDelay(retryDelay * Math.pow(2, retryCount - 1))\n}\n\nexport function createPath (cozy, isV2, doctype, id = '', query = null) {\n  let route = '/data/'\n  if (!isV2) {\n    route += `${encodeURIComponent(doctype)}/`\n  }\n  if (id !== '') {\n    route += encodeURIComponent(id)\n  }\n  const q = encodeQuery(query)\n  if (q !== '') {\n    route += '?' + q\n  }\n  return route\n}\n\nexport function encodeQuery (query) {\n  if (!query) {\n    return ''\n  }\n  let q = ''\n  for (const qname in query) {\n    if (q !== '') {\n      q += '&'\n    }\n    q += `${encodeURIComponent(qname)}=${encodeURIComponent(query[qname])}`\n  }\n  return q\n}\n\nexport function decodeQuery (url) {\n  let queryIndex = url.indexOf('?')\n  if (queryIndex < 0) {\n    queryIndex = url.length\n  }\n  const queries = {}\n  let fragIndex = url.indexOf('#')\n  if (fragIndex < 0) {\n    fragIndex = url.length\n  }\n  if (fragIndex < queryIndex) {\n    return queries\n  }\n  const queryStr = url.slice(queryIndex + 1, fragIndex)\n  if (queryStr === '') {\n    return queries\n  }\n  const parts = queryStr.split('&')\n  for (let i = 0; i < parts.length; i++) {\n    let pair = parts[i].split('=')\n    if (pair.length === 0 || pair[0] === '') {\n      continue\n    }\n    const qname = decodeURIComponent(pair[0])\n    if (queries.hasOwnProperty(qname)) {\n      continue\n    }\n    if (pair.length === 1) {\n      queries[qname] = true\n    } else if (pair.length === 2) {\n      queries[qname] = decodeURIComponent(pair[1])\n    } else {\n      throw new Error('Malformed URL')\n    }\n  }\n  return queries\n}\n\nconst warned = []\nexport function warn (text) {\n  if (warned.indexOf(text) === -1) {\n    warned.push(text)\n    console.warn('cozy-client-js', text)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","module.exports = function(it){\n  if(typeof it != 'function')throw TypeError(it + ' is not a function!');\n  return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_a-function.js\n// module id = 23\n// module chunks = 0","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function(it){\n  return Object(defined(it));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-object.js\n// module id = 24\n// module chunks = 0","var id = 0\n  , px = Math.random();\nmodule.exports = function(key){\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_uid.js\n// module id = 25\n// module chunks = 0","// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./_wks')('unscopables')\n  , ArrayProto  = Array.prototype;\nif(ArrayProto[UNSCOPABLES] == undefined)require('./_hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function(key){\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_add-to-unscopables.js\n// module id = 26\n// module chunks = 0","module.exports = function(it, Constructor, name, forbiddenField){\n  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_an-instance.js\n// module id = 27\n// module chunks = 0","var toString = {}.toString;\n\nmodule.exports = function(it){\n  return toString.call(it).slice(8, -1);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_cof.js\n// module id = 28\n// module chunks = 0","module.exports = {};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_iterators.js\n// module id = 29\n// module chunks = 0","module.exports = false;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_library.js\n// module id = 30\n// module chunks = 0","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys       = require('./_object-keys-internal')\n  , enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O){\n  return $keys(O, enumBugKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-keys.js\n// module id = 31\n// module chunks = 0","var redefine = require('./_redefine');\nmodule.exports = function(target, src, safe){\n  for(var key in src)redefine(target, key, src[key], safe);\n  return target;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_redefine-all.js\n// module id = 32\n// module chunks = 0","var def = require('./_object-dp').f\n  , has = require('./_has')\n  , TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function(it, tag, stat){\n  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_set-to-string-tag.js\n// module id = 33\n// module chunks = 0","// 7.1.4 ToInteger\nvar ceil  = Math.ceil\n  , floor = Math.floor;\nmodule.exports = function(it){\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-integer.js\n// module id = 34\n// module chunks = 0","'use strict';\n\nvar utils = require('../../utils');\nvar collate = require('pouchdb-collate');\n\nfunction getKey(obj) {\n  return Object.keys(obj)[0];\n}\n\nfunction getValue(obj) {\n  return obj[getKey(obj)];\n}\n\n// normalize the \"sort\" value\nfunction massageSort(sort) {\n  if (!Array.isArray(sort)) {\n    throw new Error('invalid sort json - should be an array');\n  }\n  return sort.map(function (sorting) {\n    if (typeof sorting === 'string') {\n      var obj = {};\n      obj[sorting] = 'asc';\n      return obj;\n    } else {\n      return sorting;\n    }\n  });\n}\n\nvar combinationFields = ['$or', '$nor', '$not'];\nfunction isCombinationalField (field) {\n  return combinationFields.indexOf(field) > -1;\n}\n\n// collapse logically equivalent gt/gte values\nfunction mergeGtGte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$gte !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gte) { // more specificity\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value >= fieldMatchers.$gte) { // more specificity\n        delete fieldMatchers.$gte;\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$gt !== 'undefined') {\n    if (operator === '$gte') {\n      if (value > fieldMatchers.$gt) { // more specificity\n        delete fieldMatchers.$gt;\n        fieldMatchers.$gte = value;\n      }\n    } else { // operator === '$gt'\n      if (value > fieldMatchers.$gt) { // more specificity\n        fieldMatchers.$gt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// collapse logically equivalent lt/lte values\nfunction mergeLtLte(operator, value, fieldMatchers) {\n  if (typeof fieldMatchers.$eq !== 'undefined') {\n    return; // do nothing\n  }\n  if (typeof fieldMatchers.$lte !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lte) { // more specificity\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value <= fieldMatchers.$lte) { // more specificity\n        delete fieldMatchers.$lte;\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else if (typeof fieldMatchers.$lt !== 'undefined') {\n    if (operator === '$lte') {\n      if (value < fieldMatchers.$lt) { // more specificity\n        delete fieldMatchers.$lt;\n        fieldMatchers.$lte = value;\n      }\n    } else { // operator === '$gt'\n      if (value < fieldMatchers.$lt) { // more specificity\n        fieldMatchers.$lt = value;\n      }\n    }\n  } else {\n    fieldMatchers[operator] = value;\n  }\n}\n\n// combine $ne values into one array\nfunction mergeNe(value, fieldMatchers) {\n  if ('$ne' in fieldMatchers) {\n    // there are many things this could \"not\" be\n    fieldMatchers.$ne.push(value);\n  } else { // doesn't exist yet\n    fieldMatchers.$ne = [value];\n  }\n}\n\n// add $eq into the mix\nfunction mergeEq(value, fieldMatchers) {\n  // these all have less specificity than the $eq\n  // TODO: check for user errors here\n  delete fieldMatchers.$gt;\n  delete fieldMatchers.$gte;\n  delete fieldMatchers.$lt;\n  delete fieldMatchers.$lte;\n  delete fieldMatchers.$ne;\n  fieldMatchers.$eq = value;\n}\n\n// flatten an array of selectors joined by an $and operator\nfunction mergeAndedSelectors(selectors) {\n\n  // sort to ensure that e.g. if the user specified\n  // $and: [{$gt: 'a'}, {$gt: 'b'}], then it's collapsed into\n  // just {$gt: 'b'}\n  var res = {};\n\n  selectors.forEach(function (selector) {\n    Object.keys(selector).forEach(function (field) {\n      var matcher = selector[field];\n      if (typeof matcher !== 'object') {\n        matcher = {$eq: matcher};\n      }\n\n      if (isCombinationalField(field)) {\n        if (matcher instanceof Array) {\n          res[field] = matcher.map(function (m) {\n            return mergeAndedSelectors([m]);\n          });\n        } else {\n          res[field] = mergeAndedSelectors([matcher]);\n        }\n      } else {\n        var fieldMatchers = res[field] = res[field] || {};\n        Object.keys(matcher).forEach(function (operator) {\n          var value = matcher[operator];\n\n          if (operator === '$gt' || operator === '$gte') {\n            return mergeGtGte(operator, value, fieldMatchers);\n          } else if (operator === '$lt' || operator === '$lte') {\n            return mergeLtLte(operator, value, fieldMatchers);\n          } else if (operator === '$ne') {\n            return mergeNe(value, fieldMatchers);\n          } else if (operator === '$eq') {\n            return mergeEq(value, fieldMatchers);\n          }\n          fieldMatchers[operator] = value;\n        });\n      }\n    });\n  });\n\n  return res;\n}\n\n//\n// normalize the selector\n//\nfunction massageSelector(input) {\n  var result = utils.clone(input);\n  var wasAnded = false;\n  if ('$and' in result) {\n    result = mergeAndedSelectors(result['$and']);\n    wasAnded = true;\n  }\n\n  if ('$not' in result) {\n    //This feels a little like forcing, but it will work for now,\n    //I would like to come back to this and make the merging of selectors a little more generic\n    result['$not'] = mergeAndedSelectors([result['$not']]);\n  }\n\n  var fields = Object.keys(result);\n\n  for (var i = 0; i < fields.length; i++) {\n    var field = fields[i];\n    var matcher = result[field];\n\n    if (typeof matcher !== 'object' || matcher === null) {\n      matcher = {$eq: matcher};\n    } else if ('$ne' in matcher && !wasAnded) {\n      // I put these in an array, since there may be more than one\n      // but in the \"mergeAnded\" operation, I already take care of that\n      matcher.$ne = [matcher.$ne];\n    }\n    result[field] = matcher;\n  }\n\n  return result;\n}\n\n\nfunction massageIndexDef(indexDef) {\n  indexDef.fields = indexDef.fields.map(function (field) {\n    if (typeof field === 'string') {\n      var obj = {};\n      obj[field] = 'asc';\n      return obj;\n    }\n    return field;\n  });\n  return indexDef;\n}\n\nfunction getKeyFromDoc(doc, index) {\n  var res = [];\n  for (var i = 0; i < index.def.fields.length; i++) {\n    var field = getKey(index.def.fields[i]);\n    res.push(doc[field]);\n  }\n  return res;\n}\n\n// have to do this manually because REASONS. I don't know why\n// CouchDB didn't implement inclusive_start\nfunction filterInclusiveStart(rows, targetValue, index) {\n  var indexFields = index.def.fields;\n  for (var i = 0, len = rows.length; i < len; i++) {\n    var row = rows[i];\n\n    // shave off any docs at the beginning that are <= the\n    // target value\n\n    var docKey = getKeyFromDoc(row.doc, index);\n    if (indexFields.length === 1) {\n      docKey = docKey[0]; // only one field, not multi-field\n    } else { // more than one field in index\n      // in the case where e.g. the user is searching {$gt: {a: 1}}\n      // but the index is [a, b], then we need to shorten the doc key\n      while (docKey.length > targetValue.length) {\n        docKey.pop();\n      }\n    }\n    //ABS as we just looking for values that don't match\n    if (Math.abs(collate.collate(docKey, targetValue)) > 0) {\n      // no need to filter any further; we're past the key\n      break;\n    }\n  }\n  return i > 0 ? rows.slice(i) : rows;\n}\n\nfunction reverseOptions(opts) {\n  var newOpts = utils.clone(opts);\n  delete newOpts.startkey;\n  delete newOpts.endkey;\n  delete newOpts.inclusive_start;\n  delete newOpts.inclusive_end;\n\n  if ('endkey' in opts) {\n    newOpts.startkey = opts.endkey;\n  }\n  if ('startkey' in opts) {\n    newOpts.endkey = opts.startkey;\n  }\n  if ('inclusive_start' in opts) {\n    newOpts.inclusive_end = opts.inclusive_start;\n  }\n  if ('inclusive_end' in opts) {\n    newOpts.inclusive_start = opts.inclusive_end;\n  }\n  return newOpts;\n}\n\nfunction validateIndex(index) {\n  var ascFields = index.fields.filter(function (field) {\n    return getValue(field) === 'asc';\n  });\n  if (ascFields.length !== 0 && ascFields.length !== index.fields.length) {\n    throw new Error('unsupported mixed sorting');\n  }\n}\n\nfunction validateSort (requestDef, index) {\n  if (index.defaultUsed && requestDef.sort) {\n    var noneIdSorts = requestDef.sort.filter(function (sortItem) {\n      return Object.keys(sortItem)[0] !== '_id';\n    }).map(function (sortItem) {\n      return Object.keys(sortItem)[0];\n    });\n\n    if (noneIdSorts.length > 0) {\n      throw new Error('Cannot sort on field(s) \"' + noneIdSorts.join(',') +\n      '\" when using the default index');\n    }\n  }\n\n  if (index.defaultUsed) {\n    return;\n  }\n}\n\nfunction validateFindRequest(requestDef) {\n  if (typeof requestDef.selector !== 'object') {\n    throw new Error('you must provide a selector when you find()');\n  }\n\n  /*var selectors = requestDef.selector['$and'] || [requestDef.selector];\n  for (var i = 0; i < selectors.length; i++) {\n    var selector = selectors[i];\n    var keys = Object.keys(selector);\n    if (keys.length === 0) {\n      throw new Error('invalid empty selector');\n    }\n    //var selection = selector[keys[0]];\n    /*if (Object.keys(selection).length !== 1) {\n      throw new Error('invalid selector: ' + JSON.stringify(selection) +\n        ' - it must have exactly one key/value');\n    }\n  }*/\n}\n\n// determine the maximum number of fields\n// we're going to need to query, e.g. if the user\n// has selection ['a'] and sorting ['a', 'b'], then we\n// need to use the longer of the two: ['a', 'b']\nfunction getUserFields(selector, sort) {\n  var selectorFields = Object.keys(selector);\n  var sortFields = sort? sort.map(getKey) : [];\n  var userFields;\n  if (selectorFields.length >= sortFields.length) {\n    userFields = selectorFields;\n  } else {\n    userFields = sortFields;\n  }\n\n  if (sortFields.length === 0) {\n    return {\n      fields: userFields\n    };\n  }\n\n  // sort according to the user's preferred sorting\n  userFields = userFields.sort(function (left, right) {\n    var leftIdx = sortFields.indexOf(left);\n    if (leftIdx === -1) {\n      leftIdx = Number.MAX_VALUE;\n    }\n    var rightIdx = sortFields.indexOf(right);\n    if (rightIdx === -1) {\n      rightIdx = Number.MAX_VALUE;\n    }\n    return leftIdx < rightIdx ? -1 : leftIdx > rightIdx ? 1 : 0;\n  });\n\n  return {\n    fields: userFields,\n    sortOrder: sort.map(getKey)\n  };\n}\n\nmodule.exports = {\n  getKey: getKey,\n  getValue: getValue,\n  massageSort: massageSort,\n  massageSelector: massageSelector,\n  validateIndex: validateIndex,\n  validateFindRequest: validateFindRequest,\n  validateSort: validateSort,\n  reverseOptions: reverseOptions,\n  filterInclusiveStart: filterInclusiveStart,\n  massageIndexDef: massageIndexDef,\n  parseField: utils.parseField,\n  getUserFields: getUserFields,\n  isCombinationalField: isCombinationalField\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/adapters/local/utils.js\n// module id = 35\n// module chunks = 0","import {warn} from './utils'\n\nexport const DOCTYPE_FILES = 'io.cozy.files'\n\nconst KNOWN_DOCTYPES = {\n  'files': DOCTYPE_FILES,\n  'folder': DOCTYPE_FILES,\n  'contact': 'io.cozy.contacts',\n  'event': 'io.cozy.events',\n  'track': 'io.cozy.labs.music.track',\n  'playlist': 'io.cozy.labs.music.playlist'\n}\n\nconst REVERSE_KNOWN = {}\nObject.keys(KNOWN_DOCTYPES).forEach(k => {\n  REVERSE_KNOWN[KNOWN_DOCTYPES[k]] = k\n})\n\nexport function normalizeDoctype (cozy, isV2, doctype) {\n  let isQualified = doctype.indexOf('.') !== -1\n  if (isV2 && isQualified) {\n    let known = REVERSE_KNOWN[doctype]\n    if (known) return known\n    return doctype.replace(/\\./g, '-')\n  }\n  if (!isV2 && !isQualified) {\n    let known = KNOWN_DOCTYPES[doctype]\n    if (known) {\n      warn('you are using a non-qualified doctype ' + doctype + ' assumed to be ' + known)\n      return known\n    }\n    throw new Error('Doctype ' + doctype + ' should be qualified.')\n  }\n  return doctype\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/doctypes.js","// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx      = require('./_ctx')\n  , IObject  = require('./_iobject')\n  , toObject = require('./_to-object')\n  , toLength = require('./_to-length')\n  , asc      = require('./_array-species-create');\nmodule.exports = function(TYPE, $create){\n  var IS_MAP        = TYPE == 1\n    , IS_FILTER     = TYPE == 2\n    , IS_SOME       = TYPE == 3\n    , IS_EVERY      = TYPE == 4\n    , IS_FIND_INDEX = TYPE == 6\n    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX\n    , create        = $create || asc;\n  return function($this, callbackfn, that){\n    var O      = toObject($this)\n      , self   = IObject(O)\n      , f      = ctx(callbackfn, that, 3)\n      , length = toLength(self.length)\n      , index  = 0\n      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined\n      , val, res;\n    for(;length > index; index++)if(NO_HOLES || index in self){\n      val = self[index];\n      res = f(val, index, O);\n      if(TYPE){\n        if(IS_MAP)result[index] = res;            // map\n        else if(res)switch(TYPE){\n          case 3: return true;                    // some\n          case 5: return val;                     // find\n          case 6: return index;                   // findIndex\n          case 2: result.push(val);               // filter\n        } else if(IS_EVERY)return false;          // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_array-methods.js\n// module id = 37\n// module chunks = 0","var core = module.exports = {version: '2.4.0'};\nif(typeof __e == 'number')__e = core; // eslint-disable-line no-undef\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_core.js\n// module id = 38\n// module chunks = 0","var META     = require('./_uid')('meta')\n  , isObject = require('./_is-object')\n  , has      = require('./_has')\n  , setDesc  = require('./_object-dp').f\n  , id       = 0;\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\nvar FREEZE = !require('./_fails')(function(){\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function(it){\n  setDesc(it, META, {value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  }});\n};\nvar fastKey = function(it, create){\n  // return primitive with prefix\n  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return 'F';\n    // not necessary to add metadata\n    if(!create)return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function(it, create){\n  if(!has(it, META)){\n    // can't set metadata to uncaught frozen object\n    if(!isExtensible(it))return true;\n    // not necessary to add metadata\n    if(!create)return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function(it){\n  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY:      META,\n  NEED:     false,\n  fastKey:  fastKey,\n  getWeak:  getWeak,\n  onFreeze: onFreeze\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_meta.js\n// module id = 39\n// module chunks = 0","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject    = require('./_an-object')\n  , dPs         = require('./_object-dps')\n  , enumBugKeys = require('./_enum-bug-keys')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , Empty       = function(){ /* empty */ }\n  , PROTOTYPE   = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function(){\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe')\n    , i      = enumBugKeys.length\n    , lt     = '<'\n    , gt     = '>'\n    , iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties){\n  var result;\n  if(O !== null){\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty;\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-create.js\n// module id = 40\n// module chunks = 0","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys      = require('./_object-keys-internal')\n  , hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){\n  return $keys(O, hiddenKeys);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-gopn.js\n// module id = 41\n// module chunks = 0","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has         = require('./_has')\n  , toObject    = require('./_to-object')\n  , IE_PROTO    = require('./_shared-key')('IE_PROTO')\n  , ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function(O){\n  O = toObject(O);\n  if(has(O, IE_PROTO))return O[IE_PROTO];\n  if(typeof O.constructor == 'function' && O instanceof O.constructor){\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-gpo.js\n// module id = 42\n// module chunks = 0","exports.f = {}.propertyIsEnumerable;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-pie.js\n// module id = 43\n// module chunks = 0","var toInteger = require('./_to-integer')\n  , max       = Math.max\n  , min       = Math.min;\nmodule.exports = function(index, length){\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-index.js\n// module id = 44\n// module chunks = 0","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function(it, S){\n  if(!isObject(it))return it;\n  var fn, val;\n  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;\n  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_to-primitive.js\n// module id = 45\n// module chunks = 0","'use strict';\nvar global            = require('./_global')\n  , $export           = require('./_export')\n  , redefine          = require('./_redefine')\n  , redefineAll       = require('./_redefine-all')\n  , meta              = require('./_meta')\n  , forOf             = require('./_for-of')\n  , anInstance        = require('./_an-instance')\n  , isObject          = require('./_is-object')\n  , fails             = require('./_fails')\n  , $iterDetect       = require('./_iter-detect')\n  , setToStringTag    = require('./_set-to-string-tag')\n  , inheritIfRequired = require('./_inherit-if-required');\n\nmodule.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){\n  var Base  = global[NAME]\n    , C     = Base\n    , ADDER = IS_MAP ? 'set' : 'add'\n    , proto = C && C.prototype\n    , O     = {};\n  var fixMethod = function(KEY){\n    var fn = proto[KEY];\n    redefine(proto, KEY,\n      KEY == 'delete' ? function(a){\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'has' ? function has(a){\n        return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'get' ? function get(a){\n        return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);\n      } : KEY == 'add' ? function add(a){ fn.call(this, a === 0 ? 0 : a); return this; }\n        : function set(a, b){ fn.call(this, a === 0 ? 0 : a, b); return this; }\n    );\n  };\n  if(typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){\n    new C().entries().next();\n  }))){\n    // create collection constructor\n    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);\n    redefineAll(C.prototype, methods);\n    meta.NEED = true;\n  } else {\n    var instance             = new C\n      // early implementations not supports chaining\n      , HASNT_CHAINING       = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance\n      // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false\n      , THROWS_ON_PRIMITIVES = fails(function(){ instance.has(1); })\n      // most early implementations doesn't supports iterables, most modern - not close it correctly\n      , ACCEPT_ITERABLES     = $iterDetect(function(iter){ new C(iter); }) // eslint-disable-line no-new\n      // for early implementations -0 and +0 not the same\n      , BUGGY_ZERO = !IS_WEAK && fails(function(){\n        // V8 ~ Chromium 42- fails only with 5+ elements\n        var $instance = new C()\n          , index     = 5;\n        while(index--)$instance[ADDER](index, index);\n        return !$instance.has(-0);\n      });\n    if(!ACCEPT_ITERABLES){ \n      C = wrapper(function(target, iterable){\n        anInstance(target, C, NAME);\n        var that = inheritIfRequired(new Base, target, C);\n        if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n        return that;\n      });\n      C.prototype = proto;\n      proto.constructor = C;\n    }\n    if(THROWS_ON_PRIMITIVES || BUGGY_ZERO){\n      fixMethod('delete');\n      fixMethod('has');\n      IS_MAP && fixMethod('get');\n    }\n    if(BUGGY_ZERO || HASNT_CHAINING)fixMethod(ADDER);\n    // weak collections should not contains .clear method\n    if(IS_WEAK && proto.clear)delete proto.clear;\n  }\n\n  setToStringTag(C, NAME);\n\n  O[NAME] = C;\n  $export($export.G + $export.W + $export.F * (C != Base), O);\n\n  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);\n\n  return C;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_collection.js\n// module id = 46\n// module chunks = 0","'use strict';\nvar hide     = require('./_hide')\n  , redefine = require('./_redefine')\n  , fails    = require('./_fails')\n  , defined  = require('./_defined')\n  , wks      = require('./_wks');\n\nmodule.exports = function(KEY, length, exec){\n  var SYMBOL   = wks(KEY)\n    , fns      = exec(defined, SYMBOL, ''[KEY])\n    , strfn    = fns[0]\n    , rxfn     = fns[1];\n  if(fails(function(){\n    var O = {};\n    O[SYMBOL] = function(){ return 7; };\n    return ''[KEY](O) != 7;\n  })){\n    redefine(String.prototype, KEY, strfn);\n    hide(RegExp.prototype, SYMBOL, length == 2\n      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)\n      // 21.2.5.11 RegExp.prototype[@@split](string, limit)\n      ? function(string, arg){ return rxfn.call(string, this, arg); }\n      // 21.2.5.6 RegExp.prototype[@@match](string)\n      // 21.2.5.9 RegExp.prototype[@@search](string)\n      : function(string){ return rxfn.call(string, this); }\n    );\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_fix-re-wks.js\n// module id = 47\n// module chunks = 0","var ctx         = require('./_ctx')\n  , call        = require('./_iter-call')\n  , isArrayIter = require('./_is-array-iter')\n  , anObject    = require('./_an-object')\n  , toLength    = require('./_to-length')\n  , getIterFn   = require('./core.get-iterator-method')\n  , BREAK       = {}\n  , RETURN      = {};\nvar exports = module.exports = function(iterable, entries, fn, that, ITERATOR){\n  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)\n    , f      = ctx(fn, that, entries ? 2 : 1)\n    , index  = 0\n    , length, step, iterator, result;\n  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');\n  // fast case for arrays with default iterator\n  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){\n    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);\n    if(result === BREAK || result === RETURN)return result;\n  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){\n    result = call(iterator, f, step.value, entries);\n    if(result === BREAK || result === RETURN)return result;\n  }\n};\nexports.BREAK  = BREAK;\nexports.RETURN = RETURN;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_for-of.js\n// module id = 48\n// module chunks = 0","// fast apply, http://jsperf.lnkit.com/fast-apply/5\nmodule.exports = function(fn, args, that){\n  var un = that === undefined;\n  switch(args.length){\n    case 0: return un ? fn()\n                      : fn.call(that);\n    case 1: return un ? fn(args[0])\n                      : fn.call(that, args[0]);\n    case 2: return un ? fn(args[0], args[1])\n                      : fn.call(that, args[0], args[1]);\n    case 3: return un ? fn(args[0], args[1], args[2])\n                      : fn.call(that, args[0], args[1], args[2]);\n    case 4: return un ? fn(args[0], args[1], args[2], args[3])\n                      : fn.call(that, args[0], args[1], args[2], args[3]);\n  } return              fn.apply(that, args);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_invoke.js\n// module id = 49\n// module chunks = 0","var ITERATOR     = require('./_wks')('iterator')\n  , SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function(){ SAFE_CLOSING = true; };\n  Array.from(riter, function(){ throw 2; });\n} catch(e){ /* empty */ }\n\nmodule.exports = function(exec, skipClosing){\n  if(!skipClosing && !SAFE_CLOSING)return false;\n  var safe = false;\n  try {\n    var arr  = [7]\n      , iter = arr[ITERATOR]();\n    iter.next = function(){ return {done: safe = true}; };\n    arr[ITERATOR] = function(){ return iter; };\n    exec(arr);\n  } catch(e){ /* empty */ }\n  return safe;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_iter-detect.js\n// module id = 50\n// module chunks = 0","exports.f = Object.getOwnPropertySymbols;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-gops.js\n// module id = 51\n// module chunks = 0","'use strict';\nvar Mutation = global.MutationObserver || global.WebKitMutationObserver;\n\nvar scheduleDrain;\n\n{\n  if (Mutation) {\n    var called = 0;\n    var observer = new Mutation(nextTick);\n    var element = global.document.createTextNode('');\n    observer.observe(element, {\n      characterData: true\n    });\n    scheduleDrain = function () {\n      element.data = (called = ++called % 2);\n    };\n  } else if (!global.setImmediate && typeof global.MessageChannel !== 'undefined') {\n    var channel = new global.MessageChannel();\n    channel.port1.onmessage = nextTick;\n    scheduleDrain = function () {\n      channel.port2.postMessage(0);\n    };\n  } else if ('document' in global && 'onreadystatechange' in global.document.createElement('script')) {\n    scheduleDrain = function () {\n\n      // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n      // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n      var scriptEl = global.document.createElement('script');\n      scriptEl.onreadystatechange = function () {\n        nextTick();\n\n        scriptEl.onreadystatechange = null;\n        scriptEl.parentNode.removeChild(scriptEl);\n        scriptEl = null;\n      };\n      global.document.documentElement.appendChild(scriptEl);\n    };\n  } else {\n    scheduleDrain = function () {\n      setTimeout(nextTick, 0);\n    };\n  }\n}\n\nvar draining;\nvar queue = [];\n//named nextTick for less confusing stack traces\nfunction nextTick() {\n  draining = true;\n  var i, oldQueue;\n  var len = queue.length;\n  while (len) {\n    oldQueue = queue;\n    queue = [];\n    i = -1;\n    while (++i < len) {\n      oldQueue[i]();\n    }\n    len = queue.length;\n  }\n  draining = false;\n}\n\nmodule.exports = immediate;\nfunction immediate(task) {\n  if (queue.push(task) === 1 && !draining) {\n    scheduleDrain();\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/immediate/lib/browser.js\n// module id = 52\n// module chunks = 0","'use strict';\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nvar utils = require('./utils');\n\nexports.collate = function (a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = exports.normalizeKey(a);\n  b = exports.normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  if (a === null) {\n    return 0;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a === b ? 0 : (a < b ? -1 : 1);\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n};\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nexports.normalizeKey = function (key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = exports.normalizeKey(origKey[i]);\n        }\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = exports.normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n};\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += exports.toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += exports.toIndexableString(objKey) +\n                exports.toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nexports.toIndexableString = function (key) {\n  var zero = '\\u0000';\n  key = exports.normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n};\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    if (neg) {\n      num = num - 10;\n    }\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nexports.parseIndexableString = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = exports.collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = exports.collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = exports.collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = utils.padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-collate/lib/index.js\n// module id = 53\n// module chunks = 0","/* global btoa */\nimport {encodeQuery, decodeQuery, isOffline} from './utils'\nimport {cozyFetchJSON, FetchError} from './fetch'\n\nconst StateSize = 16\n\nexport const CredsKey = 'creds'\nexport const StateKey = 'state'\n\nexport class Client {\n  constructor (opts) {\n    this.clientID = opts.clientID || opts.client_id || ''\n    this.clientSecret = opts.clientSecret || opts.client_secret || ''\n    this.registrationAccessToken = opts.registrationAccessToken || opts.registration_access_token || ''\n\n    if (opts.redirect_uris) {\n      this.redirectURI = opts.redirect_uris[0] || ''\n    } else {\n      this.redirectURI = opts.redirectURI || ''\n    }\n\n    this.softwareID = opts.softwareID || opts.software_id || ''\n    this.softwareVersion = opts.softwareVersion || opts.software_version || ''\n    this.clientName = opts.clientName || opts.client_name || ''\n    this.clientKind = opts.clientKind || opts.client_kind || ''\n    this.clientURI = opts.clientURI || opts.client_uri || ''\n\n    this.logoURI = opts.logoURI || opts.logo_uri || ''\n    this.policyURI = opts.policyURI || opts.policy_uri || ''\n\n    if (!this.registrationAccessToken) {\n      if (this.redirectURI === '') {\n        throw new Error('Missing redirectURI field')\n      }\n      if (this.softwareID === '') {\n        throw new Error('Missing softwareID field')\n      }\n      if (this.clientName === '') {\n        throw new Error('Missing clientName field')\n      }\n    }\n  }\n\n  isRegistered () {\n    return this.clientID !== ''\n  }\n\n  toRegisterJSON () {\n    return {\n      redirect_uris: [this.redirectURI],\n      software_id: this.softwareID,\n      software_version: this.softwareVersion,\n      client_name: this.clientName,\n      client_kind: this.clientKind,\n      client_uri: this.clientURI,\n      logo_uri: this.logoURI,\n      policy_uri: this.policyURI\n    }\n  }\n\n  toAuthHeader () {\n    return 'Bearer ' + this.registrationAccessToken\n  }\n}\n\nexport class AccessToken {\n  constructor (opts) {\n    this.tokenType = opts.tokenType || opts.token_type\n    this.accessToken = opts.accessToken || opts.access_token\n    this.refreshToken = opts.refreshToken || opts.refresh_token\n    this.scope = opts.scope\n  }\n\n  toAuthHeader () {\n    return 'Bearer ' + this.accessToken\n  }\n\n  toBasicAuth () {\n    return `user:${this.accessToken}@`\n  }\n}\n\nexport class AppToken {\n  constructor (opts) {\n    this.token = opts.token || ''\n  }\n\n  toAuthHeader () {\n    return 'Bearer ' + this.token\n  }\n\n  toBasicAuth () {\n    return `user:${this.token}@`\n  }\n}\n\nexport function client (cozy, clientParams) {\n  if (!clientParams) {\n    clientParams = cozy._clientParams\n  }\n  if (clientParams instanceof Client) {\n    return clientParams\n  }\n  return new Client(clientParams)\n}\n\nexport function registerClient (cozy, clientParams) {\n  const cli = client(cozy, clientParams)\n  if (cli.isRegistered()) {\n    return Promise.reject(new Error('Client already registered'))\n  }\n  return cozyFetchJSON(cozy, 'POST', '/auth/register', cli.toRegisterJSON(), {\n    disableAuth: true\n  })\n    .then((data) => new Client(data))\n}\n\nexport function updateClient (cozy, clientParams, resetSecret = false) {\n  const cli = client(cozy, clientParams)\n  if (!cli.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  let data = cli.toRegisterJSON()\n  data.client_id = cli.clientID\n  if (resetSecret) data.client_secret = cli.clientSecret\n\n  return cozyFetchJSON(cozy, 'PUT', `/auth/register/${cli.clientID}`, data, {\n    manualAuthCredentials: {\n      token: cli\n    }\n  }).then((data) => createClient(data, cli))\n}\n\nexport function unregisterClient (cozy, clientParams) {\n  const cli = client(cozy, clientParams)\n  if (!cli.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  return cozyFetchJSON(cozy, 'DELETE', `/auth/register/${cli.clientID}`, null, {\n    manualAuthCredentials: {\n      token: cli\n    }\n  })\n}\n\n// getClient will retrive the registered client informations from the server.\nexport function getClient (cozy, clientParams) {\n  const cli = client(cozy, clientParams)\n  if (!cli.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  if (isOffline()) {\n    return Promise.resolve(cli)\n  }\n  return cozyFetchJSON(cozy, 'GET', `/auth/register/${cli.clientID}`, null,\n    {\n      manualAuthCredentials: {\n        token: cli\n      }\n    })\n    .then((data) => createClient(data, cli))\n    .catch((err) => {\n      // If we fall into an error while fetching the client (because of a\n      // bad connectivity for instance), we do not bail the whole process\n      // since the client should be able to continue with the persisted\n      // client and token.\n      //\n      // If it is an explicit Unauthorized error though, we bail, clear th\n      // cache and retry.\n      if (FetchError.isUnauthorized(err) || FetchError.isNotFound(err)) {\n        throw new Error('Client has been revoked')\n      }\n      throw err\n    })\n}\n\n// createClient returns a new Client instance given on object containing the\n// data of the client, from the API, and an old instance of the client.\nfunction createClient (data, oldClient) {\n  const newClient = new Client(data)\n  // we need to keep track of the registrationAccessToken since it is send\n  // only on registration. The GET /auth/register/:client-id endpoint does\n  // not return this token.\n  const shouldPassRegistration = (\n    !!oldClient &&\n    oldClient.registrationAccessToken !== '' &&\n    newClient.registrationAccessToken === ''\n  )\n  if (shouldPassRegistration) {\n    newClient.registrationAccessToken = oldClient.registrationAccessToken\n  }\n  return newClient\n}\n\n// getAuthCodeURL returns a pair {authURL,state} given a registered client. The\n// state should be stored in order to be checked against on the user validation\n// phase.\nexport function getAuthCodeURL (cozy, client, scopes = []) {\n  if (!(client instanceof Client)) {\n    client = new Client(client)\n  }\n  if (!client.isRegistered()) {\n    throw new Error('Client not registered')\n  }\n  const state = generateRandomState()\n  const query = {\n    'client_id': client.clientID,\n    'redirect_uri': client.redirectURI,\n    'state': state,\n    'response_type': 'code',\n    'scope': scopes.join(' ')\n  }\n  return {\n    url: cozy._url + `/auth/authorize?${encodeQuery(query)}`,\n    state: state\n  }\n}\n\n// getAccessToken perform a request on the access_token entrypoint with the\n// authorization_code grant type in order to generate a new access token for a\n// newly registered client.\n//\n// This method extracts the access code and state from the given URL. By\n// default it uses window.location.href. Also, it checks the given state with\n// the one specified in the URL query parameter to prevent CSRF attacks.\nexport function getAccessToken (cozy, client, state, pageURL = '') {\n  if (!state) {\n    return Promise.reject(new Error('Missing state value'))\n  }\n  const grantQueries = getGrantCodeFromPageURL(pageURL)\n  if (grantQueries === null) {\n    return Promise.reject(new Error('Missing states from current URL'))\n  }\n  if (state !== grantQueries.state) {\n    return Promise.reject(new Error('Given state does not match url query state'))\n  }\n  return retrieveToken(cozy, client, null, {\n    'grant_type': 'authorization_code',\n    'code': grantQueries.code\n  })\n}\n\n// refreshToken perform a request on the access_token entrypoint with the\n// refresh_token grant type in order to refresh the given token.\nexport function refreshToken (cozy, client, token) {\n  return retrieveToken(cozy, client, token, {\n    'grant_type': 'refresh_token',\n    'refresh_token': token.refreshToken\n  })\n}\n\n// oauthFlow performs the stateful registration and access granting of an OAuth\n// client.\nexport function oauthFlow (cozy, storage, clientParams, onRegistered, ignoreCachedCredentials = false) {\n  if (ignoreCachedCredentials) {\n    return storage.clear().then(() => oauthFlow(cozy, storage, clientParams, onRegistered, false))\n  }\n\n  let tryCount = 0\n\n  function clearAndRetry (err) {\n    if (tryCount++ > 0) {\n      throw err\n    }\n    return storage.clear().then(() =>\n      oauthFlow(cozy, storage, clientParams, onRegistered))\n  }\n\n  function registerNewClient () {\n    return storage.clear()\n      .then(() => registerClient(cozy, clientParams))\n      .then((client) => {\n        const {url, state} = getAuthCodeURL(cozy, client, clientParams.scopes)\n        return storage.save(StateKey, {client, url, state})\n      })\n  }\n\n  return Promise.all([\n    storage.load(CredsKey),\n    storage.load(StateKey)\n  ]).then(([credentials, storedState]) => {\n    // If credentials are cached we re-fetch the registered client with the\n    // said token. Fetching the client, if the token is outdated we should try\n    // the token is refreshed.\n    if (credentials) {\n      let oldClient, token\n      try {\n        oldClient = new Client(credentials.client)\n        token = new AccessToken(credentials.token)\n      } catch (err) {\n        // bad cache, we should clear and retry the process\n        return clearAndRetry(err)\n      }\n      return getClient(cozy, oldClient)\n        .then((client) => ({client, token}))\n        .catch((err) => {\n          // If we fall into an error while fetching the client (because of a\n          // bad connectivity for instance), we do not bail the whole process\n          // since the client should be able to continue with the persisted\n          // client and token.\n          //\n          // If it is an explicit Unauthorized error though, we bail, clear th\n          // cache and retry.\n          if (FetchError.isUnauthorized(err) || FetchError.isNotFound(err)) {\n            throw new Error('Client has been revoked')\n          }\n          return { client: oldClient, token }\n        })\n    }\n\n    // Otherwise register a new client if necessary (ie. no client is stored)\n    // and call the onRegistered callback to wait for the user to grant the\n    // access. Finally fetches to access token on success.\n    let statePromise\n    if (!storedState) {\n      statePromise = registerNewClient()\n    } else {\n      statePromise = Promise.resolve(storedState)\n    }\n\n    let client, state, token\n    return statePromise\n      .then((data) => {\n        client = data.client\n        state = data.state\n        return Promise.resolve(onRegistered(client, data.url))\n      })\n      .then((pageURL) => getAccessToken(cozy, client, state, pageURL))\n      .then((t) => { token = t })\n      .then(() => storage.delete(StateKey))\n      .then(() => ({client, token}))\n  })\n  .then(\n    (creds) => storage.save(CredsKey, creds),\n    (err) => {\n      if (FetchError.isUnauthorized(err)) {\n        return clearAndRetry(err)\n      } else {\n        throw err\n      }\n    })\n}\n\n// retrieveToken perform a request on the access_token entrypoint in order to\n// fetch a token.\nfunction retrieveToken (cozy, client, token, query) {\n  if (!(client instanceof Client)) {\n    client = new Client(client)\n  }\n  if (!client.isRegistered()) {\n    return Promise.reject(new Error('Client not registered'))\n  }\n  const body = encodeQuery(Object.assign({}, query, {\n    'client_id': client.clientID,\n    'client_secret': client.clientSecret\n  }))\n  return cozyFetchJSON(cozy, 'POST', '/auth/access_token', body, {\n    disableAuth: (token === null),\n    dontRetry: true,\n    manualAuthCredentials: { client, token },\n    headers: { 'Content-Type': 'application/x-www-form-urlencoded' }\n  })\n    .then((data) => {\n      data.refreshToken = data.refreshToken || query.refresh_token\n      return new AccessToken(data)\n    })\n}\n\n// getGrantCodeFromPageURL extract the state and access_code query parameters\n// from the given url\nfunction getGrantCodeFromPageURL (pageURL = '') {\n  if (pageURL === '' && typeof window !== 'undefined') {\n    pageURL = window.location.href\n  }\n  const queries = decodeQuery(pageURL)\n  if (!queries.hasOwnProperty('state')) {\n    return null\n  }\n  return {\n    state: queries['state'],\n    code: queries['access_code']\n  }\n}\n\n// generateRandomState will try to generate a 128bits random value from a secure\n// pseudo random generator. It will fallback on Math.random if it cannot find\n// such generator.\nfunction generateRandomState () {\n  let buffer\n  if (typeof window !== 'undefined' &&\n      typeof window.crypto !== 'undefined' &&\n      typeof window.crypto.getRandomValues === 'function') {\n    buffer = new Uint8Array(StateSize)\n    window.crypto.getRandomValues(buffer)\n  } else {\n    try {\n      buffer = require('crypto').randomBytes(StateSize)\n    } catch (e) {}\n  }\n  if (!buffer) {\n    buffer = new Array(StateSize)\n    for (let i = 0; i < buffer.length; i++) {\n      buffer[i] = Math.floor((Math.random() * 255))\n    }\n  }\n  return btoa(String.fromCharCode.apply(null, buffer))\n    .replace(/=+$/, '')\n    .replace(/\\//g, '_')\n    .replace(/\\+/g, '-')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/auth_v3.js","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = require('./_to-object')\n  , toIndex  = require('./_to-index')\n  , toLength = require('./_to-length');\nmodule.exports = function fill(value /*, start = 0, end = @length */){\n  var O      = toObject(this)\n    , length = toLength(O.length)\n    , aLen   = arguments.length\n    , index  = toIndex(aLen > 1 ? arguments[1] : undefined, length)\n    , end    = aLen > 2 ? arguments[2] : undefined\n    , endPos = end === undefined ? length : toIndex(end, length);\n  while(endPos > index)O[index++] = value;\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_array-fill.js\n// module id = 55\n// module chunks = 0","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length')\n  , toIndex   = require('./_to-index');\nmodule.exports = function(IS_INCLUDES){\n  return function($this, el, fromIndex){\n    var O      = toIObject($this)\n      , length = toLength(O.length)\n      , index  = toIndex(fromIndex, length)\n      , value;\n    // Array#includes uses SameValueZero equality algorithm\n    if(IS_INCLUDES && el != el)while(length > index){\n      value = O[index++];\n      if(value != value)return true;\n    // Array#toIndex ignores holes, Array#includes - not\n    } else for(;length > index; index++)if(IS_INCLUDES || index in O){\n      if(O[index] === el)return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_array-includes.js\n// module id = 56\n// module chunks = 0","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof')\n  , TAG = require('./_wks')('toStringTag')\n  // ES3 wrong here\n  , ARG = cof(function(){ return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function(it, key){\n  try {\n    return it[key];\n  } catch(e){ /* empty */ }\n};\n\nmodule.exports = function(it){\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_classof.js\n// module id = 57\n// module chunks = 0","'use strict';\nvar $defineProperty = require('./_object-dp')\n  , createDesc      = require('./_property-desc');\n\nmodule.exports = function(object, index, value){\n  if(index in object)$defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_create-property.js\n// module id = 58\n// module chunks = 0","var isObject = require('./_is-object')\n  , document = require('./_global').document\n  // in old IE typeof document.createElement is 'object'\n  , is = isObject(document) && isObject(document.createElement);\nmodule.exports = function(it){\n  return is ? document.createElement(it) : {};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_dom-create.js\n// module id = 59\n// module chunks = 0","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_enum-bug-keys.js\n// module id = 60\n// module chunks = 0","var MATCH = require('./_wks')('match');\nmodule.exports = function(KEY){\n  var re = /./;\n  try {\n    '/./'[KEY](re);\n  } catch(e){\n    try {\n      re[MATCH] = false;\n      return !'/./'[KEY](re);\n    } catch(f){ /* empty */ }\n  } return true;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_fails-is-regexp.js\n// module id = 61\n// module chunks = 0","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_iobject.js\n// module id = 62\n// module chunks = 0","// check on default Array iterator\nvar Iterators  = require('./_iterators')\n  , ITERATOR   = require('./_wks')('iterator')\n  , ArrayProto = Array.prototype;\n\nmodule.exports = function(it){\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_is-array-iter.js\n// module id = 63\n// module chunks = 0","// 20.2.2.14 Math.expm1(x)\nvar $expm1 = Math.expm1;\nmodule.exports = (!$expm1\n  // Old FF bug\n  || $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168\n  // Tor Browser bug\n  || $expm1(-2e-17) != -2e-17\n) ? function expm1(x){\n  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;\n} : $expm1;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_math-expm1.js\n// module id = 64\n// module chunks = 0","// 20.2.2.28 Math.sign(x)\nmodule.exports = Math.sign || function sign(x){\n  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_math-sign.js\n// module id = 65\n// module chunks = 0","// Works with __proto__ only. Old v8 can't work with null proto objects.\n/* eslint-disable no-proto */\nvar isObject = require('./_is-object')\n  , anObject = require('./_an-object');\nvar check = function(O, proto){\n  anObject(O);\n  if(!isObject(proto) && proto !== null)throw TypeError(proto + \": can't set as prototype!\");\n};\nmodule.exports = {\n  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line\n    function(test, buggy, set){\n      try {\n        set = require('./_ctx')(Function.call, require('./_object-gopd').f(Object.prototype, '__proto__').set, 2);\n        set(test, []);\n        buggy = !(test instanceof Array);\n      } catch(e){ buggy = true; }\n      return function setPrototypeOf(O, proto){\n        check(O, proto);\n        if(buggy)O.__proto__ = proto;\n        else set(O, proto);\n        return O;\n      };\n    }({}, false) : undefined),\n  check: check\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_set-proto.js\n// module id = 66\n// module chunks = 0","'use strict';\nvar global      = require('./_global')\n  , dP          = require('./_object-dp')\n  , DESCRIPTORS = require('./_descriptors')\n  , SPECIES     = require('./_wks')('species');\n\nmodule.exports = function(KEY){\n  var C = global[KEY];\n  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {\n    configurable: true,\n    get: function(){ return this; }\n  });\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_set-species.js\n// module id = 67\n// module chunks = 0","var shared = require('./_shared')('keys')\n  , uid    = require('./_uid');\nmodule.exports = function(key){\n  return shared[key] || (shared[key] = uid(key));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_shared-key.js\n// module id = 68\n// module chunks = 0","var global = require('./_global')\n  , SHARED = '__core-js_shared__'\n  , store  = global[SHARED] || (global[SHARED] = {});\nmodule.exports = function(key){\n  return store[key] || (store[key] = {});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_shared.js\n// module id = 69\n// module chunks = 0","// helper for String#{startsWith, endsWith, includes}\nvar isRegExp = require('./_is-regexp')\n  , defined  = require('./_defined');\n\nmodule.exports = function(that, searchString, NAME){\n  if(isRegExp(searchString))throw TypeError('String#' + NAME + \" doesn't accept regex!\");\n  return String(defined(that));\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_string-context.js\n// module id = 70\n// module chunks = 0","var ctx                = require('./_ctx')\n  , invoke             = require('./_invoke')\n  , html               = require('./_html')\n  , cel                = require('./_dom-create')\n  , global             = require('./_global')\n  , process            = global.process\n  , setTask            = global.setImmediate\n  , clearTask          = global.clearImmediate\n  , MessageChannel     = global.MessageChannel\n  , counter            = 0\n  , queue              = {}\n  , ONREADYSTATECHANGE = 'onreadystatechange'\n  , defer, channel, port;\nvar run = function(){\n  var id = +this;\n  if(queue.hasOwnProperty(id)){\n    var fn = queue[id];\n    delete queue[id];\n    fn();\n  }\n};\nvar listener = function(event){\n  run.call(event.data);\n};\n// Node.js 0.9+ & IE10+ has setImmediate, otherwise:\nif(!setTask || !clearTask){\n  setTask = function setImmediate(fn){\n    var args = [], i = 1;\n    while(arguments.length > i)args.push(arguments[i++]);\n    queue[++counter] = function(){\n      invoke(typeof fn == 'function' ? fn : Function(fn), args);\n    };\n    defer(counter);\n    return counter;\n  };\n  clearTask = function clearImmediate(id){\n    delete queue[id];\n  };\n  // Node.js 0.8-\n  if(require('./_cof')(process) == 'process'){\n    defer = function(id){\n      process.nextTick(ctx(run, id, 1));\n    };\n  // Browsers with MessageChannel, includes WebWorkers\n  } else if(MessageChannel){\n    channel = new MessageChannel;\n    port    = channel.port2;\n    channel.port1.onmessage = listener;\n    defer = ctx(port.postMessage, port, 1);\n  // Browsers with postMessage, skip WebWorkers\n  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'\n  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){\n    defer = function(id){\n      global.postMessage(id + '', '*');\n    };\n    global.addEventListener('message', listener, false);\n  // IE8-\n  } else if(ONREADYSTATECHANGE in cel('script')){\n    defer = function(id){\n      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){\n        html.removeChild(this);\n        run.call(id);\n      };\n    };\n  // Rest old browsers\n  } else {\n    defer = function(id){\n      setTimeout(ctx(run, id, 1), 0);\n    };\n  }\n}\nmodule.exports = {\n  set:   setTask,\n  clear: clearTask\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_task.js\n// module id = 71\n// module chunks = 0","var global = require('./_global')\n  , hide   = require('./_hide')\n  , uid    = require('./_uid')\n  , TYPED  = uid('typed_array')\n  , VIEW   = uid('view')\n  , ABV    = !!(global.ArrayBuffer && global.DataView)\n  , CONSTR = ABV\n  , i = 0, l = 9, Typed;\n\nvar TypedArrayConstructors = (\n  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'\n).split(',');\n\nwhile(i < l){\n  if(Typed = global[TypedArrayConstructors[i++]]){\n    hide(Typed.prototype, TYPED, true);\n    hide(Typed.prototype, VIEW, true);\n  } else CONSTR = false;\n}\n\nmodule.exports = {\n  ABV:    ABV,\n  CONSTR: CONSTR,\n  TYPED:  TYPED,\n  VIEW:   VIEW\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_typed.js\n// module id = 72\n// module chunks = 0","var classof   = require('./_classof')\n  , ITERATOR  = require('./_wks')('iterator')\n  , Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function(it){\n  if(it != undefined)return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/core.get-iterator-method.js\n// module id = 73\n// module chunks = 0","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables')\n  , step             = require('./_iter-step')\n  , Iterators        = require('./_iterators')\n  , toIObject        = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function(iterated, kind){\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function(){\n  var O     = this._t\n    , kind  = this._k\n    , index = this._i++;\n  if(!O || index >= O.length){\n    this._t = undefined;\n    return step(1);\n  }\n  if(kind == 'keys'  )return step(0, index);\n  if(kind == 'values')return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.array.iterator.js\n// module id = 74\n// module chunks = 0","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/inherits/inherits_browser.js\n// module id = 75\n// module chunks = 0","'use strict';\n/* istanbul ignore if */\nexports.Promise = require('pouchdb-promise');\n\nexports.inherits = require('inherits');\nexports.extend = require('pouchdb-extend');\nvar argsarray = require('argsarray');\n\n/* istanbul ignore next */\nexports.promisedCallback = function (promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      process.nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      process.nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n};\n\n/* istanbul ignore next */\nexports.callbackify = function (fun) {\n  return argsarray(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      exports.promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n};\n\n// Promise finally util similar to Q.finally\n/* istanbul ignore next */\nexports.fin = function (promise, cb) {\n  return promise.then(function (res) {\n    var promise2 = cb();\n    if (typeof promise2.then === 'function') {\n      return promise2.then(function () {\n        return res;\n      });\n    }\n    return res;\n  }, function (reason) {\n    var promise2 = cb();\n    if (typeof promise2.then === 'function') {\n      return promise2.then(function () {\n        throw reason;\n      });\n    }\n    throw reason;\n  });\n};\n\nexports.sequentialize = function (queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n};\n\nexports.flatten = function (arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n};\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nexports.uniq = function (arr) {\n  var map = {};\n\n  for (var i = 0, len = arr.length; i < len; i++) {\n    map['$' + arr[i]] = true;\n  }\n\n  var keys = Object.keys(map);\n  var output = new Array(keys.length);\n\n  for (i = 0, len = keys.length; i < len; i++) {\n    output[i] = keys[i].substring(1);\n  }\n  return output;\n};\n\nvar crypto = require('crypto');\nvar Md5 = require('spark-md5');\n\nexports.MD5 = function (string) {\n  /* istanbul ignore else */\n  if (!process.browser) {\n    return crypto.createHash('md5').update(string).digest('hex');\n  } else {\n    return Md5.hash(string);\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/abstract-mapreduce/utils.js\n// module id = 76\n// module chunks = 0","'use strict';\n\nvar localUtils = require('./utils');\nvar abstractMapReduce = require('../../abstract-mapreduce');\nvar parseField = localUtils.parseField;\n\n//\n// One thing about these mappers:\n//\n// Per the advice of John-David Dalton (http://youtu.be/NthmeLEhDDM),\n// what you want to do in this case is optimize for the smallest possible\n// function, since that's the thing that gets run over and over again.\n//\n// This code would be a lot simpler if all the if/elses were inside\n// the function, but it would also be a lot less performant.\n//\n\n\nfunction createDeepMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, iLen = fields.length; i < iLen; i++) {\n      var parsedField = parseField(fields[i]);\n      var value = doc;\n      for (var j = 0, jLen = parsedField.length; j < jLen; j++) {\n        var key = parsedField[j];\n        value = value[key];\n        if (!value) {\n          break;\n        }\n      }\n      toEmit.push(value);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction createDeepSingleMapper(field, emit) {\n  var parsedField = parseField(field);\n  return function (doc) {\n    var value = doc;\n    for (var i = 0, len = parsedField.length; i < len; i++) {\n      var key = parsedField[i];\n      value = value[key];\n      if (!value) {\n        return; // do nothing\n      }\n    }\n    emit(value);\n  };\n}\n\nfunction createShallowSingleMapper(field, emit) {\n  return function (doc) {\n    emit(doc[field]);\n  };\n}\n\nfunction createShallowMultiMapper(fields, emit) {\n  return function (doc) {\n    var toEmit = [];\n    for (var i = 0, len = fields.length; i < len; i++) {\n      toEmit.push(doc[fields[i]]);\n    }\n    emit(toEmit);\n  };\n}\n\nfunction checkShallow(fields) {\n  for (var i = 0, len = fields.length; i < len; i++) {\n    var field = fields[i];\n    if (field.indexOf('.') !== -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction createMapper(fields, emit) {\n  var isShallow = checkShallow(fields);\n  var isSingle = fields.length === 1;\n\n  // notice we try to optimize for the most common case,\n  // i.e. single shallow indexes\n  if (isShallow) {\n    if (isSingle) {\n      return createShallowSingleMapper(fields[0], emit);\n    } else { // multi\n      return createShallowMultiMapper(fields, emit);\n    }\n  } else { // deep\n    if (isSingle) {\n      return createDeepSingleMapper(fields[0], emit);\n    } else { // multi\n      return createDeepMultiMapper(fields, emit);\n    }\n  }\n}\n\nfunction mapper(mapFunDef, emit) {\n  // mapFunDef is a list of fields\n\n  var fields = Object.keys(mapFunDef.fields);\n\n  return createMapper(fields, emit);\n}\n\n/* istanbul ignore next */\nfunction reducer(/*reduceFunDef*/) {\n  throw new Error('reduce not supported');\n}\n\nfunction ddocValidator(ddoc, viewName) {\n  var view = ddoc.views[viewName];\n  // This doesn't actually need to be here apparently, but\n  // I feel safer keeping it.\n  /* istanbul ignore if */\n  if (!view.map || !view.map.fields) {\n    throw new Error('ddoc ' + ddoc._id +' with view ' + viewName +\n      ' doesn\\'t have map.fields defined. ' +\n      'maybe it wasn\\'t created by this plugin?');\n  }\n}\n\nvar abstractMapper = abstractMapReduce({\n  name: 'indexes',\n  mapper: mapper,\n  reducer: reducer,\n  ddocValidator: ddocValidator\n});\n\nmodule.exports = abstractMapper;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/adapters/local/abstract-mapper.js\n// module id = 77\n// module chunks = 0","'use strict';\n\nmodule.exports = argsArray;\n\nfunction argsArray(fun) {\n  return function () {\n    var len = arguments.length;\n    if (len) {\n      var args = [];\n      var i = -1;\n      while (++i < len) {\n        args[i] = arguments[i];\n      }\n      return fun.call(this, args);\n    } else {\n      return fun.call(this, []);\n    }\n  };\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/argsarray/index.js\n// module id = 78\n// module chunks = 0","function indexKey (doc) {\n  return doc.type + '/' + doc.id\n}\n\nfunction findByRef (resources, ref) {\n  return resources[indexKey(ref)]\n}\n\nfunction handleResource (rawResource, resources, links) {\n  let resource = {\n    _id: rawResource.id,\n    _type: rawResource.type,\n    _rev: (rawResource.meta && rawResource.meta.rev),\n    links: Object.assign({}, rawResource.links, links),\n    attributes: rawResource.attributes,\n    relations: (name) => {\n      let rels = rawResource.relationships[name]\n      if (rels === undefined || rels.data === undefined) return undefined\n      if (rels.data === null) return null\n      if (!Array.isArray(rels.data)) return findByRef(resources, rels.data)\n      return rels.data.map(ref => findByRef(resources, ref))\n    }\n  }\n  if (rawResource.relationships) {\n    resource.relationships = rawResource.relationships\n  }\n\n  resources[indexKey(rawResource)] = resource\n\n  return resource\n}\n\nfunction handleTopLevel (doc, resources = {}) {\n  // build an index of included resource by Type & ID\n  const included = doc.included\n\n  if (Array.isArray(included)) {\n    included.forEach((r) => handleResource(r, resources, doc.links))\n  }\n\n  if (Array.isArray(doc.data)) {\n    return doc.data.map((r) => handleResource(r, resources, doc.links))\n  } else {\n    return handleResource(doc.data, resources, doc.links)\n  }\n}\n\nexport default handleTopLevel\n\n\n\n// WEBPACK FOOTER //\n// ./src/jsonapi.js","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n'use strict';\nvar toObject = require('./_to-object')\n  , toIndex  = require('./_to-index')\n  , toLength = require('./_to-length');\n\nmodule.exports = [].copyWithin || function copyWithin(target/*= 0*/, start/*= 0, end = @length*/){\n  var O     = toObject(this)\n    , len   = toLength(O.length)\n    , to    = toIndex(target, len)\n    , from  = toIndex(start, len)\n    , end   = arguments.length > 2 ? arguments[2] : undefined\n    , count = Math.min((end === undefined ? len : toIndex(end, len)) - from, len - to)\n    , inc   = 1;\n  if(from < to && to < from + count){\n    inc  = -1;\n    from += count - 1;\n    to   += count - 1;\n  }\n  while(count-- > 0){\n    if(from in O)O[to] = O[from];\n    else delete O[to];\n    to   += inc;\n    from += inc;\n  } return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_array-copy-within.js\n// module id = 80\n// module chunks = 0","'use strict';\nvar dP          = require('./_object-dp').f\n  , create      = require('./_object-create')\n  , redefineAll = require('./_redefine-all')\n  , ctx         = require('./_ctx')\n  , anInstance  = require('./_an-instance')\n  , defined     = require('./_defined')\n  , forOf       = require('./_for-of')\n  , $iterDefine = require('./_iter-define')\n  , step        = require('./_iter-step')\n  , setSpecies  = require('./_set-species')\n  , DESCRIPTORS = require('./_descriptors')\n  , fastKey     = require('./_meta').fastKey\n  , SIZE        = DESCRIPTORS ? '_s' : 'size';\n\nvar getEntry = function(that, key){\n  // fast case\n  var index = fastKey(key), entry;\n  if(index !== 'F')return that._i[index];\n  // frozen object case\n  for(entry = that._f; entry; entry = entry.n){\n    if(entry.k == key)return entry;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      anInstance(that, C, NAME, '_i');\n      that._i = create(null); // index\n      that._f = undefined;    // first entry\n      that._l = undefined;    // last entry\n      that[SIZE] = 0;         // size\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.1.3.1 Map.prototype.clear()\n      // 23.2.3.2 Set.prototype.clear()\n      clear: function clear(){\n        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){\n          entry.r = true;\n          if(entry.p)entry.p = entry.p.n = undefined;\n          delete data[entry.i];\n        }\n        that._f = that._l = undefined;\n        that[SIZE] = 0;\n      },\n      // 23.1.3.3 Map.prototype.delete(key)\n      // 23.2.3.4 Set.prototype.delete(value)\n      'delete': function(key){\n        var that  = this\n          , entry = getEntry(that, key);\n        if(entry){\n          var next = entry.n\n            , prev = entry.p;\n          delete that._i[entry.i];\n          entry.r = true;\n          if(prev)prev.n = next;\n          if(next)next.p = prev;\n          if(that._f == entry)that._f = next;\n          if(that._l == entry)that._l = prev;\n          that[SIZE]--;\n        } return !!entry;\n      },\n      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)\n      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)\n      forEach: function forEach(callbackfn /*, that = undefined */){\n        anInstance(this, C, 'forEach');\n        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)\n          , entry;\n        while(entry = entry ? entry.n : this._f){\n          f(entry.v, entry.k, this);\n          // revert to the last existing entry\n          while(entry && entry.r)entry = entry.p;\n        }\n      },\n      // 23.1.3.7 Map.prototype.has(key)\n      // 23.2.3.7 Set.prototype.has(value)\n      has: function has(key){\n        return !!getEntry(this, key);\n      }\n    });\n    if(DESCRIPTORS)dP(C.prototype, 'size', {\n      get: function(){\n        return defined(this[SIZE]);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    var entry = getEntry(that, key)\n      , prev, index;\n    // change existing entry\n    if(entry){\n      entry.v = value;\n    // create new entry\n    } else {\n      that._l = entry = {\n        i: index = fastKey(key, true), // <- index\n        k: key,                        // <- key\n        v: value,                      // <- value\n        p: prev = that._l,             // <- previous entry\n        n: undefined,                  // <- next entry\n        r: false                       // <- removed\n      };\n      if(!that._f)that._f = entry;\n      if(prev)prev.n = entry;\n      that[SIZE]++;\n      // add to index\n      if(index !== 'F')that._i[index] = entry;\n    } return that;\n  },\n  getEntry: getEntry,\n  setStrong: function(C, NAME, IS_MAP){\n    // add .keys, .values, .entries, [@@iterator]\n    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11\n    $iterDefine(C, NAME, function(iterated, kind){\n      this._t = iterated;  // target\n      this._k = kind;      // kind\n      this._l = undefined; // previous\n    }, function(){\n      var that  = this\n        , kind  = that._k\n        , entry = that._l;\n      // revert to the last existing entry\n      while(entry && entry.r)entry = entry.p;\n      // get next entry\n      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){\n        // or finish the iteration\n        that._t = undefined;\n        return step(1);\n      }\n      // return step by kind\n      if(kind == 'keys'  )return step(0, entry.k);\n      if(kind == 'values')return step(0, entry.v);\n      return step(0, [entry.k, entry.v]);\n    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);\n\n    // add [@@species], 23.1.2.2, 23.2.2.2\n    setSpecies(NAME);\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_collection-strong.js\n// module id = 81\n// module chunks = 0","'use strict';\nvar redefineAll       = require('./_redefine-all')\n  , getWeak           = require('./_meta').getWeak\n  , anObject          = require('./_an-object')\n  , isObject          = require('./_is-object')\n  , anInstance        = require('./_an-instance')\n  , forOf             = require('./_for-of')\n  , createArrayMethod = require('./_array-methods')\n  , $has              = require('./_has')\n  , arrayFind         = createArrayMethod(5)\n  , arrayFindIndex    = createArrayMethod(6)\n  , id                = 0;\n\n// fallback for uncaught frozen keys\nvar uncaughtFrozenStore = function(that){\n  return that._l || (that._l = new UncaughtFrozenStore);\n};\nvar UncaughtFrozenStore = function(){\n  this.a = [];\n};\nvar findUncaughtFrozen = function(store, key){\n  return arrayFind(store.a, function(it){\n    return it[0] === key;\n  });\n};\nUncaughtFrozenStore.prototype = {\n  get: function(key){\n    var entry = findUncaughtFrozen(this, key);\n    if(entry)return entry[1];\n  },\n  has: function(key){\n    return !!findUncaughtFrozen(this, key);\n  },\n  set: function(key, value){\n    var entry = findUncaughtFrozen(this, key);\n    if(entry)entry[1] = value;\n    else this.a.push([key, value]);\n  },\n  'delete': function(key){\n    var index = arrayFindIndex(this.a, function(it){\n      return it[0] === key;\n    });\n    if(~index)this.a.splice(index, 1);\n    return !!~index;\n  }\n};\n\nmodule.exports = {\n  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){\n    var C = wrapper(function(that, iterable){\n      anInstance(that, C, NAME, '_i');\n      that._i = id++;      // collection id\n      that._l = undefined; // leak store for uncaught frozen objects\n      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);\n    });\n    redefineAll(C.prototype, {\n      // 23.3.3.2 WeakMap.prototype.delete(key)\n      // 23.4.3.3 WeakSet.prototype.delete(value)\n      'delete': function(key){\n        if(!isObject(key))return false;\n        var data = getWeak(key);\n        if(data === true)return uncaughtFrozenStore(this)['delete'](key);\n        return data && $has(data, this._i) && delete data[this._i];\n      },\n      // 23.3.3.4 WeakMap.prototype.has(key)\n      // 23.4.3.4 WeakSet.prototype.has(value)\n      has: function has(key){\n        if(!isObject(key))return false;\n        var data = getWeak(key);\n        if(data === true)return uncaughtFrozenStore(this).has(key);\n        return data && $has(data, this._i);\n      }\n    });\n    return C;\n  },\n  def: function(that, key, value){\n    var data = getWeak(anObject(key), true);\n    if(data === true)uncaughtFrozenStore(that).set(key, value);\n    else data[that._i] = value;\n    return that;\n  },\n  ufstore: uncaughtFrozenStore\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_collection-weak.js\n// module id = 82\n// module chunks = 0","module.exports = require('./_global').document && document.documentElement;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_html.js\n// module id = 83\n// module chunks = 0","module.exports = !require('./_descriptors') && !require('./_fails')(function(){\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', {get: function(){ return 7; }}).a != 7;\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_ie8-dom-define.js\n// module id = 84\n// module chunks = 0","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg){\n  return cof(arg) == 'Array';\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_is-array.js\n// module id = 85\n// module chunks = 0","// 20.1.2.3 Number.isInteger(number)\nvar isObject = require('./_is-object')\n  , floor    = Math.floor;\nmodule.exports = function isInteger(it){\n  return !isObject(it) && isFinite(it) && floor(it) === it;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_is-integer.js\n// module id = 86\n// module chunks = 0","// 7.2.8 IsRegExp(argument)\nvar isObject = require('./_is-object')\n  , cof      = require('./_cof')\n  , MATCH    = require('./_wks')('match');\nmodule.exports = function(it){\n  var isRegExp;\n  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_is-regexp.js\n// module id = 87\n// module chunks = 0","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function(iterator, fn, value, entries){\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch(e){\n    var ret = iterator['return'];\n    if(ret !== undefined)anObject(ret.call(iterator));\n    throw e;\n  }\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_iter-call.js\n// module id = 88\n// module chunks = 0","'use strict';\nvar LIBRARY        = require('./_library')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , hide           = require('./_hide')\n  , has            = require('./_has')\n  , Iterators      = require('./_iterators')\n  , $iterCreate    = require('./_iter-create')\n  , setToStringTag = require('./_set-to-string-tag')\n  , getPrototypeOf = require('./_object-gpo')\n  , ITERATOR       = require('./_wks')('iterator')\n  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`\n  , FF_ITERATOR    = '@@iterator'\n  , KEYS           = 'keys'\n  , VALUES         = 'values';\n\nvar returnThis = function(){ return this; };\n\nmodule.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function(kind){\n    if(!BUGGY && kind in proto)return proto[kind];\n    switch(kind){\n      case KEYS: return function keys(){ return new Constructor(this, kind); };\n      case VALUES: return function values(){ return new Constructor(this, kind); };\n    } return function entries(){ return new Constructor(this, kind); };\n  };\n  var TAG        = NAME + ' Iterator'\n    , DEF_VALUES = DEFAULT == VALUES\n    , VALUES_BUG = false\n    , proto      = Base.prototype\n    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]\n    , $default   = $native || getMethod(DEFAULT)\n    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined\n    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native\n    , methods, key, IteratorPrototype;\n  // Fix native\n  if($anyNative){\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));\n    if(IteratorPrototype !== Object.prototype){\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if(DEF_VALUES && $native && $native.name !== VALUES){\n    VALUES_BUG = true;\n    $default = function values(){ return $native.call(this); };\n  }\n  // Define iterator\n  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG]  = returnThis;\n  if(DEFAULT){\n    methods = {\n      values:  DEF_VALUES ? $default : getMethod(VALUES),\n      keys:    IS_SET     ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if(FORCED)for(key in methods){\n      if(!(key in proto))redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_iter-define.js\n// module id = 89\n// module chunks = 0","module.exports = function(done, value){\n  return {value: value, done: !!done};\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_iter-step.js\n// module id = 90\n// module chunks = 0","// 20.2.2.20 Math.log1p(x)\nmodule.exports = Math.log1p || function log1p(x){\n  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_math-log1p.js\n// module id = 91\n// module chunks = 0","'use strict';\n// 19.1.2.1 Object.assign(target, source, ...)\nvar getKeys  = require('./_object-keys')\n  , gOPS     = require('./_object-gops')\n  , pIE      = require('./_object-pie')\n  , toObject = require('./_to-object')\n  , IObject  = require('./_iobject')\n  , $assign  = Object.assign;\n\n// should work with symbols and should have deterministic property order (V8 bug)\nmodule.exports = !$assign || require('./_fails')(function(){\n  var A = {}\n    , B = {}\n    , S = Symbol()\n    , K = 'abcdefghijklmnopqrst';\n  A[S] = 7;\n  K.split('').forEach(function(k){ B[k] = k; });\n  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;\n}) ? function assign(target, source){ // eslint-disable-line no-unused-vars\n  var T     = toObject(target)\n    , aLen  = arguments.length\n    , index = 1\n    , getSymbols = gOPS.f\n    , isEnum     = pIE.f;\n  while(aLen > index){\n    var S      = IObject(arguments[index++])\n      , keys   = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S)\n      , length = keys.length\n      , j      = 0\n      , key;\n    while(length > j)if(isEnum.call(S, key = keys[j++]))T[key] = S[key];\n  } return T;\n} : $assign;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-assign.js\n// module id = 92\n// module chunks = 0","var has          = require('./_has')\n  , toIObject    = require('./_to-iobject')\n  , arrayIndexOf = require('./_array-includes')(false)\n  , IE_PROTO     = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function(object, names){\n  var O      = toIObject(object)\n    , i      = 0\n    , result = []\n    , key;\n  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while(names.length > i)if(has(O, key = names[i++])){\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-keys-internal.js\n// module id = 93\n// module chunks = 0","var getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject')\n  , isEnum    = require('./_object-pie').f;\nmodule.exports = function(isEntries){\n  return function(it){\n    var O      = toIObject(it)\n      , keys   = getKeys(O)\n      , length = keys.length\n      , i      = 0\n      , result = []\n      , key;\n    while(length > i)if(isEnum.call(O, key = keys[i++])){\n      result.push(isEntries ? [key, O[key]] : O[key]);\n    } return result;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-to-array.js\n// module id = 94\n// module chunks = 0","// all object keys, includes non-enumerable and symbols\nvar gOPN     = require('./_object-gopn')\n  , gOPS     = require('./_object-gops')\n  , anObject = require('./_an-object')\n  , Reflect  = require('./_global').Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it){\n  var keys       = gOPN.f(anObject(it))\n    , getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_own-keys.js\n// module id = 95\n// module chunks = 0","// 7.2.9 SameValue(x, y)\nmodule.exports = Object.is || function is(x, y){\n  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_same-value.js\n// module id = 96\n// module chunks = 0","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject  = require('./_an-object')\n  , aFunction = require('./_a-function')\n  , SPECIES   = require('./_wks')('species');\nmodule.exports = function(O, D){\n  var C = anObject(O).constructor, S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_species-constructor.js\n// module id = 97\n// module chunks = 0","// https://github.com/tc39/proposal-string-pad-start-end\nvar toLength = require('./_to-length')\n  , repeat   = require('./_string-repeat')\n  , defined  = require('./_defined');\n\nmodule.exports = function(that, maxLength, fillString, left){\n  var S            = String(defined(that))\n    , stringLength = S.length\n    , fillStr      = fillString === undefined ? ' ' : String(fillString)\n    , intMaxLength = toLength(maxLength);\n  if(intMaxLength <= stringLength || fillStr == '')return S;\n  var fillLen = intMaxLength - stringLength\n    , stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));\n  if(stringFiller.length > fillLen)stringFiller = stringFiller.slice(0, fillLen);\n  return left ? stringFiller + S : S + stringFiller;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_string-pad.js\n// module id = 98\n// module chunks = 0","'use strict';\nvar toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n\nmodule.exports = function repeat(count){\n  var str = String(defined(this))\n    , res = ''\n    , n   = toInteger(count);\n  if(n < 0 || n == Infinity)throw RangeError(\"Count can't be negative\");\n  for(;n > 0; (n >>>= 1) && (str += str))if(n & 1)res += str;\n  return res;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_string-repeat.js\n// module id = 99\n// module chunks = 0","'use strict';\nvar global         = require('./_global')\n  , DESCRIPTORS    = require('./_descriptors')\n  , LIBRARY        = require('./_library')\n  , $typed         = require('./_typed')\n  , hide           = require('./_hide')\n  , redefineAll    = require('./_redefine-all')\n  , fails          = require('./_fails')\n  , anInstance     = require('./_an-instance')\n  , toInteger      = require('./_to-integer')\n  , toLength       = require('./_to-length')\n  , gOPN           = require('./_object-gopn').f\n  , dP             = require('./_object-dp').f\n  , arrayFill      = require('./_array-fill')\n  , setToStringTag = require('./_set-to-string-tag')\n  , ARRAY_BUFFER   = 'ArrayBuffer'\n  , DATA_VIEW      = 'DataView'\n  , PROTOTYPE      = 'prototype'\n  , WRONG_LENGTH   = 'Wrong length!'\n  , WRONG_INDEX    = 'Wrong index!'\n  , $ArrayBuffer   = global[ARRAY_BUFFER]\n  , $DataView      = global[DATA_VIEW]\n  , Math           = global.Math\n  , RangeError     = global.RangeError\n  , Infinity       = global.Infinity\n  , BaseBuffer     = $ArrayBuffer\n  , abs            = Math.abs\n  , pow            = Math.pow\n  , floor          = Math.floor\n  , log            = Math.log\n  , LN2            = Math.LN2\n  , BUFFER         = 'buffer'\n  , BYTE_LENGTH    = 'byteLength'\n  , BYTE_OFFSET    = 'byteOffset'\n  , $BUFFER        = DESCRIPTORS ? '_b' : BUFFER\n  , $LENGTH        = DESCRIPTORS ? '_l' : BYTE_LENGTH\n  , $OFFSET        = DESCRIPTORS ? '_o' : BYTE_OFFSET;\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nvar packIEEE754 = function(value, mLen, nBytes){\n  var buffer = Array(nBytes)\n    , eLen   = nBytes * 8 - mLen - 1\n    , eMax   = (1 << eLen) - 1\n    , eBias  = eMax >> 1\n    , rt     = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0\n    , i      = 0\n    , s      = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0\n    , e, m, c;\n  value = abs(value)\n  if(value != value || value === Infinity){\n    m = value != value ? 1 : 0;\n    e = eMax;\n  } else {\n    e = floor(log(value) / LN2);\n    if(value * (c = pow(2, -e)) < 1){\n      e--;\n      c *= 2;\n    }\n    if(e + eBias >= 1){\n      value += rt / c;\n    } else {\n      value += rt * pow(2, 1 - eBias);\n    }\n    if(value * c >= 2){\n      e++;\n      c /= 2;\n    }\n    if(e + eBias >= eMax){\n      m = 0;\n      e = eMax;\n    } else if(e + eBias >= 1){\n      m = (value * c - 1) * pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * pow(2, eBias - 1) * pow(2, mLen);\n      e = 0;\n    }\n  }\n  for(; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n  e = e << mLen | m;\n  eLen += mLen;\n  for(; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n  buffer[--i] |= s * 128;\n  return buffer;\n};\nvar unpackIEEE754 = function(buffer, mLen, nBytes){\n  var eLen  = nBytes * 8 - mLen - 1\n    , eMax  = (1 << eLen) - 1\n    , eBias = eMax >> 1\n    , nBits = eLen - 7\n    , i     = nBytes - 1\n    , s     = buffer[i--]\n    , e     = s & 127\n    , m;\n  s >>= 7;\n  for(; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for(; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n  if(e === 0){\n    e = 1 - eBias;\n  } else if(e === eMax){\n    return m ? NaN : s ? -Infinity : Infinity;\n  } else {\n    m = m + pow(2, mLen);\n    e = e - eBias;\n  } return (s ? -1 : 1) * m * pow(2, e - mLen);\n};\n\nvar unpackI32 = function(bytes){\n  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n};\nvar packI8 = function(it){\n  return [it & 0xff];\n};\nvar packI16 = function(it){\n  return [it & 0xff, it >> 8 & 0xff];\n};\nvar packI32 = function(it){\n  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n};\nvar packF64 = function(it){\n  return packIEEE754(it, 52, 8);\n};\nvar packF32 = function(it){\n  return packIEEE754(it, 23, 4);\n};\n\nvar addGetter = function(C, key, internal){\n  dP(C[PROTOTYPE], key, {get: function(){ return this[internal]; }});\n};\n\nvar get = function(view, bytes, index, isLittleEndian){\n  var numIndex = +index\n    , intIndex = toInteger(numIndex);\n  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b\n    , start = intIndex + view[$OFFSET]\n    , pack  = store.slice(start, start + bytes);\n  return isLittleEndian ? pack : pack.reverse();\n};\nvar set = function(view, bytes, index, conversion, value, isLittleEndian){\n  var numIndex = +index\n    , intIndex = toInteger(numIndex);\n  if(numIndex != intIndex || intIndex < 0 || intIndex + bytes > view[$LENGTH])throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b\n    , start = intIndex + view[$OFFSET]\n    , pack  = conversion(+value);\n  for(var i = 0; i < bytes; i++)store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n};\n\nvar validateArrayBufferArguments = function(that, length){\n  anInstance(that, $ArrayBuffer, ARRAY_BUFFER);\n  var numberLength = +length\n    , byteLength   = toLength(numberLength);\n  if(numberLength != byteLength)throw RangeError(WRONG_LENGTH);\n  return byteLength;\n};\n\nif(!$typed.ABV){\n  $ArrayBuffer = function ArrayBuffer(length){\n    var byteLength = validateArrayBufferArguments(this, length);\n    this._b       = arrayFill.call(Array(byteLength), 0);\n    this[$LENGTH] = byteLength;\n  };\n\n  $DataView = function DataView(buffer, byteOffset, byteLength){\n    anInstance(this, $DataView, DATA_VIEW);\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n    var bufferLength = buffer[$LENGTH]\n      , offset       = toInteger(byteOffset);\n    if(offset < 0 || offset > bufferLength)throw RangeError('Wrong offset!');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n    if(offset + byteLength > bufferLength)throw RangeError(WRONG_LENGTH);\n    this[$BUFFER] = buffer;\n    this[$OFFSET] = offset;\n    this[$LENGTH] = byteLength;\n  };\n\n  if(DESCRIPTORS){\n    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n    addGetter($DataView, BUFFER, '_b');\n    addGetter($DataView, BYTE_LENGTH, '_l');\n    addGetter($DataView, BYTE_OFFSET, '_o');\n  }\n\n  redefineAll($DataView[PROTOTYPE], {\n    getInt8: function getInt8(byteOffset){\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset){\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /*, littleEndian */){\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /*, littleEndian */){\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /*, littleEndian */){\n      return unpackI32(get(this, 4, byteOffset, arguments[1]));\n    },\n    getUint32: function getUint32(byteOffset /*, littleEndian */){\n      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /*, littleEndian */){\n      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n    },\n    getFloat64: function getFloat64(byteOffset /*, littleEndian */){\n      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n    },\n    setInt8: function setInt8(byteOffset, value){\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setUint8: function setUint8(byteOffset, value){\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /*, littleEndian */){\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setUint16: function setUint16(byteOffset, value /*, littleEndian */){\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setInt32: function setInt32(byteOffset, value /*, littleEndian */){\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setUint32: function setUint32(byteOffset, value /*, littleEndian */){\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setFloat32: function setFloat32(byteOffset, value /*, littleEndian */){\n      set(this, 4, byteOffset, packF32, value, arguments[2]);\n    },\n    setFloat64: function setFloat64(byteOffset, value /*, littleEndian */){\n      set(this, 8, byteOffset, packF64, value, arguments[2]);\n    }\n  });\n} else {\n  if(!fails(function(){\n    new $ArrayBuffer;     // eslint-disable-line no-new\n  }) || !fails(function(){\n    new $ArrayBuffer(.5); // eslint-disable-line no-new\n  })){\n    $ArrayBuffer = function ArrayBuffer(length){\n      return new BaseBuffer(validateArrayBufferArguments(this, length));\n    };\n    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n    for(var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j; ){\n      if(!((key = keys[j++]) in $ArrayBuffer))hide($ArrayBuffer, key, BaseBuffer[key]);\n    };\n    if(!LIBRARY)ArrayBufferProto.constructor = $ArrayBuffer;\n  }\n  // iOS Safari 7.x bug\n  var view = new $DataView(new $ArrayBuffer(2))\n    , $setInt8 = $DataView[PROTOTYPE].setInt8;\n  view.setInt8(0, 2147483648);\n  view.setInt8(1, 2147483649);\n  if(view.getInt8(0) || !view.getInt8(1))redefineAll($DataView[PROTOTYPE], {\n    setInt8: function setInt8(byteOffset, value){\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value){\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    }\n  }, true);\n}\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\nhide($DataView[PROTOTYPE], $typed.VIEW, true);\nexports[ARRAY_BUFFER] = $ArrayBuffer;\nexports[DATA_VIEW] = $DataView;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_typed-buffer.js\n// module id = 100\n// module chunks = 0","exports.f = require('./_wks');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_wks-ext.js\n// module id = 101\n// module chunks = 0","\"use strict\";\n\n// Extends method\n// (taken from http://code.jquery.com/jquery-1.9.0.js)\n// Populate the class2type map\nvar class2type = {};\n\nvar types = [\n  \"Boolean\", \"Number\", \"String\", \"Function\", \"Array\",\n  \"Date\", \"RegExp\", \"Object\", \"Error\"\n];\nfor (var i = 0; i < types.length; i++) {\n  var typename = types[i];\n  class2type[\"[object \" + typename + \"]\"] = typename.toLowerCase();\n}\n\nvar core_toString = class2type.toString;\nvar core_hasOwn = class2type.hasOwnProperty;\n\nfunction type(obj) {\n  if (obj === null) {\n    return String(obj);\n  }\n  return typeof obj === \"object\" || typeof obj === \"function\" ?\n    class2type[core_toString.call(obj)] || \"object\" :\n    typeof obj;\n}\n\nfunction isWindow(obj) {\n  return obj !== null && obj === obj.window;\n}\n\nfunction isPlainObject(obj) {\n  // Must be an Object.\n  // Because of IE, we also have to check the presence of\n  // the constructor property.\n  // Make sure that DOM nodes and window objects don't pass through, as well\n  if (!obj || type(obj) !== \"object\" || obj.nodeType || isWindow(obj)) {\n    return false;\n  }\n\n  try {\n    // Not own constructor property must be Object\n    if (obj.constructor &&\n      !core_hasOwn.call(obj, \"constructor\") &&\n      !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\")) {\n      return false;\n    }\n  } catch ( e ) {\n    // IE8,9 Will throw exceptions on certain host objects #9897\n    return false;\n  }\n\n  // Own properties are enumerated firstly, so to speed up,\n  // if last one is own, then all properties are own.\n  var key;\n  for (key in obj) {}\n\n  return key === undefined || core_hasOwn.call(obj, key);\n}\n\n\nfunction isFunction(obj) {\n  return type(obj) === \"function\";\n}\n\nvar isArray = Array.isArray || function (obj) {\n  return type(obj) === \"array\";\n};\n\nfunction extend() {\n  // originally extend() was recursive, but this ended up giving us\n  // \"call stack exceeded\", so it's been unrolled to use a literal stack\n  // (see https://github.com/pouchdb/pouchdb/issues/2543)\n  var stack = [];\n  var i = -1;\n  var len = arguments.length;\n  var args = new Array(len);\n  while (++i < len) {\n    args[i] = arguments[i];\n  }\n  var container = {};\n  stack.push({args: args, result: {container: container, key: 'key'}});\n  var next;\n  while ((next = stack.pop())) {\n    extendInner(stack, next.args, next.result);\n  }\n  return container.key;\n}\n\nfunction extendInner(stack, args, result) {\n  var options, name, src, copy, copyIsArray, clone,\n    target = args[0] || {},\n    i = 1,\n    length = args.length,\n    deep = false,\n    numericStringRegex = /\\d+/,\n    optionsIsArray;\n\n  // Handle a deep copy situation\n  if (typeof target === \"boolean\") {\n    deep = target;\n    target = args[1] || {};\n    // skip the boolean and the target\n    i = 2;\n  }\n\n  // Handle case when target is a string or something (possible in deep copy)\n  if (typeof target !== \"object\" && !isFunction(target)) {\n    target = {};\n  }\n\n  // extend jQuery itself if only one argument is passed\n  if (length === i) {\n    /* jshint validthis: true */\n    target = this;\n    --i;\n  }\n\n  for (; i < length; i++) {\n    // Only deal with non-null/undefined values\n    if ((options = args[i]) != null) {\n      optionsIsArray = isArray(options);\n      // Extend the base object\n      for (name in options) {\n        //if (options.hasOwnProperty(name)) {\n        if (!(name in Object.prototype)) {\n          if (optionsIsArray && !numericStringRegex.test(name)) {\n            continue;\n          }\n\n          src = target[name];\n          copy = options[name];\n\n          // Prevent never-ending loop\n          if (target === copy) {\n            continue;\n          }\n\n          // Recurse if we're merging plain objects or arrays\n          if (deep && copy && (isPlainObject(copy) ||\n              (copyIsArray = isArray(copy)))) {\n            if (copyIsArray) {\n              copyIsArray = false;\n              clone = src && isArray(src) ? src : [];\n\n            } else {\n              clone = src && isPlainObject(src) ? src : {};\n            }\n\n            // Never move original objects, clone them\n            stack.push({\n              args: [deep, clone, copy],\n              result: {\n                container: target,\n                key: name\n              }\n            });\n\n          // Don't bring in undefined values\n          } else if (copy !== undefined) {\n            if (!(isArray(options) && isFunction(copy))) {\n              target[name] = copy;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // \"Return\" the modified object by setting the key\n  // on the given container\n  result.container[result.key] = target;\n}\n\n\nmodule.exports = extend;\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-extend/index.js\n// module id = 102\n// module chunks = 0","'use strict';\n\nvar upsert = require('pouchdb-upsert').upsert;\n\nmodule.exports = function (db, doc, diffFun) {\n  return upsert.apply(db, [doc, diffFun]);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/abstract-mapreduce/upsert.js\n// module id = 103\n// module chunks = 0","'use strict';\n\nvar utils = require('../../../utils');\n\nvar localUtils = require('../utils');\nvar massageIndexDef = localUtils.massageIndexDef;\n\nfunction getIndexes(db) {\n  // just search through all the design docs and filter in-memory.\n  // hopefully there aren't that many ddocs.\n  return db.allDocs({\n    startkey: '_design/',\n    endkey: '_design/\\uffff',\n    include_docs: true\n  }).then(function (allDocsRes) {\n    var res = {\n      indexes: [{\n        ddoc: null,\n        name: '_all_docs',\n        type: 'special',\n        def: {\n          fields: [{_id: 'asc'}]\n        }\n      }]\n    };\n\n    res.indexes = utils.flatten(res.indexes, allDocsRes.rows.filter(function (row) {\n      return row.doc.language === 'query';\n    }).map(function (row) {\n      var viewNames = row.doc.views !== undefined ? Object.keys(row.doc.views) : [];\n\n      return viewNames.map(function (viewName) {\n        var view = row.doc.views[viewName];\n        return {\n          ddoc: row.id,\n          name: viewName,\n          type: 'json',\n          def: massageIndexDef(view.options.def)\n        };\n      });\n    }));\n\n    // these are sorted by view name for some reason\n    res.indexes.sort(function (left, right) {\n      return utils.compare(left.name, right.name);\n    });\n    res.total_rows = res.indexes.length;\n    return res;\n  });\n}\n\nmodule.exports = getIndexes;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/adapters/local/get-indexes/index.js\n// module id = 104\n// module chunks = 0","'use strict';\n\nvar utils = require('./utils');\nvar clone = utils.clone;\n\n// we restucture the supplied JSON considerably, because the official\n// Mango API is very particular about a lot of this stuff, but we like\n// to be liberal with what we accept in order to prevent mental\n// breakdowns in our users\nmodule.exports = function (requestDef) {\n  requestDef = clone(requestDef);\n\n  if (!requestDef.index) {\n    requestDef.index = {};\n  }\n\n  ['type', 'name', 'ddoc'].forEach(function (key) {\n    if (requestDef.index[key]) {\n      requestDef[key] = requestDef.index[key];\n      delete requestDef.index[key];\n    }\n  });\n\n  if (requestDef.fields) {\n    requestDef.index.fields = requestDef.fields;\n    delete requestDef.fields;\n  }\n\n  if (!requestDef.type) {\n    requestDef.type = 'json';\n  }\n  return requestDef;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/massageCreateIndexRequest.js\n// module id = 105\n// module chunks = 0","'use strict';\n\nvar PouchPromise = require('pouchdb-promise');\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsertInner(db, docId, diffFun) {\n  if (typeof docId !== 'string') {\n    return PouchPromise.reject(new Error('doc id is required'));\n  }\n\n  return db.get(docId).catch(function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 404) {\n      throw err;\n    }\n    return {};\n  }).then(function (doc) {\n    // the user might change the _rev, so save it for posterity\n    var docRev = doc._rev;\n    var newDoc = diffFun(doc);\n\n    if (!newDoc) {\n      // if the diffFun returns falsy, we short-circuit as\n      // an optimization\n      return { updated: false, rev: docRev };\n    }\n\n    // users aren't allowed to modify these values,\n    // so reset them here\n    newDoc._id = docId;\n    newDoc._rev = docRev;\n    return tryAndPut(db, newDoc, diffFun);\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsertInner(db, doc._id, diffFun);\n  });\n}\n\nexports.upsert = function upsert(docId, diffFun, cb) {\n  var db = this;\n  var promise = upsertInner(db, docId, diffFun);\n  if (typeof cb !== 'function') {\n    return promise;\n  }\n  promise.then(function (resp) {\n    cb(null, resp);\n  }, cb);\n};\n\nexports.putIfNotExists = function putIfNotExists(docId, doc, cb) {\n  var db = this;\n\n  if (typeof docId !== 'string') {\n    cb = doc;\n    doc = docId;\n    docId = doc._id;\n  }\n\n  var diffFun = function (existingDoc) {\n    if (existingDoc._rev) {\n      return false; // do nothing\n    }\n    return doc;\n  };\n\n  var promise = upsertInner(db, docId, diffFun);\n  if (typeof cb !== 'function') {\n    return promise;\n  }\n  promise.then(function (resp) {\n    cb(null, resp);\n  }, cb);\n};\n\n\n/* istanbul ignore next */\nif (typeof window !== 'undefined' && window.PouchDB) {\n  window.PouchDB.plugin(exports);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-upsert/index.js\n// module id = 107\n// module chunks = 0","/*jshint bitwise:false*/\n/*global unescape*/\n\n(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    /*\n     * Fastest md5 implementation around (JKM md5)\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n\n    cmn = function (q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    },\n\n    ff = function (a, b, c, d, x, s, t) {\n        return cmn((b & c) | ((~b) & d), a, b, x, s, t);\n    },\n\n    gg = function (a, b, c, d, x, s, t) {\n        return cmn((b & d) | (c & (~d)), a, b, x, s, t);\n    },\n\n    hh = function (a, b, c, d, x, s, t) {\n        return cmn(b ^ c ^ d, a, b, x, s, t);\n    },\n\n    ii = function (a, b, c, d, x, s, t) {\n        return cmn(c ^ (b | (~d)), a, b, x, s, t);\n    },\n\n    md5cycle = function (x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a = ff(a, b, c, d, k[0], 7, -680876936);\n        d = ff(d, a, b, c, k[1], 12, -389564586);\n        c = ff(c, d, a, b, k[2], 17, 606105819);\n        b = ff(b, c, d, a, k[3], 22, -1044525330);\n        a = ff(a, b, c, d, k[4], 7, -176418897);\n        d = ff(d, a, b, c, k[5], 12, 1200080426);\n        c = ff(c, d, a, b, k[6], 17, -1473231341);\n        b = ff(b, c, d, a, k[7], 22, -45705983);\n        a = ff(a, b, c, d, k[8], 7, 1770035416);\n        d = ff(d, a, b, c, k[9], 12, -1958414417);\n        c = ff(c, d, a, b, k[10], 17, -42063);\n        b = ff(b, c, d, a, k[11], 22, -1990404162);\n        a = ff(a, b, c, d, k[12], 7, 1804603682);\n        d = ff(d, a, b, c, k[13], 12, -40341101);\n        c = ff(c, d, a, b, k[14], 17, -1502002290);\n        b = ff(b, c, d, a, k[15], 22, 1236535329);\n\n        a = gg(a, b, c, d, k[1], 5, -165796510);\n        d = gg(d, a, b, c, k[6], 9, -1069501632);\n        c = gg(c, d, a, b, k[11], 14, 643717713);\n        b = gg(b, c, d, a, k[0], 20, -373897302);\n        a = gg(a, b, c, d, k[5], 5, -701558691);\n        d = gg(d, a, b, c, k[10], 9, 38016083);\n        c = gg(c, d, a, b, k[15], 14, -660478335);\n        b = gg(b, c, d, a, k[4], 20, -405537848);\n        a = gg(a, b, c, d, k[9], 5, 568446438);\n        d = gg(d, a, b, c, k[14], 9, -1019803690);\n        c = gg(c, d, a, b, k[3], 14, -187363961);\n        b = gg(b, c, d, a, k[8], 20, 1163531501);\n        a = gg(a, b, c, d, k[13], 5, -1444681467);\n        d = gg(d, a, b, c, k[2], 9, -51403784);\n        c = gg(c, d, a, b, k[7], 14, 1735328473);\n        b = gg(b, c, d, a, k[12], 20, -1926607734);\n\n        a = hh(a, b, c, d, k[5], 4, -378558);\n        d = hh(d, a, b, c, k[8], 11, -2022574463);\n        c = hh(c, d, a, b, k[11], 16, 1839030562);\n        b = hh(b, c, d, a, k[14], 23, -35309556);\n        a = hh(a, b, c, d, k[1], 4, -1530992060);\n        d = hh(d, a, b, c, k[4], 11, 1272893353);\n        c = hh(c, d, a, b, k[7], 16, -155497632);\n        b = hh(b, c, d, a, k[10], 23, -1094730640);\n        a = hh(a, b, c, d, k[13], 4, 681279174);\n        d = hh(d, a, b, c, k[0], 11, -358537222);\n        c = hh(c, d, a, b, k[3], 16, -722521979);\n        b = hh(b, c, d, a, k[6], 23, 76029189);\n        a = hh(a, b, c, d, k[9], 4, -640364487);\n        d = hh(d, a, b, c, k[12], 11, -421815835);\n        c = hh(c, d, a, b, k[15], 16, 530742520);\n        b = hh(b, c, d, a, k[2], 23, -995338651);\n\n        a = ii(a, b, c, d, k[0], 6, -198630844);\n        d = ii(d, a, b, c, k[7], 10, 1126891415);\n        c = ii(c, d, a, b, k[14], 15, -1416354905);\n        b = ii(b, c, d, a, k[5], 21, -57434055);\n        a = ii(a, b, c, d, k[12], 6, 1700485571);\n        d = ii(d, a, b, c, k[3], 10, -1894986606);\n        c = ii(c, d, a, b, k[10], 15, -1051523);\n        b = ii(b, c, d, a, k[1], 21, -2054922799);\n        a = ii(a, b, c, d, k[8], 6, 1873313359);\n        d = ii(d, a, b, c, k[15], 10, -30611744);\n        c = ii(c, d, a, b, k[6], 15, -1560198380);\n        b = ii(b, c, d, a, k[13], 21, 1309151649);\n        a = ii(a, b, c, d, k[4], 6, -145523070);\n        d = ii(d, a, b, c, k[11], 10, -1120210379);\n        c = ii(c, d, a, b, k[2], 15, 718787259);\n        b = ii(b, c, d, a, k[9], 21, -343485551);\n\n        x[0] = add32(a, x[0]);\n        x[1] = add32(b, x[1]);\n        x[2] = add32(c, x[2]);\n        x[3] = add32(d, x[3]);\n    },\n\n    /* there needs to be support for Unicode here,\n       * unless we pretend that we can redefine the MD-5\n       * algorithm for multi-byte characters (perhaps\n       * by adding every four 16-bit characters and\n       * shortening the sum to 32 bits). Otherwise\n       * I suggest performing MD-5 as if every character\n       * was two bytes--e.g., 0040 0025 = @%--but then\n       * how will an ordinary MD-5 sum be matched?\n       * There is no way to standardize text to something\n       * like UTF-8 before transformation; speed cost is\n       * utterly prohibitive. The JavaScript standard\n       * itself needs to look at this: it should start\n       * providing access to strings as preformed UTF-8\n       * 8-bit unsigned value arrays.\n       */\n    md5blk = function (s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    },\n\n    md5blk_array = function (a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    },\n\n    md51 = function (s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    },\n\n    md51_array = function (a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    },\n\n    hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'],\n\n    rhex = function (n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    },\n\n    hex = function (x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    },\n\n    md5 = function (s) {\n        return hex(md51(s));\n    },\n\n\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n    SparkMD5 = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n\n    // In some cases the fast add32 function cannot be used..\n    if (md5('hello') !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // converts the string to utf8 bytes if necessary\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        // then append as binary\n        this.appendBinary(str);\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._state, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substr(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     * Use the raw parameter to obtain the raw result instead of the hex one.\n     *\n     * @param {Boolean} raw True to get the raw result, false to get the hex result\n     *\n     * @return {String|Array} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = !!raw ? this._state : hex(this._state);\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._state, tail);\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = \"\";\n        this._length = 0;\n        this._state = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other aditional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._state;\n        delete this._buff;\n        delete this._length;\n    };\n\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw result, false to get the hex result\n     *\n     * @return {String|Array} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // converts the string to utf8 bytes if necessary\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        var hash = md51(str);\n\n        return !!raw ? hash : hex(hash);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw result, false to get the hex result\n     *\n     * @return {String|Array} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content);\n\n        return !!raw ? hash : hex(hash);\n    };\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    ////////////////////////////////////////////////////////////////////////////\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        // TODO: we could avoid the concatenation here but the algorithm would be more complex\n        //       if you find yourself needing extra performance, please make a PR.\n        var buff = this._concatArrayBuffer(this._buff, arr),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._state, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        // Avoids IE10 weirdness (documented above)\n        this._buff = (i - 64) < length ? buff.subarray(i - 64) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     * Use the raw parameter to obtain the raw result instead of the hex one.\n     *\n     * @param {Boolean} raw True to get the raw result, false to get the hex result\n     *\n     * @return {String|Array} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = !!raw ? this._state : hex(this._state);\n\n        this.reset();\n\n        return ret;\n    };\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._state = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other aditional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    /**\n     * Concats two array buffers, returning a new one.\n     *\n     * @param  {ArrayBuffer} first  The first array buffer\n     * @param  {ArrayBuffer} second The second array buffer\n     *\n     * @return {ArrayBuffer} The new array buffer\n     */\n    SparkMD5.ArrayBuffer.prototype._concatArrayBuffer = function (first, second) {\n        var firstLength = first.length,\n            result = new Uint8Array(firstLength + second.byteLength);\n\n        result.set(first);\n        result.set(new Uint8Array(second), firstLength);\n\n        return result;\n    };\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw result, false to get the hex result\n     *\n     * @return {String|Array} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr));\n\n        return !!raw ? hash : hex(hash);\n    };\n\n    return SparkMD5;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/spark-md5/spark-md5.js\n// module id = 108\n// module chunks = 0","export class LocalStorage {\n  constructor (storage, prefix) {\n    if (!storage && typeof window !== 'undefined') {\n      storage = window.localStorage\n    }\n    this.storage = storage\n    this.prefix = prefix || 'cozy:oauth:'\n  }\n\n  save (key, value) {\n    return new Promise(resolve => {\n      this.storage.setItem(this.prefix + key, JSON.stringify(value))\n      resolve(value)\n    })\n  }\n\n  load (key) {\n    return new Promise(resolve => {\n      const item = this.storage.getItem(this.prefix + key)\n      if (!item) {\n        resolve()\n      } else {\n        resolve(JSON.parse(item))\n      }\n    })\n  }\n\n  delete (key) {\n    return new Promise(resolve => resolve(\n      this.storage.removeItem(this.prefix + key)))\n  }\n\n  clear () {\n    return new Promise(resolve => {\n      const storage = this.storage\n      for (let i = 0; i < storage.length; i++) {\n        const key = storage.key(i)\n        if (key.indexOf(this.prefix) === 0) {\n          storage.removeItem(key)\n        }\n      }\n      resolve()\n    })\n  }\n}\n\nexport class MemoryStorage {\n  constructor () {\n    this.hash = Object.create(null)\n  }\n\n  save (key, value) {\n    this.hash[key] = value\n    return Promise.resolve(value)\n  }\n\n  load (key) {\n    return Promise.resolve(this.hash[key])\n  }\n\n  delete (key) {\n    const deleted = delete this.hash[key]\n    return Promise.resolve(deleted)\n  }\n\n  clear () {\n    this.hash = Object.create(null)\n    return Promise.resolve()\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/auth_storage.js","/* global btoa */\nconst V2TOKEN_ABORT_TIMEOUT = 3000\n\nexport function getAppToken () {\n  return new Promise(function (resolve, reject) {\n    if (typeof window === 'undefined') {\n      return reject(new Error('getV2Token should be used in browser'))\n    } else if (!window.parent) {\n      return reject(new Error('getV2Token should be used in iframe'))\n    } else if (!window.parent.postMessage) {\n      return reject(new Error('getV2Token should be used in modern browser'))\n    }\n    const origin = window.location.origin\n    const intent = {action: 'getToken'}\n    let timeout = null\n    const receiver = function (event) {\n      let token\n      try {\n        token = new AppToken({\n          appName: event.data.appName,\n          token: event.data.token\n        })\n      } catch (e) {\n        reject(e)\n        return\n      }\n      window.removeEventListener('message', receiver)\n      clearTimeout(timeout)\n      resolve({ client: null, token })\n    }\n    window.addEventListener('message', receiver, false)\n    window.parent.postMessage(intent, origin)\n    timeout = setTimeout(() => {\n      reject(new Error('No response from parent iframe after 3s'))\n    }, V2TOKEN_ABORT_TIMEOUT)\n  })\n}\n\nexport class AppToken {\n  constructor (opts) {\n    this.appName = opts.appName || ''\n    this.token = opts.token || ''\n  }\n\n  toAuthHeader () {\n    return 'Basic ' + btoa(`${this.appName}:${this.token}`)\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/auth_v2.js","import {createPath} from './utils'\nimport {normalizeDoctype} from './doctypes'\nimport {cozyFetchJSON} from './fetch'\n\nconst NOREV = 'stack-v2-no-rev'\n\nexport function create (cozy, doctype, attributes) {\n  return cozy.isV2().then((isV2) => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    if (isV2) {\n      attributes.docType = doctype\n    }\n    const path = createPath(cozy, isV2, doctype, attributes._id)\n    const httpVerb = attributes._id ? 'PUT' : 'POST'\n    delete attributes._id\n    return cozyFetchJSON(cozy, httpVerb, path, attributes).then((resp) => {\n      if (isV2) {\n        return find(cozy, doctype, resp._id)\n      } else {\n        return resp.data\n      }\n    })\n  })\n}\n\nexport function find (cozy, doctype, id) {\n  return cozy.isV2().then((isV2) => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n\n    if (!id) {\n      return Promise.reject(new Error('Missing id parameter'))\n    }\n\n    const path = createPath(cozy, isV2, doctype, id)\n    return cozyFetchJSON(cozy, 'GET', path).then((resp) => {\n      if (isV2) {\n        return Object.assign(resp, {_rev: NOREV})\n      } else {\n        return resp\n      }\n    })\n  })\n}\n\nexport function findMany (cozy, doctype, ids) {\n  if (!(ids instanceof Array)) {\n    return Promise.reject(new Error('Parameter ids must be a non-empty array'))\n  }\n  if (ids.length === 0) {\n    // So users don't need to be defensive regarding the array content.\n    // This should not hide issues in user code since the result will be an\n    // empty object anyway.\n    return Promise.resolve({})\n  }\n\n  return cozy.isV2().then((isV2) => {\n    if (isV2) {\n      return Promise.reject(new Error('findMany is not available on v2'))\n    }\n\n    const path = createPath(cozy, isV2, doctype, '_all_docs', {include_docs: true})\n\n    return cozyFetchJSON(cozy, 'POST', path, {keys: ids})\n      .then((resp) => {\n        const docs = {}\n\n        for (const row of resp.rows) {\n          const {key, doc, error} = row\n          docs[key] = error ? {error} : {doc}\n        }\n\n        return docs\n      })\n      .catch((error) => {\n        if (error.status !== 404) return Promise.reject(error)\n\n        // When no doc was ever created and the database does not exist yet,\n        // the response will be a 404 error.\n        const docs = {}\n\n        for (const id of ids) {\n          docs[id] = {error}\n        }\n\n        return docs\n      })\n  })\n}\n\nexport function findAll (cozy, doctype) {\n  return cozy.isV2().then((isV2) => {\n    if (isV2) {\n      return Promise.reject(new Error('findAll is not available on v2'))\n    }\n\n    const path = createPath(cozy, isV2, doctype, '_all_docs', {include_docs: true})\n\n    return cozyFetchJSON(cozy, 'POST', path, {})\n    .then((resp) => {\n      const docs = []\n\n      for (const row of resp.rows) {\n        const { doc } = row\n        // if not couchDB indexes\n        if (!doc._id.match(/_design\\//)) docs.push(doc)\n      }\n      return docs\n    })\n    .catch(error => {\n      // the _all_docs endpoint returns a 404 error if no document with the given\n      // doctype exists.\n      if (error.status === 404) return []\n      throw error\n    })\n  })\n}\n\nexport function changesFeed (cozy, doctype, options) {\n  return cozy.isV2().then((isV2) => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    const path = createPath(cozy, isV2, doctype, '_changes', options)\n    return cozyFetchJSON(cozy, 'GET', path)\n  })\n}\n\nexport function update (cozy, doctype, doc, changes) {\n  return cozy.isV2().then((isV2) => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    const {_id, _rev} = doc\n\n    if (!_id) {\n      return Promise.reject(new Error('Missing _id field in passed document'))\n    }\n\n    if (!isV2 && !_rev) {\n      return Promise.reject(new Error('Missing _rev field in passed document'))\n    }\n\n    if (isV2) {\n      changes = Object.assign({ _id }, changes)\n    } else {\n      changes = Object.assign({ _id, _rev }, changes)\n    }\n\n    const path = createPath(cozy, isV2, doctype, _id)\n    return cozyFetchJSON(cozy, 'PUT', path, changes).then((resp) => {\n      if (isV2) {\n        return find(cozy, doctype, _id)\n      } else {\n        return resp.data\n      }\n    })\n  })\n}\n\nexport function updateAttributes (cozy, doctype, _id, changes, tries = 3) {\n  return cozy.isV2().then((isV2) => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    return find(cozy, doctype, _id)\n      .then((doc) => {\n        return update(cozy, doctype, doc, Object.assign({ _id }, doc, changes))\n      })\n      .catch((err) => {\n        if (tries > 0) {\n          return updateAttributes(cozy, doctype, _id, changes, tries - 1)\n        } else {\n          throw err\n        }\n      })\n  })\n}\n\nexport function _delete (cozy, doctype, doc) {\n  return cozy.isV2().then((isV2) => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    const {_id, _rev} = doc\n\n    if (!_id) {\n      return Promise.reject(new Error('Missing _id field in passed document'))\n    }\n\n    if (!isV2 && !_rev) {\n      return Promise.reject(new Error('Missing _rev field in passed document'))\n    }\n\n    const query = isV2 ? null : { rev: _rev }\n    const path = createPath(cozy, isV2, doctype, _id, query)\n    return cozyFetchJSON(cozy, 'DELETE', path).then((resp) => {\n      if (isV2) {\n        return {id: _id, rev: NOREV}\n      } else {\n        return resp\n      }\n    })\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/data.js","/* global Blob, File */\nimport { cozyFetch, cozyFetchJSON } from './fetch'\nimport jsonapi from './jsonapi'\nimport { DOCTYPE_FILES } from './doctypes'\n\n// global variables\nexport const ROOT_DIR_ID = 'io.cozy.files.root-dir'\nexport const TRASH_DIR_ID = 'io.cozy.files.trash-dir'\n\nconst contentTypeOctetStream = 'application/octet-stream'\n\nfunction doUpload (cozy, data, method, path, options) {\n  if (!data) {\n    throw new Error('missing data argument')\n  }\n\n  // transform any ArrayBufferView to ArrayBuffer\n  if (data.buffer && data.buffer instanceof ArrayBuffer) {\n    data = data.buffer\n  }\n\n  const isBuffer = (typeof ArrayBuffer !== 'undefined' && data instanceof ArrayBuffer)\n  const isFile = (typeof File !== 'undefined' && data instanceof File)\n  const isBlob = (typeof Blob !== 'undefined' && data instanceof Blob)\n  const isStream = (data.readable === true && typeof data.pipe === 'function')\n  const isString = (typeof data === 'string')\n\n  if (!isBuffer && !isFile && !isBlob && !isStream && !isString) {\n    throw new Error('invalid data type')\n  }\n\n  let {contentType, checksum, lastModifiedDate, ifMatch} = options || {}\n  if (!contentType) {\n    if (isBuffer) {\n      contentType = contentTypeOctetStream\n    } else if (isFile) {\n      contentType = data.type || contentTypeOctetStream\n      if (!lastModifiedDate) {\n        lastModifiedDate = data.lastModifiedDate\n      }\n    } else if (isBlob) {\n      contentType = data.type || contentTypeOctetStream\n    } else if (isStream) {\n      contentType = contentTypeOctetStream\n    } else if (typeof data === 'string') {\n      contentType = 'text/plain'\n    }\n  }\n\n  if (lastModifiedDate && typeof lastModifiedDate === 'string') {\n    lastModifiedDate = new Date(lastModifiedDate)\n  }\n\n  return cozyFetch(cozy, path, {\n    method: method,\n    headers: {\n      'Content-Type': contentType,\n      'Content-MD5': checksum || '',\n      'Date': lastModifiedDate ? lastModifiedDate.toGMTString() : '',\n      'If-Match': ifMatch || ''\n    },\n    body: data\n  })\n    .then((res) => {\n      const json = res.json()\n      if (!res.ok) {\n        return json.then(err => { throw err })\n      } else {\n        return json.then(jsonapi)\n      }\n    })\n}\n\nexport function create (cozy, data, options) {\n  let {name, dirID, executable} = options || {}\n\n  // handle case where data is a file and contains the name\n  if (!name && typeof data.name === 'string') {\n    name = data.name\n  }\n\n  if (typeof name !== 'string' || name === '') {\n    throw new Error('missing name argument')\n  }\n\n  if (executable === undefined) {\n    executable = false\n  }\n\n  const path = `/files/${encodeURIComponent(dirID || '')}`\n  const query = `?Name=${encodeURIComponent(name)}&Type=file&Executable=${executable}`\n  return doUpload(cozy, data, 'POST', `${path}${query}`, options)\n}\n\nexport function createDirectory (cozy, options) {\n  let {name, dirID, lastModifiedDate} = options || {}\n\n  if (typeof name !== 'string' || name === '') {\n    throw new Error('missing name argument')\n  }\n\n  if (lastModifiedDate && typeof lastModifiedDate === 'string') {\n    lastModifiedDate = new Date(lastModifiedDate)\n  }\n\n  const path = `/files/${encodeURIComponent(dirID || '')}`\n  const query = `?Name=${encodeURIComponent(name)}&Type=directory`\n  return cozyFetchJSON(cozy, 'POST', `${path}${query}`, undefined, {\n    headers: {\n      'Date': lastModifiedDate ? lastModifiedDate.toGMTString() : ''\n    }\n  })\n}\n\nfunction getDirectoryOrCreate (cozy, name, parentDirectory) {\n  if (parentDirectory && !parentDirectory.attributes) throw new Error('Malformed parent directory')\n\n  const path = `${parentDirectory._id === ROOT_DIR_ID ? '' : parentDirectory.attributes.path}/${name}`\n\n  return cozy.files.statByPath(path || '/')\n    .catch(error => {\n      const parsedError = JSON.parse(error.message)\n      const errors = parsedError.errors\n      if (errors && errors.length && errors[0].status === '404') {\n        return cozy.files.createDirectory({\n          name: name,\n          dirID: parentDirectory && parentDirectory._id\n        })\n      }\n\n      throw errors\n    })\n}\n\nexport function createDirectoryByPath (cozy, path) {\n  const parts = path.split('/').filter(part => part !== '')\n\n  const rootDirectoryPromise = cozy.files.statById(ROOT_DIR_ID)\n\n  return parts.length\n    ? parts.reduce((parentDirectoryPromise, part) => {\n      return parentDirectoryPromise\n        .then(parentDirectory => getDirectoryOrCreate(cozy, part, parentDirectory))\n    }, rootDirectoryPromise)\n      : rootDirectoryPromise\n}\n\nexport function updateById (cozy, id, data, options) {\n  return doUpload(cozy, data, 'PUT', `/files/${encodeURIComponent(id)}`, options)\n}\n\nfunction doUpdateAttributes (cozy, attrs, path, options) {\n  if (!attrs || typeof attrs !== 'object') {\n    throw new Error('missing attrs argument')\n  }\n\n  const {ifMatch} = options || {}\n  const body = { data: { attributes: attrs } }\n  return cozyFetchJSON(cozy, 'PATCH', path, body, {\n    headers: {\n      'If-Match': ifMatch || ''\n    }\n  })\n}\n\nexport function updateAttributesById (cozy, id, attrs, options) {\n  return doUpdateAttributes(cozy, attrs,\n    `/files/${encodeURIComponent(id)}`, options)\n}\n\nexport function updateAttributesByPath (cozy, path, attrs, options) {\n  return doUpdateAttributes(cozy, attrs,\n    `/files/metadata?Path=${encodeURIComponent(path)}`, options)\n}\n\nexport function trashById (cozy, id, options) {\n  if (typeof id !== 'string' || id === '') {\n    throw new Error('missing id argument')\n  }\n  const {ifMatch} = options || {}\n  return cozyFetchJSON(cozy, 'DELETE', `/files/${encodeURIComponent(id)}`, undefined, {\n    headers: {\n      'If-Match': ifMatch || ''\n    }\n  })\n}\n\nexport function statById (cozy, id, offline = true, options = {}) {\n  if (offline && cozy.offline.hasDatabase(DOCTYPE_FILES)) {\n    let db = cozy.offline.getDatabase(DOCTYPE_FILES)\n    return Promise.all([\n      db.get(id),\n      db.find(Object.assign({ selector: { 'dir_id': id } }, options))\n    ]).then(([doc, children]) => {\n      if (id === ROOT_DIR_ID) {\n        children.docs = children.docs.filter(doc => doc._id !== TRASH_DIR_ID)\n      }\n      children = sortFiles(children.docs.map(doc => addIsDir(toJsonApi(cozy, doc))))\n      return addIsDir(toJsonApi(cozy, doc, children))\n    })\n  }\n  const query = Object.keys(options).length === 0 ? '' : `?${encodePageOptions(options)}`\n  return cozyFetchJSON(cozy, 'GET', `/files/${encodeURIComponent(id)}${query}`)\n    .then(addIsDir)\n}\n\nexport function statByPath (cozy, path) {\n  return cozyFetchJSON(cozy, 'GET', `/files/metadata?Path=${encodeURIComponent(path)}`)\n    .then(addIsDir)\n}\n\nexport function downloadById (cozy, id) {\n  return cozyFetch(cozy, `/files/download/${encodeURIComponent(id)}`)\n}\n\nexport function downloadByPath (cozy, path) {\n  return cozyFetch(cozy, `/files/download?Path=${encodeURIComponent(path)}`)\n}\n\nfunction extractResponseLinkRelated (res) {\n  let href = res.links && res.links.related\n  if (!href) throw new Error('No related link in server response')\n  return href\n}\n\nexport function getDownloadLinkByPath (cozy, path) {\n  return cozyFetchJSON(cozy, 'POST', `/files/downloads?Path=${encodeURIComponent(path)}`)\n    .then(extractResponseLinkRelated)\n}\n\nexport function getDownloadLinkById (cozy, id) {\n  return cozyFetchJSON(cozy, 'POST', `/files/downloads?Id=${encodeURIComponent(id)}`)\n    .then(extractResponseLinkRelated)\n}\n\nexport function getFilePath (cozy, file = {}, folder) {\n  if (!folder || !folder.attributes) {\n    throw Error('Folder should be valid with an attributes.path property')\n  }\n\n  const folderPath = folder.attributes.path.endsWith('/')\n    ? folder.attributes.path\n      : `${folder.attributes.path}/`\n\n  return `${folderPath}${file.name}`\n}\n\nexport function getCollectionShareLink (cozy, id, collectionType) {\n  if (!id) {\n    return Promise.reject(Error('An id should be provided to create a share link'))\n  }\n  return cozyFetchJSON(cozy, 'POST', `/permissions?codes=email`, {\n    data: {\n      type: 'io.cozy.permissions',\n      attributes: {\n        permissions: {\n          files: {\n            type: 'io.cozy.files',\n            verbs: ['GET'],\n            values: [id],\n            selector: 'referenced_by'\n          },\n          collection: {\n            type: collectionType,\n            verbs: ['GET'],\n            values: [id]\n          }\n        }\n      }\n    }\n  }).then(data => ({sharecode: `sharecode=${data.attributes.codes.email}`, id: `id=${id}`}))\n}\n\nexport function getArchiveLinkByPaths (cozy, paths, name = 'files') {\n  const archive = {\n    type: 'io.cozy.archives',\n    attributes: {\n      name: name,\n      files: paths\n    }\n  }\n  return cozyFetchJSON(cozy, 'POST', `/files/archive`, {data: archive})\n  .then(extractResponseLinkRelated)\n}\n\nexport function getArchiveLinkByIds (cozy, ids, name = 'files') {\n  const archive = {\n    type: 'io.cozy.archives',\n    attributes: {\n      name: name,\n      ids: ids\n    }\n  }\n  return cozyFetchJSON(cozy, 'POST', `/files/archive`, {data: archive})\n  .then(extractResponseLinkRelated)\n}\n\nexport function listTrash (cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/files/trash`)\n}\n\nexport function clearTrash (cozy) {\n  return cozyFetchJSON(cozy, 'DELETE', `/files/trash`)\n}\n\nexport function restoreById (cozy, id) {\n  return cozyFetchJSON(cozy, 'POST', `/files/trash/${encodeURIComponent(id)}`)\n}\n\nexport function destroyById (cozy, id, options) {\n  const {ifMatch} = options || {}\n  return cozyFetchJSON(cozy, 'DELETE', `/files/trash/${encodeURIComponent(id)}`, undefined, {\n    headers: {\n      'If-Match': ifMatch || ''\n    }\n  })\n}\n\nfunction addIsDir (obj) {\n  obj.isDir = obj.attributes.type === 'directory'\n  return obj\n}\n\nfunction encodePageOptions (options) {\n  let opts = []\n  for (const name in options) {\n    opts.push(`page[${encodeURIComponent(name)}]=${encodeURIComponent(options[name])}`)\n  }\n  return opts.join('&')\n}\n\nfunction toJsonApi (cozy, doc, contents = []) {\n  let clone = JSON.parse(JSON.stringify(doc))\n  delete clone._id\n  delete clone._rev\n  return {\n    _id: doc._id,\n    _rev: doc._rev,\n    _type: DOCTYPE_FILES,\n    attributes: clone,\n    relationships: {\n      contents: {\n        data: contents,\n        meta: {\n          count: contents.length\n        }\n      }\n    },\n    relations: (name) => {\n      if (name === 'contents') {\n        return contents\n      }\n    }\n  }\n}\n\nfunction sortFiles (allFiles) {\n  const folders = allFiles.filter(f => f.attributes.type === 'directory')\n  const files = allFiles.filter(f => f.attributes.type !== 'directory')\n  const sort = files => files.sort((a, b) => a.attributes.name.localeCompare(b.attributes.name))\n  return sort(folders).concat(sort(files))\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/files.js","/* global fetch URL */\nimport 'babel-polyfill'\n\nimport {unpromiser, retry, warn} from './utils'\nimport {LocalStorage, MemoryStorage} from './auth_storage'\nimport {AppToken as AppTokenV2, getAppToken as getAppTokenV2} from './auth_v2'\nimport * as auth from './auth_v3'\nimport * as data from './data'\nimport * as cozyFetch from './fetch'\nimport * as mango from './mango'\nimport * as files from './files'\nimport * as intents from './intents'\nimport * as jobs from './jobs'\nimport * as offline from './offline'\nimport * as settings from './settings'\nimport * as relations from './relations'\n\nconst {\n  AppToken: AppTokenV3,\n  AccessToken: AccessTokenV3,\n  Client: ClientV3\n} = auth\n\nconst AuthNone = 0\nconst AuthRunning = 1\nconst AuthError = 2\nconst AuthOK = 3\n\nconst defaultClientParams = {\n  softwareID: 'github.com/cozy/cozy-client-js'\n}\n\nconst dataProto = {\n  create: data.create,\n  find: data.find,\n  findMany: data.findMany,\n  findAll: data.findAll,\n  update: data.update,\n  delete: data._delete,\n  updateAttributes: data.updateAttributes,\n  changesFeed: data.changesFeed,\n  defineIndex: mango.defineIndex,\n  query: mango.query,\n  addReferencedFiles: relations.addReferencedFiles,\n  removeReferencedFiles: relations.removeReferencedFiles,\n  listReferencedFiles: relations.listReferencedFiles,\n  fetchReferencedFiles: relations.fetchReferencedFiles,\n  destroy: function (...args) {\n    warn('destroy is deprecated, use cozy.data.delete instead.')\n    return data._delete(...args)\n  }\n}\n\nconst authProto = {\n  client: auth.client,\n  registerClient: auth.registerClient,\n  updateClient: auth.updateClient,\n  unregisterClient: auth.unregisterClient,\n  getClient: auth.getClient,\n  getAuthCodeURL: auth.getAuthCodeURL,\n  getAccessToken: auth.getAccessToken,\n  refreshToken: auth.refreshToken\n}\n\nconst filesProto = {\n  create: files.create,\n  createDirectory: files.createDirectory,\n  createDirectoryByPath: files.createDirectoryByPath,\n  updateById: files.updateById,\n  updateAttributesById: files.updateAttributesById,\n  updateAttributesByPath: files.updateAttributesByPath,\n  trashById: files.trashById,\n  statById: files.statById,\n  statByPath: files.statByPath,\n  downloadById: files.downloadById,\n  downloadByPath: files.downloadByPath,\n  getDownloadLinkById: files.getDownloadLinkById,\n  getDownloadLink: files.getDownloadLinkByPath, // DEPRECATED, should be removed very soon\n  getDownloadLinkByPath: files.getDownloadLinkByPath,\n  getArchiveLink: function (...args) {\n    warn('getArchiveLink is deprecated, use cozy.files.getArchiveLinkByPaths instead.')\n    return files.getArchiveLinkByPaths(...args)\n  },\n  getArchiveLinkByPaths: files.getArchiveLinkByPaths,\n  getArchiveLinkByIds: files.getArchiveLinkByIds,\n  getFilePath: files.getFilePath,\n  getCollectionShareLink: files.getCollectionShareLink,\n  query: mango.queryFiles,\n  listTrash: files.listTrash,\n  clearTrash: files.clearTrash,\n  restoreById: files.restoreById,\n  destroyById: files.destroyById\n}\n\nconst intentsProto = {\n  create: intents.create,\n  createService: intents.createService\n}\n\nconst jobsProto = {\n  create: jobs.create,\n  count: jobs.count,\n  queued: jobs.queued\n}\n\nconst offlineProto = {\n  init: offline.init,\n  getDoctypes: offline.getDoctypes,\n  // database\n  hasDatabase: offline.hasDatabase,\n  getDatabase: offline.getDatabase,\n  createDatabase: offline.createDatabase,\n  destroyDatabase: offline.destroyDatabase,\n  destroyAllDatabase: offline.destroyAllDatabase,\n  // replication\n  hasReplication: offline.hasReplication,\n  replicateFromCozy: offline.replicateFromCozy,\n  stopReplication: offline.stopReplication,\n  stopAllReplication: offline.stopAllReplication,\n  // repeated replication\n  hasRepeatedReplication: offline.hasRepeatedReplication,\n  startRepeatedReplication: offline.startRepeatedReplication,\n  stopRepeatedReplication: offline.stopRepeatedReplication,\n  stopAllRepeatedReplication: offline.stopAllRepeatedReplication\n}\n\nconst settingsProto = {\n  diskUsage: settings.diskUsage,\n  changePassphrase: settings.changePassphrase,\n  getInstance: settings.getInstance,\n  updateInstance: settings.updateInstance,\n  getClients: settings.getClients,\n  deleteClientById: settings.deleteClientById,\n  updateLastSync: settings.updateLastSync\n}\n\nclass Client {\n  constructor (options) {\n    this.data = {}\n    this.files = {}\n    this.intents = {}\n    this.jobs = {}\n    this.offline = {}\n    this.settings = {}\n    this.auth = {\n      Client: ClientV3,\n      AccessToken: AccessTokenV3,\n      AppToken: AppTokenV3,\n      AppTokenV2: AppTokenV2,\n      LocalStorage: LocalStorage,\n      MemoryStorage: MemoryStorage\n    }\n    this._inited = false\n    if (options) {\n      this.init(options)\n    }\n  }\n\n  init (options = {}) {\n    this._inited = true\n    this._oauth = false // is oauth activated or not\n    this._token = null  // application token\n    this._authstate = AuthNone\n    this._authcreds = null\n    this._storage = null\n    this._version = options.version || null\n    this._offline = null\n\n    const token = options.token\n    const oauth = options.oauth\n    if (token && oauth) {\n      throw new Error('Cannot specify an application token with a oauth activated')\n    }\n\n    if (token) {\n      this._token = new AppTokenV3({ token })\n    } else if (oauth) {\n      this._oauth = true\n      this._storage = oauth.storage\n      this._clientParams = Object.assign({}, defaultClientParams, oauth.clientParams)\n      this._onRegistered = oauth.onRegistered || nopOnRegistered\n    }\n\n    let url = options.cozyURL || ''\n    while (url[url.length - 1] === '/') {\n      url = url.slice(0, -1)\n    }\n\n    this._url = url\n\n    const disablePromises = !!options.disablePromises\n    addToProto(this, this.data, dataProto, disablePromises)\n    addToProto(this, this.auth, authProto, disablePromises)\n    addToProto(this, this.files, filesProto, disablePromises)\n    addToProto(this, this.intents, intentsProto, disablePromises)\n    addToProto(this, this.jobs, jobsProto, disablePromises)\n    addToProto(this, this.offline, offlineProto, disablePromises)\n    addToProto(this, this.settings, settingsProto, disablePromises)\n\n    if (options.offline) {\n      this.offline.init(options.offline)\n    }\n\n    // Exposing cozyFetchJSON to make some development easier. Should be temporary.\n    this.fetchJSON = function _fetchJSON () {\n      const args = [this].concat(Array.prototype.slice.call(arguments))\n      return cozyFetch.cozyFetchJSON.apply(this, args)\n    }\n  }\n\n  authorize (forceTokenRefresh = false) {\n    const state = this._authstate\n    if (state === AuthOK || state === AuthRunning) {\n      return this._authcreds\n    }\n\n    this._authstate = AuthRunning\n    this._authcreds = this.isV2().then((isV2) => {\n      if (isV2 && this._oauth) {\n        throw new Error('OAuth is not supported on the V2 stack')\n      }\n      if (this._oauth) {\n        if (forceTokenRefresh && this._clientParams.redirectURI) {\n          const url = new URL(this._clientParams.redirectURI)\n          if (!url.searchParams.has('reconnect')) url.searchParams.append('reconnect', 1)\n          this._clientParams.redirectURI = url.toString()\n        }\n        return auth.oauthFlow(\n          this,\n          this._storage,\n          this._clientParams,\n          this._onRegistered,\n          forceTokenRefresh\n        )\n      }\n      // we expect to be on a client side application running in a browser\n      // with cookie-based authentication.\n      if (isV2) {\n        return getAppTokenV2()\n      } else if (this._token) {\n        return Promise.resolve({client: null, token: this._token})\n      } else {\n        throw new Error('Missing application token')\n      }\n    })\n\n    this._authcreds.then(\n      () => { this._authstate = AuthOK },\n      () => { this._authstate = AuthError })\n\n    return this._authcreds\n  }\n\n  saveCredentials (client, token) {\n    const creds = {client, token}\n    if (!this._storage || this._authstate === AuthRunning) {\n      return Promise.resolve(creds)\n    }\n    this._storage.save(auth.CredsKey, creds)\n    this._authcreds = Promise.resolve(creds)\n    return this._authcreds\n  }\n\n  fullpath (path) {\n    return this.isV2().then((isV2) => {\n      const pathprefix = isV2 ? '/ds-api' : ''\n      return this._url + pathprefix + path\n    })\n  }\n\n  isV2 () {\n    if (!this._version) {\n      return retry(() => fetch(`${this._url}/status/`), 3)()\n        .then((res) => {\n          if (!res.ok) {\n            throw new Error('Could not fetch cozy status')\n          } else {\n            return res.json()\n          }\n        })\n        .then((status) => {\n          this._version = status.datasystem !== undefined ? 2 : 3\n          return this.isV2()\n        })\n    }\n    return Promise.resolve(this._version === 2)\n  }\n}\n\nfunction nopOnRegistered () {\n  throw new Error('Missing onRegistered callback')\n}\n\nfunction protoify (context, fn) {\n  return function prototyped (...args) {\n    return fn(context, ...args)\n  }\n}\n\nfunction addToProto (ctx, obj, proto, disablePromises) {\n  for (const attr in proto) {\n    let fn = protoify(ctx, proto[attr])\n    if (disablePromises) {\n      fn = unpromiser(fn)\n    }\n    obj[attr] = fn\n  }\n}\n\nmodule.exports = new Client()\nObject.assign(module.exports, {Client, LocalStorage, MemoryStorage})\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","import {cozyFetchJSON} from './fetch'\n\nconst intentClass = 'coz-intent'\n\n// helper to serialize/deserialize an error for/from postMessage\nconst errorSerializer = (() => {\n  function mapErrorProperties (from, to) {\n    const result = Object.assign(to, from)\n    const nativeProperties = ['name', 'message']\n    return nativeProperties.reduce((result, property) => {\n      if (from[property]) {\n        to[property] = from[property]\n      }\n      return result\n    }, result)\n  }\n  return {\n    serialize: (error) => mapErrorProperties(error, {}),\n    deserialize: (data) => mapErrorProperties(data, new Error(data.message))\n  }\n})()\n\n// inject iframe for service in given element\nfunction injectService (url, element, intent, data, onReadyCallback) {\n  const document = element.ownerDocument\n  if (!document) throw new Error('Cannot retrieve document object from given element')\n\n  const window = document.defaultView\n  if (!window) throw new Error('Cannot retrieve window object from document')\n\n  const iframe = document.createElement('iframe')\n  // if callback provided for when iframe is loaded\n  if (typeof onReadyCallback === 'function') iframe.onload = onReadyCallback\n  // TODO: implement 'title' attribute\n  iframe.setAttribute('src', url)\n  iframe.classList.add(intentClass)\n  element.appendChild(iframe)\n  iframe.focus()\n\n  // Keeps only http://domain:port/\n  const serviceOrigin = url.split('/', 3).join('/')\n\n  return new Promise((resolve, reject) => {\n    let handshaken = false\n    const messageHandler = (event) => {\n      if (event.origin !== serviceOrigin) return\n\n      if (event.data.type === 'load') {\n        // Safari 9.1 (At least) send a MessageEvent when the iframe loads,\n        // making the handshake fails.\n        console.warn && console.warn('Cozy Client ignored MessageEvent having data.type `load`.')\n        return\n      }\n\n      if (event.data.type === `intent-${intent._id}:ready`) {\n        handshaken = true\n        return event.source.postMessage(data, event.origin)\n      }\n\n      if (handshaken && event.data.type === `intent-${intent._id}:resize`) {\n        ['width', 'height', 'maxWidth', 'maxHeight'].forEach(prop => {\n          if (event.data.transition) element.style.transition = event.data.transition\n          if (event.data.dimensions[prop]) element.style[prop] = `${event.data.dimensions[prop]}px`\n        })\n\n        return true\n      }\n\n      window.removeEventListener('message', messageHandler)\n      const removeIntentFrame = () => {\n        // check if the parent node has not been already removed from the DOM\n        iframe.parentNode && iframe.parentNode.removeChild(iframe)\n      }\n\n      if (handshaken && event.data.type === `intent-${intent._id}:exposeFrameRemoval`) {\n        return resolve({removeIntentFrame, doc: event.data.document})\n      }\n\n      removeIntentFrame()\n\n      if (event.data.type === `intent-${intent._id}:error`) {\n        return reject(errorSerializer.deserialize(event.data.error))\n      }\n\n      if (handshaken && event.data.type === `intent-${intent._id}:cancel`) {\n        return resolve(null)\n      }\n\n      if (handshaken && event.data.type === `intent-${intent._id}:done`) {\n        return resolve(event.data.document)\n      }\n\n      if (!handshaken) {\n        return reject(new Error('Unexpected handshake message from intent service'))\n      }\n\n      // We may be in a state where the messageHandler is still attached to then\n      // window, but will not be needed anymore. For example, the service failed\n      // before adding the `unload` listener, so no `intent:cancel` message has\n      // never been sent.\n      // So we simply ignore other messages, and this listener will stay here,\n      // waiting for a message which will never come, forever (almost).\n    }\n\n    window.addEventListener('message', messageHandler)\n  })\n}\n\nexport function create (cozy, action, type, data = {}, permissions = []) {\n  if (!action) throw new Error(`Misformed intent, \"action\" property must be provided`)\n  if (!type) throw new Error(`Misformed intent, \"type\" property must be provided`)\n\n  const createPromise = cozyFetchJSON(cozy, 'POST', '/intents', {\n    data: {\n      type: 'io.cozy.intents',\n      attributes: {\n        action: action,\n        type: type,\n        data: data,\n        permissions: permissions\n      }\n    }\n  })\n\n  createPromise.start = (element, onReadyCallback) => {\n    return createPromise.then(intent => {\n      let service = intent.attributes.services && intent.attributes.services[0]\n\n      if (!service) {\n        return Promise.reject(new Error('Unable to find a service'))\n      }\n\n      return injectService(service.href, element, intent, data, onReadyCallback)\n    })\n  }\n\n  return createPromise\n}\n\nfunction listenClientData (intent, window) {\n  return new Promise((resolve, reject) => {\n    const messageEventListener = (event) => {\n      if (event.origin !== intent.attributes.client) return\n\n      window.removeEventListener('message', messageEventListener)\n      resolve(event.data)\n    }\n\n    window.addEventListener('message', messageEventListener)\n    window.parent.postMessage({\n      type: `intent-${intent._id}:ready`\n    }, intent.attributes.client)\n  })\n}\n\n// returns a service to communicate with intent client\nexport function createService (cozy, intentId, serviceWindow) {\n  serviceWindow = serviceWindow || typeof window !== 'undefined' && window\n  if (!serviceWindow) throw new Error('Intent service should be used in browser')\n\n  intentId = intentId || serviceWindow.location.search.split('=')[1]\n  if (!intentId) throw new Error('Cannot retrieve intent from URL')\n\n  return cozyFetchJSON(cozy, 'GET', `/intents/${intentId}`)\n    .then(intent => {\n      let terminated = false\n\n      const terminate = (message) => {\n        if (terminated) throw new Error('Intent service has already been terminated')\n        terminated = true\n        serviceWindow.parent.postMessage(message, intent.attributes.client)\n      }\n\n      const resizeClient = (dimensions, transitionProperty) => {\n        if (terminated) throw new Error('Intent service has been terminated')\n\n        const message = {\n          type: `intent-${intent._id}:resize`,\n          // if a dom element is passed, calculate its size\n          dimensions: dimensions.element\n            ? Object.assign({}, dimensions, {\n              maxHeight: dimensions.element.clientHeight,\n              maxWidth: dimensions.element.clientWidth\n            })\n              : dimensions,\n          transition: transitionProperty\n        }\n\n        serviceWindow.parent.postMessage(message, intent.attributes.client)\n      }\n\n      const cancel = () => {\n        terminate({type: `intent-${intent._id}:cancel`})\n      }\n\n      // Prevent unfulfilled client promises when this window unloads for a\n      // reason or another.\n      serviceWindow.addEventListener('unload', () => {\n        if (!terminated) cancel()\n      })\n\n      return listenClientData(intent, serviceWindow)\n        .then(data => {\n          return {\n            getData: () => data,\n            getIntent: () => intent,\n            terminate: (doc) => {\n              if (data && data.exposeIntentFrameRemoval) {\n                return terminate({\n                  type: `intent-${intent._id}:exposeFrameRemoval`,\n                  document: doc\n                })\n              } else {\n                return terminate({\n                  type: `intent-${intent._id}:done`,\n                  document: doc\n                })\n              }\n            },\n            throw: error => terminate({\n              type: `intent-${intent._id}:error`,\n              error: errorSerializer.serialize(error)\n            }),\n            resizeClient: resizeClient,\n            cancel: cancel\n          }\n        })\n    })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/intents.js","import {cozyFetchJSON} from './fetch'\n\nexport function count (cozy, workerType) {\n  return cozyFetchJSON(cozy, 'GET', `/jobs/queue/${workerType}`)\n    .then(data => data.length)\n}\n\nexport function queued (cozy, workerType) {\n  return cozyFetchJSON(cozy, 'GET', `/jobs/queue/${workerType}`)\n}\n\nexport function create (cozy, workerType, args, options) {\n  return cozyFetchJSON(cozy, 'POST', `/jobs/queue/${workerType}`, {\n    data: {\n      type: 'io.cozy.jobs',\n      attributes: {\n        arguments: args || {},\n        options: options || {}\n      }\n    }\n  })\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/jobs.js","import {warn, createPath, sleep} from './utils'\nimport {normalizeDoctype} from './doctypes'\nimport {cozyFetchJSON, cozyFetchRawJSON} from './fetch'\n\nexport function defineIndex (cozy, doctype, fields) {\n  return cozy.isV2().then((isV2) => {\n    doctype = normalizeDoctype(cozy, isV2, doctype)\n    if (!Array.isArray(fields) || fields.length === 0) {\n      throw new Error('defineIndex fields should be a non-empty array')\n    }\n    if (isV2) {\n      return defineIndexV2(cozy, doctype, fields)\n    } else {\n      return defineIndexV3(cozy, doctype, fields)\n    }\n  })\n}\n\nexport function query (cozy, indexRef, options) {\n  return cozy.isV2().then((isV2) => {\n    if (!indexRef) {\n      throw new Error('query should be passed the indexRef')\n    }\n    if (isV2) {\n      return queryV2(cozy, indexRef, options)\n    } else {\n      return queryV3(cozy, indexRef, options)\n    }\n  })\n}\n\nexport function queryFiles (cozy, indexRef, options) {\n  const opts = getV3Options(indexRef, options)\n  return cozyFetchRawJSON(cozy, 'POST', '/files/_find', opts)\n    .then((response) => options.wholeResponse ? response : response.docs)\n}\n\n// Internals\n\nconst VALUEOPERATORS = ['$eq', '$gt', '$gte', '$lt', '$lte']\nconst LOGICOPERATORS = ['$or', '$and', '$not']\n\n/* eslint-disable */\nconst MAP_TEMPLATE = (function (doc) {\n  if (doc.docType.toLowerCase() === 'DOCTYPEPLACEHOLDER'){\n    emit(FIELDSPLACEHOLDER, doc)\n  }\n}).toString().replace(/ /g, '').replace(/\\n/g, '')\nconst COUCHDB_INFINITY = {\"\\uFFFF\": \"\\uFFFF\"}\nconst COUCHDB_LOWEST = null\n/* eslint-enable */\n\n// defineIndexV2 is equivalent to defineIndex but only works for V2.\n// It transforms the index fields into a map reduce view.\nfunction defineIndexV2 (cozy, doctype, fields) {\n  let indexName = 'by' + fields.map(capitalize).join('')\n  let indexDefinition = { map: makeMapFunction(doctype, fields), reduce: '_count' }\n  let path = `/request/${doctype}/${indexName}/`\n  return cozyFetchJSON(cozy, 'PUT', path, indexDefinition)\n    .then(() => ({ doctype: doctype, type: 'mapreduce', name: indexName, fields: fields }))\n}\n\nfunction defineIndexV3 (cozy, doctype, fields) {\n  let path = createPath(cozy, false, doctype, '_index')\n  let indexDefinition = {'index': {fields}}\n  return cozyFetchJSON(cozy, 'POST', path, indexDefinition)\n    .then((response) => {\n      const indexResult = { doctype: doctype, type: 'mango', name: response.id, fields }\n\n      if (response.result === 'exists') return indexResult\n\n      // indexes might not be usable right after being created; so we delay the resolving until they are\n      const selector = {}\n      selector[fields[0]] = {'$gt': null}\n\n      const opts = getV3Options(indexResult, {'selector': selector})\n      let path = createPath(cozy, false, indexResult.doctype, '_find')\n      return cozyFetchJSON(cozy, 'POST', path, opts)\n      .then(() => indexResult)\n      .catch(() => { // one retry\n        return sleep(1000)\n        .then(() => cozyFetchJSON(cozy, 'POST', path, opts))\n        .then(() => indexResult)\n        .catch(() => {\n          return sleep(500).then(() => indexResult)\n        })\n      })\n    })\n}\n\n// queryV2 is equivalent to query but only works for V2.\n// It transforms the query into a _views call using makeMapReduceQuery\nfunction queryV2 (cozy, indexRef, options) {\n  if (indexRef.type !== 'mapreduce') {\n    throw new Error('query indexRef should be the return value of defineIndexV2')\n  }\n  if (options.fields) {\n    warn('query fields will be ignored on v2')\n  }\n\n  let path = `/request/${indexRef.doctype}/${indexRef.name}/`\n  let opts = makeMapReduceQuery(indexRef, options)\n  return cozyFetchJSON(cozy, 'POST', path, opts)\n    .then((response) => response.map(r => r.value))\n}\n\n// queryV3 is equivalent to query but only works for V3\nfunction queryV3 (cozy, indexRef, options) {\n  const opts = getV3Options(indexRef, options)\n\n  let path = createPath(cozy, false, indexRef.doctype, '_find')\n  return cozyFetchJSON(cozy, 'POST', path, opts)\n    .then((response) => options.wholeResponse ? response : response.docs)\n}\n\nfunction getV3Options (indexRef, options) {\n  if (indexRef.type !== 'mango') {\n    throw new Error('indexRef should be the return value of defineIndexV3')\n  }\n\n  let opts = {\n    use_index: indexRef.name,\n    fields: options.fields,\n    selector: options.selector,\n    limit: options.limit,\n    skip: options.skip,\n    since: options.since,\n    sort: options.sort\n  }\n\n  if (options.descending) {\n    opts.sort = indexRef.fields.map(f => ({ [f]: 'desc' }))\n  }\n\n  return opts\n}\n\n// misc\nfunction capitalize (name) {\n  return name.charAt(0).toUpperCase() + name.slice(1)\n}\n\nfunction makeMapFunction (doctype, fields) {\n  fields = '[' + fields.map(name => 'doc.' + name).join(',') + ']'\n\n  return MAP_TEMPLATE.replace('DOCTYPEPLACEHOLDER', doctype.toLowerCase())\n                     .replace('FIELDSPLACEHOLDER', fields)\n}\n\n// parseSelector takes a mango selector and returns it as an array of filter\n// a filter is [path, operator, value] array\n// a path is an array of field names\n// This function is only exported so it can be unit tested.\n// Example :\n// parseSelector({\"test\":{\"deep\": {\"$gt\": 3}}})\n// [[['test', 'deep'], '$gt', 3 ]]\nexport function parseSelector (selector, path = [], operator = '$eq') {\n  if ((typeof selector) !== 'object') {\n    return [[path, operator, selector]]\n  }\n\n  let keys = Object.keys(selector)\n  if (keys.length === 0) {\n    throw new Error('empty selector')\n  } else {\n    return keys.reduce(function (acc, k) {\n      if (LOGICOPERATORS.indexOf(k) !== -1) {\n        throw new Error('cozy-client-js does not support mango logic ops')\n      } else if (VALUEOPERATORS.indexOf(k) !== -1) {\n        return acc.concat(parseSelector(selector[k], path, k))\n      } else {\n        return acc.concat(parseSelector(selector[k], path.concat(k), '$eq'))\n      }\n    }, [])\n  }\n}\n\n// normalizeSelector takes a mango selector and returns it as an object\n// normalized.\n// This function is only exported so it can be unit tested.\n// Example :\n// parseSelector({\"test\":{\"deep\": {\"$gt\": 3}}})\n// {\"test.deep\": {\"$gt\": 3}}\nexport function normalizeSelector (selector) {\n  var filters = parseSelector(selector)\n  return filters.reduce(function (acc, filter) {\n    let [path, op, value] = filter\n    let field = path.join('.')\n    acc[field] = acc[field] || {}\n    acc[field][op] = value\n    return acc\n  }, {})\n}\n\n// applySelector takes the normalized selector for the current field\n// and append the proper values to opts.startkey, opts.endkey\nfunction applySelector (selector, opts) {\n  let value = selector['$eq']\n  let lower = COUCHDB_LOWEST\n  let upper = COUCHDB_INFINITY\n  let inclusiveEnd\n\n  if (value) {\n    opts.startkey.push(value)\n    opts.endkey.push(value)\n    return false\n  }\n\n  value = selector['$gt']\n  if (value) {\n    throw new Error('operator $gt (strict greater than) not supported')\n  }\n\n  value = selector['$gte']\n  if (value) {\n    lower = value\n  }\n\n  value = selector['$lte']\n  if (value) {\n    upper = value\n    inclusiveEnd = true\n  }\n\n  value = selector['$lt']\n  if (value) {\n    upper = value\n    inclusiveEnd = false\n  }\n\n  opts.startkey.push(lower)\n  opts.endkey.push(upper)\n  if (inclusiveEnd !== undefined) opts.inclusive_end = inclusiveEnd\n  return true\n}\n\n// makeMapReduceQuery takes a mango query and generate _views call parameters\n// to obtain same results depending on fields in the passed indexRef.\nexport function makeMapReduceQuery (indexRef, query) {\n  let mrquery = {\n    startkey: [],\n    endkey: [],\n    reduce: false\n  }\n  let firstFreeValueField = null\n  let normalizedSelector = normalizeSelector(query.selector)\n\n  indexRef.fields.forEach(function (field) {\n    let selector = normalizedSelector[field]\n\n    if (selector && firstFreeValueField != null) {\n      throw new Error('Selector on field ' + field + ', but not on ' + firstFreeValueField + ' which is higher in index fields.')\n    } else if (selector) {\n      selector.used = true\n      let isFreeValue = applySelector(selector, mrquery)\n      if (isFreeValue) firstFreeValueField = field\n    } else if (firstFreeValueField == null) {\n      firstFreeValueField = field\n      mrquery.endkey.push(COUCHDB_INFINITY)\n    }\n  })\n\n  Object.keys(normalizedSelector).forEach(function (field) {\n    if (!normalizedSelector[field].used) {\n      throw new Error('Cant apply selector on ' + field + ', it is not in index')\n    }\n  })\n\n  if (query.descending) {\n    mrquery = {\n      descending: true,\n      reduce: false,\n      startkey: mrquery.endkey,\n      endkey: mrquery.startkey,\n      inclusive_end: mrquery.inclusive_end\n    }\n  }\n\n  return mrquery\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/mango.js","/* global pouchdbAdapterCordovaSqlite */\nimport {DOCTYPE_FILES} from './doctypes'\nimport {refreshToken} from './auth_v3'\nimport {isOffline} from './utils'\nimport PouchDB from 'pouchdb'\nimport pouchdbFind from 'pouchdb-find'\n\nexport const replicationOfflineError = 'Replication abort, your device is actually offline.'\n\nlet pluginLoaded = false\n\n/*\n  For each doctype we have some parameters:\n  cozy._offline[doctype] = {\n    database: pouchdb database\n    replication: the pouchdb replication\n    replicationPromise: promise of replication\n    interval: repeated replication interval\n  }\n*/\n\nexport function init (cozy, { options = {}, doctypes = [] }) {\n  for (let doctype of doctypes) {\n    createDatabase(cozy, doctype, options)\n  }\n}\n\n// helper\n\nfunction getInfo (cozy, doctype) {\n  cozy._offline = cozy._offline || []\n  cozy._offline[doctype] = cozy._offline[doctype] || {}\n  return cozy._offline[doctype]\n}\n\nexport function getDoctypes (cozy) {\n  cozy._offline = cozy._offline || []\n  return Object.keys(cozy._offline)\n}\n\n//\n// DATABASE\n//\n\nexport function hasDatabase (cozy, doctype) {\n  return getDatabase(cozy, doctype) !== undefined\n}\n\nexport function getDatabase (cozy, doctype) {\n  return getInfo(cozy, doctype).database\n}\n\nexport function setDatabase (cozy, doctype, database) {\n  cozy._offline[doctype].database = database\n  return getDatabase(cozy, doctype)\n}\n\nexport function createDatabase (cozy, doctype, options = {}) {\n  if (!pluginLoaded) {\n    PouchDB.plugin(pouchdbFind)\n    if (typeof pouchdbAdapterCordovaSqlite !== 'undefined') PouchDB.plugin(pouchdbAdapterCordovaSqlite)\n    pluginLoaded = true\n  }\n\n  if (hasDatabase(cozy, doctype)) {\n    return Promise.resolve(getDatabase(cozy, doctype))\n  }\n\n  setDatabase(cozy, doctype, new PouchDB(doctype, options))\n  return createIndexes(cozy, doctype).then(() => getDatabase(cozy, doctype))\n}\n\nexport function destroyDatabase (cozy, doctype) {\n  if (!hasDatabase(cozy, doctype)) {\n    return Promise.resolve(false)\n  }\n\n  return stopRepeatedReplication(cozy, doctype)\n    .then(() => stopReplication(cozy, doctype))\n    .then(() => getDatabase(cozy, doctype).destroy())\n    .then(response => {\n      setDatabase(cozy, doctype, undefined)\n      return response\n    })\n}\n\nexport function destroyAllDatabase (cozy) {\n  const doctypes = getDoctypes(cozy)\n  const destroy = (doctype) => destroyDatabase(cozy, doctype)\n  return Promise.all(doctypes.map(destroy))\n}\n\nfunction createIndexes (cozy, doctype) {\n  if (doctype === DOCTYPE_FILES) {\n    return getDatabase(cozy, doctype).createIndex({index: {fields: ['dir_id']}})\n  }\n  return Promise.resolve()\n}\n\n//\n// REPLICATION\n//\n\nexport function hasReplication (cozy, doctype) {\n  return getReplication(cozy, doctype) !== undefined\n}\n\nfunction getReplication (cozy, doctype) {\n  return getInfo(cozy, doctype).replication\n}\n\nfunction setReplication (cozy, doctype, replication) {\n  cozy._offline[doctype].replication = replication\n  return getReplication(cozy, doctype)\n}\n\nfunction getReplicationUrl (cozy, doctype) {\n  return cozy.authorize()\n    .then(credentials => {\n      const basic = credentials.token.toBasicAuth()\n      return (cozy._url + '/data/' + doctype).replace('//', `//${basic}`)\n    })\n}\n\nfunction getReplicationPromise (cozy, doctype) {\n  return getInfo(cozy, doctype).replicationPromise\n}\n\nfunction setReplicationPromise (cozy, doctype, promise) {\n  cozy._offline[doctype].replicationPromise = promise\n  return getReplicationPromise(cozy, doctype)\n}\n\nexport function replicateFromCozy (cozy, doctype, options = {}) {\n  return setReplicationPromise(cozy, doctype, new Promise((resolve, reject) => {\n    if (!hasDatabase(cozy, doctype)) {\n      createDatabase(cozy, doctype)\n    }\n    if (options.live === true) {\n      return reject(new Error('You can\\'t use `live` option with Cozy couchdb.'))\n    }\n\n    if (isOffline()) {\n      reject(replicationOfflineError)\n      options.onError && options.onError(replicationOfflineError)\n      return\n    }\n\n    getReplicationUrl(cozy, doctype)\n      .then(url => setReplication(cozy, doctype,\n        getDatabase(cozy, doctype).replicate.from(url, options).on('complete', (info) => {\n          setReplication(cozy, doctype, undefined)\n          resolve(info)\n          options.onComplete && options.onComplete(info)\n        }).on('error', (err) => {\n          if (err.error === 'code=400, message=Expired token') {\n            cozy.authorize().then(({client, token}) => {\n              refreshToken(cozy, client, token)\n                .then((newToken) => cozy.saveCredentials(client, newToken))\n                .then((credentials) => replicateFromCozy(cozy, doctype, options))\n            })\n          } else {\n            console.warn(`ReplicateFromCozy '${doctype}' Error:`)\n            console.warn(err)\n            setReplication(cozy, doctype, undefined)\n            reject(err)\n            options.onError && options.onError(err)\n          }\n        })\n      ))\n  }))\n}\n\nexport function stopReplication (cozy, doctype) {\n  if (!getDatabase(cozy, doctype) || !hasReplication(cozy, doctype)) {\n    return Promise.resolve()\n  }\n\n  return new Promise(resolve => {\n    try {\n      getReplicationPromise(cozy, doctype).then(() => {\n        resolve()\n      })\n      getReplication(cozy, doctype).cancel()\n      // replication is set to undefined by complete replication\n    } catch (e) {\n      resolve()\n    }\n  })\n}\n\nexport function stopAllReplication (cozy) {\n  const doctypes = getDoctypes(cozy)\n  const stop = (doctype) => stopReplication(cozy, doctype)\n  return Promise.all(doctypes.map(stop))\n}\n\n//\n// REPEATED REPLICATION\n//\n\nfunction getRepeatedReplication (cozy, doctype) {\n  return getInfo(cozy, doctype).interval\n}\n\nfunction setRepeatedReplication (cozy, doctype, interval) {\n  cozy._offline[doctype].interval = interval\n}\n\nexport function hasRepeatedReplication (cozy, doctype) {\n  return getRepeatedReplication(cozy, doctype) !== undefined\n}\n\nexport function startRepeatedReplication (cozy, doctype, timer, options = {}) {\n  // TODO: add timer limitation for not flooding Gozy\n  if (hasRepeatedReplication(cozy, doctype)) {\n    return getRepeatedReplication(cozy, doctype)\n  }\n\n  return setRepeatedReplication(cozy, doctype, setInterval(() => {\n    if (isOffline()) {\n      // network is offline, replication cannot be launched\n      console.info(replicationOfflineError)\n      return\n    }\n    if (!hasReplication(cozy, doctype)) {\n      replicateFromCozy(cozy, doctype, options)\n      // TODO: add replicationToCozy\n    }\n  }, timer * 1000))\n}\n\nexport function stopRepeatedReplication (cozy, doctype) {\n  if (hasRepeatedReplication(cozy, doctype)) {\n    clearInterval(getRepeatedReplication(cozy, doctype))\n    setRepeatedReplication(cozy, doctype, undefined)\n  }\n  if (hasReplication(cozy, doctype)) {\n    return stopReplication(cozy, doctype)\n  }\n\n  return Promise.resolve()\n}\n\nexport function stopAllRepeatedReplication (cozy) {\n  const doctypes = getDoctypes(cozy)\n  const stop = (doctype) => stopRepeatedReplication(cozy, doctype)\n  return Promise.all(doctypes.map(stop))\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/offline.js","import { cozyFetchJSON, cozyFetchRawJSON } from './fetch'\nimport { DOCTYPE_FILES } from './doctypes'\n\nfunction updateRelations (verb) {\n  return function (cozy, doc, ids) {\n    if (!doc) throw new Error('missing doc argument')\n    if (!Array.isArray(ids)) ids = [ids]\n\n    const refs = ids.map((id) => ({type: DOCTYPE_FILES, id}))\n\n    return cozyFetchJSON(cozy, verb, makeReferencesPath(doc), {data: refs})\n  }\n}\n\nexport const addReferencedFiles = updateRelations('POST')\nexport const removeReferencedFiles = updateRelations('DELETE')\n\nexport function listReferencedFiles (cozy, doc) {\n  if (!doc) throw new Error('missing doc argument')\n  return cozyFetchJSON(cozy, 'GET', makeReferencesPath(doc))\n    .then((files) => files.map((file) => file._id))\n}\n\nexport function fetchReferencedFiles (cozy, doc, options) {\n  if (!doc) throw new Error('missing doc argument')\n  const params = Object.keys(options).map(key => `&page[${key}]=${options[key]}`).join('')\n  // As datetime is the only sort option available, I see no reason to not have it by default\n  return cozyFetchRawJSON(cozy, 'GET', `${makeReferencesPath(doc)}?include=files&sort=datetime${params}`)\n}\n\nfunction makeReferencesPath (doc) {\n  const type = encodeURIComponent(doc._type)\n  const id = encodeURIComponent(doc._id)\n  return `/data/${type}/${id}/relationships/references`\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/relations.js","import {cozyFetchJSON} from './fetch'\n\nexport function diskUsage (cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/settings/disk-usage`)\n}\n\nexport function changePassphrase (cozy, currentPassPhrase, newPassPhrase) {\n  return cozyFetchJSON(cozy, 'PUT', `/settings/passphrase`, {\n    current_passphrase: currentPassPhrase,\n    new_passphrase: newPassPhrase\n  })\n}\n\nexport function getInstance (cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/settings/instance`)\n}\n\nexport function updateInstance (cozy, instance) {\n  return cozyFetchJSON(cozy, 'PUT', `/settings/instance`, instance)\n}\n\nexport function getClients (cozy) {\n  return cozyFetchJSON(cozy, 'GET', `/settings/clients`)\n}\n\nexport function deleteClientById (cozy, id) {\n  return cozyFetchJSON(cozy, 'DELETE', `/settings/clients/${id}`)\n}\n\nexport function updateLastSync (cozy) {\n  return cozyFetchJSON(cozy, 'POST', '/settings/synchronized')\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/settings.js","var isObject = require('./_is-object')\n  , isArray  = require('./_is-array')\n  , SPECIES  = require('./_wks')('species');\n\nmodule.exports = function(original){\n  var C;\n  if(isArray(original)){\n    C = original.constructor;\n    // cross-realm fallback\n    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;\n    if(isObject(C)){\n      C = C[SPECIES];\n      if(C === null)C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_array-species-constructor.js\n// module id = 120\n// module chunks = 0","// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = require('./_array-species-constructor');\n\nmodule.exports = function(original, length){\n  return new (speciesConstructor(original))(length);\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_array-species-create.js\n// module id = 121\n// module chunks = 0","'use strict';\nvar aFunction  = require('./_a-function')\n  , isObject   = require('./_is-object')\n  , invoke     = require('./_invoke')\n  , arraySlice = [].slice\n  , factories  = {};\n\nvar construct = function(F, len, args){\n  if(!(len in factories)){\n    for(var n = [], i = 0; i < len; i++)n[i] = 'a[' + i + ']';\n    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');\n  } return factories[len](F, args);\n};\n\nmodule.exports = Function.bind || function bind(that /*, args... */){\n  var fn       = aFunction(this)\n    , partArgs = arraySlice.call(arguments, 1);\n  var bound = function(/* args... */){\n    var args = partArgs.concat(arraySlice.call(arguments));\n    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);\n  };\n  if(isObject(fn.prototype))bound.prototype = fn.prototype;\n  return bound;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_bind.js\n// module id = 122\n// module chunks = 0","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys')\n  , gOPS    = require('./_object-gops')\n  , pIE     = require('./_object-pie');\nmodule.exports = function(it){\n  var result     = getKeys(it)\n    , getSymbols = gOPS.f;\n  if(getSymbols){\n    var symbols = getSymbols(it)\n      , isEnum  = pIE.f\n      , i       = 0\n      , key;\n    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);\n  } return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_enum-keys.js\n// module id = 123\n// module chunks = 0","'use strict';\n// 21.2.5.3 get RegExp.prototype.flags\nvar anObject = require('./_an-object');\nmodule.exports = function(){\n  var that   = anObject(this)\n    , result = '';\n  if(that.global)     result += 'g';\n  if(that.ignoreCase) result += 'i';\n  if(that.multiline)  result += 'm';\n  if(that.unicode)    result += 'u';\n  if(that.sticky)     result += 'y';\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_flags.js\n// module id = 124\n// module chunks = 0","var isObject       = require('./_is-object')\n  , setPrototypeOf = require('./_set-proto').set;\nmodule.exports = function(that, target, C){\n  var P, S = target.constructor;\n  if(S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf){\n    setPrototypeOf(that, P);\n  } return that;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_inherit-if-required.js\n// module id = 125\n// module chunks = 0","'use strict';\nvar create         = require('./_object-create')\n  , descriptor     = require('./_property-desc')\n  , setToStringTag = require('./_set-to-string-tag')\n  , IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function(){ return this; });\n\nmodule.exports = function(Constructor, NAME, next){\n  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_iter-create.js\n// module id = 126\n// module chunks = 0","var getKeys   = require('./_object-keys')\n  , toIObject = require('./_to-iobject');\nmodule.exports = function(object, el){\n  var O      = toIObject(object)\n    , keys   = getKeys(O)\n    , length = keys.length\n    , index  = 0\n    , key;\n  while(length > index)if(O[key = keys[index++]] === el)return key;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_keyof.js\n// module id = 127\n// module chunks = 0","var global    = require('./_global')\n  , macrotask = require('./_task').set\n  , Observer  = global.MutationObserver || global.WebKitMutationObserver\n  , process   = global.process\n  , Promise   = global.Promise\n  , isNode    = require('./_cof')(process) == 'process';\n\nmodule.exports = function(){\n  var head, last, notify;\n\n  var flush = function(){\n    var parent, fn;\n    if(isNode && (parent = process.domain))parent.exit();\n    while(head){\n      fn   = head.fn;\n      head = head.next;\n      try {\n        fn();\n      } catch(e){\n        if(head)notify();\n        else last = undefined;\n        throw e;\n      }\n    } last = undefined;\n    if(parent)parent.enter();\n  };\n\n  // Node.js\n  if(isNode){\n    notify = function(){\n      process.nextTick(flush);\n    };\n  // browsers with MutationObserver\n  } else if(Observer){\n    var toggle = true\n      , node   = document.createTextNode('');\n    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new\n    notify = function(){\n      node.data = toggle = !toggle;\n    };\n  // environments with maybe non-completely correct, but existent Promise\n  } else if(Promise && Promise.resolve){\n    var promise = Promise.resolve();\n    notify = function(){\n      promise.then(flush);\n    };\n  // for other environments - macrotask based on:\n  // - setImmediate\n  // - MessageChannel\n  // - window.postMessag\n  // - onreadystatechange\n  // - setTimeout\n  } else {\n    notify = function(){\n      // strange IE + webpack dev server bug - use .call(global)\n      macrotask.call(global, flush);\n    };\n  }\n\n  return function(fn){\n    var task = {fn: fn, next: undefined};\n    if(last)last.next = task;\n    if(!head){\n      head = task;\n      notify();\n    } last = task;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_microtask.js\n// module id = 128\n// module chunks = 0","var dP       = require('./_object-dp')\n  , anObject = require('./_an-object')\n  , getKeys  = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties){\n  anObject(O);\n  var keys   = getKeys(Properties)\n    , length = keys.length\n    , i = 0\n    , P;\n  while(length > i)dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-dps.js\n// module id = 129\n// module chunks = 0","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject')\n  , gOPN      = require('./_object-gopn').f\n  , toString  = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function(it){\n  try {\n    return gOPN(it);\n  } catch(e){\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it){\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_object-gopn-ext.js\n// module id = 130\n// module chunks = 0","'use strict';\nvar path      = require('./_path')\n  , invoke    = require('./_invoke')\n  , aFunction = require('./_a-function');\nmodule.exports = function(/* ...pargs */){\n  var fn     = aFunction(this)\n    , length = arguments.length\n    , pargs  = Array(length)\n    , i      = 0\n    , _      = path._\n    , holder = false;\n  while(length > i)if((pargs[i] = arguments[i++]) === _)holder = true;\n  return function(/* ...args */){\n    var that = this\n      , aLen = arguments.length\n      , j = 0, k = 0, args;\n    if(!holder && !aLen)return invoke(fn, pargs, that);\n    args = pargs.slice();\n    if(holder)for(;length > j; j++)if(args[j] === _)args[j] = arguments[k++];\n    while(aLen > k)args.push(arguments[k++]);\n    return invoke(fn, args, that);\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_partial.js\n// module id = 131\n// module chunks = 0","module.exports = require('./_global');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_path.js\n// module id = 132\n// module chunks = 0","var toInteger = require('./_to-integer')\n  , defined   = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function(TO_STRING){\n  return function(that, pos){\n    var s = String(defined(that))\n      , i = toInteger(pos)\n      , l = s.length\n      , a, b;\n    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_string-at.js\n// module id = 133\n// module chunks = 0","var global         = require('./_global')\n  , core           = require('./_core')\n  , LIBRARY        = require('./_library')\n  , wksExt         = require('./_wks-ext')\n  , defineProperty = require('./_object-dp').f;\nmodule.exports = function(name){\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/_wks-define.js\n// module id = 134\n// module chunks = 0","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', {copyWithin: require('./_array-copy-within')});\n\nrequire('./_add-to-unscopables')('copyWithin');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.array.copy-within.js\n// module id = 135\n// module chunks = 0","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\nvar $export = require('./_export');\n\n$export($export.P, 'Array', {fill: require('./_array-fill')});\n\nrequire('./_add-to-unscopables')('fill');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.array.fill.js\n// module id = 136\n// module chunks = 0","'use strict';\n// 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)\nvar $export = require('./_export')\n  , $find   = require('./_array-methods')(6)\n  , KEY     = 'findIndex'\n  , forced  = true;\n// Shouldn't skip holes\nif(KEY in [])Array(1)[KEY](function(){ forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  findIndex: function findIndex(callbackfn/*, that = undefined */){\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.array.find-index.js\n// module id = 137\n// module chunks = 0","'use strict';\n// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)\nvar $export = require('./_export')\n  , $find   = require('./_array-methods')(5)\n  , KEY     = 'find'\n  , forced  = true;\n// Shouldn't skip holes\nif(KEY in [])Array(1)[KEY](function(){ forced = false; });\n$export($export.P + $export.F * forced, 'Array', {\n  find: function find(callbackfn/*, that = undefined */){\n    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\nrequire('./_add-to-unscopables')(KEY);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.array.find.js\n// module id = 138\n// module chunks = 0","'use strict';\nvar ctx            = require('./_ctx')\n  , $export        = require('./_export')\n  , toObject       = require('./_to-object')\n  , call           = require('./_iter-call')\n  , isArrayIter    = require('./_is-array-iter')\n  , toLength       = require('./_to-length')\n  , createProperty = require('./_create-property')\n  , getIterFn      = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function(iter){ Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){\n    var O       = toObject(arrayLike)\n      , C       = typeof this == 'function' ? this : Array\n      , aLen    = arguments.length\n      , mapfn   = aLen > 1 ? arguments[1] : undefined\n      , mapping = mapfn !== undefined\n      , index   = 0\n      , iterFn  = getIterFn(O)\n      , length, result, step, iterator;\n    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){\n      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for(result = new C(length); length > index; index++){\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.array.from.js\n// module id = 139\n// module chunks = 0","'use strict';\nvar $export        = require('./_export')\n  , createProperty = require('./_create-property');\n\n// WebKit Array.of isn't generic\n$export($export.S + $export.F * require('./_fails')(function(){\n  function F(){}\n  return !(Array.of.call(F) instanceof F);\n}), 'Array', {\n  // 22.1.2.3 Array.of( ...items)\n  of: function of(/* ...args */){\n    var index  = 0\n      , aLen   = arguments.length\n      , result = new (typeof this == 'function' ? this : Array)(aLen);\n    while(aLen > index)createProperty(result, index, arguments[index++]);\n    result.length = aLen;\n    return result;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.array.of.js\n// module id = 140\n// module chunks = 0","var dP         = require('./_object-dp').f\n  , createDesc = require('./_property-desc')\n  , has        = require('./_has')\n  , FProto     = Function.prototype\n  , nameRE     = /^\\s*function ([^ (]*)/\n  , NAME       = 'name';\n\nvar isExtensible = Object.isExtensible || function(){\n  return true;\n};\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function(){\n    try {\n      var that = this\n        , name = ('' + that).match(nameRE)[1];\n      has(that, NAME) || !isExtensible(that) || dP(that, NAME, createDesc(5, name));\n      return name;\n    } catch(e){\n      return '';\n    }\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.function.name.js\n// module id = 141\n// module chunks = 0","'use strict';\nvar strong = require('./_collection-strong');\n\n// 23.1 Map Objects\nmodule.exports = require('./_collection')('Map', function(get){\n  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.1.3.6 Map.prototype.get(key)\n  get: function get(key){\n    var entry = strong.getEntry(this, key);\n    return entry && entry.v;\n  },\n  // 23.1.3.9 Map.prototype.set(key, value)\n  set: function set(key, value){\n    return strong.def(this, key === 0 ? 0 : key, value);\n  }\n}, strong, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.map.js\n// module id = 142\n// module chunks = 0","// 20.2.2.3 Math.acosh(x)\nvar $export = require('./_export')\n  , log1p   = require('./_math-log1p')\n  , sqrt    = Math.sqrt\n  , $acosh  = Math.acosh;\n\n$export($export.S + $export.F * !($acosh\n  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509\n  && Math.floor($acosh(Number.MAX_VALUE)) == 710\n  // Tor Browser bug: Math.acosh(Infinity) -> NaN \n  && $acosh(Infinity) == Infinity\n), 'Math', {\n  acosh: function acosh(x){\n    return (x = +x) < 1 ? NaN : x > 94906265.62425156\n      ? Math.log(x) + Math.LN2\n      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.acosh.js\n// module id = 143\n// module chunks = 0","// 20.2.2.5 Math.asinh(x)\nvar $export = require('./_export')\n  , $asinh  = Math.asinh;\n\nfunction asinh(x){\n  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));\n}\n\n// Tor Browser bug: Math.asinh(0) -> -0 \n$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {asinh: asinh});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.asinh.js\n// module id = 144\n// module chunks = 0","// 20.2.2.7 Math.atanh(x)\nvar $export = require('./_export')\n  , $atanh  = Math.atanh;\n\n// Tor Browser bug: Math.atanh(-0) -> 0 \n$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {\n  atanh: function atanh(x){\n    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.atanh.js\n// module id = 145\n// module chunks = 0","// 20.2.2.9 Math.cbrt(x)\nvar $export = require('./_export')\n  , sign    = require('./_math-sign');\n\n$export($export.S, 'Math', {\n  cbrt: function cbrt(x){\n    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.cbrt.js\n// module id = 146\n// module chunks = 0","// 20.2.2.11 Math.clz32(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  clz32: function clz32(x){\n    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.clz32.js\n// module id = 147\n// module chunks = 0","// 20.2.2.12 Math.cosh(x)\nvar $export = require('./_export')\n  , exp     = Math.exp;\n\n$export($export.S, 'Math', {\n  cosh: function cosh(x){\n    return (exp(x = +x) + exp(-x)) / 2;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.cosh.js\n// module id = 148\n// module chunks = 0","// 20.2.2.14 Math.expm1(x)\nvar $export = require('./_export')\n  , $expm1  = require('./_math-expm1');\n\n$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {expm1: $expm1});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.expm1.js\n// module id = 149\n// module chunks = 0","// 20.2.2.16 Math.fround(x)\nvar $export   = require('./_export')\n  , sign      = require('./_math-sign')\n  , pow       = Math.pow\n  , EPSILON   = pow(2, -52)\n  , EPSILON32 = pow(2, -23)\n  , MAX32     = pow(2, 127) * (2 - EPSILON32)\n  , MIN32     = pow(2, -126);\n\nvar roundTiesToEven = function(n){\n  return n + 1 / EPSILON - 1 / EPSILON;\n};\n\n\n$export($export.S, 'Math', {\n  fround: function fround(x){\n    var $abs  = Math.abs(x)\n      , $sign = sign(x)\n      , a, result;\n    if($abs < MIN32)return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;\n    a = (1 + EPSILON32 / EPSILON) * $abs;\n    result = a - (a - $abs);\n    if(result > MAX32 || result != result)return $sign * Infinity;\n    return $sign * result;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.fround.js\n// module id = 150\n// module chunks = 0","// 20.2.2.17 Math.hypot([value1[, value2[, â¦ ]]])\nvar $export = require('./_export')\n  , abs     = Math.abs;\n\n$export($export.S, 'Math', {\n  hypot: function hypot(value1, value2){ // eslint-disable-line no-unused-vars\n    var sum  = 0\n      , i    = 0\n      , aLen = arguments.length\n      , larg = 0\n      , arg, div;\n    while(i < aLen){\n      arg = abs(arguments[i++]);\n      if(larg < arg){\n        div  = larg / arg;\n        sum  = sum * div * div + 1;\n        larg = arg;\n      } else if(arg > 0){\n        div  = arg / larg;\n        sum += div * div;\n      } else sum += arg;\n    }\n    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.hypot.js\n// module id = 151\n// module chunks = 0","// 20.2.2.18 Math.imul(x, y)\nvar $export = require('./_export')\n  , $imul   = Math.imul;\n\n// some WebKit versions fails with big numbers, some has wrong arity\n$export($export.S + $export.F * require('./_fails')(function(){\n  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;\n}), 'Math', {\n  imul: function imul(x, y){\n    var UINT16 = 0xffff\n      , xn = +x\n      , yn = +y\n      , xl = UINT16 & xn\n      , yl = UINT16 & yn;\n    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.imul.js\n// module id = 152\n// module chunks = 0","// 20.2.2.21 Math.log10(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log10: function log10(x){\n    return Math.log(x) / Math.LN10;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.log10.js\n// module id = 153\n// module chunks = 0","// 20.2.2.20 Math.log1p(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {log1p: require('./_math-log1p')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.log1p.js\n// module id = 154\n// module chunks = 0","// 20.2.2.22 Math.log2(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  log2: function log2(x){\n    return Math.log(x) / Math.LN2;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.log2.js\n// module id = 155\n// module chunks = 0","// 20.2.2.28 Math.sign(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {sign: require('./_math-sign')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.sign.js\n// module id = 156\n// module chunks = 0","// 20.2.2.30 Math.sinh(x)\nvar $export = require('./_export')\n  , expm1   = require('./_math-expm1')\n  , exp     = Math.exp;\n\n// V8 near Chromium 38 has a problem with very small numbers\n$export($export.S + $export.F * require('./_fails')(function(){\n  return !Math.sinh(-2e-17) != -2e-17;\n}), 'Math', {\n  sinh: function sinh(x){\n    return Math.abs(x = +x) < 1\n      ? (expm1(x) - expm1(-x)) / 2\n      : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.sinh.js\n// module id = 157\n// module chunks = 0","// 20.2.2.33 Math.tanh(x)\nvar $export = require('./_export')\n  , expm1   = require('./_math-expm1')\n  , exp     = Math.exp;\n\n$export($export.S, 'Math', {\n  tanh: function tanh(x){\n    var a = expm1(x = +x)\n      , b = expm1(-x);\n    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.tanh.js\n// module id = 158\n// module chunks = 0","// 20.2.2.34 Math.trunc(x)\nvar $export = require('./_export');\n\n$export($export.S, 'Math', {\n  trunc: function trunc(it){\n    return (it > 0 ? Math.floor : Math.ceil)(it);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.math.trunc.js\n// module id = 159\n// module chunks = 0","// 20.1.2.1 Number.EPSILON\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {EPSILON: Math.pow(2, -52)});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.number.epsilon.js\n// module id = 160\n// module chunks = 0","// 20.1.2.2 Number.isFinite(number)\nvar $export   = require('./_export')\n  , _isFinite = require('./_global').isFinite;\n\n$export($export.S, 'Number', {\n  isFinite: function isFinite(it){\n    return typeof it == 'number' && _isFinite(it);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.number.is-finite.js\n// module id = 161\n// module chunks = 0","// 20.1.2.3 Number.isInteger(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {isInteger: require('./_is-integer')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.number.is-integer.js\n// module id = 162\n// module chunks = 0","// 20.1.2.4 Number.isNaN(number)\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {\n  isNaN: function isNaN(number){\n    return number != number;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.number.is-nan.js\n// module id = 163\n// module chunks = 0","// 20.1.2.5 Number.isSafeInteger(number)\nvar $export   = require('./_export')\n  , isInteger = require('./_is-integer')\n  , abs       = Math.abs;\n\n$export($export.S, 'Number', {\n  isSafeInteger: function isSafeInteger(number){\n    return isInteger(number) && abs(number) <= 0x1fffffffffffff;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.number.is-safe-integer.js\n// module id = 164\n// module chunks = 0","// 20.1.2.6 Number.MAX_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {MAX_SAFE_INTEGER: 0x1fffffffffffff});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.number.max-safe-integer.js\n// module id = 165\n// module chunks = 0","// 20.1.2.10 Number.MIN_SAFE_INTEGER\nvar $export = require('./_export');\n\n$export($export.S, 'Number', {MIN_SAFE_INTEGER: -0x1fffffffffffff});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.number.min-safe-integer.js\n// module id = 166\n// module chunks = 0","// 19.1.3.1 Object.assign(target, source)\nvar $export = require('./_export');\n\n$export($export.S + $export.F, 'Object', {assign: require('./_object-assign')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.object.assign.js\n// module id = 167\n// module chunks = 0","// 19.1.3.10 Object.is(value1, value2)\nvar $export = require('./_export');\n$export($export.S, 'Object', {is: require('./_same-value')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.object.is.js\n// module id = 168\n// module chunks = 0","// 19.1.3.19 Object.setPrototypeOf(O, proto)\nvar $export = require('./_export');\n$export($export.S, 'Object', {setPrototypeOf: require('./_set-proto').set});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.object.set-prototype-of.js\n// module id = 169\n// module chunks = 0","'use strict';\nvar LIBRARY            = require('./_library')\n  , global             = require('./_global')\n  , ctx                = require('./_ctx')\n  , classof            = require('./_classof')\n  , $export            = require('./_export')\n  , isObject           = require('./_is-object')\n  , aFunction          = require('./_a-function')\n  , anInstance         = require('./_an-instance')\n  , forOf              = require('./_for-of')\n  , speciesConstructor = require('./_species-constructor')\n  , task               = require('./_task').set\n  , microtask          = require('./_microtask')()\n  , PROMISE            = 'Promise'\n  , TypeError          = global.TypeError\n  , process            = global.process\n  , $Promise           = global[PROMISE]\n  , process            = global.process\n  , isNode             = classof(process) == 'process'\n  , empty              = function(){ /* empty */ }\n  , Internal, GenericPromiseCapability, Wrapper;\n\nvar USE_NATIVE = !!function(){\n  try {\n    // correct subclassing with @@species support\n    var promise     = $Promise.resolve(1)\n      , FakePromise = (promise.constructor = {})[require('./_wks')('species')] = function(exec){ exec(empty, empty); };\n    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test\n    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;\n  } catch(e){ /* empty */ }\n}();\n\n// helpers\nvar sameConstructor = function(a, b){\n  // with library wrapper special case\n  return a === b || a === $Promise && b === Wrapper;\n};\nvar isThenable = function(it){\n  var then;\n  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;\n};\nvar newPromiseCapability = function(C){\n  return sameConstructor($Promise, C)\n    ? new PromiseCapability(C)\n    : new GenericPromiseCapability(C);\n};\nvar PromiseCapability = GenericPromiseCapability = function(C){\n  var resolve, reject;\n  this.promise = new C(function($$resolve, $$reject){\n    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');\n    resolve = $$resolve;\n    reject  = $$reject;\n  });\n  this.resolve = aFunction(resolve);\n  this.reject  = aFunction(reject);\n};\nvar perform = function(exec){\n  try {\n    exec();\n  } catch(e){\n    return {error: e};\n  }\n};\nvar notify = function(promise, isReject){\n  if(promise._n)return;\n  promise._n = true;\n  var chain = promise._c;\n  microtask(function(){\n    var value = promise._v\n      , ok    = promise._s == 1\n      , i     = 0;\n    var run = function(reaction){\n      var handler = ok ? reaction.ok : reaction.fail\n        , resolve = reaction.resolve\n        , reject  = reaction.reject\n        , domain  = reaction.domain\n        , result, then;\n      try {\n        if(handler){\n          if(!ok){\n            if(promise._h == 2)onHandleUnhandled(promise);\n            promise._h = 1;\n          }\n          if(handler === true)result = value;\n          else {\n            if(domain)domain.enter();\n            result = handler(value);\n            if(domain)domain.exit();\n          }\n          if(result === reaction.promise){\n            reject(TypeError('Promise-chain cycle'));\n          } else if(then = isThenable(result)){\n            then.call(result, resolve, reject);\n          } else resolve(result);\n        } else reject(value);\n      } catch(e){\n        reject(e);\n      }\n    };\n    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach\n    promise._c = [];\n    promise._n = false;\n    if(isReject && !promise._h)onUnhandled(promise);\n  });\n};\nvar onUnhandled = function(promise){\n  task.call(global, function(){\n    var value = promise._v\n      , abrupt, handler, console;\n    if(isUnhandled(promise)){\n      abrupt = perform(function(){\n        if(isNode){\n          process.emit('unhandledRejection', value, promise);\n        } else if(handler = global.onunhandledrejection){\n          handler({promise: promise, reason: value});\n        } else if((console = global.console) && console.error){\n          console.error('Unhandled promise rejection', value);\n        }\n      });\n      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should\n      promise._h = isNode || isUnhandled(promise) ? 2 : 1;\n    } promise._a = undefined;\n    if(abrupt)throw abrupt.error;\n  });\n};\nvar isUnhandled = function(promise){\n  if(promise._h == 1)return false;\n  var chain = promise._a || promise._c\n    , i     = 0\n    , reaction;\n  while(chain.length > i){\n    reaction = chain[i++];\n    if(reaction.fail || !isUnhandled(reaction.promise))return false;\n  } return true;\n};\nvar onHandleUnhandled = function(promise){\n  task.call(global, function(){\n    var handler;\n    if(isNode){\n      process.emit('rejectionHandled', promise);\n    } else if(handler = global.onrejectionhandled){\n      handler({promise: promise, reason: promise._v});\n    }\n  });\n};\nvar $reject = function(value){\n  var promise = this;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  promise._v = value;\n  promise._s = 2;\n  if(!promise._a)promise._a = promise._c.slice();\n  notify(promise, true);\n};\nvar $resolve = function(value){\n  var promise = this\n    , then;\n  if(promise._d)return;\n  promise._d = true;\n  promise = promise._w || promise; // unwrap\n  try {\n    if(promise === value)throw TypeError(\"Promise can't be resolved itself\");\n    if(then = isThenable(value)){\n      microtask(function(){\n        var wrapper = {_w: promise, _d: false}; // wrap\n        try {\n          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));\n        } catch(e){\n          $reject.call(wrapper, e);\n        }\n      });\n    } else {\n      promise._v = value;\n      promise._s = 1;\n      notify(promise, false);\n    }\n  } catch(e){\n    $reject.call({_w: promise, _d: false}, e); // wrap\n  }\n};\n\n// constructor polyfill\nif(!USE_NATIVE){\n  // 25.4.3.1 Promise(executor)\n  $Promise = function Promise(executor){\n    anInstance(this, $Promise, PROMISE, '_h');\n    aFunction(executor);\n    Internal.call(this);\n    try {\n      executor(ctx($resolve, this, 1), ctx($reject, this, 1));\n    } catch(err){\n      $reject.call(this, err);\n    }\n  };\n  Internal = function Promise(executor){\n    this._c = [];             // <- awaiting reactions\n    this._a = undefined;      // <- checked in isUnhandled reactions\n    this._s = 0;              // <- state\n    this._d = false;          // <- done\n    this._v = undefined;      // <- value\n    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled\n    this._n = false;          // <- notify\n  };\n  Internal.prototype = require('./_redefine-all')($Promise.prototype, {\n    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)\n    then: function then(onFulfilled, onRejected){\n      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));\n      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;\n      reaction.fail   = typeof onRejected == 'function' && onRejected;\n      reaction.domain = isNode ? process.domain : undefined;\n      this._c.push(reaction);\n      if(this._a)this._a.push(reaction);\n      if(this._s)notify(this, false);\n      return reaction.promise;\n    },\n    // 25.4.5.1 Promise.prototype.catch(onRejected)\n    'catch': function(onRejected){\n      return this.then(undefined, onRejected);\n    }\n  });\n  PromiseCapability = function(){\n    var promise  = new Internal;\n    this.promise = promise;\n    this.resolve = ctx($resolve, promise, 1);\n    this.reject  = ctx($reject, promise, 1);\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});\nrequire('./_set-to-string-tag')($Promise, PROMISE);\nrequire('./_set-species')(PROMISE);\nWrapper = require('./_core')[PROMISE];\n\n// statics\n$export($export.S + $export.F * !USE_NATIVE, PROMISE, {\n  // 25.4.4.5 Promise.reject(r)\n  reject: function reject(r){\n    var capability = newPromiseCapability(this)\n      , $$reject   = capability.reject;\n    $$reject(r);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {\n  // 25.4.4.6 Promise.resolve(x)\n  resolve: function resolve(x){\n    // instanceof instead of internal slot check because we should fix it without replacement native Promise core\n    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;\n    var capability = newPromiseCapability(this)\n      , $$resolve  = capability.resolve;\n    $$resolve(x);\n    return capability.promise;\n  }\n});\n$export($export.S + $export.F * !(USE_NATIVE && require('./_iter-detect')(function(iter){\n  $Promise.all(iter)['catch'](empty);\n})), PROMISE, {\n  // 25.4.4.1 Promise.all(iterable)\n  all: function all(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , resolve    = capability.resolve\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      var values    = []\n        , index     = 0\n        , remaining = 1;\n      forOf(iterable, false, function(promise){\n        var $index        = index++\n          , alreadyCalled = false;\n        values.push(undefined);\n        remaining++;\n        C.resolve(promise).then(function(value){\n          if(alreadyCalled)return;\n          alreadyCalled  = true;\n          values[$index] = value;\n          --remaining || resolve(values);\n        }, reject);\n      });\n      --remaining || resolve(values);\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  },\n  // 25.4.4.4 Promise.race(iterable)\n  race: function race(iterable){\n    var C          = this\n      , capability = newPromiseCapability(C)\n      , reject     = capability.reject;\n    var abrupt = perform(function(){\n      forOf(iterable, false, function(promise){\n        C.resolve(promise).then(capability.resolve, reject);\n      });\n    });\n    if(abrupt)reject(abrupt.error);\n    return capability.promise;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.promise.js\n// module id = 170\n// module chunks = 0","// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)\nvar $export   = require('./_export')\n  , aFunction = require('./_a-function')\n  , anObject  = require('./_an-object')\n  , rApply    = (require('./_global').Reflect || {}).apply\n  , fApply    = Function.apply;\n// MS Edge argumentsList argument is optional\n$export($export.S + $export.F * !require('./_fails')(function(){\n  rApply(function(){});\n}), 'Reflect', {\n  apply: function apply(target, thisArgument, argumentsList){\n    var T = aFunction(target)\n      , L = anObject(argumentsList);\n    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.apply.js\n// module id = 171\n// module chunks = 0","// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])\nvar $export    = require('./_export')\n  , create     = require('./_object-create')\n  , aFunction  = require('./_a-function')\n  , anObject   = require('./_an-object')\n  , isObject   = require('./_is-object')\n  , fails      = require('./_fails')\n  , bind       = require('./_bind')\n  , rConstruct = (require('./_global').Reflect || {}).construct;\n\n// MS Edge supports only 2 arguments and argumentsList argument is optional\n// FF Nightly sets third argument as `new.target`, but does not create `this` from it\nvar NEW_TARGET_BUG = fails(function(){\n  function F(){}\n  return !(rConstruct(function(){}, [], F) instanceof F);\n});\nvar ARGS_BUG = !fails(function(){\n  rConstruct(function(){});\n});\n\n$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {\n  construct: function construct(Target, args /*, newTarget*/){\n    aFunction(Target);\n    anObject(args);\n    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);\n    if(ARGS_BUG && !NEW_TARGET_BUG)return rConstruct(Target, args, newTarget);\n    if(Target == newTarget){\n      // w/o altered newTarget, optimization for 0-4 arguments\n      switch(args.length){\n        case 0: return new Target;\n        case 1: return new Target(args[0]);\n        case 2: return new Target(args[0], args[1]);\n        case 3: return new Target(args[0], args[1], args[2]);\n        case 4: return new Target(args[0], args[1], args[2], args[3]);\n      }\n      // w/o altered newTarget, lot of arguments case\n      var $args = [null];\n      $args.push.apply($args, args);\n      return new (bind.apply(Target, $args));\n    }\n    // with altered newTarget, not support built-in constructors\n    var proto    = newTarget.prototype\n      , instance = create(isObject(proto) ? proto : Object.prototype)\n      , result   = Function.apply.call(Target, instance, args);\n    return isObject(result) ? result : instance;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.construct.js\n// module id = 172\n// module chunks = 0","// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)\nvar dP          = require('./_object-dp')\n  , $export     = require('./_export')\n  , anObject    = require('./_an-object')\n  , toPrimitive = require('./_to-primitive');\n\n// MS Edge has broken Reflect.defineProperty - throwing instead of returning false\n$export($export.S + $export.F * require('./_fails')(function(){\n  Reflect.defineProperty(dP.f({}, 1, {value: 1}), 1, {value: 2});\n}), 'Reflect', {\n  defineProperty: function defineProperty(target, propertyKey, attributes){\n    anObject(target);\n    propertyKey = toPrimitive(propertyKey, true);\n    anObject(attributes);\n    try {\n      dP.f(target, propertyKey, attributes);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.define-property.js\n// module id = 173\n// module chunks = 0","// 26.1.4 Reflect.deleteProperty(target, propertyKey)\nvar $export  = require('./_export')\n  , gOPD     = require('./_object-gopd').f\n  , anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  deleteProperty: function deleteProperty(target, propertyKey){\n    var desc = gOPD(anObject(target), propertyKey);\n    return desc && !desc.configurable ? false : delete target[propertyKey];\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.delete-property.js\n// module id = 174\n// module chunks = 0","// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)\nvar gOPD     = require('./_object-gopd')\n  , $export  = require('./_export')\n  , anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey){\n    return gOPD.f(anObject(target), propertyKey);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.get-own-property-descriptor.js\n// module id = 175\n// module chunks = 0","// 26.1.8 Reflect.getPrototypeOf(target)\nvar $export  = require('./_export')\n  , getProto = require('./_object-gpo')\n  , anObject = require('./_an-object');\n\n$export($export.S, 'Reflect', {\n  getPrototypeOf: function getPrototypeOf(target){\n    return getProto(anObject(target));\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.get-prototype-of.js\n// module id = 176\n// module chunks = 0","// 26.1.6 Reflect.get(target, propertyKey [, receiver])\nvar gOPD           = require('./_object-gopd')\n  , getPrototypeOf = require('./_object-gpo')\n  , has            = require('./_has')\n  , $export        = require('./_export')\n  , isObject       = require('./_is-object')\n  , anObject       = require('./_an-object');\n\nfunction get(target, propertyKey/*, receiver*/){\n  var receiver = arguments.length < 3 ? target : arguments[2]\n    , desc, proto;\n  if(anObject(target) === receiver)return target[propertyKey];\n  if(desc = gOPD.f(target, propertyKey))return has(desc, 'value')\n    ? desc.value\n    : desc.get !== undefined\n      ? desc.get.call(receiver)\n      : undefined;\n  if(isObject(proto = getPrototypeOf(target)))return get(proto, propertyKey, receiver);\n}\n\n$export($export.S, 'Reflect', {get: get});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.get.js\n// module id = 177\n// module chunks = 0","// 26.1.9 Reflect.has(target, propertyKey)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', {\n  has: function has(target, propertyKey){\n    return propertyKey in target;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.has.js\n// module id = 178\n// module chunks = 0","// 26.1.10 Reflect.isExtensible(target)\nvar $export       = require('./_export')\n  , anObject      = require('./_an-object')\n  , $isExtensible = Object.isExtensible;\n\n$export($export.S, 'Reflect', {\n  isExtensible: function isExtensible(target){\n    anObject(target);\n    return $isExtensible ? $isExtensible(target) : true;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.is-extensible.js\n// module id = 179\n// module chunks = 0","// 26.1.11 Reflect.ownKeys(target)\nvar $export = require('./_export');\n\n$export($export.S, 'Reflect', {ownKeys: require('./_own-keys')});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.own-keys.js\n// module id = 180\n// module chunks = 0","// 26.1.12 Reflect.preventExtensions(target)\nvar $export            = require('./_export')\n  , anObject           = require('./_an-object')\n  , $preventExtensions = Object.preventExtensions;\n\n$export($export.S, 'Reflect', {\n  preventExtensions: function preventExtensions(target){\n    anObject(target);\n    try {\n      if($preventExtensions)$preventExtensions(target);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.prevent-extensions.js\n// module id = 181\n// module chunks = 0","// 26.1.14 Reflect.setPrototypeOf(target, proto)\nvar $export  = require('./_export')\n  , setProto = require('./_set-proto');\n\nif(setProto)$export($export.S, 'Reflect', {\n  setPrototypeOf: function setPrototypeOf(target, proto){\n    setProto.check(target, proto);\n    try {\n      setProto.set(target, proto);\n      return true;\n    } catch(e){\n      return false;\n    }\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.set-prototype-of.js\n// module id = 182\n// module chunks = 0","// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])\nvar dP             = require('./_object-dp')\n  , gOPD           = require('./_object-gopd')\n  , getPrototypeOf = require('./_object-gpo')\n  , has            = require('./_has')\n  , $export        = require('./_export')\n  , createDesc     = require('./_property-desc')\n  , anObject       = require('./_an-object')\n  , isObject       = require('./_is-object');\n\nfunction set(target, propertyKey, V/*, receiver*/){\n  var receiver = arguments.length < 4 ? target : arguments[3]\n    , ownDesc  = gOPD.f(anObject(target), propertyKey)\n    , existingDescriptor, proto;\n  if(!ownDesc){\n    if(isObject(proto = getPrototypeOf(target))){\n      return set(proto, propertyKey, V, receiver);\n    }\n    ownDesc = createDesc(0);\n  }\n  if(has(ownDesc, 'value')){\n    if(ownDesc.writable === false || !isObject(receiver))return false;\n    existingDescriptor = gOPD.f(receiver, propertyKey) || createDesc(0);\n    existingDescriptor.value = V;\n    dP.f(receiver, propertyKey, existingDescriptor);\n    return true;\n  }\n  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);\n}\n\n$export($export.S, 'Reflect', {set: set});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.reflect.set.js\n// module id = 183\n// module chunks = 0","// 21.2.5.3 get RegExp.prototype.flags()\nif(require('./_descriptors') && /./g.flags != 'g')require('./_object-dp').f(RegExp.prototype, 'flags', {\n  configurable: true,\n  get: require('./_flags')\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.regexp.flags.js\n// module id = 184\n// module chunks = 0","// @@match logic\nrequire('./_fix-re-wks')('match', 1, function(defined, MATCH, $match){\n  // 21.1.3.11 String.prototype.match(regexp)\n  return [function match(regexp){\n    'use strict';\n    var O  = defined(this)\n      , fn = regexp == undefined ? undefined : regexp[MATCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));\n  }, $match];\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.regexp.match.js\n// module id = 185\n// module chunks = 0","// @@replace logic\nrequire('./_fix-re-wks')('replace', 2, function(defined, REPLACE, $replace){\n  // 21.1.3.14 String.prototype.replace(searchValue, replaceValue)\n  return [function replace(searchValue, replaceValue){\n    'use strict';\n    var O  = defined(this)\n      , fn = searchValue == undefined ? undefined : searchValue[REPLACE];\n    return fn !== undefined\n      ? fn.call(searchValue, O, replaceValue)\n      : $replace.call(String(O), searchValue, replaceValue);\n  }, $replace];\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.regexp.replace.js\n// module id = 186\n// module chunks = 0","// @@search logic\nrequire('./_fix-re-wks')('search', 1, function(defined, SEARCH, $search){\n  // 21.1.3.15 String.prototype.search(regexp)\n  return [function search(regexp){\n    'use strict';\n    var O  = defined(this)\n      , fn = regexp == undefined ? undefined : regexp[SEARCH];\n    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));\n  }, $search];\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.regexp.search.js\n// module id = 187\n// module chunks = 0","// @@split logic\nrequire('./_fix-re-wks')('split', 2, function(defined, SPLIT, $split){\n  'use strict';\n  var isRegExp   = require('./_is-regexp')\n    , _split     = $split\n    , $push      = [].push\n    , $SPLIT     = 'split'\n    , LENGTH     = 'length'\n    , LAST_INDEX = 'lastIndex';\n  if(\n    'abbc'[$SPLIT](/(b)*/)[1] == 'c' ||\n    'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 ||\n    'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 ||\n    '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 ||\n    '.'[$SPLIT](/()()/)[LENGTH] > 1 ||\n    ''[$SPLIT](/.?/)[LENGTH]\n  ){\n    var NPCG = /()??/.exec('')[1] === undefined; // nonparticipating capturing group\n    // based on es5-shim implementation, need to rework it\n    $split = function(separator, limit){\n      var string = String(this);\n      if(separator === undefined && limit === 0)return [];\n      // If `separator` is not a regex, use native split\n      if(!isRegExp(separator))return _split.call(string, separator, limit);\n      var output = [];\n      var flags = (separator.ignoreCase ? 'i' : '') +\n                  (separator.multiline ? 'm' : '') +\n                  (separator.unicode ? 'u' : '') +\n                  (separator.sticky ? 'y' : '');\n      var lastLastIndex = 0;\n      var splitLimit = limit === undefined ? 4294967295 : limit >>> 0;\n      // Make `global` and avoid `lastIndex` issues by working with a copy\n      var separatorCopy = new RegExp(separator.source, flags + 'g');\n      var separator2, match, lastIndex, lastLength, i;\n      // Doesn't need flags gy, but they don't hurt\n      if(!NPCG)separator2 = new RegExp('^' + separatorCopy.source + '$(?!\\\\s)', flags);\n      while(match = separatorCopy.exec(string)){\n        // `separatorCopy.lastIndex` is not reliable cross-browser\n        lastIndex = match.index + match[0][LENGTH];\n        if(lastIndex > lastLastIndex){\n          output.push(string.slice(lastLastIndex, match.index));\n          // Fix browsers whose `exec` methods don't consistently return `undefined` for NPCG\n          if(!NPCG && match[LENGTH] > 1)match[0].replace(separator2, function(){\n            for(i = 1; i < arguments[LENGTH] - 2; i++)if(arguments[i] === undefined)match[i] = undefined;\n          });\n          if(match[LENGTH] > 1 && match.index < string[LENGTH])$push.apply(output, match.slice(1));\n          lastLength = match[0][LENGTH];\n          lastLastIndex = lastIndex;\n          if(output[LENGTH] >= splitLimit)break;\n        }\n        if(separatorCopy[LAST_INDEX] === match.index)separatorCopy[LAST_INDEX]++; // Avoid an infinite loop\n      }\n      if(lastLastIndex === string[LENGTH]){\n        if(lastLength || !separatorCopy.test(''))output.push('');\n      } else output.push(string.slice(lastLastIndex));\n      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;\n    };\n  // Chakra, V8\n  } else if('0'[$SPLIT](undefined, 0)[LENGTH]){\n    $split = function(separator, limit){\n      return separator === undefined && limit === 0 ? [] : _split.call(this, separator, limit);\n    };\n  }\n  // 21.1.3.17 String.prototype.split(separator, limit)\n  return [function split(separator, limit){\n    var O  = defined(this)\n      , fn = separator == undefined ? undefined : separator[SPLIT];\n    return fn !== undefined ? fn.call(separator, O, limit) : $split.call(String(O), separator, limit);\n  }, $split];\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.regexp.split.js\n// module id = 188\n// module chunks = 0","'use strict';\nvar strong = require('./_collection-strong');\n\n// 23.2 Set Objects\nmodule.exports = require('./_collection')('Set', function(get){\n  return function Set(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.2.3.1 Set.prototype.add(value)\n  add: function add(value){\n    return strong.def(this, value = value === 0 ? 0 : value, value);\n  }\n}, strong);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.set.js\n// module id = 189\n// module chunks = 0","'use strict';\nvar $export = require('./_export')\n  , $at     = require('./_string-at')(false);\n$export($export.P, 'String', {\n  // 21.1.3.3 String.prototype.codePointAt(pos)\n  codePointAt: function codePointAt(pos){\n    return $at(this, pos);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.string.code-point-at.js\n// module id = 190\n// module chunks = 0","// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])\n'use strict';\nvar $export   = require('./_export')\n  , toLength  = require('./_to-length')\n  , context   = require('./_string-context')\n  , ENDS_WITH = 'endsWith'\n  , $endsWith = ''[ENDS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(ENDS_WITH), 'String', {\n  endsWith: function endsWith(searchString /*, endPosition = @length */){\n    var that = context(this, searchString, ENDS_WITH)\n      , endPosition = arguments.length > 1 ? arguments[1] : undefined\n      , len    = toLength(that.length)\n      , end    = endPosition === undefined ? len : Math.min(toLength(endPosition), len)\n      , search = String(searchString);\n    return $endsWith\n      ? $endsWith.call(that, search, end)\n      : that.slice(end - search.length, end) === search;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.string.ends-with.js\n// module id = 191\n// module chunks = 0","var $export        = require('./_export')\n  , toIndex        = require('./_to-index')\n  , fromCharCode   = String.fromCharCode\n  , $fromCodePoint = String.fromCodePoint;\n\n// length should be 1, old FF problem\n$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {\n  // 21.1.2.2 String.fromCodePoint(...codePoints)\n  fromCodePoint: function fromCodePoint(x){ // eslint-disable-line no-unused-vars\n    var res  = []\n      , aLen = arguments.length\n      , i    = 0\n      , code;\n    while(aLen > i){\n      code = +arguments[i++];\n      if(toIndex(code, 0x10ffff) !== code)throw RangeError(code + ' is not a valid code point');\n      res.push(code < 0x10000\n        ? fromCharCode(code)\n        : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00)\n      );\n    } return res.join('');\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.string.from-code-point.js\n// module id = 192\n// module chunks = 0","// 21.1.3.7 String.prototype.includes(searchString, position = 0)\n'use strict';\nvar $export  = require('./_export')\n  , context  = require('./_string-context')\n  , INCLUDES = 'includes';\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(INCLUDES), 'String', {\n  includes: function includes(searchString /*, position = 0 */){\n    return !!~context(this, searchString, INCLUDES)\n      .indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.string.includes.js\n// module id = 193\n// module chunks = 0","var $export   = require('./_export')\n  , toIObject = require('./_to-iobject')\n  , toLength  = require('./_to-length');\n\n$export($export.S, 'String', {\n  // 21.1.2.4 String.raw(callSite, ...substitutions)\n  raw: function raw(callSite){\n    var tpl  = toIObject(callSite.raw)\n      , len  = toLength(tpl.length)\n      , aLen = arguments.length\n      , res  = []\n      , i    = 0;\n    while(len > i){\n      res.push(String(tpl[i++]));\n      if(i < aLen)res.push(String(arguments[i]));\n    } return res.join('');\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.string.raw.js\n// module id = 194\n// module chunks = 0","var $export = require('./_export');\n\n$export($export.P, 'String', {\n  // 21.1.3.13 String.prototype.repeat(count)\n  repeat: require('./_string-repeat')\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.string.repeat.js\n// module id = 195\n// module chunks = 0","// 21.1.3.18 String.prototype.startsWith(searchString [, position ])\n'use strict';\nvar $export     = require('./_export')\n  , toLength    = require('./_to-length')\n  , context     = require('./_string-context')\n  , STARTS_WITH = 'startsWith'\n  , $startsWith = ''[STARTS_WITH];\n\n$export($export.P + $export.F * require('./_fails-is-regexp')(STARTS_WITH), 'String', {\n  startsWith: function startsWith(searchString /*, position = 0 */){\n    var that   = context(this, searchString, STARTS_WITH)\n      , index  = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length))\n      , search = String(searchString);\n    return $startsWith\n      ? $startsWith.call(that, search, index)\n      : that.slice(index, index + search.length) === search;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.string.starts-with.js\n// module id = 196\n// module chunks = 0","'use strict';\n// ECMAScript 6 symbols shim\nvar global         = require('./_global')\n  , has            = require('./_has')\n  , DESCRIPTORS    = require('./_descriptors')\n  , $export        = require('./_export')\n  , redefine       = require('./_redefine')\n  , META           = require('./_meta').KEY\n  , $fails         = require('./_fails')\n  , shared         = require('./_shared')\n  , setToStringTag = require('./_set-to-string-tag')\n  , uid            = require('./_uid')\n  , wks            = require('./_wks')\n  , wksExt         = require('./_wks-ext')\n  , wksDefine      = require('./_wks-define')\n  , keyOf          = require('./_keyof')\n  , enumKeys       = require('./_enum-keys')\n  , isArray        = require('./_is-array')\n  , anObject       = require('./_an-object')\n  , toIObject      = require('./_to-iobject')\n  , toPrimitive    = require('./_to-primitive')\n  , createDesc     = require('./_property-desc')\n  , _create        = require('./_object-create')\n  , gOPNExt        = require('./_object-gopn-ext')\n  , $GOPD          = require('./_object-gopd')\n  , $DP            = require('./_object-dp')\n  , $keys          = require('./_object-keys')\n  , gOPD           = $GOPD.f\n  , dP             = $DP.f\n  , gOPN           = gOPNExt.f\n  , $Symbol        = global.Symbol\n  , $JSON          = global.JSON\n  , _stringify     = $JSON && $JSON.stringify\n  , PROTOTYPE      = 'prototype'\n  , HIDDEN         = wks('_hidden')\n  , TO_PRIMITIVE   = wks('toPrimitive')\n  , isEnum         = {}.propertyIsEnumerable\n  , SymbolRegistry = shared('symbol-registry')\n  , AllSymbols     = shared('symbols')\n  , OPSymbols      = shared('op-symbols')\n  , ObjectProto    = Object[PROTOTYPE]\n  , USE_NATIVE     = typeof $Symbol == 'function'\n  , QObject        = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function(){\n  return _create(dP({}, 'a', {\n    get: function(){ return dP(this, 'a', {value: 7}).a; }\n  })).a != 7;\n}) ? function(it, key, D){\n  var protoDesc = gOPD(ObjectProto, key);\n  if(protoDesc)delete ObjectProto[key];\n  dP(it, key, D);\n  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function(tag){\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){\n  return typeof it == 'symbol';\n} : function(it){\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D){\n  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if(has(AllSymbols, key)){\n    if(!D.enumerable){\n      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;\n      D = _create(D, {enumerable: createDesc(0, false)});\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P){\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P))\n    , i    = 0\n    , l = keys.length\n    , key;\n  while(l > i)$defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P){\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key){\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){\n  it  = toIObject(it);\n  key = toPrimitive(key, true);\n  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;\n  var D = gOPD(it, key);\n  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it){\n  var names  = gOPN(toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it){\n  var IS_OP  = it === ObjectProto\n    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))\n    , result = []\n    , i      = 0\n    , key;\n  while(names.length > i){\n    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif(!USE_NATIVE){\n  $Symbol = function Symbol(){\n    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function(value){\n      if(this === ObjectProto)$set.call(OPSymbols, value);\n      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString(){\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f   = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f  = $propertyIsEnumerable;\n  require('./_object-gops').f = $getOwnPropertySymbols;\n\n  if(DESCRIPTORS && !require('./_library')){\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function(name){\n    return wrap(wks(name));\n  }\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});\n\nfor(var symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);\n\nfor(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function(key){\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(key){\n    if(isSymbol(key))return keyOf(SymbolRegistry, key);\n    throw TypeError(key + ' is not a symbol!');\n  },\n  useSetter: function(){ setter = true; },\n  useSimple: function(){ setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it){\n    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined\n    var args = [it]\n      , i    = 1\n      , replacer, $replacer;\n    while(arguments.length > i)args.push(arguments[i++]);\n    replacer = args[1];\n    if(typeof replacer == 'function')$replacer = replacer;\n    if($replacer || !isArray(replacer))replacer = function(key, value){\n      if($replacer)value = $replacer.call(this, key, value);\n      if(!isSymbol(value))return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.symbol.js\n// module id = 197\n// module chunks = 0","var $export = require('./_export');\n$export($export.G + $export.W + $export.F * !require('./_typed').ABV, {\n  DataView: require('./_typed-buffer').DataView\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.typed.data-view.js\n// module id = 198\n// module chunks = 0","require('./_typed-array')('Float32', 4, function(init){\n  return function Float32Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.typed.float32-array.js\n// module id = 199\n// module chunks = 0","require('./_typed-array')('Float64', 8, function(init){\n  return function Float64Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.typed.float64-array.js\n// module id = 200\n// module chunks = 0","require('./_typed-array')('Int16', 2, function(init){\n  return function Int16Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.typed.int16-array.js\n// module id = 201\n// module chunks = 0","require('./_typed-array')('Int32', 4, function(init){\n  return function Int32Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.typed.int32-array.js\n// module id = 202\n// module chunks = 0","require('./_typed-array')('Int8', 1, function(init){\n  return function Int8Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.typed.int8-array.js\n// module id = 203\n// module chunks = 0","require('./_typed-array')('Uint16', 2, function(init){\n  return function Uint16Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.typed.uint16-array.js\n// module id = 204\n// module chunks = 0","require('./_typed-array')('Uint32', 4, function(init){\n  return function Uint32Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.typed.uint32-array.js\n// module id = 205\n// module chunks = 0","require('./_typed-array')('Uint8', 1, function(init){\n  return function Uint8Array(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.typed.uint8-array.js\n// module id = 206\n// module chunks = 0","require('./_typed-array')('Uint8', 1, function(init){\n  return function Uint8ClampedArray(data, byteOffset, length){\n    return init(this, data, byteOffset, length);\n  };\n}, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.typed.uint8-clamped-array.js\n// module id = 207\n// module chunks = 0","'use strict';\nvar each         = require('./_array-methods')(0)\n  , redefine     = require('./_redefine')\n  , meta         = require('./_meta')\n  , assign       = require('./_object-assign')\n  , weak         = require('./_collection-weak')\n  , isObject     = require('./_is-object')\n  , getWeak      = meta.getWeak\n  , isExtensible = Object.isExtensible\n  , uncaughtFrozenStore = weak.ufstore\n  , tmp          = {}\n  , InternalMap;\n\nvar wrapper = function(get){\n  return function WeakMap(){\n    return get(this, arguments.length > 0 ? arguments[0] : undefined);\n  };\n};\n\nvar methods = {\n  // 23.3.3.3 WeakMap.prototype.get(key)\n  get: function get(key){\n    if(isObject(key)){\n      var data = getWeak(key);\n      if(data === true)return uncaughtFrozenStore(this).get(key);\n      return data ? data[this._i] : undefined;\n    }\n  },\n  // 23.3.3.5 WeakMap.prototype.set(key, value)\n  set: function set(key, value){\n    return weak.def(this, key, value);\n  }\n};\n\n// 23.3 WeakMap Objects\nvar $WeakMap = module.exports = require('./_collection')('WeakMap', wrapper, methods, weak, true, true);\n\n// IE11 WeakMap frozen keys fix\nif(new $WeakMap().set((Object.freeze || Object)(tmp), 7).get(tmp) != 7){\n  InternalMap = weak.getConstructor(wrapper);\n  assign(InternalMap.prototype, methods);\n  meta.NEED = true;\n  each(['delete', 'has', 'get', 'set'], function(key){\n    var proto  = $WeakMap.prototype\n      , method = proto[key];\n    redefine(proto, key, function(a, b){\n      // store frozen objects on internal weakmap shim\n      if(isObject(a) && !isExtensible(a)){\n        if(!this._f)this._f = new InternalMap;\n        var result = this._f[key](a, b);\n        return key == 'set' ? this : result;\n      // store all the rest on native weakmap\n      } return method.call(this, a, b);\n    });\n  });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.weak-map.js\n// module id = 208\n// module chunks = 0","'use strict';\nvar weak = require('./_collection-weak');\n\n// 23.4 WeakSet Objects\nrequire('./_collection')('WeakSet', function(get){\n  return function WeakSet(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };\n}, {\n  // 23.4.3.1 WeakSet.prototype.add(value)\n  add: function add(value){\n    return weak.def(this, value, true);\n  }\n}, weak, false, true);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es6.weak-set.js\n// module id = 209\n// module chunks = 0","'use strict';\n// https://github.com/tc39/Array.prototype.includes\nvar $export   = require('./_export')\n  , $includes = require('./_array-includes')(true);\n\n$export($export.P, 'Array', {\n  includes: function includes(el /*, fromIndex = 0 */){\n    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);\n  }\n});\n\nrequire('./_add-to-unscopables')('includes');\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es7.array.includes.js\n// module id = 210\n// module chunks = 0","// https://github.com/tc39/proposal-object-values-entries\nvar $export  = require('./_export')\n  , $entries = require('./_object-to-array')(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it){\n    return $entries(it);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es7.object.entries.js\n// module id = 211\n// module chunks = 0","// https://github.com/tc39/proposal-object-getownpropertydescriptors\nvar $export        = require('./_export')\n  , ownKeys        = require('./_own-keys')\n  , toIObject      = require('./_to-iobject')\n  , gOPD           = require('./_object-gopd')\n  , createProperty = require('./_create-property');\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object){\n    var O       = toIObject(object)\n      , getDesc = gOPD.f\n      , keys    = ownKeys(O)\n      , result  = {}\n      , i       = 0\n      , key;\n    while(keys.length > i)createProperty(result, key = keys[i++], getDesc(O, key));\n    return result;\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es7.object.get-own-property-descriptors.js\n// module id = 212\n// module chunks = 0","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export')\n  , $values = require('./_object-to-array')(false);\n\n$export($export.S, 'Object', {\n  values: function values(it){\n    return $values(it);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es7.object.values.js\n// module id = 213\n// module chunks = 0","'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export')\n  , $pad    = require('./_string-pad');\n\n$export($export.P, 'String', {\n  padEnd: function padEnd(maxLength /*, fillString = ' ' */){\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es7.string.pad-end.js\n// module id = 214\n// module chunks = 0","'use strict';\n// https://github.com/tc39/proposal-string-pad-start-end\nvar $export = require('./_export')\n  , $pad    = require('./_string-pad');\n\n$export($export.P, 'String', {\n  padStart: function padStart(maxLength /*, fillString = ' ' */){\n    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);\n  }\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/es7.string.pad-start.js\n// module id = 215\n// module chunks = 0","var $iterators    = require('./es6.array.iterator')\n  , redefine      = require('./_redefine')\n  , global        = require('./_global')\n  , hide          = require('./_hide')\n  , Iterators     = require('./_iterators')\n  , wks           = require('./_wks')\n  , ITERATOR      = wks('iterator')\n  , TO_STRING_TAG = wks('toStringTag')\n  , ArrayValues   = Iterators.Array;\n\nfor(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){\n  var NAME       = collections[i]\n    , Collection = global[NAME]\n    , proto      = Collection && Collection.prototype\n    , key;\n  if(proto){\n    if(!proto[ITERATOR])hide(proto, ITERATOR, ArrayValues);\n    if(!proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    for(key in $iterators)if(!proto[key])redefine(proto, key, $iterators[key], true);\n  }\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/web.dom.iterable.js\n// module id = 216\n// module chunks = 0","var $export = require('./_export')\n  , $task   = require('./_task');\n$export($export.G + $export.B, {\n  setImmediate:   $task.set,\n  clearImmediate: $task.clear\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/web.immediate.js\n// module id = 217\n// module chunks = 0","// ie9- setTimeout & setInterval additional parameters fix\nvar global     = require('./_global')\n  , $export    = require('./_export')\n  , invoke     = require('./_invoke')\n  , partial    = require('./_partial')\n  , navigator  = global.navigator\n  , MSIE       = !!navigator && /MSIE .\\./.test(navigator.userAgent); // <- dirty ie9- check\nvar wrap = function(set){\n  return MSIE ? function(fn, time /*, ...args */){\n    return set(invoke(\n      partial,\n      [].slice.call(arguments, 2),\n      typeof fn == 'function' ? fn : Function(fn)\n    ), time);\n  } : set;\n};\n$export($export.G + $export.B + $export.F * MSIE, {\n  setTimeout:  wrap(global.setTimeout),\n  setInterval: wrap(global.setInterval)\n});\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/core-js/modules/web.timers.js\n// module id = 218\n// module chunks = 0","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/events/events.js\n// module id = 219\n// module chunks = 0","\n/**\n * isArray\n */\n\nvar isArray = Array.isArray;\n\n/**\n * toString\n */\n\nvar str = Object.prototype.toString;\n\n/**\n * Whether or not the given `val`\n * is an array.\n *\n * example:\n *\n *        isArray([]);\n *        // > true\n *        isArray(arguments);\n *        // > false\n *        isArray('');\n *        // > false\n *\n * @param {mixed} val\n * @return {bool}\n */\n\nmodule.exports = isArray || function (val) {\n  return !! val && '[object Array]' == str.call(val);\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/is-array/index.js\n// module id = 220\n// module chunks = 0","// the whatwg-fetch polyfill installs the fetch() function\n// on the global object (window or self)\n//\n// Return that as the export for use in Webpack, Browserify etc.\nrequire('whatwg-fetch');\nmodule.exports = self.fetch.bind(self);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/isomorphic-fetch/fetch-npm-browserify.js\n// module id = 221\n// module chunks = 0","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype[\"catch\"] = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/lie/lib/browser.js\n// module id = 222\n// module chunks = 0","'use strict';\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nexports.padLeft = function (str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n};\n\nexports.padRight = function (str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return str + padding;\n};\n\nexports.stringLexCompare = function (a, b) {\n\n  var aLen = a.length;\n  var bLen = b.length;\n\n  var i;\n  for (i = 0; i < aLen; i++) {\n    if (i === bLen) {\n      // b is shorter substring of a\n      return 1;\n    }\n    var aChar = a.charAt(i);\n    var bChar = b.charAt(i);\n    if (aChar !== bChar) {\n      return aChar < bChar ? -1 : 1;\n    }\n  }\n\n  if (aLen < bLen) {\n    // a is shorter substring of b\n    return -1;\n  }\n\n  return 0;\n};\n\n/*\n * returns the decimal form for the given integer, i.e. writes\n * out all the digits (in base-10) instead of using scientific notation\n */\nexports.intToDecimalForm = function (int) {\n\n  var isNeg = int < 0;\n  var result = '';\n\n  do {\n    var remainder = isNeg ? -Math.ceil(int % 10) : Math.floor(int % 10);\n\n    result = remainder + result;\n    int = isNeg ? Math.ceil(int / 10) : Math.floor(int / 10);\n  } while (int);\n\n\n  if (isNeg && result !== '0') {\n    result = '-' + result;\n  }\n\n  return result;\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-collate/lib/utils.js\n// module id = 223\n// module chunks = 0","'use strict';\n\nvar upsert = require('./upsert');\nvar utils = require('./utils');\nvar Promise = utils.Promise;\n\nfunction stringify(input) {\n  if (!input) {\n    return 'undefined'; // backwards compat for empty reduce\n  }\n  // for backwards compat with mapreduce, functions/strings are stringified\n  // as-is. everything else is JSON-stringified.\n  switch (typeof input) {\n    case 'function':\n      // e.g. a mapreduce map\n      return input.toString();\n    case 'string':\n      // e.g. a mapreduce built-in _reduce function\n      return input.toString();\n    default:\n      // e.g. a JSON object in the case of mango queries\n      return JSON.stringify(input);\n  }\n}\n\nmodule.exports = function (opts) {\n  var sourceDB = opts.db;\n  var viewName = opts.viewName;\n  var mapFun = opts.map;\n  var reduceFun = opts.reduce;\n  var temporary = opts.temporary;\n  var pluginName = opts.pluginName;\n\n  // the \"undefined\" part is for backwards compatibility\n  var viewSignature = stringify(mapFun) + stringify(reduceFun) +\n    'undefined';\n\n  if (!temporary && sourceDB._cachedViews) {\n    var cachedView = sourceDB._cachedViews[viewSignature];\n    if (cachedView) {\n      return Promise.resolve(cachedView);\n    }\n  }\n\n  return sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : utils.MD5(viewSignature));\n\n    // save the view name in the source PouchDB so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/' + pluginName, diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db, \n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (!temporary) {\n            sourceDB._cachedViews = sourceDB._cachedViews || {};\n            sourceDB._cachedViews[viewSignature] = view;\n            view.db.on('destroyed', function () {\n              delete sourceDB._cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/abstract-mapreduce/create-view.js\n// module id = 224\n// module chunks = 0","'use strict';\n\nvar pouchCollate = require('pouchdb-collate');\nvar TaskQueue = require('./taskqueue');\nvar collate = pouchCollate.collate;\nvar toIndexableString = pouchCollate.toIndexableString;\nvar normalizeKey = pouchCollate.normalizeKey;\nvar createView = require('./create-view');\nvar log;\n/* istanbul ignore else */\nif ((typeof console !== 'undefined') && (typeof console.log === 'function')) {\n  log = Function.prototype.bind.call(console.log, console);\n} else {\n  log = function () {};\n}\nvar utils = require('./utils');\nvar Promise = utils.Promise;\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue();\nvar CHANGES_BATCH_SIZE = 50;\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\nutils.inherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\nutils.inherits(NotFoundError, Error);\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction sortByKeyThenValue(x, y) {\n  var keyCompare = collate(x.key, y.key);\n  return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n}\n\nfunction sliceResults(results, limit, skip) {\n  skip = skip || 0;\n  if (typeof limit === 'number') {\n    return results.slice(skip, limit + skip);\n  } else if (skip > 0) {\n    return results.slice(skip);\n  }\n  return results;\n}\n\nfunction rowToDocId(row) {\n  var val = row.value;\n  // Users can explicitly specify a joined doc _id, or it\n  // defaults to the doc _id that emitted the key/value.\n  var docId = (val && typeof val === 'object' && val._id) || row.id;\n  return docId;\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    console.error(\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    console.error(e);\n  }\n}\n\nfunction tryCode(db, fun, args) {\n  // emit an event if there was an error thrown by a map/reduce function.\n  // putting try/catches in a single function also avoids deoptimizations.\n  try {\n    return {\n      output : fun.apply(null, args)\n    };\n  } catch (e) {\n    emitError(db, e);\n    return {error: e};\n  }\n}\n\nfunction checkQueryParseError(options, fun) {\n  var startkeyName = options.descending ? 'endkey' : 'startkey';\n  var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n  if (typeof options[startkeyName] !== 'undefined' &&\n    typeof options[endkeyName] !== 'undefined' &&\n    collate(options[startkeyName], options[endkeyName]) > 0) {\n    throw new QueryParseError('No rows can match your key range, reverse your ' +\n    'start_key and end_key or set {descending : true}');\n  } else if (fun.reduce && options.reduce !== false) {\n    if (options.include_docs) {\n      throw new QueryParseError('{include_docs:true} is invalid for reduce');\n    } else if (options.keys && options.keys.length > 1 &&\n      !options.group && !options.group_level) {\n      throw new QueryParseError('Multi-key fetches for reduce views must use {group: true}');\n    }\n  }\n  if (options.group_level) {\n    if (typeof options.group_level !== 'number') {\n      throw new QueryParseError('Invalid value for integer: \"' + options.group_level + '\"');\n    }\n    if (options.group_level < 0) {\n      throw new QueryParseError('Invalid value for positive integer: ' +\n      '\"' + options.group_level + '\"');\n    }\n  }\n}\n\nfunction defaultsTo(value) {\n  return function (reason) {\n    /* istanbul ignore else */\n    if (reason.status === 404) {\n      return value;\n    } else {\n      throw reason;\n    }\n  };\n}\n\nfunction createIndexer(def) {\n\n  var pluginName = def.name;\n  var mapper = def.mapper;\n  var reducer = def.reducer;\n  var ddocValidator = def.ddocValidator;\n\n\n  // returns a promise for a list of docs to update, based on the input docId.\n  // the order doesn't matter, because post-3.2.0, bulkDocs\n  // is an atomic operation in all three adapters.\n  function getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n    var metaDocId = '_local/doc_' + docId;\n    var defaultMetaDoc = {_id: metaDocId, keys: []};\n    var docData = docIdsToChangesAndEmits[docId];\n    var indexableKeysToKeyValues = docData.indexableKeysToKeyValues;\n    var changes = docData.changes;\n\n    function getMetaDoc() {\n      if (isGenOne(changes)) {\n        // generation 1, so we can safely assume initial state\n        // for performance reasons (avoids unnecessary GETs)\n        return Promise.resolve(defaultMetaDoc);\n      }\n      return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n    }\n\n    function getKeyValueDocs(metaDoc) {\n      if (!metaDoc.keys.length) {\n        // no keys, no need for a lookup\n        return Promise.resolve({rows: []});\n      }\n      return view.db.allDocs({\n        keys: metaDoc.keys,\n        include_docs: true\n      });\n    }\n\n    function processKvDocs(metaDoc, kvDocsRes) {\n      var kvDocs = [];\n      var oldKeysMap = {};\n\n      for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n        var row = kvDocsRes.rows[i];\n        var doc = row.doc;\n        if (!doc) { // deleted\n          continue;\n        }\n        kvDocs.push(doc);\n        oldKeysMap[doc._id] = true;\n        doc._deleted = !indexableKeysToKeyValues[doc._id];\n        if (!doc._deleted) {\n          var keyValue = indexableKeysToKeyValues[doc._id];\n          if ('value' in keyValue) {\n            doc.value = keyValue.value;\n          }\n        }\n      }\n\n      var newKeys = Object.keys(indexableKeysToKeyValues);\n      newKeys.forEach(function (key) {\n        if (!oldKeysMap[key]) {\n          // new doc\n          var kvDoc = {\n            _id: key\n          };\n          var keyValue = indexableKeysToKeyValues[key];\n          if ('value' in keyValue) {\n            kvDoc.value = keyValue.value;\n          }\n          kvDocs.push(kvDoc);\n        }\n      });\n      metaDoc.keys = utils.uniq(newKeys.concat(metaDoc.keys));\n      kvDocs.push(metaDoc);\n\n      return kvDocs;\n    }\n\n    return getMetaDoc().then(function (metaDoc) {\n      return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n        return processKvDocs(metaDoc, kvDocsRes);\n      });\n    });\n  }\n\n  // updates all emitted key/value docs and metaDocs in the mrview database\n  // for the given batch of documents from the source database\n  function saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n    var seqDocId = '_local/lastSeq';\n    return view.db.get(seqDocId)\n    .catch(defaultsTo({_id: seqDocId, seq: 0}))\n    .then(function (lastSeqDoc) {\n      var docIds = Object.keys(docIdsToChangesAndEmits);\n      return Promise.all(docIds.map(function (docId) {\n        return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n      })).then(function (listOfDocsToPersist) {\n        var docsToPersist = utils.flatten(listOfDocsToPersist);\n        lastSeqDoc.seq = seq;\n        docsToPersist.push(lastSeqDoc);\n        // write all docs in a single operation, update the seq once\n        return view.db.bulkDocs({docs : docsToPersist});\n      });\n    });\n  }\n\n  function getQueue(view) {\n    var viewName = typeof view === 'string' ? view : view.name;\n    var queue = persistentQueues[viewName];\n    if (!queue) {\n      queue = persistentQueues[viewName] = new TaskQueue();\n    }\n    return queue;\n  }\n\n  function updateView(view) {\n    return utils.sequentialize(getQueue(view), function () {\n      return updateViewInQueue(view);\n    })();\n  }\n\n  function updateViewInQueue(view) {\n    // bind the emit function once\n    var mapResults;\n    var doc;\n\n    function emit(key, value) {\n      var output = {id: doc._id, key: normalizeKey(key)};\n      // Don't explicitly store the value unless it's defined and non-null.\n      // This saves on storage space, because often people don't use it.\n      if (typeof value !== 'undefined' && value !== null) {\n        output.value = normalizeKey(value);\n      }\n      mapResults.push(output);\n    }\n\n    var mapFun = mapper(view.mapFun, emit);\n\n    var currentSeq = view.seq || 0;\n\n    function processChange(docIdsToChangesAndEmits, seq) {\n      return function () {\n        return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n      };\n    }\n\n    var queue = new TaskQueue();\n\n    return new Promise(function (resolve, reject) {\n\n      function complete() {\n        queue.finish().then(function () {\n          view.seq = currentSeq;\n          resolve();\n        });\n      }\n\n      function processNextBatch() {\n        view.sourceDB.changes({\n          conflicts: true,\n          include_docs: true,\n          style: 'all_docs',\n          since: currentSeq,\n          limit: CHANGES_BATCH_SIZE\n        }).on('complete', function (response) {\n          var results = response.results;\n          if (!results.length) {\n            return complete();\n          }\n          var docIdsToChangesAndEmits = {};\n          for (var i = 0, l = results.length; i < l; i++) {\n            var change = results[i];\n            if (change.doc._id[0] !== '_') {\n              mapResults = [];\n              doc = change.doc;\n\n              if (!doc._deleted) {\n                tryCode(view.sourceDB, mapFun, [doc]);\n              }\n              mapResults.sort(sortByKeyThenValue);\n\n              var indexableKeysToKeyValues = {};\n              var lastKey;\n              for (var j = 0, jl = mapResults.length; j < jl; j++) {\n                var obj = mapResults[j];\n                var complexKey = [obj.key, obj.id];\n                if (collate(obj.key, lastKey) === 0) {\n                  complexKey.push(j); // dup key+id, so make it unique\n                }\n                var indexableKey = toIndexableString(complexKey);\n                indexableKeysToKeyValues[indexableKey] = obj;\n                lastKey = obj.key;\n              }\n              docIdsToChangesAndEmits[change.doc._id] = {\n                indexableKeysToKeyValues: indexableKeysToKeyValues,\n                changes: change.changes\n              };\n            }\n            currentSeq = change.seq;\n          }\n          queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n          if (results.length < CHANGES_BATCH_SIZE) {\n            return complete();\n          }\n          return processNextBatch();\n        }).on('error', onError);\n        /* istanbul ignore next */\n        function onError(err) {\n          reject(err);\n        }\n      }\n\n      processNextBatch();\n    });\n  }\n\n  function reduceView(view, results, options) {\n    if (options.group_level === 0) {\n      delete options.group_level;\n    }\n\n    var shouldGroup = options.group || options.group_level;\n\n    var reduceFun = reducer(view.reduceFun);\n\n    var groups = [];\n    var lvl = options.group_level;\n    results.forEach(function (e) {\n      var last = groups[groups.length - 1];\n      var key = shouldGroup ? e.key : null;\n\n      // only set group_level for array keys\n      if (shouldGroup && Array.isArray(key) && typeof lvl === 'number') {\n        key = key.length > lvl ? key.slice(0, lvl) : key;\n      }\n\n      if (last && collate(last.key[0][0], key) === 0) {\n        last.key.push([key, e.id]);\n        last.value.push(e.value);\n        return;\n      }\n      groups.push({key: [\n        [key, e.id]\n      ], value: [e.value]});\n    });\n    for (var i = 0, len = groups.length; i < len; i++) {\n      var e = groups[i];\n      var reduceTry = tryCode(view.sourceDB, reduceFun, [e.key, e.value, false]);\n      // TODO: can't do instanceof BuiltInError because this class is buried\n      // in mapreduce.js\n      if (reduceTry.error && /BuiltInError/.test(reduceTry.error.constructor)) {\n        // CouchDB returns an error if a built-in errors out\n        throw reduceTry.error;\n      }\n      // CouchDB just sets the value to null if a non-built-in errors out\n      e.value = reduceTry.error ? null : reduceTry.output;\n      e.key = e.key[0][0];\n    }\n    // no total_rows/offset when reducing\n    return {rows: sliceResults(groups, options.limit, options.skip)};\n  }\n\n  function queryView(view, opts) {\n    return utils.sequentialize(getQueue(view), function () {\n      return queryViewInQueue(view, opts);\n    })();\n  }\n\n  function queryViewInQueue(view, opts) {\n    var totalRows;\n    var shouldReduce = view.reduceFun && opts.reduce !== false;\n    var skip = opts.skip || 0;\n    if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n      // equivalent query\n      opts.limit = 0;\n      delete opts.keys;\n    }\n\n    function fetchFromView(viewOpts) {\n      viewOpts.include_docs = true;\n      return view.db.allDocs(viewOpts).then(function (res) {\n        totalRows = res.total_rows;\n        return res.rows.map(function (result) {\n\n          // implicit migration - in older versions of PouchDB,\n          // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n          // this is tested in a migration test\n          /* istanbul ignore next */\n          if ('value' in result.doc && typeof result.doc.value === 'object' &&\n              result.doc.value !== null) {\n            var keys = Object.keys(result.doc.value).sort();\n            // this detection method is not perfect, but it's unlikely the user\n            // emitted a value which was an object with these 3 exact keys\n            var expectedKeys = ['id', 'key', 'value'];\n            if (!(keys < expectedKeys || keys > expectedKeys)) {\n              return result.doc.value;\n            }\n          }\n\n          var parsedKeyAndDocId = pouchCollate.parseIndexableString(result.doc._id);\n          return {\n            key: parsedKeyAndDocId[0],\n            id: parsedKeyAndDocId[1],\n            value: ('value' in result.doc ? result.doc.value : null)\n          };\n        });\n      });\n    }\n\n    function onMapResultsReady(rows) {\n      var finalResults;\n      if (shouldReduce) {\n        finalResults = reduceView(view, rows, opts);\n      } else {\n        finalResults = {\n          total_rows: totalRows,\n          offset: skip,\n          rows: rows\n        };\n      }\n      if (opts.include_docs) {\n        var docIds = utils.uniq(rows.map(rowToDocId));\n\n        return view.sourceDB.allDocs({\n          keys: docIds,\n          include_docs: true,\n          conflicts: opts.conflicts,\n          attachments: opts.attachments,\n          binary: opts.binary\n        }).then(function (allDocsRes) {\n          var docIdsToDocs = {};\n          allDocsRes.rows.forEach(function (row) {\n            if (row.doc) {\n              docIdsToDocs['$' + row.id] = row.doc;\n            }\n          });\n          rows.forEach(function (row) {\n            var docId = rowToDocId(row);\n            var doc = docIdsToDocs['$' + docId];\n            if (doc) {\n              row.doc = doc;\n            }\n          });\n          return finalResults;\n        });\n      } else {\n        return finalResults;\n      }\n    }\n\n    var flatten = function (array) {\n      return array.reduce(function (prev, cur) {\n        return prev.concat(cur);\n      });\n    };\n\n    if (typeof opts.keys !== 'undefined') {\n      var keys = opts.keys;\n      var fetchPromises = keys.map(function (key) {\n        var viewOpts = {\n          startkey : toIndexableString([key]),\n          endkey   : toIndexableString([key, {}])\n        };\n        return fetchFromView(viewOpts);\n      });\n      return Promise.all(fetchPromises).then(flatten).then(onMapResultsReady);\n    } else { // normal query, no 'keys'\n      var viewOpts = {\n        descending : opts.descending\n      };\n      if (typeof opts.startkey !== 'undefined') {\n        viewOpts.startkey = opts.descending ?\n          toIndexableString([opts.startkey, {}]) :\n          toIndexableString([opts.startkey]);\n      }\n      if (typeof opts.endkey !== 'undefined') {\n        var inclusiveEnd = opts.inclusive_end !== false;\n        if (opts.descending) {\n          inclusiveEnd = !inclusiveEnd;\n        }\n\n        viewOpts.endkey = toIndexableString(inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);\n      }\n      if (typeof opts.key !== 'undefined') {\n        var keyStart = toIndexableString([opts.key]);\n        var keyEnd = toIndexableString([opts.key, {}]);\n        if (viewOpts.descending) {\n          viewOpts.endkey = keyStart;\n          viewOpts.startkey = keyEnd;\n        } else {\n          viewOpts.startkey = keyStart;\n          viewOpts.endkey = keyEnd;\n        }\n      }\n      if (!shouldReduce) {\n        if (typeof opts.limit === 'number') {\n          viewOpts.limit = opts.limit;\n        }\n        viewOpts.skip = skip;\n      }\n      return fetchFromView(viewOpts).then(onMapResultsReady);\n    }\n  }\n\n  function localViewCleanup(db) {\n    return db.get('_local/' + pluginName).then(function (metaDoc) {\n      var docsToViews = {};\n      Object.keys(metaDoc.views).forEach(function (fullViewName) {\n        var parts = parseViewName(fullViewName);\n        var designDocName = '_design/' + parts[0];\n        var viewName = parts[1];\n        docsToViews[designDocName] = docsToViews[designDocName] || {};\n        docsToViews[designDocName][viewName] = true;\n      });\n      var opts = {\n        keys : Object.keys(docsToViews),\n        include_docs : true\n      };\n      return db.allDocs(opts).then(function (res) {\n        var viewsToStatus = {};\n        res.rows.forEach(function (row) {\n          var ddocName = row.key.substring(8);\n          Object.keys(docsToViews[row.key]).forEach(function (viewName) {\n            var fullViewName = ddocName + '/' + viewName;\n            /* istanbul ignore if */\n            if (!metaDoc.views[fullViewName]) {\n              // new format, without slashes, to support PouchDB 2.2.0\n              // migration test in pouchdb's browser.migration.js verifies this\n              fullViewName = viewName;\n            }\n            var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n            // design doc deleted, or view function nonexistent\n            var statusIsGood = row.doc && row.doc.views && row.doc.views[viewName];\n            viewDBNames.forEach(function (viewDBName) {\n              viewsToStatus[viewDBName] = viewsToStatus[viewDBName] || statusIsGood;\n            });\n          });\n        });\n        var dbsToDelete = Object.keys(viewsToStatus).filter(function (viewDBName) {\n          return !viewsToStatus[viewDBName];\n        });\n        var destroyPromises = dbsToDelete.map(function (viewDBName) {\n          return utils.sequentialize(getQueue(viewDBName), function () {\n            return new db.constructor(viewDBName, db.__opts).destroy();\n          })();\n        });\n        return Promise.all(destroyPromises).then(function () {\n          return {ok: true};\n        });\n      });\n    }, defaultsTo({ok: true}));\n  }\n\n  function queryPromised(db, fun, opts) {\n    if (typeof fun !== 'string') {\n      // temp_view\n      checkQueryParseError(opts, fun);\n\n      var createViewOpts = {\n        db : db,\n        viewName : 'temp_view/temp_view',\n        map : fun.map,\n        reduce : fun.reduce,\n        temporary : true,\n        pluginName: pluginName\n      };\n      tempViewQueue.add(function () {\n        return createView(createViewOpts).then(function (view) {\n          function cleanup() {\n            return view.db.destroy();\n          }\n          return utils.fin(updateView(view).then(function () {\n            return queryView(view, opts);\n          }), cleanup);\n        });\n      });\n      return tempViewQueue.finish();\n    } else {\n      // persistent view\n      var fullViewName = fun;\n      var parts = parseViewName(fullViewName);\n      var designDocName = parts[0];\n      var viewName = parts[1];\n      return db.get('_design/' + designDocName).then(function (doc) {\n        var fun = doc.views && doc.views[viewName];\n\n        if (!fun) {\n          // basic validator; it's assumed that every subclass would want this\n          throw new NotFoundError('ddoc ' + doc._id + ' has no view named ' +\n            viewName);\n        }\n\n        ddocValidator(doc, viewName);\n        checkQueryParseError(opts, fun);\n\n        var createViewOpts = {\n          db : db,\n          viewName : fullViewName,\n          map : fun.map,\n          reduce : fun.reduce,\n          pluginName: pluginName\n        };\n        return createView(createViewOpts).then(function (view) {\n          if (opts.stale === 'ok' || opts.stale === 'update_after') {\n            if (opts.stale === 'update_after') {\n              process.nextTick(function () {\n                updateView(view);\n              });\n            }\n            return queryView(view, opts);\n          } else { // stale not ok\n            return updateView(view).then(function () {\n              return queryView(view, opts);\n            });\n          }\n        });\n      });\n    }\n  }\n\n  var query = function (fun, opts, callback) {\n    var db = this;\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = utils.extend(true, {}, opts);\n\n    if (typeof fun === 'function') {\n      fun = {map : fun};\n    }\n\n    var promise = Promise.resolve().then(function () {\n      return queryPromised(db, fun, opts);\n    });\n    utils.promisedCallback(promise, callback);\n    return promise;\n  };\n\n  var viewCleanup = utils.callbackify(function () {\n    var db = this;\n    return localViewCleanup(db);\n  });\n\n  return {\n    query: query,\n    viewCleanup: viewCleanup\n  };\n}\n\nmodule.exports = createIndexer;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/abstract-mapreduce/index.js\n// module id = 225\n// module chunks = 0","'use strict';\n/*\n * Simple task queue to sequentialize actions. Assumes callbacks will eventually fire (once).\n */\n\nvar Promise = require('./utils').Promise;\n\nfunction TaskQueue() {\n  this.promise = new Promise(function (fulfill) {fulfill(); });\n}\nTaskQueue.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue.prototype.finish = function () {\n  return this.promise;\n};\n\nmodule.exports = TaskQueue;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/abstract-mapreduce/taskqueue.js\n// module id = 226\n// module chunks = 0","'use strict';\n\nvar massageCreateIndexRequest = require('../../massageCreateIndexRequest');\n\nfunction createIndex(db, requestDef, callback) {\n  requestDef = massageCreateIndexRequest(requestDef);\n\n  db.request({\n    method: 'POST',\n    url: '_index',\n    body: requestDef\n  }, callback);\n}\n\nfunction find(db, requestDef, callback) {\n  db.request({\n    method: 'POST',\n    url: '_find',\n    body: requestDef\n  }, callback);\n}\n\nfunction getIndexes(db, callback) {\n  db.request({\n    method: 'GET',\n    url: '_index'\n  }, callback);\n}\n\nfunction deleteIndex(db, indexDef, callback) {\n\n\n  var ddoc = indexDef.ddoc;\n  var type = indexDef.type || 'json';\n  var name = indexDef.name;\n\n  if (!ddoc) {\n    return callback(new Error('you must provide an index\\'s ddoc'));\n  }\n\n  if (!name) {\n    return callback(new Error('you must provide an index\\'s name'));\n  }\n\n  var url = '_index/' + [ddoc, type, name].map(encodeURIComponent).join('/');\n\n  db.request({\n    method: 'DELETE',\n    url: url\n  }, callback);\n}\n\nexports.createIndex = createIndex;\nexports.find = find;\nexports.getIndexes = getIndexes;\nexports.deleteIndex = deleteIndex;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/adapters/http/index.js\n// module id = 227\n// module chunks = 0","'use strict';\n\nvar utils = require('../../../utils');\nvar log = utils.log;\n\nvar pouchUpsert = require('pouchdb-upsert');\nvar abstractMapper = require('../abstract-mapper');\nvar localUtils = require('../utils');\nvar validateIndex = localUtils.validateIndex;\nvar massageIndexDef = localUtils.massageIndexDef;\nvar massageCreateIndexRequest = require('../../../massageCreateIndexRequest');\n\nfunction upsert(db, docId, diffFun) {\n  return pouchUpsert.upsert.call(db, docId, diffFun);\n}\n\nfunction createIndex(db, requestDef) {\n  requestDef = massageCreateIndexRequest(requestDef);\n  var originalIndexDef = utils.clone(requestDef.index);\n  requestDef.index = massageIndexDef(requestDef.index);\n\n  validateIndex(requestDef.index);\n\n  var md5 = utils.MD5(JSON.stringify(requestDef));\n\n  var viewName = requestDef.name || ('idx-' + md5);\n\n  var ddocName = requestDef.ddoc || ('idx-' + md5);\n  var ddocId = '_design/' + ddocName;\n\n  var hasInvalidLanguage = false;\n  var viewExists = false;\n\n  function updateDdoc(doc) {\n    if (doc._rev && doc.language !== 'query') {\n      hasInvalidLanguage = true;\n    }\n    doc.language = 'query';\n    doc.views = doc.views || {};\n\n    viewExists = !!doc.views[viewName];\n\n    if (viewExists) {\n      return false;\n    }\n\n    doc.views[viewName] = {\n      map: {\n        fields: utils.mergeObjects(requestDef.index.fields)\n      },\n      reduce: '_count',\n      options: {\n        def: originalIndexDef\n      }\n    };\n\n    return doc;\n  }\n\n  log('creating index', ddocId);\n\n  return upsert(db, ddocId, updateDdoc).then(function () {\n    if (hasInvalidLanguage) {\n      throw new Error('invalid language for ddoc with id \"' +\n      ddocId +\n      '\" (should be \"query\")');\n    }\n  }).then(function () {\n    // kick off a build\n    // TODO: abstract-pouchdb-mapreduce should support auto-updating\n    // TODO: should also use update_after, but pouchdb/pouchdb#3415 blocks me\n    var signature = ddocName + '/' + viewName;\n    return abstractMapper.query.call(db, signature, {\n      limit: 0,\n      reduce: false\n    }).then(function () {\n      return {\n        id: ddocId,\n        name: viewName,\n        result: viewExists ? 'exists' : 'created'\n      };\n    });\n  });\n}\n\nmodule.exports = createIndex;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/adapters/local/create-index/index.js\n// module id = 228\n// module chunks = 0","'use strict';\n\nvar abstractMapper = require('../abstract-mapper');\nvar upsert = require('../../../abstract-mapreduce/upsert');\n\nfunction deleteIndex(db, index) {\n\n  if (!index.ddoc) {\n    throw new Error('you must supply an index.ddoc when deleting');\n  }\n\n  if (!index.name) {\n    throw new Error('you must supply an index.name when deleting');\n  }\n\n  var docId = index.ddoc;\n  var viewName = index.name;\n\n  function deltaFun (doc) {\n    if (Object.keys(doc.views).length === 1 && doc.views[viewName]) {\n      // only one view in this ddoc, delete the whole ddoc\n      return {_id: docId, _deleted: true};\n    }\n    // more than one view here, just remove the view\n    delete doc.views[viewName];\n    return doc;\n  }\n\n  return upsert(db, docId, deltaFun).then(function () {\n    return abstractMapper.viewCleanup.apply(db);\n  }).then(function () {\n    return {ok: true};\n  });\n}\n\nmodule.exports = deleteIndex;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/adapters/local/delete-index/index.js\n// module id = 229\n// module chunks = 0","'use strict';\n\n//\n// Do an in-memory filtering of rows that aren't covered by the index.\n// E.g. if the user is asking for foo=1 and bar=2, but the index\n// only covers \"foo\", then this in-memory filter would take care of\n// \"bar\".\n//\n\nvar isArray = require('is-array');\nvar collate = require('pouchdb-collate').collate;\nvar localUtils = require('../utils');\nvar isCombinationalField = localUtils.isCombinationalField;\nvar getKey = localUtils.getKey;\nvar getValue = localUtils.getValue;\nvar parseField = localUtils.parseField;\nvar utils = require('../../../utils');\nvar getFieldFromDoc = utils.getFieldFromDoc;\n\n// create a comparator based on the sort object\nfunction createFieldSorter(sort) {\n\n  function getFieldValuesAsArray(doc) {\n    return sort.map(function (sorting) {\n      var fieldName = getKey(sorting);\n      var parsedField = parseField(fieldName);\n      var docFieldValue = getFieldFromDoc(doc, parsedField);\n      return docFieldValue;\n    });\n  }\n\n  return function (aRow, bRow) {\n    var aFieldValues = getFieldValuesAsArray(aRow.doc);\n    var bFieldValues = getFieldValuesAsArray(bRow.doc);\n    var collation = collate(aFieldValues, bFieldValues);\n    if (collation !== 0) {\n      return collation;\n    }\n    // this is what mango seems to do\n    return utils.compare(aRow.doc._id, bRow.doc._id);\n  };\n}\n\nfunction filterInMemoryFields (rows, requestDef, inMemoryFields) {\n  rows = rows.filter(function (row) {\n    return rowFilter(row.doc, requestDef.selector, inMemoryFields);\n  });\n\n  if (requestDef.sort) {\n    // in-memory sort\n    var fieldSorter = createFieldSorter(requestDef.sort);\n    rows = rows.sort(fieldSorter);\n    if (typeof requestDef.sort[0] !== 'string' &&\n        getValue(requestDef.sort[0]) === 'desc') {\n      rows = rows.reverse();\n    }\n  }\n\n  if ('limit' in requestDef || 'skip' in requestDef) {\n    // have to do the limit in-memory\n    var skip = requestDef.skip || 0;\n    var limit = ('limit' in requestDef ? requestDef.limit : rows.length) + skip;\n    rows = rows.slice(skip, limit);\n  }\n  return rows;\n}\n\nfunction rowFilter (doc, selector, inMemoryFields) {\n  return inMemoryFields.every(function (field) {\n    var matcher = selector[field];\n    var parsedField = parseField(field);\n    var docFieldValue = getFieldFromDoc(doc, parsedField);\n    if (isCombinationalField(field)) {\n      return matchCominationalSelector(field, matcher, doc);\n    }\n\n    return matchSelector(matcher, doc, parsedField, docFieldValue);\n  });\n}\n\nfunction matchSelector (matcher, doc, parsedField, docFieldValue) {\n  if (!matcher) {\n    // no filtering necessary; this field is just needed for sorting\n    return true;\n  }\n\n  return Object.keys(matcher).every(function (userOperator) {\n    var userValue = matcher[userOperator];\n    return match(userOperator, doc, userValue, parsedField, docFieldValue);\n  });\n}\n\nfunction matchCominationalSelector (field, matcher, doc) {\n\n  if (field === '$or') {\n    return matcher.some(function (orMatchers) {\n      return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n    });\n  }\n\n  if (field === '$not') {\n    return !rowFilter(doc, matcher, Object.keys(matcher));\n  }\n\n  //`$nor`\n  return !matcher.find(function (orMatchers) {\n    return rowFilter(doc, orMatchers, Object.keys(orMatchers));\n  });\n\n}\n\nfunction match(userOperator, doc, userValue, parsedField, docFieldValue) {\n  if (!matchers[userOperator]) {\n    throw new Error('unknown operator \"' + userOperator +\n      '\" - should be one of $eq, $lte, $lt, $gt, $gte, $exists, $ne, $in, ' +\n      '$nin, $size, $mod, $regex, $elemMatch, $type or $all');\n  }\n  return matchers[userOperator](doc, userValue, parsedField, docFieldValue);\n}\n\nfunction fieldExists(docFieldValue) {\n  return typeof docFieldValue !== 'undefined' && docFieldValue !== null;\n}\n\nfunction fieldIsNotUndefined(docFieldValue) {\n  return typeof docFieldValue !== 'undefined';\n}\n\nfunction modField (docFieldValue, userValue) {\n  var divisor = userValue[0];\n  var mod = userValue[1];\n  if (divisor === 0) {\n    throw new Error('Bad divisor, cannot divide by zero');\n  }\n\n  if (parseInt(divisor, 10) !== divisor ) {\n    throw new Error('Divisor is not an integer');\n  }\n\n  if (parseInt(mod, 10) !== mod ) {\n    throw new Error('Modulus is not an integer');\n  }\n\n  if (parseInt(docFieldValue, 10) !== docFieldValue) {\n    return false;\n  }\n\n  return docFieldValue % divisor === mod;\n}\n\nfunction arrayContainsValue (docFieldValue, userValue) {\n  return userValue.some(function (val) {\n    if (docFieldValue instanceof Array) {\n      return docFieldValue.indexOf(val) > -1;\n    }\n\n    return docFieldValue === val;\n  });\n}\n\nfunction arrayContainsAllValues (docFieldValue, userValue) {\n  return userValue.every(function (val) {\n    return docFieldValue.indexOf(val) > -1;\n  });\n}\n\nfunction arraySize (docFieldValue, userValue) {\n  return docFieldValue.length === userValue;\n}\n\nfunction regexMatch(docFieldValue, userValue) {\n  var re = new RegExp(userValue);\n\n  return re.test(docFieldValue);\n}\n\nfunction typeMatch(docFieldValue, userValue) {\n\n  switch (userValue) {\n    case 'null':\n      return docFieldValue === null;\n    case 'boolean':\n      return typeof(docFieldValue) === 'boolean';\n    case 'number':\n      return typeof(docFieldValue) === 'number';\n    case 'string':\n      return typeof(docFieldValue) === 'string';\n    case 'array':\n      return docFieldValue instanceof Array;\n    case 'object':\n      return ({}).toString.call(docFieldValue) === '[object Object]';\n  }\n\n  throw new Error(userValue + ' not supported as a type.' +\n                  'Please use one of object, string, array, number, boolean or null.');\n\n}\n\nvar matchers = {\n\n  '$elemMatch': function (doc, userValue, parsedField, docFieldValue) {\n    if (!isArray(docFieldValue)) {\n      return false;\n    }\n\n    if (docFieldValue.length === 0) {\n      return false;\n    }\n\n    if (typeof docFieldValue[0] === 'object') {\n      return docFieldValue.some(function (val) {\n        return rowFilter(val, userValue, Object.keys(userValue));\n      });\n    }\n\n    return docFieldValue.some(function (val) {\n      return matchSelector(userValue, doc, parsedField, val);\n    });\n  },\n\n  '$eq': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) === 0;\n  },\n\n  '$gte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) >= 0;\n  },\n\n  '$gt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) > 0;\n  },\n\n  '$lte': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) <= 0;\n  },\n\n  '$lt': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldIsNotUndefined(docFieldValue) && collate(docFieldValue, userValue) < 0;\n  },\n\n  '$exists': function (doc, userValue, parsedField, docFieldValue) {\n    //a field that is null is still considered to exist\n    if (userValue) {\n      return fieldIsNotUndefined(docFieldValue);\n    }\n\n    return !fieldIsNotUndefined(docFieldValue);\n  },\n\n  '$mod': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && modField(docFieldValue, userValue);\n  },\n\n  '$ne': function (doc, userValue, parsedField, docFieldValue) {\n    return userValue.every(function (neValue) {\n      return collate(docFieldValue, neValue) !== 0;\n    });\n  },\n  '$in': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$nin': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && !arrayContainsValue(docFieldValue, userValue);\n  },\n\n  '$size': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && arraySize(docFieldValue, userValue);\n  },\n\n  '$all': function (doc, userValue, parsedField, docFieldValue) {\n    return isArray(docFieldValue) && arrayContainsAllValues(docFieldValue, userValue);\n  },\n\n  '$regex': function (doc, userValue, parsedField, docFieldValue) {\n    return fieldExists(docFieldValue) && regexMatch(docFieldValue, userValue);\n  },\n\n  '$type': function (doc, userValue, parsedField, docFieldValue) {\n    return typeMatch(docFieldValue, userValue);\n  }\n};\n\nmodule.exports = filterInMemoryFields;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/adapters/local/find/in-memory-filter.js\n// module id = 230\n// module chunks = 0","'use strict';\n\nvar utils = require('../../../utils');\nvar clone = utils.clone;\nvar getIndexes = require('../get-indexes');\nvar collate = require('pouchdb-collate').collate;\nvar abstractMapper = require('../abstract-mapper');\nvar planQuery = require('./query-planner');\nvar localUtils = require('../utils');\nvar filterInMemoryFields = require('./in-memory-filter');\nvar massageSelector = localUtils.massageSelector;\nvar massageSort = localUtils.massageSort;\nvar getValue = localUtils.getValue;\nvar validateFindRequest = localUtils.validateFindRequest;\nvar validateSort = localUtils.validateSort;\nvar reverseOptions = localUtils.reverseOptions;\nvar filterInclusiveStart = localUtils.filterInclusiveStart;\nvar Promise = utils.Promise;\n\nfunction indexToSignature(index) {\n  // remove '_design/'\n  return index.ddoc.substring(8) + '/' + index.name;\n}\n\nfunction doAllDocs(db, originalOpts) {\n  var opts = clone(originalOpts);\n\n  // CouchDB responds in weird ways when you provide a non-string to _id;\n  // we mimic the behavior for consistency. See issue66 tests for details.\n\n  if (opts.descending) {\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.endkey = '';\n    }\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.limit = 0;\n    }\n  } else {\n    if ('startkey' in opts && typeof opts.startkey !== 'string') {\n      opts.startkey = '';\n    }\n    if ('endkey' in opts && typeof opts.endkey !== 'string') {\n      opts.limit = 0;\n    }\n  }\n  if ('key' in opts && typeof opts.key !== 'string') {\n    opts.limit = 0;\n  }\n\n  return db.allDocs(opts);\n}\n\nfunction find(db, requestDef) {\n\n  if (requestDef.selector) {\n    requestDef.selector = massageSelector(requestDef.selector);\n  }\n  if (requestDef.sort) {\n    requestDef.sort = massageSort(requestDef.sort);\n  }\n\n  validateFindRequest(requestDef);\n\n  return getIndexes(db).then(function (getIndexesRes) {\n\n    var queryPlan = planQuery(requestDef, getIndexesRes.indexes);\n\n    var indexToUse = queryPlan.index;\n\n    validateSort(requestDef, indexToUse);\n\n    var opts = utils.extend(true, {\n      include_docs: true,\n      reduce: false\n    }, queryPlan.queryOpts);\n\n    if ('startkey' in opts && 'endkey' in opts &&\n        collate(opts.startkey, opts.endkey) > 0) {\n      // can't possibly return any results, startkey > endkey\n      return {docs: []};\n    }\n\n    var isDescending = requestDef.sort &&\n      typeof requestDef.sort[0] !== 'string' &&\n      getValue(requestDef.sort[0]) === 'desc';\n\n    if (isDescending) {\n      // either all descending or all ascending\n      opts.descending = true;\n      opts = reverseOptions(opts);\n    }\n\n    if (!queryPlan.inMemoryFields.length) {\n      // no in-memory filtering necessary, so we can let the\n      // database do the limit/skip for us\n      if ('limit' in requestDef) {\n        opts.limit = requestDef.limit;\n      }\n      if ('skip' in requestDef) {\n        opts.skip = requestDef.skip;\n      }\n    }\n\n    return Promise.resolve().then(function () {\n      if (indexToUse.name === '_all_docs') {\n        return doAllDocs(db, opts);\n      } else {\n        var signature = indexToSignature(indexToUse);\n        return abstractMapper.query.call(db, signature, opts);\n      }\n    }).then(function (res) {\n\n      if (opts.inclusive_start === false) {\n        // may have to manually filter the first one,\n        // since couchdb has no true inclusive_start option\n        res.rows = filterInclusiveStart(res.rows, opts.startkey, indexToUse);\n      }\n\n      if (queryPlan.inMemoryFields.length) {\n        // need to filter some stuff in-memory\n        res.rows = filterInMemoryFields(res.rows, requestDef, queryPlan.inMemoryFields);\n      }\n\n      var resp = {\n        docs: res.rows.map(function (row) {\n          var doc = row.doc;\n          if (requestDef.fields) {\n            return utils.pick(doc, requestDef.fields);\n          }\n          return doc;\n        })\n      };\n\n      if (indexToUse.defaultUsed) {\n        resp.warning = 'no matching index found, create an index to optimize query time';\n      }\n\n      return resp;\n    });\n  });\n}\n\nmodule.exports = find;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/adapters/local/find/index.js\n// module id = 231\n// module chunks = 0","'use strict';\n\nvar utils = require('../../../utils');\nvar log = utils.log;\nvar localUtils = require('../utils');\nvar getKey = localUtils.getKey;\nvar getUserFields = localUtils.getUserFields;\n\n// couchdb lowest collation value\nvar COLLATE_LO = null;\n\n// couchdb highest collation value (TODO: well not really, but close enough amirite)\nvar COLLATE_HI = {\"\\uffff\": {}};\n\n// couchdb second-lowest collation value\n\nfunction checkFieldInIndex(index, field) {\n  var indexFields = index.def.fields.map(getKey);\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n    if (field === indexField) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// so when you do e.g. $eq/$eq, we can do it entirely in the database.\n// but when you do e.g. $gt/$eq, the first part can be done\n// in the database, but the second part has to be done in-memory,\n// because $gt has forced us to lose precision.\n// so that's what this determines\nfunction userOperatorLosesPrecision(selector, field) {\n  var matcher = selector[field];\n  var userOperator = getKey(matcher);\n\n  return userOperator !== '$eq';\n}\n\n// sort the user fields by their position in the index,\n// if they're in the index\nfunction sortFieldsByIndex(userFields, index) {\n  var indexFields = index.def.fields.map(getKey);\n\n  return userFields.slice().sort(function (a, b) {\n    var aIdx = indexFields.indexOf(a);\n    var bIdx = indexFields.indexOf(b);\n    if (aIdx === -1) {\n      aIdx = Number.MAX_VALUE;\n    }\n    if (bIdx === -1) {\n      bIdx = Number.MAX_VALUE;\n    }\n    return utils.compare(aIdx, bIdx);\n  });\n}\n\n// first pass to try to find fields that will need to be sorted in-memory\nfunction getBasicInMemoryFields(index, selector, userFields) {\n\n  userFields = sortFieldsByIndex(userFields, index);\n\n  // check if any of the user selectors lose precision\n  var needToFilterInMemory = false;\n  for (var i = 0, len = userFields.length; i < len; i++) {\n    var field = userFields[i];\n    if (needToFilterInMemory || !checkFieldInIndex(index, field)) {\n      return userFields.slice(i);\n    }\n    if (i < len - 1 && userOperatorLosesPrecision(selector, field)) {\n      needToFilterInMemory = true;\n    }\n  }\n  return [];\n}\n\nfunction getInMemoryFieldsFromNe(selector) {\n  var fields = [];\n  Object.keys(selector).forEach(function (field) {\n    var matcher = selector[field];\n    Object.keys(matcher).forEach(function (operator) {\n      if (operator === '$ne') {\n        fields.push(field);\n      }\n    });\n  });\n  return fields;\n}\n\nfunction getInMemoryFields(coreInMemoryFields, index, selector, userFields) {\n  var result = utils.flatten(\n    // in-memory fields reported as necessary by the query planner\n    coreInMemoryFields,\n    // combine with another pass that checks for any we may have missed\n    getBasicInMemoryFields(index, selector, userFields),\n    // combine with another pass that checks for $ne's\n    getInMemoryFieldsFromNe(selector)\n  );\n\n  return sortFieldsByIndex(utils.uniq(result), index);\n}\n\n// check that at least one field in the user's query is represented\n// in the index. order matters in the case of sorts\nfunction checkIndexFieldsMatch(indexFields, sortOrder, fields) {\n  if (sortOrder) {\n    // array has to be a strict subarray of index array. furthermore,\n    // the sortOrder fields need to all be represented in the index\n    var sortMatches = utils.oneArrayIsStrictSubArrayOfOther(sortOrder, indexFields);\n    var selectorMatches = utils.oneArrayIsSubArrayOfOther(fields, indexFields);\n\n    return sortMatches && selectorMatches;\n  }\n\n  // all of the user's specified fields still need to be\n  // on the left side of the index array, although the order\n  // doesn't matter\n  return utils.oneSetIsSubArrayOfOther(fields, indexFields);\n}\n\nvar logicalMatchers = ['$eq', '$gt', '$gte', '$lt', '$lte'];\nfunction isNonLogicalMatcher (matcher) {\n  return logicalMatchers.indexOf(matcher) === -1;\n}\n\n// check all the index fields for usages of '$ne'\n// e.g. if the user queries {foo: {$ne: 'foo'}, bar: {$eq: 'bar'}},\n// then we can neither use an index on ['foo'] nor an index on\n// ['foo', 'bar'], but we can use an index on ['bar'] or ['bar', 'foo']\nfunction checkFieldsLogicallySound(indexFields, selector) {\n  var firstField = indexFields[0];\n  var matcher = selector[firstField];\n\n  var hasLogicalOperator = Object.keys(matcher).some(function (matcherKey) {\n    return !(isNonLogicalMatcher(matcherKey));\n  });\n\n  if (!hasLogicalOperator) {\n    return false;\n  }\n\n  var isInvalidNe = Object.keys(matcher).length === 1 &&\n    getKey(matcher) === '$ne';\n\n  return !isInvalidNe;\n}\n\nfunction checkIndexMatches(index, sortOrder, fields, selector) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var fieldsMatch = checkIndexFieldsMatch(indexFields, sortOrder, fields);\n\n  if (!fieldsMatch) {\n    return false;\n  }\n\n  return checkFieldsLogicallySound(indexFields, selector);\n}\n\n//\n// the algorithm is very simple:\n// take all the fields the user supplies, and if those fields\n// are a strict subset of the fields in some index,\n// then use that index\n//\n//\nfunction findMatchingIndexes(selector, userFields, sortOrder, indexes) {\n\n  return indexes.reduce(function (res, index) {\n    var indexMatches = checkIndexMatches(index, sortOrder, userFields, selector);\n    if (indexMatches) {\n      res.push(index);\n    }\n    return res;\n  }, []);\n}\n\n// find the best index, i.e. the one that matches the most fields\n// in the user's query\nfunction findBestMatchingIndex(selector, userFields, sortOrder, indexes) {\n\n  var matchingIndexes = findMatchingIndexes(selector, userFields, sortOrder, indexes);\n\n  if (matchingIndexes.length === 0) {\n    //return `all_docs` as a default index;\n    //I'm assuming that _all_docs is always first\n    var defaultIndex = indexes[0];\n    defaultIndex.defaultUsed = true;\n    return defaultIndex;\n  }\n  if (matchingIndexes.length === 1) {\n    return matchingIndexes[0];\n  }\n\n  var userFieldsMap = utils.arrayToObject(userFields);\n\n  function scoreIndex(index) {\n    var indexFields = index.def.fields.map(getKey);\n    var score = 0;\n    for (var i = 0, len = indexFields.length; i < len; i++) {\n      var indexField = indexFields[i];\n      if (userFieldsMap[indexField]) {\n        score++;\n      }\n    }\n    return score;\n  }\n\n  return utils.max(matchingIndexes, scoreIndex);\n}\n\nfunction getSingleFieldQueryOptsFor(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {key: userValue};\n    case '$lte':\n      return {endkey: userValue};\n    case '$gte':\n      return {startkey: userValue};\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getSingleFieldCoreQueryPlan(selector, index) {\n  var field = getKey(index.def.fields[0]);\n  var matcher = selector[field];\n  var inMemoryFields = [];\n\n  var userOperators = Object.keys(matcher);\n\n  var combinedOpts;\n\n  userOperators.forEach(function (userOperator) {\n\n    if (isNonLogicalMatcher(userOperator)) {\n      inMemoryFields.push(field);\n      return;\n    }\n\n    var userValue = matcher[userOperator];\n\n    var newQueryOpts = getSingleFieldQueryOptsFor(userOperator, userValue);\n\n    if (combinedOpts) {\n      combinedOpts = utils.mergeObjects([combinedOpts, newQueryOpts]);\n    } else {\n      combinedOpts = newQueryOpts;\n    }\n  });\n\n  return {\n    queryOpts: combinedOpts,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getMultiFieldCoreQueryPlan(userOperator, userValue) {\n  switch (userOperator) {\n    case '$eq':\n      return {\n        startkey: userValue,\n        endkey: userValue\n      };\n    case '$lte':\n      return {\n        endkey: userValue\n      };\n    case '$gte':\n      return {\n        startkey: userValue\n      };\n    case '$lt':\n      return {\n        endkey: userValue,\n        inclusive_end: false\n      };\n    case '$gt':\n      return {\n        startkey: userValue,\n        inclusive_start: false\n      };\n  }\n}\n\nfunction getMultiFieldQueryOpts(selector, index) {\n\n  var indexFields = index.def.fields.map(getKey);\n\n  var inMemoryFields = [];\n  var startkey = [];\n  var endkey = [];\n  var inclusiveStart;\n  var inclusiveEnd;\n\n\n  function finish(i) {\n\n    if (inclusiveStart !== false) {\n      startkey.push(COLLATE_LO);\n    }\n    if (inclusiveEnd !== false) {\n      endkey.push(COLLATE_HI);\n    }\n    // keep track of the fields where we lost specificity,\n    // and therefore need to filter in-memory\n    inMemoryFields = indexFields.slice(i);\n  }\n\n  for (var i = 0, len = indexFields.length; i < len; i++) {\n    var indexField = indexFields[i];\n\n    var matcher = selector[indexField];\n\n    if (!matcher) { // fewer fields in user query than in index\n      finish(i);\n      break;\n    } else if (i > 0) {\n      if ('$ne' in matcher) { // unusable $ne index\n        finish(i);\n        break;\n      }\n      var usingGtlt = (\n        '$gt' in matcher || '$gte' in matcher ||\n        '$lt' in matcher || '$lte' in matcher);\n      var previousKeys = Object.keys(selector[indexFields[i - 1]]);\n      var previousWasEq = utils.arrayEquals(previousKeys, ['$eq']);\n      var previousWasSame = utils.arrayEquals(previousKeys, Object.keys(matcher));\n      var gtltLostSpecificity = usingGtlt && !previousWasEq && !previousWasSame;\n      if (gtltLostSpecificity) {\n        finish(i);\n        break;\n      }\n    }\n\n    var userOperators = Object.keys(matcher);\n\n    var combinedOpts = null;\n\n    for (var j = 0; j < userOperators.length; j++) {\n      var userOperator = userOperators[j];\n      var userValue = matcher[userOperator];\n\n      var newOpts = getMultiFieldCoreQueryPlan(userOperator, userValue);\n\n      if (combinedOpts) {\n        combinedOpts = utils.mergeObjects([combinedOpts, newOpts]);\n      } else {\n        combinedOpts = newOpts;\n      }\n    }\n\n    startkey.push('startkey' in combinedOpts ? combinedOpts.startkey : COLLATE_LO);\n    endkey.push('endkey' in combinedOpts ? combinedOpts.endkey : COLLATE_HI);\n    if ('inclusive_start' in combinedOpts) {\n      inclusiveStart = combinedOpts.inclusive_start;\n    }\n    if ('inclusive_end' in combinedOpts) {\n      inclusiveEnd = combinedOpts.inclusive_end;\n    }\n  }\n\n  var res = {\n    startkey: startkey,\n    endkey: endkey\n  };\n\n  if (typeof inclusiveStart !== 'undefined') {\n    res.inclusive_start = inclusiveStart;\n  }\n  if (typeof inclusiveEnd !== 'undefined') {\n    res.inclusive_end = inclusiveEnd;\n  }\n\n  return {\n    queryOpts: res,\n    inMemoryFields: inMemoryFields\n  };\n}\n\nfunction getDefaultQueryPlan () {\n  return {\n    queryOpts: {startkey: null},\n    //getInMemoryFields will do the work here later\n    inMemoryFields: []\n  };\n}\n\nfunction getCoreQueryPlan(selector, index) {\n  if (index.defaultUsed) {\n    return getDefaultQueryPlan(selector, index);\n  }\n\n  if (index.def.fields.length === 1) {\n    // one field in index, so the value was indexed as a singleton\n    return getSingleFieldCoreQueryPlan(selector, index);\n  }\n  // else index has multiple fields, so the value was indexed as an array\n  return getMultiFieldQueryOpts(selector, index);\n}\n\nfunction planQuery(request, indexes) {\n\n  log('planning query', request);\n\n  var selector = request.selector;\n  var sort = request.sort;\n\n  var userFieldsRes = getUserFields(selector, sort);\n\n  var userFields = userFieldsRes.fields;\n  var sortOrder = userFieldsRes.sortOrder;\n  var index = findBestMatchingIndex(selector, userFields, sortOrder, indexes);\n\n  var coreQueryPlan = getCoreQueryPlan(selector, index);\n  var queryOpts = coreQueryPlan.queryOpts;\n  var coreInMemoryFields = coreQueryPlan.inMemoryFields;\n\n  var inMemoryFields = getInMemoryFields(coreInMemoryFields, index, selector, userFields);\n\n  var res = {\n    queryOpts: queryOpts,\n    index: index,\n    inMemoryFields: inMemoryFields\n  };\n  log('query plan', res);\n  return res;\n}\n\nmodule.exports = planQuery;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/adapters/local/find/query-planner.js\n// module id = 232\n// module chunks = 0","'use strict';\n\nvar utils = require('../../utils');\nvar callbackify = utils.callbackify;\n\nexports.createIndex = callbackify(require('./create-index'));\nexports.find = callbackify(require('./find'));\nexports.getIndexes = callbackify(require('./get-indexes'));\nexports.deleteIndex = callbackify(require('./delete-index'));\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/adapters/local/index.js\n// module id = 233\n// module chunks = 0","'use strict';\n\nvar utils = require('./utils');\n\nvar httpIndexes = require('./adapters/http');\nvar localIndexes = require('./adapters/local');\n\nvar plugin = {};\nplugin.createIndex = utils.toPromise(function (requestDef, callback) {\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide an index to create'));\n  }\n\n  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\n  adapter.createIndex(this, requestDef, callback);\n});\n\nplugin.find = utils.toPromise(function (requestDef, callback) {\n\n  if (typeof callback === 'undefined') {\n    callback = requestDef;\n    requestDef = undefined;\n  }\n\n  if (typeof requestDef !== 'object') {\n    return callback(new Error('you must provide search parameters to find()'));\n  }\n\n  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\n  adapter.find(this, requestDef, callback);\n});\n\nplugin.getIndexes = utils.toPromise(function (callback) {\n\n  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\n  adapter.getIndexes(this, callback);\n});\n\nplugin.deleteIndex = utils.toPromise(function (indexDef, callback) {\n\n  if (typeof indexDef !== 'object') {\n    return callback(new Error('you must provide an index to delete'));\n  }\n\n  var adapter = this.type() === 'http' ? httpIndexes : localIndexes;\n\n  adapter.deleteIndex(this, indexDef, callback);\n});\n\nmodule.exports = plugin;\n\n/* istanbul ignore next */\nif (typeof window !== 'undefined' && window.PouchDB) {\n  window.PouchDB.plugin(plugin);\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/lib/index.js\n// module id = 234\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/~/debug/src/debug.js\n// module id = 236\n// module chunks = 0","/**\n * Helpers.\n */\n\nvar s = 1000\nvar m = s * 60\nvar h = m * 60\nvar d = h * 24\nvar y = d * 365.25\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function (val, options) {\n  options = options || {}\n  var type = typeof val\n  if (type === 'string' && val.length > 0) {\n    return parse(val)\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ?\n\t\t\tfmtLong(val) :\n\t\t\tfmtShort(val)\n  }\n  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))\n}\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str)\n  if (str.length > 10000) {\n    return\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)\n  if (!match) {\n    return\n  }\n  var n = parseFloat(match[1])\n  var type = (match[2] || 'ms').toLowerCase()\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n\n    default:\n      return undefined\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd'\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h'\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm'\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's'\n  }\n  return ms + 'ms'\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms'\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's'\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-find/~/ms/index.js\n// module id = 237\n// module chunks = 0","'use strict';\nvar immediate = require('immediate');\n\n/* istanbul ignore next */\nfunction INTERNAL() {}\n\nvar handlers = {};\n\nvar REJECTED = ['REJECTED'];\nvar FULFILLED = ['FULFILLED'];\nvar PENDING = ['PENDING'];\n/* istanbul ignore else */\nif (!process.browser) {\n  // in which we actually take advantage of JS scoping\n  var UNHANDLED = ['UNHANDLED'];\n}\n\nmodule.exports = Promise;\n\nfunction Promise(resolver) {\n  if (typeof resolver !== 'function') {\n    throw new TypeError('resolver must be a function');\n  }\n  this.state = PENDING;\n  this.queue = [];\n  this.outcome = void 0;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    this.handled = UNHANDLED;\n  }\n  if (resolver !== INTERNAL) {\n    safelyResolveThenable(this, resolver);\n  }\n}\n\nPromise.prototype.catch = function (onRejected) {\n  return this.then(null, onRejected);\n};\nPromise.prototype.then = function (onFulfilled, onRejected) {\n  if (typeof onFulfilled !== 'function' && this.state === FULFILLED ||\n    typeof onRejected !== 'function' && this.state === REJECTED) {\n    return this;\n  }\n  var promise = new this.constructor(INTERNAL);\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (this.handled === UNHANDLED) {\n      this.handled = null;\n    }\n  }\n  if (this.state !== PENDING) {\n    var resolver = this.state === FULFILLED ? onFulfilled : onRejected;\n    unwrap(promise, resolver, this.outcome);\n  } else {\n    this.queue.push(new QueueItem(promise, onFulfilled, onRejected));\n  }\n\n  return promise;\n};\nfunction QueueItem(promise, onFulfilled, onRejected) {\n  this.promise = promise;\n  if (typeof onFulfilled === 'function') {\n    this.onFulfilled = onFulfilled;\n    this.callFulfilled = this.otherCallFulfilled;\n  }\n  if (typeof onRejected === 'function') {\n    this.onRejected = onRejected;\n    this.callRejected = this.otherCallRejected;\n  }\n}\nQueueItem.prototype.callFulfilled = function (value) {\n  handlers.resolve(this.promise, value);\n};\nQueueItem.prototype.otherCallFulfilled = function (value) {\n  unwrap(this.promise, this.onFulfilled, value);\n};\nQueueItem.prototype.callRejected = function (value) {\n  handlers.reject(this.promise, value);\n};\nQueueItem.prototype.otherCallRejected = function (value) {\n  unwrap(this.promise, this.onRejected, value);\n};\n\nfunction unwrap(promise, func, value) {\n  immediate(function () {\n    var returnValue;\n    try {\n      returnValue = func(value);\n    } catch (e) {\n      return handlers.reject(promise, e);\n    }\n    if (returnValue === promise) {\n      handlers.reject(promise, new TypeError('Cannot resolve promise with itself'));\n    } else {\n      handlers.resolve(promise, returnValue);\n    }\n  });\n}\n\nhandlers.resolve = function (self, value) {\n  var result = tryCatch(getThen, value);\n  if (result.status === 'error') {\n    return handlers.reject(self, result.value);\n  }\n  var thenable = result.value;\n\n  if (thenable) {\n    safelyResolveThenable(self, thenable);\n  } else {\n    self.state = FULFILLED;\n    self.outcome = value;\n    var i = -1;\n    var len = self.queue.length;\n    while (++i < len) {\n      self.queue[i].callFulfilled(value);\n    }\n  }\n  return self;\n};\nhandlers.reject = function (self, error) {\n  self.state = REJECTED;\n  self.outcome = error;\n  /* istanbul ignore else */\n  if (!process.browser) {\n    if (self.handled === UNHANDLED) {\n      immediate(function () {\n        if (self.handled === UNHANDLED) {\n          process.emit('unhandledRejection', error, self);\n        }\n      });\n    }\n  }\n  var i = -1;\n  var len = self.queue.length;\n  while (++i < len) {\n    self.queue[i].callRejected(error);\n  }\n  return self;\n};\n\nfunction getThen(obj) {\n  // Make sure we only access the accessor once as required by the spec\n  var then = obj && obj.then;\n  if (obj && typeof obj === 'object' && typeof then === 'function') {\n    return function appyThen() {\n      then.apply(obj, arguments);\n    };\n  }\n}\n\nfunction safelyResolveThenable(self, thenable) {\n  // Either fulfill, reject or reject with error\n  var called = false;\n  function onError(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.reject(self, value);\n  }\n\n  function onSuccess(value) {\n    if (called) {\n      return;\n    }\n    called = true;\n    handlers.resolve(self, value);\n  }\n\n  function tryToUnwrap() {\n    thenable(onSuccess, onError);\n  }\n\n  var result = tryCatch(tryToUnwrap);\n  if (result.status === 'error') {\n    onError(result.value);\n  }\n}\n\nfunction tryCatch(func, value) {\n  var out = {};\n  try {\n    out.value = func(value);\n    out.status = 'success';\n  } catch (e) {\n    out.status = 'error';\n    out.value = e;\n  }\n  return out;\n}\n\nPromise.resolve = resolve;\nfunction resolve(value) {\n  if (value instanceof this) {\n    return value;\n  }\n  return handlers.resolve(new this(INTERNAL), value);\n}\n\nPromise.reject = reject;\nfunction reject(reason) {\n  var promise = new this(INTERNAL);\n  return handlers.reject(promise, reason);\n}\n\nPromise.all = all;\nfunction all(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var values = new Array(len);\n  var resolved = 0;\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    allResolver(iterable[i], i);\n  }\n  return promise;\n  function allResolver(value, i) {\n    self.resolve(value).then(resolveFromAll, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n    function resolveFromAll(outValue) {\n      values[i] = outValue;\n      if (++resolved === len && !called) {\n        called = true;\n        handlers.resolve(promise, values);\n      }\n    }\n  }\n}\n\nPromise.race = race;\nfunction race(iterable) {\n  var self = this;\n  if (Object.prototype.toString.call(iterable) !== '[object Array]') {\n    return this.reject(new TypeError('must be an array'));\n  }\n\n  var len = iterable.length;\n  var called = false;\n  if (!len) {\n    return this.resolve([]);\n  }\n\n  var i = -1;\n  var promise = new this(INTERNAL);\n\n  while (++i < len) {\n    resolver(iterable[i]);\n  }\n  return promise;\n  function resolver(value) {\n    self.resolve(value).then(function (response) {\n      if (!called) {\n        called = true;\n        handlers.resolve(promise, response);\n      }\n    }, function (error) {\n      if (!called) {\n        called = true;\n        handlers.reject(promise, error);\n      }\n    });\n  }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-promise/~/lie/lib/index.js\n// module id = 238\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(require('lie'));\nvar getArguments = _interopDefault(require('argsarray'));\nvar debug = _interopDefault(require('debug'));\nvar events = require('events');\nvar inherits = _interopDefault(require('inherits'));\nvar nextTick = _interopDefault(require('immediate'));\nvar scopedEval = _interopDefault(require('scope-eval'));\nvar Md5 = _interopDefault(require('spark-md5'));\nvar vuvuzela = _interopDefault(require('vuvuzela'));\n\n/* istanbul ignore next */\nvar PouchPromise$1 = typeof Promise === 'function' ? Promise : lie;\n\nfunction isBinaryObject(object) {\n  return (typeof ArrayBuffer !== 'undefined' && object instanceof ArrayBuffer) ||\n    (typeof Blob !== 'undefined' && object instanceof Blob);\n}\n\nfunction cloneArrayBuffer(buff) {\n  if (typeof buff.slice === 'function') {\n    return buff.slice(0);\n  }\n  // IE10-11 slice() polyfill\n  var target = new ArrayBuffer(buff.byteLength);\n  var targetArray = new Uint8Array(target);\n  var sourceArray = new Uint8Array(buff);\n  targetArray.set(sourceArray);\n  return target;\n}\n\nfunction cloneBinaryObject(object) {\n  if (object instanceof ArrayBuffer) {\n    return cloneArrayBuffer(object);\n  }\n  var size = object.size;\n  var type = object.type;\n  // Blob\n  if (typeof object.slice === 'function') {\n    return object.slice(0, size, type);\n  }\n  // PhantomJS slice() replacement\n  return object.webkitSlice(0, size, type);\n}\n\n// most of this is borrowed from lodash.isPlainObject:\n// https://github.com/fis-components/lodash.isplainobject/\n// blob/29c358140a74f252aeb08c9eb28bef86f2217d4a/index.js\n\nvar funcToString = Function.prototype.toString;\nvar objectCtorString = funcToString.call(Object);\n\nfunction isPlainObject(value) {\n  var proto = Object.getPrototypeOf(value);\n  /* istanbul ignore if */\n  if (proto === null) { // not sure when this happens, but I guess it can\n    return true;\n  }\n  var Ctor = proto.constructor;\n  return (typeof Ctor == 'function' &&\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\n}\n\nfunction clone(object) {\n  var newObject;\n  var i;\n  var len;\n\n  if (!object || typeof object !== 'object') {\n    return object;\n  }\n\n  if (Array.isArray(object)) {\n    newObject = [];\n    for (i = 0, len = object.length; i < len; i++) {\n      newObject[i] = clone(object[i]);\n    }\n    return newObject;\n  }\n\n  // special case: to avoid inconsistencies between IndexedDB\n  // and other backends, we automatically stringify Dates\n  if (object instanceof Date) {\n    return object.toISOString();\n  }\n\n  if (isBinaryObject(object)) {\n    return cloneBinaryObject(object);\n  }\n\n  if (!isPlainObject(object)) {\n    return object; // don't clone objects like Workers\n  }\n\n  newObject = {};\n  for (i in object) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(object, i)) {\n      var value = clone(object[i]);\n      if (typeof value !== 'undefined') {\n        newObject[i] = value;\n      }\n    }\n  }\n  return newObject;\n}\n\nfunction once(fun) {\n  var called = false;\n  return getArguments(function (args) {\n    /* istanbul ignore if */\n    if (called) {\n      // this is a smoke test and should never actually happen\n      throw new Error('once called more than once');\n    } else {\n      called = true;\n      fun.apply(this, args);\n    }\n  });\n}\n\nfunction toPromise(func) {\n  //create the function we will be returning\n  return getArguments(function (args) {\n    // Clone arguments\n    args = clone(args);\n    var self = this;\n    // if the last argument is a function, assume its a callback\n    var usedCB = (typeof args[args.length - 1] === 'function') ? args.pop() : false;\n    var promise = new PouchPromise$1(function (fulfill, reject) {\n      var resp;\n      try {\n        var callback = once(function (err, mesg) {\n          if (err) {\n            reject(err);\n          } else {\n            fulfill(mesg);\n          }\n        });\n        // create a callback for this invocation\n        // apply the function in the orig context\n        args.push(callback);\n        resp = func.apply(self, args);\n        if (resp && typeof resp.then === 'function') {\n          fulfill(resp);\n        }\n      } catch (e) {\n        reject(e);\n      }\n    });\n    // if there is a callback, call it back\n    if (usedCB) {\n      promise.then(function (result) {\n        usedCB(null, result);\n      }, usedCB);\n    }\n    return promise;\n  });\n}\n\nvar log = debug('pouchdb:api');\n\nfunction adapterFun(name, callback) {\n  function logApiCall(self, name, args) {\n    /* istanbul ignore if */\n    if (log.enabled) {\n      var logArgs = [self.name, name];\n      for (var i = 0; i < args.length - 1; i++) {\n        logArgs.push(args[i]);\n      }\n      log.apply(null, logArgs);\n\n      // override the callback itself to log the response\n      var origCallback = args[args.length - 1];\n      args[args.length - 1] = function (err, res) {\n        var responseArgs = [self.name, name];\n        responseArgs = responseArgs.concat(\n          err ? ['error', err] : ['success', res]\n        );\n        log.apply(null, responseArgs);\n        origCallback(err, res);\n      };\n    }\n  }\n\n  return toPromise(getArguments(function (args) {\n    if (this._closed) {\n      return PouchPromise$1.reject(new Error('database is closed'));\n    }\n    if (this._destroyed) {\n      return PouchPromise$1.reject(new Error('database is destroyed'));\n    }\n    var self = this;\n    logApiCall(self, name, args);\n    if (!this.taskqueue.isReady) {\n      return new PouchPromise$1(function (fulfill, reject) {\n        self.taskqueue.addTask(function (failed) {\n          if (failed) {\n            reject(failed);\n          } else {\n            fulfill(self[name].apply(self, args));\n          }\n        });\n      });\n    }\n    return callback.apply(this, args);\n  }));\n}\n\n// like underscore/lodash _.pick()\nfunction pick(obj, arr) {\n  var res = {};\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var prop = arr[i];\n    if (prop in obj) {\n      res[prop] = obj[prop];\n    }\n  }\n  return res;\n}\n\nfunction mangle(key) {\n  return '$' + key;\n}\nfunction unmangle(key) {\n  return key.substring(1);\n}\nfunction Map$1() {\n  this._store = {};\n}\nMap$1.prototype.get = function (key) {\n  var mangled = mangle(key);\n  return this._store[mangled];\n};\nMap$1.prototype.set = function (key, value) {\n  var mangled = mangle(key);\n  this._store[mangled] = value;\n  return true;\n};\nMap$1.prototype.has = function (key) {\n  var mangled = mangle(key);\n  return mangled in this._store;\n};\nMap$1.prototype.delete = function (key) {\n  var mangled = mangle(key);\n  var res = mangled in this._store;\n  delete this._store[mangled];\n  return res;\n};\nMap$1.prototype.forEach = function (cb) {\n  var keys = Object.keys(this._store);\n  for (var i = 0, len = keys.length; i < len; i++) {\n    var key = keys[i];\n    var value = this._store[key];\n    key = unmangle(key);\n    cb(value, key);\n  }\n};\nObject.defineProperty(Map$1.prototype, 'size', {\n  get: function () {\n    return Object.keys(this._store).length;\n  }\n});\n\nfunction Set$1(array) {\n  this._store = new Map$1();\n\n  // init with an array\n  if (array && Array.isArray(array)) {\n    for (var i = 0, len = array.length; i < len; i++) {\n      this.add(array[i]);\n    }\n  }\n}\nSet$1.prototype.add = function (key) {\n  return this._store.set(key, true);\n};\nSet$1.prototype.has = function (key) {\n  return this._store.has(key);\n};\nSet$1.prototype.forEach = function (cb) {\n  this._store.forEach(function (value, key) {\n    cb(key);\n  });\n};\nObject.defineProperty(Set$1.prototype, 'size', {\n  get: function () {\n    return this._store.size;\n  }\n});\n\n/* global Map,Set,Symbol */\n// Based on https://kangax.github.io/compat-table/es6/ we can sniff out\n// incomplete Map/Set implementations which would otherwise cause our tests to fail.\n// Notably they fail in IE11 and iOS 8.4, which this prevents.\nfunction supportsMapAndSet() {\n  if (typeof Symbol === 'undefined' || typeof Map === 'undefined' || typeof Set === 'undefined') {\n    return false;\n  }\n  var prop = Object.getOwnPropertyDescriptor(Map, Symbol.species);\n  return prop && 'get' in prop && Map[Symbol.species] === Map;\n}\n\n// based on https://github.com/montagejs/collections\n/* global Map,Set */\n\nvar ExportedSet;\nvar ExportedMap;\n\n{\n  if (supportsMapAndSet()) { // prefer built-in Map/Set\n    ExportedSet = Set;\n    ExportedMap = Map;\n  } else { // fall back to our polyfill\n    ExportedSet = Set$1;\n    ExportedMap = Map$1;\n  }\n}\n\n// Most browsers throttle concurrent requests at 6, so it's silly\n// to shim _bulk_get by trying to launch potentially hundreds of requests\n// and then letting the majority time out. We can handle this ourselves.\nvar MAX_NUM_CONCURRENT_REQUESTS = 6;\n\nfunction identityFunction(x) {\n  return x;\n}\n\nfunction formatResultForOpenRevsGet(result) {\n  return [{\n    ok: result\n  }];\n}\n\n// shim for P/CouchDB adapters that don't directly implement _bulk_get\nfunction bulkGet(db, opts, callback) {\n  var requests = opts.docs;\n\n  // consolidate into one request per doc if possible\n  var requestsById = new ExportedMap();\n  requests.forEach(function (request) {\n    if (requestsById.has(request.id)) {\n      requestsById.get(request.id).push(request);\n    } else {\n      requestsById.set(request.id, [request]);\n    }\n  });\n\n  var numDocs = requestsById.size;\n  var numDone = 0;\n  var perDocResults = new Array(numDocs);\n\n  function collapseResultsAndFinish() {\n    var results = [];\n    perDocResults.forEach(function (res) {\n      res.docs.forEach(function (info) {\n        results.push({\n          id: res.id,\n          docs: [info]\n        });\n      });\n    });\n    callback(null, {results: results});\n  }\n\n  function checkDone() {\n    if (++numDone === numDocs) {\n      collapseResultsAndFinish();\n    }\n  }\n\n  function gotResult(docIndex, id, docs) {\n    perDocResults[docIndex] = {id: id, docs: docs};\n    checkDone();\n  }\n\n  var allRequests = [];\n  requestsById.forEach(function (value, key) {\n    allRequests.push(key);\n  });\n\n  var i = 0;\n\n  function nextBatch() {\n\n    if (i >= allRequests.length) {\n      return;\n    }\n\n    var upTo = Math.min(i + MAX_NUM_CONCURRENT_REQUESTS, allRequests.length);\n    var batch = allRequests.slice(i, upTo);\n    processBatch(batch, i);\n    i += batch.length;\n  }\n\n  function processBatch(batch, offset) {\n    batch.forEach(function (docId, j) {\n      var docIdx = offset + j;\n      var docRequests = requestsById.get(docId);\n\n      // just use the first request as the \"template\"\n      // TODO: The _bulk_get API allows for more subtle use cases than this,\n      // but for now it is unlikely that there will be a mix of different\n      // \"atts_since\" or \"attachments\" in the same request, since it's just\n      // replicate.js that is using this for the moment.\n      // Also, atts_since is aspirational, since we don't support it yet.\n      var docOpts = pick(docRequests[0], ['atts_since', 'attachments']);\n      docOpts.open_revs = docRequests.map(function (request) {\n        // rev is optional, open_revs disallowed\n        return request.rev;\n      });\n\n      // remove falsey / undefined revisions\n      docOpts.open_revs = docOpts.open_revs.filter(identityFunction);\n\n      var formatResult = identityFunction;\n\n      if (docOpts.open_revs.length === 0) {\n        delete docOpts.open_revs;\n\n        // when fetching only the \"winning\" leaf,\n        // transform the result so it looks like an open_revs\n        // request\n        formatResult = formatResultForOpenRevsGet;\n      }\n\n      // globally-supplied options\n      ['revs', 'attachments', 'binary', 'ajax', 'latest'].forEach(function (param) {\n        if (param in opts) {\n          docOpts[param] = opts[param];\n        }\n      });\n      db.get(docId, docOpts, function (err, res) {\n        var result;\n        /* istanbul ignore if */\n        if (err) {\n          result = [{error: err}];\n        } else {\n          result = formatResult(res);\n        }\n        gotResult(docIdx, docId, result);\n        nextBatch();\n      });\n    });\n  }\n\n  nextBatch();\n\n}\n\nfunction isChromeApp() {\n  return (typeof chrome !== \"undefined\" &&\n    typeof chrome.storage !== \"undefined\" &&\n    typeof chrome.storage.local !== \"undefined\");\n}\n\nvar hasLocal;\n\nif (isChromeApp()) {\n  hasLocal = false;\n} else {\n  try {\n    localStorage.setItem('_pouch_check_localstorage', 1);\n    hasLocal = !!localStorage.getItem('_pouch_check_localstorage');\n  } catch (e) {\n    hasLocal = false;\n  }\n}\n\nfunction hasLocalStorage() {\n  return hasLocal;\n}\n\ninherits(Changes, events.EventEmitter);\n\n/* istanbul ignore next */\nfunction attachBrowserEvents(self) {\n  if (isChromeApp()) {\n    chrome.storage.onChanged.addListener(function (e) {\n      // make sure it's event addressed to us\n      if (e.db_name != null) {\n        //object only has oldValue, newValue members\n        self.emit(e.dbName.newValue);\n      }\n    });\n  } else if (hasLocalStorage()) {\n    if (typeof addEventListener !== 'undefined') {\n      addEventListener(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    } else { // old IE\n      window.attachEvent(\"storage\", function (e) {\n        self.emit(e.key);\n      });\n    }\n  }\n}\n\nfunction Changes() {\n  events.EventEmitter.call(this);\n  this._listeners = {};\n\n  attachBrowserEvents(this);\n}\nChanges.prototype.addListener = function (dbName, id, db, opts) {\n  /* istanbul ignore if */\n  if (this._listeners[id]) {\n    return;\n  }\n  var self = this;\n  var inprogress = false;\n  function eventFunction() {\n    /* istanbul ignore if */\n    if (!self._listeners[id]) {\n      return;\n    }\n    if (inprogress) {\n      inprogress = 'waiting';\n      return;\n    }\n    inprogress = true;\n    var changesOpts = pick(opts, [\n      'style', 'include_docs', 'attachments', 'conflicts', 'filter',\n      'doc_ids', 'view', 'since', 'query_params', 'binary'\n    ]);\n\n    /* istanbul ignore next */\n    function onError() {\n      inprogress = false;\n    }\n\n    db.changes(changesOpts).on('change', function (c) {\n      if (c.seq > opts.since && !opts.cancelled) {\n        opts.since = c.seq;\n        opts.onChange(c);\n      }\n    }).on('complete', function () {\n      if (inprogress === 'waiting') {\n        nextTick(eventFunction);\n      }\n      inprogress = false;\n    }).on('error', onError);\n  }\n  this._listeners[id] = eventFunction;\n  this.on(dbName, eventFunction);\n};\n\nChanges.prototype.removeListener = function (dbName, id) {\n  /* istanbul ignore if */\n  if (!(id in this._listeners)) {\n    return;\n  }\n  events.EventEmitter.prototype.removeListener.call(this, dbName,\n    this._listeners[id]);\n  delete this._listeners[id];\n};\n\n\n/* istanbul ignore next */\nChanges.prototype.notifyLocalWindows = function (dbName) {\n  //do a useless change on a storage thing\n  //in order to get other windows's listeners to activate\n  if (isChromeApp()) {\n    chrome.storage.local.set({dbName: dbName});\n  } else if (hasLocalStorage()) {\n    localStorage[dbName] = (localStorage[dbName] === \"a\") ? \"b\" : \"a\";\n  }\n};\n\nChanges.prototype.notify = function (dbName) {\n  this.emit(dbName);\n  this.notifyLocalWindows(dbName);\n};\n\nfunction guardedConsole(method) {\n  /* istanbul ignore else */\n  if (console !== 'undefined' && method in console) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    console[method].apply(console, args);\n  }\n}\n\nfunction randomNumber(min, max) {\n  var maxTimeout = 600000; // Hard-coded default of 10 minutes\n  min = parseInt(min, 10) || 0;\n  max = parseInt(max, 10);\n  if (max !== max || max <= min) {\n    max = (min || 1) << 1; //doubling\n  } else {\n    max = max + 1;\n  }\n  // In order to not exceed maxTimeout, pick a random value between half of maxTimeout and maxTimeout\n  if(max > maxTimeout) {\n    min = maxTimeout >> 1; // divide by two\n    max = maxTimeout;\n  }\n  var ratio = Math.random();\n  var range = max - min;\n\n  return ~~(range * ratio + min); // ~~ coerces to an int, but fast.\n}\n\nfunction defaultBackOff(min) {\n  var max = 0;\n  if (!min) {\n    max = 2000;\n  }\n  return randomNumber(min, max);\n}\n\n// designed to give info to browser users, who are disturbed\n// when they see http errors in the console\nfunction explainError(status, str) {\n  guardedConsole('info', 'The above ' + status + ' is totally normal. ' + str);\n}\n\nvar assign;\n{\n  if (typeof Object.assign === 'function') {\n    assign = Object.assign;\n  } else {\n    // lite Object.assign polyfill based on\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n    assign = function (target) {\n      var to = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var nextSource = arguments[index];\n\n        if (nextSource != null) { // Skip over if undefined or null\n          for (var nextKey in nextSource) {\n            // Avoid bugs when hasOwnProperty is shadowed\n            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n      }\n      return to;\n    };\n  }\n}\n\nvar assign$1 = assign;\n\ninherits(PouchError, Error);\n\nfunction PouchError(status, error, reason) {\n  Error.call(this, reason);\n  this.status = status;\n  this.name = error;\n  this.message = reason;\n  this.error = true;\n}\n\nPouchError.prototype.toString = function () {\n  return JSON.stringify({\n    status: this.status,\n    name: this.name,\n    message: this.message,\n    reason: this.reason\n  });\n};\n\nvar UNAUTHORIZED = new PouchError(401, 'unauthorized', \"Name or password is incorrect.\");\nvar MISSING_BULK_DOCS = new PouchError(400, 'bad_request', \"Missing JSON list of 'docs'\");\nvar MISSING_DOC = new PouchError(404, 'not_found', 'missing');\nvar REV_CONFLICT = new PouchError(409, 'conflict', 'Document update conflict');\nvar INVALID_ID = new PouchError(400, 'bad_request', '_id field must contain a string');\nvar MISSING_ID = new PouchError(412, 'missing_id', '_id is required for puts');\nvar RESERVED_ID = new PouchError(400, 'bad_request', 'Only reserved document ids may start with underscore.');\nvar NOT_OPEN = new PouchError(412, 'precondition_failed', 'Database not open');\nvar UNKNOWN_ERROR = new PouchError(500, 'unknown_error', 'Database encountered an unknown error');\nvar BAD_ARG = new PouchError(500, 'badarg', 'Some query argument is invalid');\nvar INVALID_REQUEST = new PouchError(400, 'invalid_request', 'Request was invalid');\nvar QUERY_PARSE_ERROR = new PouchError(400, 'query_parse_error', 'Some query parameter is invalid');\nvar DOC_VALIDATION = new PouchError(500, 'doc_validation', 'Bad special document member');\nvar BAD_REQUEST = new PouchError(400, 'bad_request', 'Something wrong with the request');\nvar NOT_AN_OBJECT = new PouchError(400, 'bad_request', 'Document must be a JSON object');\nvar DB_MISSING = new PouchError(404, 'not_found', 'Database not found');\nvar IDB_ERROR = new PouchError(500, 'indexed_db_went_bad', 'unknown');\nvar WSQ_ERROR = new PouchError(500, 'web_sql_went_bad', 'unknown');\nvar LDB_ERROR = new PouchError(500, 'levelDB_went_went_bad', 'unknown');\nvar FORBIDDEN = new PouchError(403, 'forbidden', 'Forbidden by design doc validate_doc_update function');\nvar INVALID_REV = new PouchError(400, 'bad_request', 'Invalid rev format');\nvar FILE_EXISTS = new PouchError(412, 'file_exists', 'The database could not be created, the file already exists.');\nvar MISSING_STUB = new PouchError(412, 'missing_stub', 'A pre-existing attachment stub wasn\\'t found');\nvar INVALID_URL = new PouchError(413, 'invalid_url', 'Provided URL is invalid');\n\nfunction createError(error, reason) {\n  function CustomPouchError(reason) {\n    // inherit error properties from our parent error manually\n    // so as to allow proper JSON parsing.\n    /* jshint ignore:start */\n    for (var p in error) {\n      if (typeof error[p] !== 'function') {\n        this[p] = error[p];\n      }\n    }\n    /* jshint ignore:end */\n    if (reason !== undefined) {\n      this.reason = reason;\n    }\n  }\n  CustomPouchError.prototype = PouchError.prototype;\n  return new CustomPouchError(reason);\n}\n\nfunction generateErrorFromResponse(err) {\n\n  if (typeof err !== 'object') {\n    var data = err;\n    err = UNKNOWN_ERROR;\n    err.data = data;\n  }\n\n  if ('error' in err && err.error === 'conflict') {\n    err.name = 'conflict';\n    err.status = 409;\n  }\n\n  if (!('name' in err)) {\n    err.name = err.error || 'unknown';\n  }\n\n  if (!('status' in err)) {\n    err.status = 500;\n  }\n\n  if (!('message' in err)) {\n    err.message = err.message || err.reason;\n  }\n\n  return err;\n}\n\nfunction tryFilter(filter, doc, req) {\n  try {\n    return !filter(doc, req);\n  } catch (err) {\n    var msg = 'Filter function threw: ' + err.toString();\n    return createError(BAD_REQUEST, msg);\n  }\n}\n\nfunction filterChange(opts) {\n  var req = {};\n  var hasFilter = opts.filter && typeof opts.filter === 'function';\n  req.query = opts.query_params;\n\n  return function filter(change) {\n    if (!change.doc) {\n      // CSG sends events on the changes feed that don't have documents,\n      // this hack makes a whole lot of existing code robust.\n      change.doc = {};\n    }\n\n    var filterReturn = hasFilter && tryFilter(opts.filter, change.doc, req);\n\n    if (typeof filterReturn === 'object') {\n      return filterReturn;\n    }\n\n    if (filterReturn) {\n      return false;\n    }\n\n    if (!opts.include_docs) {\n      delete change.doc;\n    } else if (!opts.attachments) {\n      for (var att in change.doc._attachments) {\n        /* istanbul ignore else */\n        if (change.doc._attachments.hasOwnProperty(att)) {\n          change.doc._attachments[att].stub = true;\n        }\n      }\n    }\n    return true;\n  };\n}\n\nfunction flatten(arrs) {\n  var res = [];\n  for (var i = 0, len = arrs.length; i < len; i++) {\n    res = res.concat(arrs[i]);\n  }\n  return res;\n}\n\n// shim for Function.prototype.name,\n// for browsers that don't support it like IE\n\n/* istanbul ignore next */\nfunction f() {}\n\nvar hasName = f.name;\nvar res;\n\n// We dont run coverage in IE\n/* istanbul ignore else */\nif (hasName) {\n  res = function (fun) {\n    return fun.name;\n  };\n} else {\n  res = function (fun) {\n    return fun.toString().match(/^\\s*function\\s*(\\S*)\\s*\\(/)[1];\n  };\n}\n\n// Determine id an ID is valid\n//   - invalid IDs begin with an underescore that does not begin '_design' or\n//     '_local'\n//   - any other string value is a valid id\n// Returns the specific error object for each case\nfunction invalidIdError(id) {\n  var err;\n  if (!id) {\n    err = createError(MISSING_ID);\n  } else if (typeof id !== 'string') {\n    err = createError(INVALID_ID);\n  } else if (/^_/.test(id) && !(/^_(design|local)/).test(id)) {\n    err = createError(RESERVED_ID);\n  }\n  if (err) {\n    throw err;\n  }\n}\n\nfunction listenerCount(ee, type) {\n  return 'listenerCount' in ee ? ee.listenerCount(type) :\n                                 events.EventEmitter.listenerCount(ee, type);\n}\n\n// Custom nextTick() shim for browsers. In node, this will just be process.nextTick(). We\n// avoid using process.nextTick() directly because the polyfill is very large and we don't\n// need all of it (see: https://github.com/defunctzombie/node-process).\n// \"immediate\" 3.0.8 is used by lie, and it's a smaller version of the latest \"immediate\"\n// package, so it's the one we use.\n// When we use nextTick() in our codebase, we only care about not releasing Zalgo\n// (see: http://blog.izs.me/post/59142742143/designing-apis-for-asynchrony).\n// Microtask vs macrotask doesn't matter to us. So we're free to use the fastest\n// (least latency) option, which is \"immediate\" due to use of microtasks.\n// All of our nextTicks are isolated to this one function so we can easily swap out one\n// implementation for another.\n\nfunction parseDesignDocFunctionName(s) {\n  if (!s) {\n    return null;\n  }\n  var parts = s.split('/');\n  if (parts.length === 2) {\n    return parts;\n  }\n  if (parts.length === 1) {\n    return [s, s];\n  }\n  return null;\n}\n\nfunction normalizeDesignDocFunctionName(s) {\n  var normalized = parseDesignDocFunctionName(s);\n  return normalized ? normalized.join('/') : null;\n}\n\n// originally parseUri 1.2.2, now patched by us\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\nvar keys = [\"source\", \"protocol\", \"authority\", \"userInfo\", \"user\", \"password\",\n    \"host\", \"port\", \"relative\", \"path\", \"directory\", \"file\", \"query\", \"anchor\"];\nvar qName =\"queryKey\";\nvar qParser = /(?:^|&)([^&=]*)=?([^&]*)/g;\n\n// use the \"loose\" parser\n/* jshint maxlen: false */\nvar parser = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nfunction parseUri(str) {\n  var m = parser.exec(str);\n  var uri = {};\n  var i = 14;\n\n  while (i--) {\n    var key = keys[i];\n    var value = m[i] || \"\";\n    var encoded = ['user', 'password'].indexOf(key) !== -1;\n    uri[key] = encoded ? decodeURIComponent(value) : value;\n  }\n\n  uri[qName] = {};\n  uri[keys[12]].replace(qParser, function ($0, $1, $2) {\n    if ($1) {\n      uri[qName][$1] = $2;\n    }\n  });\n\n  return uri;\n}\n\n// this is essentially the \"update sugar\" function from daleharvey/pouchdb#1388\n// the diffFun tells us what delta to apply to the doc.  it either returns\n// the doc, or false if it doesn't need to do an update after all\nfunction upsert(db, docId, diffFun) {\n  return new PouchPromise$1(function (fulfill, reject) {\n    db.get(docId, function (err, doc) {\n      if (err) {\n        /* istanbul ignore next */\n        if (err.status !== 404) {\n          return reject(err);\n        }\n        doc = {};\n      }\n\n      // the user might change the _rev, so save it for posterity\n      var docRev = doc._rev;\n      var newDoc = diffFun(doc);\n\n      if (!newDoc) {\n        // if the diffFun returns falsy, we short-circuit as\n        // an optimization\n        return fulfill({updated: false, rev: docRev});\n      }\n\n      // users aren't allowed to modify these values,\n      // so reset them here\n      newDoc._id = docId;\n      newDoc._rev = docRev;\n      fulfill(tryAndPut(db, newDoc, diffFun));\n    });\n  });\n}\n\nfunction tryAndPut(db, doc, diffFun) {\n  return db.put(doc).then(function (res) {\n    return {\n      updated: true,\n      rev: res.rev\n    };\n  }, function (err) {\n    /* istanbul ignore next */\n    if (err.status !== 409) {\n      throw err;\n    }\n    return upsert(db, doc._id, diffFun);\n  });\n}\n\n// BEGIN Math.uuid.js\n\n/*!\nMath.uuid.js (v1.4)\nhttp://www.broofa.com\nmailto:robert@broofa.com\n\nCopyright (c) 2010 Robert Kieffer\nDual licensed under the MIT and GPL licenses.\n*/\n\n/*\n * Generate a random uuid.\n *\n * USAGE: Math.uuid(length, radix)\n *   length - the desired number of characters\n *   radix  - the number of allowable values for each character.\n *\n * EXAMPLES:\n *   // No arguments  - returns RFC4122, version 4 ID\n *   >>> Math.uuid()\n *   \"92329D39-6F5C-4520-ABFC-AAB64544E172\"\n *\n *   // One argument - returns ID of the specified length\n *   >>> Math.uuid(15)     // 15 character ID (default base=62)\n *   \"VcydxgltxrVZSTV\"\n *\n *   // Two arguments - returns ID of the specified length, and radix. \n *   // (Radix must be <= 62)\n *   >>> Math.uuid(8, 2)  // 8 character ID (base=2)\n *   \"01001010\"\n *   >>> Math.uuid(8, 10) // 8 character ID (base=10)\n *   \"47473046\"\n *   >>> Math.uuid(8, 16) // 8 character ID (base=16)\n *   \"098F4D35\"\n */\nvar chars = (\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n  'abcdefghijklmnopqrstuvwxyz'\n).split('');\nfunction getValue(radix) {\n  return 0 | Math.random() * radix;\n}\nfunction uuid(len, radix) {\n  radix = radix || chars.length;\n  var out = '';\n  var i = -1;\n\n  if (len) {\n    // Compact form\n    while (++i < len) {\n      out += chars[getValue(radix)];\n    }\n    return out;\n  }\n    // rfc4122, version 4 form\n    // Fill in random data.  At i==19 set the high bits of clock sequence as\n    // per rfc4122, sec. 4.1.5\n  while (++i < 36) {\n    switch (i) {\n      case 8:\n      case 13:\n      case 18:\n      case 23:\n        out += '-';\n        break;\n      case 19:\n        out += chars[(getValue(16) & 0x3) | 0x8];\n        break;\n      default:\n        out += chars[getValue(16)];\n    }\n  }\n\n  return out;\n}\n\n// We fetch all leafs of the revision tree, and sort them based on tree length\n// and whether they were deleted, undeleted documents with the longest revision\n// tree (most edits) win\n// The final sort algorithm is slightly documented in a sidebar here:\n// http://guide.couchdb.org/draft/conflicts.html\nfunction winningRev(metadata) {\n  var winningId;\n  var winningPos;\n  var winningDeleted;\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var tree = node.ids;\n    var branches = tree[2];\n    var pos = node.pos;\n    if (branches.length) { // non-leaf\n      for (var i = 0, len = branches.length; i < len; i++) {\n        toVisit.push({pos: pos + 1, ids: branches[i]});\n      }\n      continue;\n    }\n    var deleted = !!tree[1].deleted;\n    var id = tree[0];\n    // sort by deleted, then pos, then id\n    if (!winningId || (winningDeleted !== deleted ? winningDeleted :\n        winningPos !== pos ? winningPos < pos : winningId < id)) {\n      winningId = id;\n      winningPos = pos;\n      winningDeleted = deleted;\n    }\n  }\n\n  return winningPos + '-' + winningId;\n}\n\n// Pretty much all below can be combined into a higher order function to\n// traverse revisions\n// The return value from the callback will be passed as context to all\n// children of that node\nfunction traverseRevTree(revs, callback) {\n  var toVisit = revs.slice();\n\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var branches = tree[2];\n    var newCtx =\n      callback(branches.length === 0, pos, tree[0], node.ctx, tree[1]);\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], ctx: newCtx});\n    }\n  }\n}\n\nfunction sortByPos(a, b) {\n  return a.pos - b.pos;\n}\n\nfunction collectLeaves(revs) {\n  var leaves = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, acc, opts) {\n    if (isLeaf) {\n      leaves.push({rev: pos + \"-\" + id, pos: pos, opts: opts});\n    }\n  });\n  leaves.sort(sortByPos).reverse();\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    delete leaves[i].pos;\n  }\n  return leaves;\n}\n\n// returns revs of all conflicts that is leaves such that\n// 1. are not deleted and\n// 2. are different than winning revision\nfunction collectConflicts(metadata) {\n  var win = winningRev(metadata);\n  var leaves = collectLeaves(metadata.rev_tree);\n  var conflicts = [];\n  for (var i = 0, len = leaves.length; i < len; i++) {\n    var leaf = leaves[i];\n    if (leaf.rev !== win && !leaf.opts.deleted) {\n      conflicts.push(leaf.rev);\n    }\n  }\n  return conflicts;\n}\n\n// compact a tree by marking its non-leafs as missing,\n// and return a list of revs to delete\nfunction compactTree(metadata) {\n  var revs = [];\n  traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                               revHash, ctx, opts) {\n    if (opts.status === 'available' && !isLeaf) {\n      revs.push(pos + '-' + revHash);\n      opts.status = 'missing';\n    }\n  });\n  return revs;\n}\n\n// build up a list of all the paths to the leafs in this revision tree\nfunction rootToLeaf(revs) {\n  var paths = [];\n  var toVisit = revs.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, opts: opts});\n    if (isLeaf) {\n      paths.push({pos: (pos + 1 - history.length), ids: history});\n    }\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: pos + 1, ids: branches[i], history: history});\n    }\n  }\n  return paths.reverse();\n}\n\n// for a better overview of what this is doing, read:\n// https://github.com/apache/couchdb-couch/blob/master/src/couch_key_tree.erl\n//\n// But for a quick intro, CouchDB uses a revision tree to store a documents\n// history, A -> B -> C, when a document has conflicts, that is a branch in the\n// tree, A -> (B1 | B2 -> C), We store these as a nested array in the format\n//\n// KeyTree = [Path ... ]\n// Path = {pos: position_from_root, ids: Tree}\n// Tree = [Key, Opts, [Tree, ...]], in particular single node: [Key, []]\n\nfunction sortByPos$1(a, b) {\n  return a.pos - b.pos;\n}\n\n// classic binary search\nfunction binarySearch(arr, item, comparator) {\n  var low = 0;\n  var high = arr.length;\n  var mid;\n  while (low < high) {\n    mid = (low + high) >>> 1;\n    if (comparator(arr[mid], item) < 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  return low;\n}\n\n// assuming the arr is sorted, insert the item in the proper place\nfunction insertSorted(arr, item, comparator) {\n  var idx = binarySearch(arr, item, comparator);\n  arr.splice(idx, 0, item);\n}\n\n// Turn a path as a flat array into a tree with a single branch.\n// If any should be stemmed from the beginning of the array, that's passed\n// in as the second argument\nfunction pathToTree(path, numStemmed) {\n  var root;\n  var leaf;\n  for (var i = numStemmed, len = path.length; i < len; i++) {\n    var node = path[i];\n    var currentLeaf = [node.id, node.opts, []];\n    if (leaf) {\n      leaf[2].push(currentLeaf);\n      leaf = currentLeaf;\n    } else {\n      root = leaf = currentLeaf;\n    }\n  }\n  return root;\n}\n\n// compare the IDs of two trees\nfunction compareTree(a, b) {\n  return a[0] < b[0] ? -1 : 1;\n}\n\n// Merge two trees together\n// The roots of tree1 and tree2 must be the same revision\nfunction mergeTree(in_tree1, in_tree2) {\n  var queue = [{tree1: in_tree1, tree2: in_tree2}];\n  var conflicts = false;\n  while (queue.length > 0) {\n    var item = queue.pop();\n    var tree1 = item.tree1;\n    var tree2 = item.tree2;\n\n    if (tree1[1].status || tree2[1].status) {\n      tree1[1].status =\n        (tree1[1].status ===  'available' ||\n        tree2[1].status === 'available') ? 'available' : 'missing';\n    }\n\n    for (var i = 0; i < tree2[2].length; i++) {\n      if (!tree1[2][0]) {\n        conflicts = 'new_leaf';\n        tree1[2][0] = tree2[2][i];\n        continue;\n      }\n\n      var merged = false;\n      for (var j = 0; j < tree1[2].length; j++) {\n        if (tree1[2][j][0] === tree2[2][i][0]) {\n          queue.push({tree1: tree1[2][j], tree2: tree2[2][i]});\n          merged = true;\n        }\n      }\n      if (!merged) {\n        conflicts = 'new_branch';\n        insertSorted(tree1[2], tree2[2][i], compareTree);\n      }\n    }\n  }\n  return {conflicts: conflicts, tree: in_tree1};\n}\n\nfunction doMerge(tree, path, dontExpand) {\n  var restree = [];\n  var conflicts = false;\n  var merged = false;\n  var res;\n\n  if (!tree.length) {\n    return {tree: [path], conflicts: 'new_leaf'};\n  }\n\n  for (var i = 0, len = tree.length; i < len; i++) {\n    var branch = tree[i];\n    if (branch.pos === path.pos && branch.ids[0] === path.ids[0]) {\n      // Paths start at the same position and have the same root, so they need\n      // merged\n      res = mergeTree(branch.ids, path.ids);\n      restree.push({pos: branch.pos, ids: res.tree});\n      conflicts = conflicts || res.conflicts;\n      merged = true;\n    } else if (dontExpand !== true) {\n      // The paths start at a different position, take the earliest path and\n      // traverse up until it as at the same point from root as the path we\n      // want to merge.  If the keys match we return the longer path with the\n      // other merged After stemming we dont want to expand the trees\n\n      var t1 = branch.pos < path.pos ? branch : path;\n      var t2 = branch.pos < path.pos ? path : branch;\n      var diff = t2.pos - t1.pos;\n\n      var candidateParents = [];\n\n      var trees = [];\n      trees.push({ids: t1.ids, diff: diff, parent: null, parentIdx: null});\n      while (trees.length > 0) {\n        var item = trees.pop();\n        if (item.diff === 0) {\n          if (item.ids[0] === t2.ids[0]) {\n            candidateParents.push(item);\n          }\n          continue;\n        }\n        var elements = item.ids[2];\n        for (var j = 0, elementsLen = elements.length; j < elementsLen; j++) {\n          trees.push({\n            ids: elements[j],\n            diff: item.diff - 1,\n            parent: item.ids,\n            parentIdx: j\n          });\n        }\n      }\n\n      var el = candidateParents[0];\n\n      if (!el) {\n        restree.push(branch);\n      } else {\n        res = mergeTree(el.ids, t2.ids);\n        el.parent[2][el.parentIdx] = res.tree;\n        restree.push({pos: t1.pos, ids: t1.ids});\n        conflicts = conflicts || res.conflicts;\n        merged = true;\n      }\n    } else {\n      restree.push(branch);\n    }\n  }\n\n  // We didnt find\n  if (!merged) {\n    restree.push(path);\n  }\n\n  restree.sort(sortByPos$1);\n\n  return {\n    tree: restree,\n    conflicts: conflicts || 'internal_node'\n  };\n}\n\n// To ensure we dont grow the revision tree infinitely, we stem old revisions\nfunction stem(tree, depth) {\n  // First we break out the tree into a complete list of root to leaf paths\n  var paths = rootToLeaf(tree);\n  var maybeStem = {};\n\n  var result;\n  for (var i = 0, len = paths.length; i < len; i++) {\n    // Then for each path, we cut off the start of the path based on the\n    // `depth` to stem to, and generate a new set of flat trees\n    var path = paths[i];\n    var stemmed = path.ids;\n    var numStemmed = Math.max(0, stemmed.length - depth);\n    var stemmedNode = {\n      pos: path.pos + numStemmed,\n      ids: pathToTree(stemmed, numStemmed)\n    };\n\n    for (var s = 0; s < numStemmed; s++) {\n      var rev = (path.pos + s) + '-' + stemmed[s].id;\n      maybeStem[rev] = true;\n    }\n\n    // Then we remerge all those flat trees together, ensuring that we dont\n    // connect trees that would go beyond the depth limit\n    if (result) {\n      result = doMerge(result, stemmedNode, true).tree;\n    } else {\n      result = [stemmedNode];\n    }\n  }\n\n  traverseRevTree(result, function (isLeaf, pos, revHash) {\n    // some revisions may have been removed in a branch but not in another\n    delete maybeStem[pos + '-' + revHash];\n  });\n\n  return {\n    tree: result,\n    revs: Object.keys(maybeStem)\n  };\n}\n\nfunction merge(tree, path, depth) {\n  var newTree = doMerge(tree, path);\n  var stemmed = stem(newTree.tree, depth);\n  return {\n    tree: stemmed.tree,\n    stemmedRevs: stemmed.revs,\n    conflicts: newTree.conflicts\n  };\n}\n\n// return true if a rev exists in the rev tree, false otherwise\nfunction revExists(revs, rev) {\n  var toVisit = revs.slice();\n  var splitRev = rev.split('-');\n  var targetPos = parseInt(splitRev[0], 10);\n  var targetId = splitRev[1];\n\n  var node;\n  while ((node = toVisit.pop())) {\n    if (node.pos === targetPos && node.ids[0] === targetId) {\n      return true;\n    }\n    var branches = node.ids[2];\n    for (var i = 0, len = branches.length; i < len; i++) {\n      toVisit.push({pos: node.pos + 1, ids: branches[i]});\n    }\n  }\n  return false;\n}\n\nfunction getTrees(node) {\n  return node.ids;\n}\n\n// check if a specific revision of a doc has been deleted\n//  - metadata: the metadata object from the doc store\n//  - rev: (optional) the revision to check. defaults to winning revision\nfunction isDeleted(metadata, rev) {\n  if (!rev) {\n    rev = winningRev(metadata);\n  }\n  var id = rev.substring(rev.indexOf('-') + 1);\n  var toVisit = metadata.rev_tree.map(getTrees);\n\n  var tree;\n  while ((tree = toVisit.pop())) {\n    if (tree[0] === id) {\n      return !!tree[1].deleted;\n    }\n    toVisit = toVisit.concat(tree[2]);\n  }\n}\n\nfunction isLocalId(id) {\n  return (/^_local/).test(id);\n}\n\n// returns the current leaf node for a given revision\nfunction latest(rev, metadata) {\n  var toVisit = metadata.rev_tree.slice();\n  var node;\n  while ((node = toVisit.pop())) {\n    var pos = node.pos;\n    var tree = node.ids;\n    var id = tree[0];\n    var opts = tree[1];\n    var branches = tree[2];\n    var isLeaf = branches.length === 0;\n\n    var history = node.history ? node.history.slice() : [];\n    history.push({id: id, pos: pos, opts: opts});\n\n    if (isLeaf) {\n      for (var i = 0, len = history.length; i < len; i++) {\n        var historyNode = history[i];\n        var historyRev = historyNode.pos + '-' + historyNode.id;\n\n        if (historyRev === rev) {\n          // return the rev of this leaf\n          return pos + '-' + id;\n        }\n      }\n    }\n\n    for (var j = 0, l = branches.length; j < l; j++) {\n      toVisit.push({pos: pos + 1, ids: branches[j], history: history});\n    }\n  }\n\n  /* istanbul ignore next */\n  throw new Error('Unable to resolve latest revision for id ' + metadata.id + ', rev ' + rev);\n}\n\nfunction evalFilter(input) {\n  return scopedEval('\"use strict\";\\nreturn ' + input + ';', {});\n}\n\nfunction evalView(input) {\n  var code = [\n    'return function(doc) {',\n    '  \"use strict\";',\n    '  var emitted = false;',\n    '  var emit = function (a, b) {',\n    '    emitted = true;',\n    '  };',\n    '  var view = ' + input + ';',\n    '  view(doc);',\n    '  if (emitted) {',\n    '    return true;',\n    '  }',\n    '};'\n  ].join('\\n');\n\n  return scopedEval(code, {});\n}\n\ninherits(Changes$2, events.EventEmitter);\n\nfunction tryCatchInChangeListener(self, change) {\n  // isolate try/catches to avoid V8 deoptimizations\n  try {\n    self.emit('change', change);\n  } catch (e) {\n    guardedConsole('error', 'Error in .on(\"change\", function):', e);\n  }\n}\n\nfunction Changes$2(db, opts, callback) {\n  events.EventEmitter.call(this);\n  var self = this;\n  this.db = db;\n  opts = opts ? clone(opts) : {};\n  var complete = opts.complete = once(function (err, resp) {\n    if (err) {\n      if (listenerCount(self, 'error') > 0) {\n        self.emit('error', err);\n      }\n    } else {\n      self.emit('complete', resp);\n    }\n    self.removeAllListeners();\n    db.removeListener('destroyed', onDestroy);\n  });\n  if (callback) {\n    self.on('complete', function (resp) {\n      callback(null, resp);\n    });\n    self.on('error', callback);\n  }\n  function onDestroy() {\n    self.cancel();\n  }\n  db.once('destroyed', onDestroy);\n\n  opts.onChange = function (change) {\n    /* istanbul ignore if */\n    if (self.isCancelled) {\n      return;\n    }\n    tryCatchInChangeListener(self, change);\n  };\n\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    opts.complete = function (err, res) {\n      if (err) {\n        reject(err);\n      } else {\n        fulfill(res);\n      }\n    };\n  });\n  self.once('cancel', function () {\n    db.removeListener('destroyed', onDestroy);\n    opts.complete(null, {status: 'cancelled'});\n  });\n  this.then = promise.then.bind(promise);\n  this['catch'] = promise['catch'].bind(promise);\n  this.then(function (result) {\n    complete(null, result);\n  }, complete);\n\n\n\n  if (!db.taskqueue.isReady) {\n    db.taskqueue.addTask(function (failed) {\n      if (failed) {\n        opts.complete(failed);\n      } else if (self.isCancelled) {\n        self.emit('cancel');\n      } else {\n        self.doChanges(opts);\n      }\n    });\n  } else {\n    self.doChanges(opts);\n  }\n}\nChanges$2.prototype.cancel = function () {\n  this.isCancelled = true;\n  if (this.db.taskqueue.isReady) {\n    this.emit('cancel');\n  }\n};\nfunction processChange(doc, metadata, opts) {\n  var changeList = [{rev: doc._rev}];\n  if (opts.style === 'all_docs') {\n    changeList = collectLeaves(metadata.rev_tree)\n    .map(function (x) { return {rev: x.rev}; });\n  }\n  var change = {\n    id: metadata.id,\n    changes: changeList,\n    doc: doc\n  };\n\n  if (isDeleted(metadata, doc._rev)) {\n    change.deleted = true;\n  }\n  if (opts.conflicts) {\n    change.doc._conflicts = collectConflicts(metadata);\n    if (!change.doc._conflicts.length) {\n      delete change.doc._conflicts;\n    }\n  }\n  return change;\n}\n\nChanges$2.prototype.doChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n\n  opts = clone(opts);\n  if ('live' in opts && !('continuous' in opts)) {\n    opts.continuous = opts.live;\n  }\n  opts.processChange = processChange;\n\n  if (opts.since === 'latest') {\n    opts.since = 'now';\n  }\n  if (!opts.since) {\n    opts.since = 0;\n  }\n  if (opts.since === 'now') {\n    this.db.info().then(function (info) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        callback(null, {status: 'cancelled'});\n        return;\n      }\n      opts.since = info.update_seq;\n      self.doChanges(opts);\n    }, callback);\n    return;\n  }\n\n\n  if (opts.view && !opts.filter) {\n    opts.filter = '_view';\n  }\n\n  if (opts.filter && typeof opts.filter === 'string') {\n    if (opts.filter === '_view') {\n      opts.view = normalizeDesignDocFunctionName(opts.view);\n    } else {\n      opts.filter = normalizeDesignDocFunctionName(opts.filter);\n    }\n\n    if (this.db.type() !== 'http' && !opts.doc_ids) {\n      return this.filterChanges(opts);\n    }\n  }\n\n  if (!('descending' in opts)) {\n    opts.descending = false;\n  }\n\n  // 0 and 1 should return 1 document\n  opts.limit = opts.limit === 0 ? 1 : opts.limit;\n  opts.complete = callback;\n  var newPromise = this.db._changes(opts);\n  /* istanbul ignore else */\n  if (newPromise && typeof newPromise.cancel === 'function') {\n    var cancel = self.cancel;\n    self.cancel = getArguments(function (args) {\n      newPromise.cancel();\n      cancel.apply(this, args);\n    });\n  }\n};\n\nChanges$2.prototype.filterChanges = function (opts) {\n  var self = this;\n  var callback = opts.complete;\n  if (opts.filter === '_view') {\n    if (!opts.view || typeof opts.view !== 'string') {\n      var err = createError(BAD_REQUEST,\n        '`view` filter parameter not found or invalid.');\n      return callback(err);\n    }\n    // fetch a view from a design doc, make it behave like a filter\n    var viewName = parseDesignDocFunctionName(opts.view);\n    this.db.get('_design/' + viewName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var mapFun = ddoc && ddoc.views && ddoc.views[viewName[1]] &&\n        ddoc.views[viewName[1]].map;\n      if (!mapFun) {\n        return callback(createError(MISSING_DOC,\n          (ddoc.views ? 'missing json key: ' + viewName[1] :\n            'missing json key: views')));\n      }\n      opts.filter = evalView(mapFun);\n      self.doChanges(opts);\n    });\n  } else {\n    // fetch a filter from a design doc\n    var filterName = parseDesignDocFunctionName(opts.filter);\n    if (!filterName) {\n      return self.doChanges(opts);\n    }\n    this.db.get('_design/' + filterName[0], function (err, ddoc) {\n      /* istanbul ignore if */\n      if (self.isCancelled) {\n        return callback(null, {status: 'cancelled'});\n      }\n      /* istanbul ignore next */\n      if (err) {\n        return callback(generateErrorFromResponse(err));\n      }\n      var filterFun = ddoc && ddoc.filters && ddoc.filters[filterName[1]];\n      if (!filterFun) {\n        return callback(createError(MISSING_DOC,\n          ((ddoc && ddoc.filters) ? 'missing json key: ' + filterName[1]\n            : 'missing json key: filters')));\n      }\n      opts.filter = evalFilter(filterFun);\n      self.doChanges(opts);\n    });\n  }\n};\n\n/*\n * A generic pouch adapter\n */\n\nfunction compare(left, right) {\n  return left < right ? -1 : left > right ? 1 : 0;\n}\n\n// Wrapper for functions that call the bulkdocs api with a single doc,\n// if the first result is an error, return an error\nfunction yankError(callback) {\n  return function (err, results) {\n    if (err || (results[0] && results[0].error)) {\n      callback(err || results[0]);\n    } else {\n      callback(null, results.length ? results[0]  : results);\n    }\n  };\n}\n\n// clean docs given to us by the user\nfunction cleanDocs(docs) {\n  for (var i = 0; i < docs.length; i++) {\n    var doc = docs[i];\n    if (doc._deleted) {\n      delete doc._attachments; // ignore atts for deleted docs\n    } else if (doc._attachments) {\n      // filter out extraneous keys from _attachments\n      var atts = Object.keys(doc._attachments);\n      for (var j = 0; j < atts.length; j++) {\n        var att = atts[j];\n        doc._attachments[att] = pick(doc._attachments[att],\n          ['data', 'digest', 'content_type', 'length', 'revpos', 'stub']);\n      }\n    }\n  }\n}\n\n// compare two docs, first by _id then by _rev\nfunction compareByIdThenRev(a, b) {\n  var idCompare = compare(a._id, b._id);\n  if (idCompare !== 0) {\n    return idCompare;\n  }\n  var aStart = a._revisions ? a._revisions.start : 0;\n  var bStart = b._revisions ? b._revisions.start : 0;\n  return compare(aStart, bStart);\n}\n\n// for every node in a revision tree computes its distance from the closest\n// leaf\nfunction computeHeight(revs) {\n  var height = {};\n  var edges = [];\n  traverseRevTree(revs, function (isLeaf, pos, id, prnt) {\n    var rev = pos + \"-\" + id;\n    if (isLeaf) {\n      height[rev] = 0;\n    }\n    if (prnt !== undefined) {\n      edges.push({from: prnt, to: rev});\n    }\n    return rev;\n  });\n\n  edges.reverse();\n  edges.forEach(function (edge) {\n    if (height[edge.from] === undefined) {\n      height[edge.from] = 1 + height[edge.to];\n    } else {\n      height[edge.from] = Math.min(height[edge.from], 1 + height[edge.to]);\n    }\n  });\n  return height;\n}\n\nfunction allDocsKeysQuery(api, opts, callback) {\n  var keys =  ('limit' in opts) ?\n      opts.keys.slice(opts.skip, opts.limit + opts.skip) :\n      (opts.skip > 0) ? opts.keys.slice(opts.skip) : opts.keys;\n  if (opts.descending) {\n    keys.reverse();\n  }\n  if (!keys.length) {\n    return api._allDocs({limit: 0}, callback);\n  }\n  var finalResults = {\n    offset: opts.skip\n  };\n  return PouchPromise$1.all(keys.map(function (key) {\n    var subOpts = assign$1({key: key, deleted: 'ok'}, opts);\n    ['limit', 'skip', 'keys'].forEach(function (optKey) {\n      delete subOpts[optKey];\n    });\n    return new PouchPromise$1(function (resolve, reject) {\n      api._allDocs(subOpts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        finalResults.total_rows = res.total_rows;\n        resolve(res.rows[0] || {key: key, error: 'not_found'});\n      });\n    });\n  })).then(function (results) {\n    finalResults.rows = results;\n    return finalResults;\n  });\n}\n\n// all compaction is done in a queue, to avoid attaching\n// too many listeners at once\nfunction doNextCompaction(self) {\n  var task = self._compactionQueue[0];\n  var opts = task.opts;\n  var callback = task.callback;\n  self.get('_local/compaction').catch(function () {\n    return false;\n  }).then(function (doc) {\n    if (doc && doc.last_seq) {\n      opts.last_seq = doc.last_seq;\n    }\n    self._compact(opts, function (err, res) {\n      /* istanbul ignore if */\n      if (err) {\n        callback(err);\n      } else {\n        callback(null, res);\n      }\n      nextTick(function () {\n        self._compactionQueue.shift();\n        if (self._compactionQueue.length) {\n          doNextCompaction(self);\n        }\n      });\n    });\n  });\n}\n\nfunction attachmentNameError(name) {\n  if (name.charAt(0) === '_') {\n    return name + 'is not a valid attachment name, attachment ' +\n      'names cannot start with \\'_\\'';\n  }\n  return false;\n}\n\ninherits(AbstractPouchDB, events.EventEmitter);\n\nfunction AbstractPouchDB() {\n  events.EventEmitter.call(this);\n}\n\nAbstractPouchDB.prototype.post =\n  adapterFun('post', function (doc, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return callback(createError(NOT_AN_OBJECT));\n  }\n  this.bulkDocs({docs: [doc]}, opts, yankError(callback));\n});\n\nAbstractPouchDB.prototype.put = adapterFun('put', function (doc, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof doc !== 'object' || Array.isArray(doc)) {\n    return cb(createError(NOT_AN_OBJECT));\n  }\n  invalidIdError(doc._id);\n  if (isLocalId(doc._id) && typeof this._putLocal === 'function') {\n    if (doc._deleted) {\n      return this._removeLocal(doc, cb);\n    } else {\n      return this._putLocal(doc, cb);\n    }\n  }\n  if (typeof this._put === 'function' && opts.new_edits !== false) {\n    this._put(doc, opts, cb);\n  } else {\n    this.bulkDocs({docs: [doc]}, opts, yankError(cb));\n  }\n});\n\nAbstractPouchDB.prototype.putAttachment =\n  adapterFun('putAttachment', function (docId, attachmentId, rev,\n                                              blob, type) {\n  var api = this;\n  if (typeof type === 'function') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  // Lets fix in https://github.com/pouchdb/pouchdb/issues/3267\n  /* istanbul ignore if */\n  if (typeof type === 'undefined') {\n    type = blob;\n    blob = rev;\n    rev = null;\n  }\n  if (!type) {\n    guardedConsole('warn', 'Attachment', attachmentId, 'on document', docId, 'is missing content_type');\n  }\n\n  function createAttachment(doc) {\n    var prevrevpos = '_rev' in doc ? parseInt(doc._rev, 10) : 0;\n    doc._attachments = doc._attachments || {};\n    doc._attachments[attachmentId] = {\n      content_type: type,\n      data: blob,\n      revpos: ++prevrevpos\n    };\n    return api.put(doc);\n  }\n\n  return api.get(docId).then(function (doc) {\n    if (doc._rev !== rev) {\n      throw createError(REV_CONFLICT);\n    }\n\n    return createAttachment(doc);\n  }, function (err) {\n     // create new doc\n    /* istanbul ignore else */\n    if (err.reason === MISSING_DOC.message) {\n      return createAttachment({_id: docId});\n    } else {\n      throw err;\n    }\n  });\n});\n\nAbstractPouchDB.prototype.removeAttachment =\n  adapterFun('removeAttachment', function (docId, attachmentId, rev,\n                                                 callback) {\n  var self = this;\n  self.get(docId, function (err, obj) {\n    /* istanbul ignore if */\n    if (err) {\n      callback(err);\n      return;\n    }\n    if (obj._rev !== rev) {\n      callback(createError(REV_CONFLICT));\n      return;\n    }\n    /* istanbul ignore if */\n    if (!obj._attachments) {\n      return callback();\n    }\n    delete obj._attachments[attachmentId];\n    if (Object.keys(obj._attachments).length === 0) {\n      delete obj._attachments;\n    }\n    self.put(obj, callback);\n  });\n});\n\nAbstractPouchDB.prototype.remove =\n  adapterFun('remove', function (docOrId, optsOrRev, opts, callback) {\n  var doc;\n  if (typeof optsOrRev === 'string') {\n    // id, rev, opts, callback style\n    doc = {\n      _id: docOrId,\n      _rev: optsOrRev\n    };\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n  } else {\n    // doc, opts, callback style\n    doc = docOrId;\n    if (typeof optsOrRev === 'function') {\n      callback = optsOrRev;\n      opts = {};\n    } else {\n      callback = opts;\n      opts = optsOrRev;\n    }\n  }\n  opts = opts || {};\n  opts.was_delete = true;\n  var newDoc = {_id: doc._id, _rev: (doc._rev || opts.rev)};\n  newDoc._deleted = true;\n  if (isLocalId(newDoc._id) && typeof this._removeLocal === 'function') {\n    return this._removeLocal(doc, callback);\n  }\n  this.bulkDocs({docs: [newDoc]}, opts, yankError(callback));\n});\n\nAbstractPouchDB.prototype.revsDiff =\n  adapterFun('revsDiff', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  var ids = Object.keys(req);\n\n  if (!ids.length) {\n    return callback(null, {});\n  }\n\n  var count = 0;\n  var missing = new ExportedMap();\n\n  function addToMissing(id, revId) {\n    if (!missing.has(id)) {\n      missing.set(id, {missing: []});\n    }\n    missing.get(id).missing.push(revId);\n  }\n\n  function processDoc(id, rev_tree) {\n    // Is this fast enough? Maybe we should switch to a set simulated by a map\n    var missingForId = req[id].slice(0);\n    traverseRevTree(rev_tree, function (isLeaf, pos, revHash, ctx,\n      opts) {\n        var rev = pos + '-' + revHash;\n        var idx = missingForId.indexOf(rev);\n        if (idx === -1) {\n          return;\n        }\n\n        missingForId.splice(idx, 1);\n        /* istanbul ignore if */\n        if (opts.status !== 'available') {\n          addToMissing(id, rev);\n        }\n      });\n\n    // Traversing the tree is synchronous, so now `missingForId` contains\n    // revisions that were not found in the tree\n    missingForId.forEach(function (rev) {\n      addToMissing(id, rev);\n    });\n  }\n\n  ids.map(function (id) {\n    this._getRevisionTree(id, function (err, rev_tree) {\n      if (err && err.status === 404 && err.message === 'missing') {\n        missing.set(id, {missing: req[id]});\n      } else if (err) {\n        /* istanbul ignore next */\n        return callback(err);\n      } else {\n        processDoc(id, rev_tree);\n      }\n\n      if (++count === ids.length) {\n        // convert LazyMap to object\n        var missingObj = {};\n        missing.forEach(function (value, key) {\n          missingObj[key] = value;\n        });\n        return callback(null, missingObj);\n      }\n    });\n  }, this);\n});\n\n// _bulk_get API for faster replication, as described in\n// https://github.com/apache/couchdb-chttpd/pull/33\n// At the \"abstract\" level, it will just run multiple get()s in\n// parallel, because this isn't much of a performance cost\n// for local databases (except the cost of multiple transactions, which is\n// small). The http adapter overrides this in order\n// to do a more efficient single HTTP request.\nAbstractPouchDB.prototype.bulkGet =\n  adapterFun('bulkGet', function (opts, callback) {\n  bulkGet(this, opts, callback);\n});\n\n// compact one document and fire callback\n// by compacting we mean removing all revisions which\n// are further from the leaf in revision tree than max_height\nAbstractPouchDB.prototype.compactDocument =\n  adapterFun('compactDocument', function (docId, maxHeight, callback) {\n  var self = this;\n  this._getRevisionTree(docId, function (err, revTree) {\n    /* istanbul ignore if */\n    if (err) {\n      return callback(err);\n    }\n    var height = computeHeight(revTree);\n    var candidates = [];\n    var revs = [];\n    Object.keys(height).forEach(function (rev) {\n      if (height[rev] > maxHeight) {\n        candidates.push(rev);\n      }\n    });\n\n    traverseRevTree(revTree, function (isLeaf, pos, revHash, ctx, opts) {\n      var rev = pos + '-' + revHash;\n      if (opts.status === 'available' && candidates.indexOf(rev) !== -1) {\n        revs.push(rev);\n      }\n    });\n    self._doCompaction(docId, revs, callback);\n  });\n});\n\n// compact the whole database using single document\n// compaction\nAbstractPouchDB.prototype.compact =\n  adapterFun('compact', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  self._compactionQueue = self._compactionQueue || [];\n  self._compactionQueue.push({opts: opts, callback: callback});\n  if (self._compactionQueue.length === 1) {\n    doNextCompaction(self);\n  }\n});\nAbstractPouchDB.prototype._compact = function (opts, callback) {\n  var self = this;\n  var changesOpts = {\n    return_docs: false,\n    last_seq: opts.last_seq || 0\n  };\n  var promises = [];\n\n  function onChange(row) {\n    promises.push(self.compactDocument(row.id, 0));\n  }\n  function onComplete(resp) {\n    var lastSeq = resp.last_seq;\n    PouchPromise$1.all(promises).then(function () {\n      return upsert(self, '_local/compaction', function deltaFunc(doc) {\n        if (!doc.last_seq || doc.last_seq < lastSeq) {\n          doc.last_seq = lastSeq;\n          return doc;\n        }\n        return false; // somebody else got here first, don't update\n      });\n    }).then(function () {\n      callback(null, {ok: true});\n    }).catch(callback);\n  }\n  self.changes(changesOpts)\n    .on('change', onChange)\n    .on('complete', onComplete)\n    .on('error', callback);\n};\n\n/* Begin api wrappers. Specific functionality to storage belongs in the\n   _[method] */\nAbstractPouchDB.prototype.get = adapterFun('get', function (id, opts, cb) {\n  if (typeof opts === 'function') {\n    cb = opts;\n    opts = {};\n  }\n  if (typeof id !== 'string') {\n    return cb(createError(INVALID_ID));\n  }\n  if (isLocalId(id) && typeof this._getLocal === 'function') {\n    return this._getLocal(id, cb);\n  }\n  var leaves = [], self = this;\n\n  function finishOpenRevs() {\n    var result = [];\n    var count = leaves.length;\n    /* istanbul ignore if */\n    if (!count) {\n      return cb(null, result);\n    }\n\n    // order with open_revs is unspecified\n    leaves.forEach(function (leaf) {\n      self.get(id, {\n        rev: leaf,\n        revs: opts.revs,\n        latest: opts.latest,\n        attachments: opts.attachments\n      }, function (err, doc) {\n        if (!err) {\n          // using latest=true can produce duplicates\n          var existing;\n          for (var i = 0, l = result.length; i < l; i++) {\n            if (result[i].ok && result[i].ok._rev === doc._rev) {\n              existing = true;\n              break;\n            }\n          }\n          if (!existing) {\n            result.push({ok: doc});\n          }\n        } else {\n          result.push({missing: leaf});\n        }\n        count--;\n        if (!count) {\n          cb(null, result);\n        }\n      });\n    });\n  }\n\n  if (opts.open_revs) {\n    if (opts.open_revs === \"all\") {\n      this._getRevisionTree(id, function (err, rev_tree) {\n        if (err) {\n          return cb(err);\n        }\n        leaves = collectLeaves(rev_tree).map(function (leaf) {\n          return leaf.rev;\n        });\n        finishOpenRevs();\n      });\n    } else {\n      if (Array.isArray(opts.open_revs)) {\n        leaves = opts.open_revs;\n        for (var i = 0; i < leaves.length; i++) {\n          var l = leaves[i];\n          // looks like it's the only thing couchdb checks\n          if (!(typeof (l) === \"string\" && /^\\d+-/.test(l))) {\n            return cb(createError(INVALID_REV));\n          }\n        }\n        finishOpenRevs();\n      } else {\n        return cb(createError(UNKNOWN_ERROR, 'function_clause'));\n      }\n    }\n    return; // open_revs does not like other options\n  }\n\n  return this._get(id, opts, function (err, result) {\n    if (err) {\n      return cb(err);\n    }\n\n    var doc = result.doc;\n    var metadata = result.metadata;\n    var ctx = result.ctx;\n\n    if (opts.conflicts) {\n      var conflicts = collectConflicts(metadata);\n      if (conflicts.length) {\n        doc._conflicts = conflicts;\n      }\n    }\n\n    if (isDeleted(metadata, doc._rev)) {\n      doc._deleted = true;\n    }\n\n    if (opts.revs || opts.revs_info) {\n      var splittedRev = doc._rev.split('-');\n      var revNo       = parseInt(splittedRev[0], 10);\n      var revHash     = splittedRev[1];\n\n      var paths = rootToLeaf(metadata.rev_tree);\n      var path = null;\n\n      for (var i = 0; i < paths.length; i++) {\n        var currentPath = paths[i];\n        var hashIndex = currentPath.ids.map(function (x) { return x.id; })\n          .indexOf(revHash);\n        var hashFoundAtRevPos = hashIndex === (revNo - 1);\n\n        if (hashFoundAtRevPos || (!path && hashIndex !== -1)) {\n          path = currentPath;\n        }\n      }\n\n      var indexOfRev = path.ids.map(function (x) { return x.id; })\n        .indexOf(doc._rev.split('-')[1]) + 1;\n      var howMany = path.ids.length - indexOfRev;\n      path.ids.splice(indexOfRev, howMany);\n      path.ids.reverse();\n\n      if (opts.revs) {\n        doc._revisions = {\n          start: (path.pos + path.ids.length) - 1,\n          ids: path.ids.map(function (rev) {\n            return rev.id;\n          })\n        };\n      }\n      if (opts.revs_info) {\n        var pos =  path.pos + path.ids.length;\n        doc._revs_info = path.ids.map(function (rev) {\n          pos--;\n          return {\n            rev: pos + '-' + rev.id,\n            status: rev.opts.status\n          };\n        });\n      }\n    }\n\n    if (opts.attachments && doc._attachments) {\n      var attachments = doc._attachments;\n      var count = Object.keys(attachments).length;\n      if (count === 0) {\n        return cb(null, doc);\n      }\n      Object.keys(attachments).forEach(function (key) {\n        this._getAttachment(doc._id, key, attachments[key], {\n          // Previously the revision handling was done in adapter.js\n          // getAttachment, however since idb-next doesnt we need to\n          // pass the rev through\n          rev: doc._rev,\n          binary: opts.binary,\n          ctx: ctx\n        }, function (err, data) {\n          var att = doc._attachments[key];\n          att.data = data;\n          delete att.stub;\n          delete att.length;\n          if (!--count) {\n            cb(null, doc);\n          }\n        });\n      }, self);\n    } else {\n      if (doc._attachments) {\n        for (var key in doc._attachments) {\n          /* istanbul ignore else */\n          if (doc._attachments.hasOwnProperty(key)) {\n            doc._attachments[key].stub = true;\n          }\n        }\n      }\n      cb(null, doc);\n    }\n  });\n});\n\n// TODO: I dont like this, it forces an extra read for every\n// attachment read and enforces a confusing api between\n// adapter.js and the adapter implementation\nAbstractPouchDB.prototype.getAttachment =\n  adapterFun('getAttachment', function (docId, attachmentId, opts, callback) {\n  var self = this;\n  if (opts instanceof Function) {\n    callback = opts;\n    opts = {};\n  }\n  this._get(docId, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (res.doc._attachments && res.doc._attachments[attachmentId]) {\n      opts.ctx = res.ctx;\n      opts.binary = true;\n      self._getAttachment(docId, attachmentId,\n                          res.doc._attachments[attachmentId], opts, callback);\n    } else {\n      return callback(createError(MISSING_DOC));\n    }\n  });\n});\n\nAbstractPouchDB.prototype.allDocs =\n  adapterFun('allDocs', function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts.skip = typeof opts.skip !== 'undefined' ? opts.skip : 0;\n  if (opts.start_key) {\n    opts.startkey = opts.start_key;\n  }\n  if (opts.end_key) {\n    opts.endkey = opts.end_key;\n  }\n  if ('keys' in opts) {\n    if (!Array.isArray(opts.keys)) {\n      return callback(new TypeError('options.keys must be an array'));\n    }\n    var incompatibleOpt =\n      ['startkey', 'endkey', 'key'].filter(function (incompatibleOpt) {\n      return incompatibleOpt in opts;\n    })[0];\n    if (incompatibleOpt) {\n      callback(createError(QUERY_PARSE_ERROR,\n        'Query parameter `' + incompatibleOpt +\n        '` is not compatible with multi-get'\n      ));\n      return;\n    }\n    if (this.type() !== 'http') {\n      return allDocsKeysQuery(this, opts, callback);\n    }\n  }\n\n  return this._allDocs(opts, callback);\n});\n\nAbstractPouchDB.prototype.changes = function (opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  return new Changes$2(this, opts, callback);\n};\n\nAbstractPouchDB.prototype.close = adapterFun('close', function (callback) {\n  this._closed = true;\n  this.emit('closed');\n  return this._close(callback);\n});\n\nAbstractPouchDB.prototype.info = adapterFun('info', function (callback) {\n  var self = this;\n  this._info(function (err, info) {\n    if (err) {\n      return callback(err);\n    }\n    // assume we know better than the adapter, unless it informs us\n    info.db_name = info.db_name || self.name;\n    info.auto_compaction = !!(self.auto_compaction && self.type() !== 'http');\n    info.adapter = self.type();\n    callback(null, info);\n  });\n});\n\nAbstractPouchDB.prototype.id = adapterFun('id', function (callback) {\n  return this._id(callback);\n});\n\n/* istanbul ignore next */\nAbstractPouchDB.prototype.type = function () {\n  return (typeof this._type === 'function') ? this._type() : this.adapter;\n};\n\nAbstractPouchDB.prototype.bulkDocs =\n  adapterFun('bulkDocs', function (req, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  opts = opts || {};\n\n  if (Array.isArray(req)) {\n    req = {\n      docs: req\n    };\n  }\n\n  if (!req || !req.docs || !Array.isArray(req.docs)) {\n    return callback(createError(MISSING_BULK_DOCS));\n  }\n\n  for (var i = 0; i < req.docs.length; ++i) {\n    if (typeof req.docs[i] !== 'object' || Array.isArray(req.docs[i])) {\n      return callback(createError(NOT_AN_OBJECT));\n    }\n  }\n\n  var attachmentError;\n  req.docs.forEach(function (doc) {\n    if (doc._attachments) {\n      Object.keys(doc._attachments).forEach(function (name) {\n        attachmentError = attachmentError || attachmentNameError(name);\n        if (!doc._attachments[name].content_type) {\n          guardedConsole('warn', 'Attachment', name, 'on document', doc._id, 'is missing content_type');\n        }\n      });\n    }\n  });\n\n  if (attachmentError) {\n    return callback(createError(BAD_REQUEST, attachmentError));\n  }\n\n  if (!('new_edits' in opts)) {\n    if ('new_edits' in req) {\n      opts.new_edits = req.new_edits;\n    } else {\n      opts.new_edits = true;\n    }\n  }\n\n  var adapter = this;\n  if (!opts.new_edits && adapter.type() !== 'http') {\n    // ensure revisions of the same doc are sorted, so that\n    // the local adapter processes them correctly (#2935)\n    req.docs.sort(compareByIdThenRev);\n  }\n\n  cleanDocs(req.docs);\n\n  // in the case of conflicts, we want to return the _ids to the user\n  // however, the underlying adapter may destroy the docs array, so\n  // create a copy here\n  var ids = req.docs.map(function (doc) {\n    return doc._id;\n  });\n\n  return this._bulkDocs(req, opts, function (err, res) {\n    if (err) {\n      return callback(err);\n    }\n    if (!opts.new_edits) {\n      // this is what couch does when new_edits is false\n      res = res.filter(function (x) {\n        return x.error;\n      });\n    }\n    // add ids for error/conflict responses (not required for CouchDB)\n    if (adapter.type() !== 'http') {\n      for (var i = 0, l = res.length; i < l; i++) {\n        res[i].id = res[i].id || ids[i];\n      }\n    }\n\n    callback(null, res);\n  });\n});\n\nAbstractPouchDB.prototype.registerDependentDatabase =\n  adapterFun('registerDependentDatabase', function (dependentDb,\n                                                          callback) {\n  var depDB = new this.constructor(dependentDb, this.__opts);\n\n  function diffFun(doc) {\n    doc.dependentDbs = doc.dependentDbs || {};\n    if (doc.dependentDbs[dependentDb]) {\n      return false; // no update required\n    }\n    doc.dependentDbs[dependentDb] = true;\n    return doc;\n  }\n  upsert(this, '_local/_pouch_dependentDbs', diffFun)\n    .then(function () {\n      callback(null, {db: depDB});\n    }).catch(callback);\n});\n\nAbstractPouchDB.prototype.destroy =\n  adapterFun('destroy', function (opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n\n  var self = this;\n  var usePrefix = 'use_prefix' in self ? self.use_prefix : true;\n\n  function destroyDb() {\n    // call destroy method of the particular adaptor\n    self._destroy(opts, function (err, resp) {\n      if (err) {\n        return callback(err);\n      }\n      self._destroyed = true;\n      self.emit('destroyed');\n      callback(null, resp || { 'ok': true });\n    });\n  }\n\n  if (self.type() === 'http') {\n    // no need to check for dependent DBs if it's a remote DB\n    return destroyDb();\n  }\n\n  self.get('_local/_pouch_dependentDbs', function (err, localDoc) {\n    if (err) {\n      /* istanbul ignore if */\n      if (err.status !== 404) {\n        return callback(err);\n      } else { // no dependencies\n        return destroyDb();\n      }\n    }\n    var dependentDbs = localDoc.dependentDbs;\n    var PouchDB = self.constructor;\n    var deletedMap = Object.keys(dependentDbs).map(function (name) {\n      // use_prefix is only false in the browser\n      /* istanbul ignore next */\n      var trueName = usePrefix ?\n        name.replace(new RegExp('^' + PouchDB.prefix), '') : name;\n      return new PouchDB(trueName, self.__opts).destroy();\n    });\n    PouchPromise$1.all(deletedMap).then(destroyDb, callback);\n  });\n});\n\nfunction TaskQueue$1() {\n  this.isReady = false;\n  this.failed = false;\n  this.queue = [];\n}\n\nTaskQueue$1.prototype.execute = function () {\n  var fun;\n  if (this.failed) {\n    while ((fun = this.queue.shift())) {\n      fun(this.failed);\n    }\n  } else {\n    while ((fun = this.queue.shift())) {\n      fun();\n    }\n  }\n};\n\nTaskQueue$1.prototype.fail = function (err) {\n  this.failed = err;\n  this.execute();\n};\n\nTaskQueue$1.prototype.ready = function (db) {\n  this.isReady = true;\n  this.db = db;\n  this.execute();\n};\n\nTaskQueue$1.prototype.addTask = function (fun) {\n  this.queue.push(fun);\n  if (this.failed) {\n    this.execute();\n  }\n};\n\nfunction parseAdapter(name, opts) {\n  var match = name.match(/([a-z\\-]*):\\/\\/(.*)/);\n  if (match) {\n    // the http adapter expects the fully qualified name\n    return {\n      name: /https?/.test(match[1]) ? match[1] + '://' + match[2] : match[2],\n      adapter: match[1]\n    };\n  }\n\n  var adapters = PouchDB$5.adapters;\n  var preferredAdapters = PouchDB$5.preferredAdapters;\n  var prefix = PouchDB$5.prefix;\n  var adapterName = opts.adapter;\n\n  if (!adapterName) { // automatically determine adapter\n    for (var i = 0; i < preferredAdapters.length; ++i) {\n      adapterName = preferredAdapters[i];\n      // check for browsers that have been upgraded from websql-only to websql+idb\n      /* istanbul ignore if */\n      if (adapterName === 'idb' && 'websql' in adapters &&\n          hasLocalStorage() && localStorage['_pouch__websqldb_' + prefix + name]) {\n        // log it, because this can be confusing during development\n        guardedConsole('log', 'PouchDB is downgrading \"' + name + '\" to WebSQL to' +\n          ' avoid data loss, because it was already opened with WebSQL.');\n        continue; // keep using websql to avoid user data loss\n      }\n      break;\n    }\n  }\n\n  var adapter = adapters[adapterName];\n\n  // if adapter is invalid, then an error will be thrown later\n  var usePrefix = (adapter && 'use_prefix' in adapter) ?\n    adapter.use_prefix : true;\n\n  return {\n    name: usePrefix ? (prefix + name) : name,\n    adapter: adapterName\n  };\n}\n\n// OK, so here's the deal. Consider this code:\n//     var db1 = new PouchDB('foo');\n//     var db2 = new PouchDB('foo');\n//     db1.destroy();\n// ^ these two both need to emit 'destroyed' events,\n// as well as the PouchDB constructor itself.\n// So we have one db object (whichever one got destroy() called on it)\n// responsible for emitting the initial event, which then gets emitted\n// by the constructor, which then broadcasts it to any other dbs\n// that may have been created with the same name.\nfunction prepareForDestruction(self) {\n\n  var destructionListeners = self.constructor._destructionListeners;\n\n  function onDestroyed() {\n    self.removeListener('closed', onClosed);\n    self.constructor.emit('destroyed', self.name);\n  }\n\n  function onConstructorDestroyed() {\n    self.removeListener('destroyed', onDestroyed);\n    self.removeListener('closed', onClosed);\n    self.emit('destroyed');\n  }\n\n  function onClosed() {\n    self.removeListener('destroyed', onDestroyed);\n    destructionListeners.delete(self.name);\n  }\n\n  self.once('destroyed', onDestroyed);\n  self.once('closed', onClosed);\n\n  // in setup.js, the constructor is primed to listen for destroy events\n  if (!destructionListeners.has(self.name)) {\n    destructionListeners.set(self.name, []);\n  }\n  destructionListeners.get(self.name).push(onConstructorDestroyed);\n}\n\ninherits(PouchDB$5, AbstractPouchDB);\nfunction PouchDB$5(name, opts) {\n  // In Node our test suite only tests this for PouchAlt unfortunately\n  /* istanbul ignore if */\n  if (!(this instanceof PouchDB$5)) {\n    return new PouchDB$5(name, opts);\n  }\n\n  var self = this;\n  opts = opts || {};\n\n  if (name && typeof name === 'object') {\n    opts = name;\n    name = opts.name;\n    delete opts.name;\n  }\n\n  this.__opts = opts = clone(opts);\n\n  self.auto_compaction = opts.auto_compaction;\n  self.prefix = PouchDB$5.prefix;\n\n  if (typeof name !== 'string') {\n    throw new Error('Missing/invalid DB name');\n  }\n\n  var prefixedName = (opts.prefix || '') + name;\n  var backend = parseAdapter(prefixedName, opts);\n\n  opts.name = backend.name;\n  opts.adapter = opts.adapter || backend.adapter;\n\n  self.name = name;\n  self._adapter = opts.adapter;\n  debug('pouchdb:adapter')('Picked adapter: ' + opts.adapter);\n\n  if (!PouchDB$5.adapters[opts.adapter] ||\n      !PouchDB$5.adapters[opts.adapter].valid()) {\n    throw new Error('Invalid Adapter: ' + opts.adapter);\n  }\n\n  AbstractPouchDB.call(self);\n  self.taskqueue = new TaskQueue$1();\n\n  self.adapter = opts.adapter;\n\n  PouchDB$5.adapters[opts.adapter].call(self, opts, function (err) {\n    if (err) {\n      return self.taskqueue.fail(err);\n    }\n    prepareForDestruction(self);\n\n    self.emit('created', self);\n    PouchDB$5.emit('created', self.name);\n    self.taskqueue.ready(self);\n  });\n\n}\n\nPouchDB$5.debug = debug;\n\nPouchDB$5.adapters = {};\nPouchDB$5.preferredAdapters = [];\n\nPouchDB$5.prefix = '_pouch_';\n\nvar eventEmitter = new events.EventEmitter();\n\nfunction setUpEventEmitter(Pouch) {\n  Object.keys(events.EventEmitter.prototype).forEach(function (key) {\n    if (typeof events.EventEmitter.prototype[key] === 'function') {\n      Pouch[key] = eventEmitter[key].bind(eventEmitter);\n    }\n  });\n\n  // these are created in constructor.js, and allow us to notify each DB with\n  // the same name that it was destroyed, via the constructor object\n  var destructListeners = Pouch._destructionListeners = new ExportedMap();\n  Pouch.on('destroyed', function onConstructorDestroyed(name) {\n    destructListeners.get(name).forEach(function (callback) {\n      callback();\n    });\n    destructListeners.delete(name);\n  });\n}\n\nsetUpEventEmitter(PouchDB$5);\n\nPouchDB$5.adapter = function (id, obj, addToPreferredAdapters) {\n  /* istanbul ignore else */\n  if (obj.valid()) {\n    PouchDB$5.adapters[id] = obj;\n    if (addToPreferredAdapters) {\n      PouchDB$5.preferredAdapters.push(id);\n    }\n  }\n};\n\nPouchDB$5.plugin = function (obj) {\n  if (typeof obj === 'function') { // function style for plugins\n    obj(PouchDB$5);\n  } else if (typeof obj !== 'object' || Object.keys(obj).length === 0){\n    throw new Error('Invalid plugin: got \\\"' + obj + '\\\", expected an object or a function');\n  } else {\n    Object.keys(obj).forEach(function (id) { // object style for plugins\n      PouchDB$5.prototype[id] = obj[id];\n    });\n  }\n  return PouchDB$5;\n};\n\nPouchDB$5.defaults = function (defaultOpts) {\n  function PouchAlt(name, opts) {\n    if (!(this instanceof PouchAlt)) {\n      return new PouchAlt(name, opts);\n    }\n\n    opts = opts || {};\n\n    if (name && typeof name === 'object') {\n      opts = name;\n      name = opts.name;\n      delete opts.name;\n    }\n\n    opts = assign$1({}, PouchAlt.__defaults, opts);\n    PouchDB$5.call(this, name, opts);\n  }\n\n  inherits(PouchAlt, PouchDB$5);\n\n  PouchAlt.preferredAdapters = PouchDB$5.preferredAdapters.slice();\n  Object.keys(PouchDB$5).forEach(function (key) {\n    if (!(key in PouchAlt)) {\n      PouchAlt[key] = PouchDB$5[key];\n    }\n  });\n\n  // make default options transitive\n  // https://github.com/pouchdb/pouchdb/issues/5922\n  PouchAlt.__defaults = assign$1({}, this.__defaults, defaultOpts);\n\n  return PouchAlt;\n};\n\n// managed automatically by set-version.js\nvar version = \"6.1.1\";\n\nPouchDB$5.version = version;\n\nfunction toObject(array) {\n  return array.reduce(function (obj, item) {\n    obj[item] = true;\n    return obj;\n  }, {});\n}\n// List of top level reserved words for doc\nvar reservedWords = toObject([\n  '_id',\n  '_rev',\n  '_attachments',\n  '_deleted',\n  '_revisions',\n  '_revs_info',\n  '_conflicts',\n  '_deleted_conflicts',\n  '_local_seq',\n  '_rev_tree',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats',\n  // Specific to Couchbase Sync Gateway\n  '_removed'\n]);\n\n// List of reserved words that should end up the document\nvar dataWords = toObject([\n  '_attachments',\n  //replication documents\n  '_replication_id',\n  '_replication_state',\n  '_replication_state_time',\n  '_replication_state_reason',\n  '_replication_stats'\n]);\n\nfunction parseRevisionInfo(rev) {\n  if (!/^\\d+\\-./.test(rev)) {\n    return createError(INVALID_REV);\n  }\n  var idx = rev.indexOf('-');\n  var left = rev.substring(0, idx);\n  var right = rev.substring(idx + 1);\n  return {\n    prefix: parseInt(left, 10),\n    id: right\n  };\n}\n\nfunction makeRevTreeFromRevisions(revisions, opts) {\n  var pos = revisions.start - revisions.ids.length + 1;\n\n  var revisionIds = revisions.ids;\n  var ids = [revisionIds[0], opts, []];\n\n  for (var i = 1, len = revisionIds.length; i < len; i++) {\n    ids = [revisionIds[i], {status: 'missing'}, [ids]];\n  }\n\n  return [{\n    pos: pos,\n    ids: ids\n  }];\n}\n\n// Preprocess documents, parse their revisions, assign an id and a\n// revision for new writes that are missing them, etc\nfunction parseDoc(doc, newEdits) {\n\n  var nRevNum;\n  var newRevId;\n  var revInfo;\n  var opts = {status: 'available'};\n  if (doc._deleted) {\n    opts.deleted = true;\n  }\n\n  if (newEdits) {\n    if (!doc._id) {\n      doc._id = uuid();\n    }\n    newRevId = uuid(32, 16).toLowerCase();\n    if (doc._rev) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      doc._rev_tree = [{\n        pos: revInfo.prefix,\n        ids: [revInfo.id, {status: 'missing'}, [[newRevId, opts, []]]]\n      }];\n      nRevNum = revInfo.prefix + 1;\n    } else {\n      doc._rev_tree = [{\n        pos: 1,\n        ids : [newRevId, opts, []]\n      }];\n      nRevNum = 1;\n    }\n  } else {\n    if (doc._revisions) {\n      doc._rev_tree = makeRevTreeFromRevisions(doc._revisions, opts);\n      nRevNum = doc._revisions.start;\n      newRevId = doc._revisions.ids[0];\n    }\n    if (!doc._rev_tree) {\n      revInfo = parseRevisionInfo(doc._rev);\n      if (revInfo.error) {\n        return revInfo;\n      }\n      nRevNum = revInfo.prefix;\n      newRevId = revInfo.id;\n      doc._rev_tree = [{\n        pos: nRevNum,\n        ids: [newRevId, opts, []]\n      }];\n    }\n  }\n\n  invalidIdError(doc._id);\n\n  doc._rev = nRevNum + '-' + newRevId;\n\n  var result = {metadata : {}, data : {}};\n  for (var key in doc) {\n    /* istanbul ignore else */\n    if (Object.prototype.hasOwnProperty.call(doc, key)) {\n      var specialKey = key[0] === '_';\n      if (specialKey && !reservedWords[key]) {\n        var error = createError(DOC_VALIDATION, key);\n        error.message = DOC_VALIDATION.message + ': ' + key;\n        throw error;\n      } else if (specialKey && !dataWords[key]) {\n        result.metadata[key.slice(1)] = doc[key];\n      } else {\n        result.data[key] = doc[key];\n      }\n    }\n  }\n  return result;\n}\n\nvar thisAtob = function (str) {\n  return atob(str);\n};\n\nvar thisBtoa = function (str) {\n  return btoa(str);\n};\n\n// Abstracts constructing a Blob object, so it also works in older\n// browsers that don't support the native Blob constructor (e.g.\n// old QtWebKit versions, Android < 4.4).\nfunction createBlob(parts, properties) {\n  /* global BlobBuilder,MSBlobBuilder,MozBlobBuilder,WebKitBlobBuilder */\n  parts = parts || [];\n  properties = properties || {};\n  try {\n    return new Blob(parts, properties);\n  } catch (e) {\n    if (e.name !== \"TypeError\") {\n      throw e;\n    }\n    var Builder = typeof BlobBuilder !== 'undefined' ? BlobBuilder :\n                  typeof MSBlobBuilder !== 'undefined' ? MSBlobBuilder :\n                  typeof MozBlobBuilder !== 'undefined' ? MozBlobBuilder :\n                  WebKitBlobBuilder;\n    var builder = new Builder();\n    for (var i = 0; i < parts.length; i += 1) {\n      builder.append(parts[i]);\n    }\n    return builder.getBlob(properties.type);\n  }\n}\n\n// From http://stackoverflow.com/questions/14967647/ (continues on next line)\n// encode-decode-image-with-base64-breaks-image (2013-04-21)\nfunction binaryStringToArrayBuffer(bin) {\n  var length = bin.length;\n  var buf = new ArrayBuffer(length);\n  var arr = new Uint8Array(buf);\n  for (var i = 0; i < length; i++) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return buf;\n}\n\nfunction binStringToBluffer(binString, type) {\n  return createBlob([binaryStringToArrayBuffer(binString)], {type: type});\n}\n\nfunction b64ToBluffer(b64, type) {\n  return binStringToBluffer(thisAtob(b64), type);\n}\n\n//Can't find original post, but this is close\n//http://stackoverflow.com/questions/6965107/ (continues on next line)\n//converting-between-strings-and-arraybuffers\nfunction arrayBufferToBinaryString(buffer) {\n  var binary = '';\n  var bytes = new Uint8Array(buffer);\n  var length = bytes.byteLength;\n  for (var i = 0; i < length; i++) {\n    binary += String.fromCharCode(bytes[i]);\n  }\n  return binary;\n}\n\n// shim for browsers that don't support it\nfunction readAsBinaryString(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(arrayBufferToBinaryString(\n      new FileReaderSync().readAsArrayBuffer(blob)));\n  }\n\n  var reader = new FileReader();\n  var hasBinaryString = typeof reader.readAsBinaryString === 'function';\n  reader.onloadend = function (e) {\n    var result = e.target.result || '';\n    if (hasBinaryString) {\n      return callback(result);\n    }\n    callback(arrayBufferToBinaryString(result));\n  };\n  if (hasBinaryString) {\n    reader.readAsBinaryString(blob);\n  } else {\n    reader.readAsArrayBuffer(blob);\n  }\n}\n\nfunction blobToBinaryString(blobOrBuffer, callback) {\n  readAsBinaryString(blobOrBuffer, function (bin) {\n    callback(bin);\n  });\n}\n\nfunction blobToBase64(blobOrBuffer, callback) {\n  blobToBinaryString(blobOrBuffer, function (base64) {\n    callback(thisBtoa(base64));\n  });\n}\n\n// simplified API. universal browser support is assumed\nfunction readAsArrayBuffer(blob, callback) {\n  if (typeof FileReader === 'undefined') {\n    // fix for Firefox in a web worker:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=901097\n    return callback(new FileReaderSync().readAsArrayBuffer(blob));\n  }\n\n  var reader = new FileReader();\n  reader.onloadend = function (e) {\n    var result = e.target.result || new ArrayBuffer(0);\n    callback(result);\n  };\n  reader.readAsArrayBuffer(blob);\n}\n\n// this is not used in the browser\n\nvar setImmediateShim = global.setImmediate || global.setTimeout;\nvar MD5_CHUNK_SIZE = 32768;\n\nfunction rawToBase64(raw) {\n  return thisBtoa(raw);\n}\n\nfunction sliceBlob(blob$$1, start, end) {\n  if (blob$$1.webkitSlice) {\n    return blob$$1.webkitSlice(start, end);\n  }\n  return blob$$1.slice(start, end);\n}\n\nfunction appendBlob(buffer, blob$$1, start, end, callback) {\n  if (start > 0 || end < blob$$1.size) {\n    // only slice blob if we really need to\n    blob$$1 = sliceBlob(blob$$1, start, end);\n  }\n  readAsArrayBuffer(blob$$1, function (arrayBuffer) {\n    buffer.append(arrayBuffer);\n    callback();\n  });\n}\n\nfunction appendString(buffer, string, start, end, callback) {\n  if (start > 0 || end < string.length) {\n    // only create a substring if we really need to\n    string = string.substring(start, end);\n  }\n  buffer.appendBinary(string);\n  callback();\n}\n\nfunction binaryMd5(data, callback) {\n  var inputIsString = typeof data === 'string';\n  var len = inputIsString ? data.length : data.size;\n  var chunkSize = Math.min(MD5_CHUNK_SIZE, len);\n  var chunks = Math.ceil(len / chunkSize);\n  var currentChunk = 0;\n  var buffer = inputIsString ? new Md5() : new Md5.ArrayBuffer();\n\n  var append = inputIsString ? appendString : appendBlob;\n\n  function next() {\n    setImmediateShim(loadNextChunk);\n  }\n\n  function done() {\n    var raw = buffer.end(true);\n    var base64 = rawToBase64(raw);\n    callback(base64);\n    buffer.destroy();\n  }\n\n  function loadNextChunk() {\n    var start = currentChunk * chunkSize;\n    var end = start + chunkSize;\n    currentChunk++;\n    if (currentChunk < chunks) {\n      append(buffer, data, start, end, next);\n    } else {\n      append(buffer, data, start, end, done);\n    }\n  }\n  loadNextChunk();\n}\n\nfunction stringMd5(string) {\n  return Md5.hash(string);\n}\n\nfunction parseBase64(data) {\n  try {\n    return thisAtob(data);\n  } catch (e) {\n    var err = createError(BAD_ARG,\n      'Attachment is not a valid base64 string');\n    return {error: err};\n  }\n}\n\nfunction preprocessString(att, blobType, callback) {\n  var asBinary = parseBase64(att.data);\n  if (asBinary.error) {\n    return callback(asBinary.error);\n  }\n\n  att.length = asBinary.length;\n  if (blobType === 'blob') {\n    att.data = binStringToBluffer(asBinary, att.content_type);\n  } else if (blobType === 'base64') {\n    att.data = thisBtoa(asBinary);\n  } else { // binary\n    att.data = asBinary;\n  }\n  binaryMd5(asBinary, function (result) {\n    att.digest = 'md5-' + result;\n    callback();\n  });\n}\n\nfunction preprocessBlob(att, blobType, callback) {\n  binaryMd5(att.data, function (md5) {\n    att.digest = 'md5-' + md5;\n    // size is for blobs (browser), length is for buffers (node)\n    att.length = att.data.size || att.data.length || 0;\n    if (blobType === 'binary') {\n      blobToBinaryString(att.data, function (binString) {\n        att.data = binString;\n        callback();\n      });\n    } else if (blobType === 'base64') {\n      blobToBase64(att.data, function (b64) {\n        att.data = b64;\n        callback();\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\nfunction preprocessAttachment(att, blobType, callback) {\n  if (att.stub) {\n    return callback();\n  }\n  if (typeof att.data === 'string') { // input is a base64 string\n    preprocessString(att, blobType, callback);\n  } else { // input is a blob\n    preprocessBlob(att, blobType, callback);\n  }\n}\n\nfunction preprocessAttachments(docInfos, blobType, callback) {\n\n  if (!docInfos.length) {\n    return callback();\n  }\n\n  var docv = 0;\n  var overallErr;\n\n  docInfos.forEach(function (docInfo) {\n    var attachments = docInfo.data && docInfo.data._attachments ?\n      Object.keys(docInfo.data._attachments) : [];\n    var recv = 0;\n\n    if (!attachments.length) {\n      return done();\n    }\n\n    function processedAttachment(err) {\n      overallErr = err;\n      recv++;\n      if (recv === attachments.length) {\n        done();\n      }\n    }\n\n    for (var key in docInfo.data._attachments) {\n      if (docInfo.data._attachments.hasOwnProperty(key)) {\n        preprocessAttachment(docInfo.data._attachments[key],\n          blobType, processedAttachment);\n      }\n    }\n  });\n\n  function done() {\n    docv++;\n    if (docInfos.length === docv) {\n      if (overallErr) {\n        callback(overallErr);\n      } else {\n        callback();\n      }\n    }\n  }\n}\n\nfunction updateDoc(revLimit, prev, docInfo, results,\n                   i, cb, writeDoc, newEdits) {\n\n  if (revExists(prev.rev_tree, docInfo.metadata.rev)) {\n    results[i] = docInfo;\n    return cb();\n  }\n\n  // sometimes this is pre-calculated. historically not always\n  var previousWinningRev = prev.winningRev || winningRev(prev);\n  var previouslyDeleted = 'deleted' in prev ? prev.deleted :\n    isDeleted(prev, previousWinningRev);\n  var deleted = 'deleted' in docInfo.metadata ? docInfo.metadata.deleted :\n    isDeleted(docInfo.metadata);\n  var isRoot = /^1-/.test(docInfo.metadata.rev);\n\n  if (previouslyDeleted && !deleted && newEdits && isRoot) {\n    var newDoc = docInfo.data;\n    newDoc._rev = previousWinningRev;\n    newDoc._id = docInfo.metadata.id;\n    docInfo = parseDoc(newDoc, newEdits);\n  }\n\n  var merged = merge(prev.rev_tree, docInfo.metadata.rev_tree[0], revLimit);\n\n  var inConflict = newEdits && (((previouslyDeleted && deleted) ||\n    (!previouslyDeleted && merged.conflicts !== 'new_leaf') ||\n    (previouslyDeleted && !deleted && merged.conflicts === 'new_branch')));\n\n  if (inConflict) {\n    var err = createError(REV_CONFLICT);\n    results[i] = err;\n    return cb();\n  }\n\n  var newRev = docInfo.metadata.rev;\n  docInfo.metadata.rev_tree = merged.tree;\n  docInfo.stemmedRevs = merged.stemmedRevs || [];\n  /* istanbul ignore else */\n  if (prev.rev_map) {\n    docInfo.metadata.rev_map = prev.rev_map; // used only by leveldb\n  }\n\n  // recalculate\n  var winningRev$$1 = winningRev(docInfo.metadata);\n  var winningRevIsDeleted = isDeleted(docInfo.metadata, winningRev$$1);\n\n  // calculate the total number of documents that were added/removed,\n  // from the perspective of total_rows/doc_count\n  var delta = (previouslyDeleted === winningRevIsDeleted) ? 0 :\n    previouslyDeleted < winningRevIsDeleted ? -1 : 1;\n\n  var newRevIsDeleted;\n  if (newRev === winningRev$$1) {\n    // if the new rev is the same as the winning rev, we can reuse that value\n    newRevIsDeleted = winningRevIsDeleted;\n  } else {\n    // if they're not the same, then we need to recalculate\n    newRevIsDeleted = isDeleted(docInfo.metadata, newRev);\n  }\n\n  writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n    true, delta, i, cb);\n}\n\nfunction rootIsMissing(docInfo) {\n  return docInfo.metadata.rev_tree[0].ids[1].status === 'missing';\n}\n\nfunction processDocs(revLimit, docInfos, api, fetchedDocs, tx, results,\n                     writeDoc, opts, overallCallback) {\n\n  // Default to 1000 locally\n  revLimit = revLimit || 1000;\n\n  function insertDoc(docInfo, resultsIdx, callback) {\n    // Cant insert new deleted documents\n    var winningRev$$1 = winningRev(docInfo.metadata);\n    var deleted = isDeleted(docInfo.metadata, winningRev$$1);\n    if ('was_delete' in opts && deleted) {\n      results[resultsIdx] = createError(MISSING_DOC, 'deleted');\n      return callback();\n    }\n\n    // 4712 - detect whether a new document was inserted with a _rev\n    var inConflict = newEdits && rootIsMissing(docInfo);\n\n    if (inConflict) {\n      var err = createError(REV_CONFLICT);\n      results[resultsIdx] = err;\n      return callback();\n    }\n\n    var delta = deleted ? 0 : 1;\n\n    writeDoc(docInfo, winningRev$$1, deleted, deleted, false,\n      delta, resultsIdx, callback);\n  }\n\n  var newEdits = opts.new_edits;\n  var idsToDocs = new ExportedMap();\n\n  var docsDone = 0;\n  var docsToDo = docInfos.length;\n\n  function checkAllDocsDone() {\n    if (++docsDone === docsToDo && overallCallback) {\n      overallCallback();\n    }\n  }\n\n  docInfos.forEach(function (currentDoc, resultsIdx) {\n\n    if (currentDoc._id && isLocalId(currentDoc._id)) {\n      var fun = currentDoc._deleted ? '_removeLocal' : '_putLocal';\n      api[fun](currentDoc, {ctx: tx}, function (err, res) {\n        results[resultsIdx] = err || res;\n        checkAllDocsDone();\n      });\n      return;\n    }\n\n    var id = currentDoc.metadata.id;\n    if (idsToDocs.has(id)) {\n      docsToDo--; // duplicate\n      idsToDocs.get(id).push([currentDoc, resultsIdx]);\n    } else {\n      idsToDocs.set(id, [[currentDoc, resultsIdx]]);\n    }\n  });\n\n  // in the case of new_edits, the user can provide multiple docs\n  // with the same id. these need to be processed sequentially\n  idsToDocs.forEach(function (docs, id) {\n    var numDone = 0;\n\n    function docWritten() {\n      if (++numDone < docs.length) {\n        nextDoc();\n      } else {\n        checkAllDocsDone();\n      }\n    }\n    function nextDoc() {\n      var value = docs[numDone];\n      var currentDoc = value[0];\n      var resultsIdx = value[1];\n\n      if (fetchedDocs.has(id)) {\n        updateDoc(revLimit, fetchedDocs.get(id), currentDoc, results,\n          resultsIdx, docWritten, writeDoc, newEdits);\n      } else {\n        // Ensure stemming applies to new writes as well\n        var merged = merge([], currentDoc.metadata.rev_tree[0], revLimit);\n        currentDoc.metadata.rev_tree = merged.tree;\n        currentDoc.stemmedRevs = merged.stemmedRevs || [];\n        insertDoc(currentDoc, resultsIdx, docWritten);\n      }\n    }\n    nextDoc();\n  });\n}\n\n// IndexedDB requires a versioned database structure, so we use the\n// version here to manage migrations.\nvar ADAPTER_VERSION = 5;\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\n// Keyed by document id\nvar DOC_STORE = 'document-store';\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE = 'by-sequence';\n// Where we store attachments\nvar ATTACH_STORE = 'attach-store';\n// Where we store many-to-many relations\n// between attachment digests and seqs\nvar ATTACH_AND_SEQ_STORE = 'attach-seq-store';\n\n// Where we store database-wide meta data in a single record\n// keyed by id: META_STORE\nvar META_STORE = 'meta-store';\n// Where we store local documents\nvar LOCAL_STORE = 'local-store';\n// Where we detect blob support\nvar DETECT_BLOB_SUPPORT_STORE = 'detect-blob-support';\n\nfunction safeJsonParse(str) {\n  // This try/catch guards against stack overflow errors.\n  // JSON.parse() is faster than vuvuzela.parse() but vuvuzela\n  // cannot overflow.\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.parse(str);\n  }\n}\n\nfunction safeJsonStringify(json) {\n  try {\n    return JSON.stringify(json);\n  } catch (e) {\n    /* istanbul ignore next */\n    return vuvuzela.stringify(json);\n  }\n}\n\nfunction idbError(callback) {\n  return function (evt) {\n    var message = 'unknown_error';\n    if (evt.target && evt.target.error) {\n      message = evt.target.error.name || evt.target.error.message;\n    }\n    callback(createError(IDB_ERROR, message, evt.type));\n  };\n}\n\n// Unfortunately, the metadata has to be stringified\n// when it is put into the database, because otherwise\n// IndexedDB can throw errors for deeply-nested objects.\n// Originally we just used JSON.parse/JSON.stringify; now\n// we use this custom vuvuzela library that avoids recursion.\n// If we could do it all over again, we'd probably use a\n// format for the revision trees other than JSON.\nfunction encodeMetadata(metadata, winningRev, deleted) {\n  return {\n    data: safeJsonStringify(metadata),\n    winningRev: winningRev,\n    deletedOrLocal: deleted ? '1' : '0',\n    seq: metadata.seq, // highest seq for this doc\n    id: metadata.id\n  };\n}\n\nfunction decodeMetadata(storedObject) {\n  if (!storedObject) {\n    return null;\n  }\n  var metadata = safeJsonParse(storedObject.data);\n  metadata.winningRev = storedObject.winningRev;\n  metadata.deleted = storedObject.deletedOrLocal === '1';\n  metadata.seq = storedObject.seq;\n  return metadata;\n}\n\n// read the doc back out from the database. we don't store the\n// _id or _rev because we already have _doc_id_rev.\nfunction decodeDoc(doc) {\n  if (!doc) {\n    return doc;\n  }\n  var idx = doc._doc_id_rev.lastIndexOf(':');\n  doc._id = doc._doc_id_rev.substring(0, idx - 1);\n  doc._rev = doc._doc_id_rev.substring(idx + 1);\n  delete doc._doc_id_rev;\n  return doc;\n}\n\n// Read a blob from the database, encoding as necessary\n// and translating from base64 if the IDB doesn't support\n// native Blobs\nfunction readBlobData(body, type, asBlob, callback) {\n  if (asBlob) {\n    if (!body) {\n      callback(createBlob([''], {type: type}));\n    } else if (typeof body !== 'string') { // we have blob support\n      callback(body);\n    } else { // no blob support\n      callback(b64ToBluffer(body, type));\n    }\n  } else { // as base64 string\n    if (!body) {\n      callback('');\n    } else if (typeof body !== 'string') { // we have blob support\n      readAsBinaryString(body, function (binary) {\n        callback(thisBtoa(binary));\n      });\n    } else { // no blob support\n      callback(body);\n    }\n  }\n}\n\nfunction fetchAttachmentsIfNecessary(doc, opts, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var digest = attObj.digest;\n    var req = txn.objectStore(ATTACH_STORE).get(digest);\n    req.onsuccess = function (e) {\n      attObj.body = e.target.result.body;\n      checkDone();\n    };\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\n// IDB-specific postprocessing necessary because\n// we don't know whether we stored a true Blob or\n// a base64-encoded string, and if it's a Blob it\n// needs to be read outside of the transaction context\nfunction postProcessAttachments(results, asBlob) {\n  return PouchPromise$1.all(results.map(function (row) {\n    if (row.doc && row.doc._attachments) {\n      var attNames = Object.keys(row.doc._attachments);\n      return PouchPromise$1.all(attNames.map(function (att) {\n        var attObj = row.doc._attachments[att];\n        if (!('body' in attObj)) { // already processed\n          return;\n        }\n        var body = attObj.body;\n        var type = attObj.content_type;\n        return new PouchPromise$1(function (resolve) {\n          readBlobData(body, type, asBlob, function (data) {\n            row.doc._attachments[att] = assign$1(\n              pick(attObj, ['digest', 'content_type']),\n              {data: data}\n            );\n            resolve();\n          });\n        });\n      }));\n    }\n  }));\n}\n\nfunction compactRevs(revs, docId, txn) {\n\n  var possiblyOrphanedDigests = [];\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var attStore = txn.objectStore(ATTACH_STORE);\n  var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n  var count = revs.length;\n\n  function checkDone() {\n    count--;\n    if (!count) { // done processing all revs\n      deleteOrphanedAttachments();\n    }\n  }\n\n  function deleteOrphanedAttachments() {\n    if (!possiblyOrphanedDigests.length) {\n      return;\n    }\n    possiblyOrphanedDigests.forEach(function (digest) {\n      var countReq = attAndSeqStore.index('digestSeq').count(\n        IDBKeyRange.bound(\n          digest + '::', digest + '::\\uffff', false, false));\n      countReq.onsuccess = function (e) {\n        var count = e.target.result;\n        if (!count) {\n          // orphaned\n          attStore.delete(digest);\n        }\n      };\n    });\n  }\n\n  revs.forEach(function (rev) {\n    var index = seqStore.index('_doc_id_rev');\n    var key = docId + \"::\" + rev;\n    index.getKey(key).onsuccess = function (e) {\n      var seq = e.target.result;\n      if (typeof seq !== 'number') {\n        return checkDone();\n      }\n      seqStore.delete(seq);\n\n      var cursor = attAndSeqStore.index('seq')\n        .openCursor(IDBKeyRange.only(seq));\n\n      cursor.onsuccess = function (event) {\n        var cursor = event.target.result;\n        if (cursor) {\n          var digest = cursor.value.digestSeq.split('::')[0];\n          possiblyOrphanedDigests.push(digest);\n          attAndSeqStore.delete(cursor.primaryKey);\n          cursor.continue();\n        } else { // done\n          checkDone();\n        }\n      };\n    };\n  });\n}\n\nfunction openTransactionSafely(idb, stores, mode) {\n  try {\n    return {\n      txn: idb.transaction(stores, mode)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nvar changesHandler$$1 = new Changes();\n\nfunction idbBulkDocs(dbOpts, req, opts, api, idb, callback) {\n  var docInfos = req.docs;\n  var txn;\n  var docStore;\n  var bySeqStore;\n  var attachStore;\n  var attachAndSeqStore;\n  var metaStore;\n  var docInfoError;\n  var metaDoc;\n\n  for (var i = 0, len = docInfos.length; i < len; i++) {\n    var doc = docInfos[i];\n    if (doc._id && isLocalId(doc._id)) {\n      continue;\n    }\n    doc = docInfos[i] = parseDoc(doc, opts.new_edits);\n    if (doc.error && !docInfoError) {\n      docInfoError = doc;\n    }\n  }\n\n  if (docInfoError) {\n    return callback(docInfoError);\n  }\n\n  var allDocsProcessed = false;\n  var docCountDelta = 0;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n  var preconditionErrored = false;\n  var blobType = api._meta.blobSupport ? 'blob' : 'base64';\n\n  preprocessAttachments(docInfos, blobType, function (err) {\n    if (err) {\n      return callback(err);\n    }\n    startTransaction();\n  });\n\n  function startTransaction() {\n\n    var stores = [\n      DOC_STORE, BY_SEQ_STORE,\n      ATTACH_STORE,\n      LOCAL_STORE, ATTACH_AND_SEQ_STORE,\n      META_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    txn = txnResult.txn;\n    txn.onabort = idbError(callback);\n    txn.ontimeout = idbError(callback);\n    txn.oncomplete = complete;\n    docStore = txn.objectStore(DOC_STORE);\n    bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    attachStore = txn.objectStore(ATTACH_STORE);\n    attachAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n    metaStore = txn.objectStore(META_STORE);\n\n    metaStore.get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result;\n      updateDocCountIfReady();\n    };\n\n    verifyAttachments(function (err) {\n      if (err) {\n        preconditionErrored = true;\n        return callback(err);\n      }\n      fetchExistingDocs();\n    });\n  }\n\n  function onAllDocsProcessed() {\n    allDocsProcessed = true;\n    updateDocCountIfReady();\n  }\n\n  function idbProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs,\n                txn, results, writeDoc, opts, onAllDocsProcessed);\n  }\n\n  function updateDocCountIfReady() {\n    if (!metaDoc || !allDocsProcessed) {\n      return;\n    }\n    // caching the docCount saves a lot of time in allDocs() and\n    // info(), which is why we go to all the trouble of doing this\n    metaDoc.docCount += docCountDelta;\n    metaStore.put(metaDoc);\n  }\n\n  function fetchExistingDocs() {\n\n    if (!docInfos.length) {\n      return;\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        idbProcessDocs();\n      }\n    }\n\n    function readMetadata(event) {\n      var metadata = decodeMetadata(event.target.result);\n\n      if (metadata) {\n        fetchedDocs.set(metadata.id, metadata);\n      }\n      checkDone();\n    }\n\n    for (var i = 0, len = docInfos.length; i < len; i++) {\n      var docInfo = docInfos[i];\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        checkDone(); // skip local docs\n        continue;\n      }\n      var req = docStore.get(docInfo.metadata.id);\n      req.onsuccess = readMetadata;\n    }\n  }\n\n  function complete() {\n    if (preconditionErrored) {\n      return;\n    }\n\n    changesHandler$$1.notify(api._meta.name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n\n    var req = attachStore.get(digest);\n    req.onsuccess = function (e) {\n      if (!e.target.result) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        err.status = 412;\n        callback(err);\n      } else {\n        callback();\n      }\n    };\n  }\n\n  function verifyAttachments(finish) {\n\n\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    docInfo.metadata.winningRev = winningRev$$1;\n    docInfo.metadata.deleted = winningRevIsDeleted;\n\n    var doc = docInfo.data;\n    doc._id = docInfo.metadata.id;\n    doc._rev = docInfo.metadata.rev;\n\n    if (newRevIsDeleted) {\n      doc._deleted = true;\n    }\n\n    var hasAttachments = doc._attachments &&\n      Object.keys(doc._attachments).length;\n    if (hasAttachments) {\n      return writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n        isUpdate, resultsIdx, callback);\n    }\n\n    docCountDelta += delta;\n    updateDocCountIfReady();\n\n    finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n      isUpdate, resultsIdx, callback);\n  }\n\n  function finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n                     isUpdate, resultsIdx, callback) {\n\n    var doc = docInfo.data;\n    var metadata = docInfo.metadata;\n\n    doc._doc_id_rev = metadata.id + '::' + metadata.rev;\n    delete doc._id;\n    delete doc._rev;\n\n    function afterPutDoc(e) {\n      var revsToDelete = docInfo.stemmedRevs || [];\n\n      if (isUpdate && api.auto_compaction) {\n        revsToDelete = revsToDelete.concat(compactTree(docInfo.metadata));\n      }\n\n      if (revsToDelete && revsToDelete.length) {\n        compactRevs(revsToDelete, docInfo.metadata.id, txn);\n      }\n\n      metadata.seq = e.target.result;\n      // Current _rev is calculated from _rev_tree on read\n      // delete metadata.rev;\n      var metadataToStore = encodeMetadata(metadata, winningRev$$1,\n        winningRevIsDeleted);\n      var metaDataReq = docStore.put(metadataToStore);\n      metaDataReq.onsuccess = afterPutMetadata;\n    }\n\n    function afterPutDocError(e) {\n      // ConstraintError, need to update, not put (see #1638 for details)\n      e.preventDefault(); // avoid transaction abort\n      e.stopPropagation(); // avoid transaction onerror\n      var index = bySeqStore.index('_doc_id_rev');\n      var getKeyReq = index.getKey(doc._doc_id_rev);\n      getKeyReq.onsuccess = function (e) {\n        var putReq = bySeqStore.put(doc, e.target.result);\n        putReq.onsuccess = afterPutDoc;\n      };\n    }\n\n    function afterPutMetadata() {\n      results[resultsIdx] = {\n        ok: true,\n        id: metadata.id,\n        rev: metadata.rev\n      };\n      fetchedDocs.set(docInfo.metadata.id, docInfo.metadata);\n      insertAttachmentMappings(docInfo, metadata.seq, callback);\n    }\n\n    var putReq = bySeqStore.put(doc);\n\n    putReq.onsuccess = afterPutDoc;\n    putReq.onerror = afterPutDocError;\n  }\n\n  function writeAttachments(docInfo, winningRev$$1, winningRevIsDeleted,\n                            isUpdate, resultsIdx, callback) {\n\n\n    var doc = docInfo.data;\n\n    var numDone = 0;\n    var attachments = Object.keys(doc._attachments);\n\n    function collectResults() {\n      if (numDone === attachments.length) {\n        finishDoc(docInfo, winningRev$$1, winningRevIsDeleted,\n          isUpdate, resultsIdx, callback);\n      }\n    }\n\n    function attachmentSaved() {\n      numDone++;\n      collectResults();\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        numDone++;\n        collectResults();\n      }\n    });\n  }\n\n  // map seqs to attachment digests, which\n  // we will need later during compaction\n  function insertAttachmentMappings(docInfo, seq, callback) {\n\n    var attsAdded = 0;\n    var attsToAdd = Object.keys(docInfo.data._attachments || {});\n\n    if (!attsToAdd.length) {\n      return callback();\n    }\n\n    function checkDone() {\n      if (++attsAdded === attsToAdd.length) {\n        callback();\n      }\n    }\n\n    function add(att) {\n      var digest = docInfo.data._attachments[att].digest;\n      var req = attachAndSeqStore.put({\n        seq: seq,\n        digestSeq: digest + '::' + seq\n      });\n\n      req.onsuccess = checkDone;\n      req.onerror = function (e) {\n        // this callback is for a constaint error, which we ignore\n        // because this docid/rev has already been associated with\n        // the digest (e.g. when new_edits == false)\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n        checkDone();\n      };\n    }\n    for (var i = 0; i < attsToAdd.length; i++) {\n      add(attsToAdd[i]); // do in parallel\n    }\n  }\n\n  function saveAttachment(digest, data, callback) {\n\n\n    var getKeyReq = attachStore.count(digest);\n    getKeyReq.onsuccess = function (e) {\n      var count = e.target.result;\n      if (count) {\n        return callback(); // already exists\n      }\n      var newAtt = {\n        digest: digest,\n        body: data\n      };\n      var putReq = attachStore.put(newAtt);\n      putReq.onsuccess = callback;\n    };\n  }\n}\n\n// Abstraction over IDBCursor and getAll()/getAllKeys() that allows us to batch our operations\n// while falling back to a normal IDBCursor operation on browsers that don't support getAll() or\n// getAllKeys(). This allows for a much faster implementation than just straight-up cursors, because\n// we're not processing each document one-at-a-time.\nfunction runBatchedCursor(objectStore, keyRange, descending, batchSize, onBatch) {\n\n  // Bail out of getAll()/getAllKeys() in the following cases:\n  // 1) either method is unsupported - we need both\n  // 2) batchSize is 1 (might as well use IDBCursor), or batchSize is -1 (i.e. batchSize unlimited,\n  //    not really clear the user wants a batched approach where the entire DB is read into memory,\n  //    perhaps they are filtering on a per-doc basis)\n  // 3) descending â no real way to do this via getAll()/getAllKeys()\n\n  var useGetAll = typeof objectStore.getAll === 'function' &&\n    typeof objectStore.getAllKeys === 'function' &&\n    batchSize > 1 && !descending;\n\n  var keysBatch;\n  var valuesBatch;\n  var pseudoCursor;\n\n  function onGetAll(e) {\n    valuesBatch = e.target.result;\n    if (keysBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function onGetAllKeys(e) {\n    keysBatch = e.target.result;\n    if (valuesBatch) {\n      onBatch(keysBatch, valuesBatch, pseudoCursor);\n    }\n  }\n\n  function continuePseudoCursor() {\n    if (!keysBatch.length) { // no more results\n      return onBatch();\n    }\n    // fetch next batch, exclusive start\n    var lastKey = keysBatch[keysBatch.length - 1];\n    var newKeyRange;\n    if (keyRange && keyRange.upper) {\n      try {\n        newKeyRange = IDBKeyRange.bound(lastKey, keyRange.upper,\n          true, keyRange.upperOpen);\n      } catch (e) {\n        if (e.name === \"DataError\" && e.code === 0) {\n          return onBatch(); // we're done, startkey and endkey are equal\n        }\n      }\n    } else {\n      newKeyRange = IDBKeyRange.lowerBound(lastKey, true);\n    }\n    keyRange = newKeyRange;\n    keysBatch = null;\n    valuesBatch = null;\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  }\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (!cursor) { // done\n      return onBatch();\n    }\n    // regular IDBCursor acts like a batch where batch size is always 1\n    onBatch([cursor.key], [cursor.value], cursor);\n  }\n\n  if (useGetAll) {\n    pseudoCursor = {\"continue\": continuePseudoCursor};\n    objectStore.getAll(keyRange, batchSize).onsuccess = onGetAll;\n    objectStore.getAllKeys(keyRange, batchSize).onsuccess = onGetAllKeys;\n  } else if (descending) {\n    objectStore.openCursor(keyRange, 'prev').onsuccess = onCursor;\n  } else {\n    objectStore.openCursor(keyRange).onsuccess = onCursor;\n  }\n}\n\n// simple shim for objectStore.getAll(), falling back to IDBCursor\nfunction getAll(objectStore, keyRange, onSuccess) {\n  if (typeof objectStore.getAll === 'function') {\n    // use native getAll\n    objectStore.getAll(keyRange).onsuccess = onSuccess;\n    return;\n  }\n  // fall back to cursors\n  var values = [];\n\n  function onCursor(e) {\n    var cursor = e.target.result;\n    if (cursor) {\n      values.push(cursor.value);\n      cursor.continue();\n    } else {\n      onSuccess({\n        target: {\n          result: values\n        }\n      });\n    }\n  }\n\n  objectStore.openCursor(keyRange).onsuccess = onCursor;\n}\n\nfunction createKeyRange(start, end, inclusiveEnd, key, descending) {\n  try {\n    if (start && end) {\n      if (descending) {\n        return IDBKeyRange.bound(end, start, !inclusiveEnd, false);\n      } else {\n        return IDBKeyRange.bound(start, end, false, !inclusiveEnd);\n      }\n    } else if (start) {\n      if (descending) {\n        return IDBKeyRange.upperBound(start);\n      } else {\n        return IDBKeyRange.lowerBound(start);\n      }\n    } else if (end) {\n      if (descending) {\n        return IDBKeyRange.lowerBound(end, !inclusiveEnd);\n      } else {\n        return IDBKeyRange.upperBound(end, !inclusiveEnd);\n      }\n    } else if (key) {\n      return IDBKeyRange.only(key);\n    }\n  } catch (e) {\n    return {error: e};\n  }\n  return null;\n}\n\nfunction idbAllDocs(opts, idb, callback) {\n  var start = 'startkey' in opts ? opts.startkey : false;\n  var end = 'endkey' in opts ? opts.endkey : false;\n  var key = 'key' in opts ? opts.key : false;\n  var skip = opts.skip || 0;\n  var limit = typeof opts.limit === 'number' ? opts.limit : -1;\n  var inclusiveEnd = opts.inclusive_end !== false;\n\n  var keyRange = createKeyRange(start, end, inclusiveEnd, key, opts.descending);\n  var keyRangeError = keyRange && keyRange.error;\n  if (keyRangeError && !(keyRangeError.name === \"DataError\" &&\n      keyRangeError.code === 0)) {\n    // DataError with error code 0 indicates start is less than end, so\n    // can just do an empty query. Else need to throw\n    return callback(createError(IDB_ERROR,\n      keyRangeError.name, keyRangeError.message));\n  }\n\n  var stores = [DOC_STORE, BY_SEQ_STORE, META_STORE];\n\n  if (opts.attachments) {\n    stores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, stores, 'readonly');\n  if (txnResult.error) {\n    return callback(txnResult.error);\n  }\n  var txn = txnResult.txn;\n  txn.oncomplete = onTxnComplete;\n  txn.onabort = idbError(callback);\n  var docStore = txn.objectStore(DOC_STORE);\n  var seqStore = txn.objectStore(BY_SEQ_STORE);\n  var metaStore = txn.objectStore(META_STORE);\n  var docIdRevIndex = seqStore.index('_doc_id_rev');\n  var results = [];\n  var docCount;\n\n  metaStore.get(META_STORE).onsuccess = function (e) {\n    docCount = e.target.result.docCount;\n  };\n\n  // if the user specifies include_docs=true, then we don't\n  // want to block the main cursor while we're fetching the doc\n  function fetchDocAsynchronously(metadata, row, winningRev$$1) {\n    var key = metadata.id + \"::\" + winningRev$$1;\n    docIdRevIndex.get(key).onsuccess =  function onGetDoc(e) {\n      row.doc = decodeDoc(e.target.result);\n      if (opts.conflicts) {\n        var conflicts = collectConflicts(metadata);\n        if (conflicts.length) {\n          row.doc._conflicts = conflicts;\n        }\n      }\n      fetchAttachmentsIfNecessary(row.doc, opts, txn);\n    };\n  }\n\n  function allDocsInner(winningRev$$1, metadata) {\n    var row = {\n      id: metadata.id,\n      key: metadata.id,\n      value: {\n        rev: winningRev$$1\n      }\n    };\n    var deleted = metadata.deleted;\n    if (opts.deleted === 'ok') {\n      results.push(row);\n      // deleted docs are okay with \"keys\" requests\n      if (deleted) {\n        row.value.deleted = true;\n        row.doc = null;\n      } else if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    } else if (!deleted && skip-- <= 0) {\n      results.push(row);\n      if (opts.include_docs) {\n        fetchDocAsynchronously(metadata, row, winningRev$$1);\n      }\n    }\n  }\n\n  function processBatch(batchValues) {\n    for (var i = 0, len = batchValues.length; i < len; i++) {\n      if (results.length === limit) {\n        break;\n      }\n      var batchValue = batchValues[i];\n      var metadata = decodeMetadata(batchValue);\n      var winningRev$$1 = metadata.winningRev;\n      allDocsInner(winningRev$$1, metadata);\n    }\n  }\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor) {\n      return;\n    }\n    processBatch(batchValues);\n    if (results.length < limit) {\n      cursor.continue();\n    }\n  }\n\n  function onGetAll(e) {\n    var values = e.target.result;\n    if (opts.descending) {\n      values = values.reverse();\n    }\n    processBatch(values);\n  }\n\n  function onResultsReady() {\n    callback(null, {\n      total_rows: docCount,\n      offset: opts.skip,\n      rows: results\n    });\n  }\n\n  function onTxnComplete() {\n    if (opts.attachments) {\n      postProcessAttachments(results, opts.binary).then(onResultsReady);\n    } else {\n      onResultsReady();\n    }\n  }\n\n  // don't bother doing any requests if start > end or limit === 0\n  if (keyRangeError || limit === 0) {\n    return;\n  }\n  if (limit === -1) { // just fetch everything\n    return getAll(docStore, keyRange, onGetAll);\n  }\n  // else do a cursor\n  // choose a batch size based on the skip, since we'll need to skip that many\n  runBatchedCursor(docStore, keyRange, opts.descending, limit + skip, onBatch);\n}\n\n//\n// Blobs are not supported in all versions of IndexedDB, notably\n// Chrome <37 and Android <5. In those versions, storing a blob will throw.\n//\n// Various other blob bugs exist in Chrome v37-42 (inclusive).\n// Detecting them is expensive and confusing to users, and Chrome 37-42\n// is at very low usage worldwide, so we do a hacky userAgent check instead.\n//\n// content-type bug: https://code.google.com/p/chromium/issues/detail?id=408120\n// 404 bug: https://code.google.com/p/chromium/issues/detail?id=447916\n// FileReader bug: https://code.google.com/p/chromium/issues/detail?id=447836\n//\nfunction checkBlobSupport(txn) {\n  return new PouchPromise$1(function (resolve) {\n    var blob$$1 = createBlob(['']);\n    var req = txn.objectStore(DETECT_BLOB_SUPPORT_STORE).put(blob$$1, 'key');\n\n    req.onsuccess = function () {\n      var matchedChrome = navigator.userAgent.match(/Chrome\\/(\\d+)/);\n      var matchedEdge = navigator.userAgent.match(/Edge\\//);\n      // MS Edge pretends to be Chrome 42:\n      // https://msdn.microsoft.com/en-us/library/hh869301%28v=vs.85%29.aspx\n      resolve(matchedEdge || !matchedChrome ||\n        parseInt(matchedChrome[1], 10) >= 43);\n    };\n\n    txn.onabort = function (e) {\n      // If the transaction aborts now its due to not being able to\n      // write to the database, likely due to the disk being full\n      e.preventDefault();\n      e.stopPropagation();\n      resolve(false);\n    };\n  }).catch(function () {\n    return false; // error, so assume unsupported\n  });\n}\n\nfunction countDocs(txn, cb) {\n  var index = txn.objectStore(DOC_STORE).index('deletedOrLocal');\n  index.count(IDBKeyRange.only('0')).onsuccess = function (e) {\n    cb(e.target.result);\n  };\n}\n\n// This task queue ensures that IDB open calls are done in their own tick\n// and sequentially - i.e. we wait for the async IDB open to *fully* complete\n// before calling the next one. This works around IE/Edge race conditions in IDB.\n\nvar running = false;\nvar queue = [];\n\nfunction tryCode(fun, err, res, PouchDB) {\n  try {\n    fun(err, res);\n  } catch (err) {\n    // Shouldn't happen, but in some odd cases\n    // IndexedDB implementations might throw a sync\n    // error, in which case this will at least log it.\n    PouchDB.emit('error', err);\n  }\n}\n\nfunction applyNext() {\n  if (running || !queue.length) {\n    return;\n  }\n  running = true;\n  queue.shift()();\n}\n\nfunction enqueueTask(action, callback, PouchDB) {\n  queue.push(function runAction() {\n    action(function runCallback(err, res) {\n      tryCode(callback, err, res, PouchDB);\n      running = false;\n      nextTick(function runNext() {\n        applyNext(PouchDB);\n      });\n    });\n  });\n  applyNext();\n}\n\nfunction changes(opts, api, dbName, idb) {\n  opts = clone(opts);\n\n  if (opts.continuous) {\n    var id = dbName + ':' + uuid();\n    changesHandler$$1.addListener(dbName, id, api, opts);\n    changesHandler$$1.notify(dbName);\n    return {\n      cancel: function () {\n        changesHandler$$1.removeListener(dbName, id);\n      }\n    };\n  }\n\n  var docIds = opts.doc_ids && new ExportedSet(opts.doc_ids);\n\n  opts.since = opts.since || 0;\n  var lastSeq = opts.since;\n\n  var limit = 'limit' in opts ? opts.limit : -1;\n  if (limit === 0) {\n    limit = 1; // per CouchDB _changes spec\n  }\n  var returnDocs;\n  if ('return_docs' in opts) {\n    returnDocs = opts.return_docs;\n  } else if ('returnDocs' in opts) {\n    // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n    returnDocs = opts.returnDocs;\n  } else {\n    returnDocs = true;\n  }\n\n  var results = [];\n  var numResults = 0;\n  var filter = filterChange(opts);\n  var docIdsToMetadata = new ExportedMap();\n\n  var txn;\n  var bySeqStore;\n  var docStore;\n  var docIdRevIndex;\n\n  function onBatch(batchKeys, batchValues, cursor) {\n    if (!cursor || !batchKeys.length) { // done\n      return;\n    }\n\n    var winningDocs = new Array(batchKeys.length);\n    var metadatas = new Array(batchKeys.length);\n\n    function processMetadataAndWinningDoc(metadata, winningDoc) {\n      var change = opts.processChange(winningDoc, metadata, opts);\n      lastSeq = change.seq = metadata.seq;\n\n      var filtered = filter(change);\n      if (typeof filtered === 'object') { // anything but true/false indicates error\n        return opts.complete(filtered);\n      }\n\n      if (filtered) {\n        numResults++;\n        if (returnDocs) {\n          results.push(change);\n        }\n        // process the attachment immediately\n        // for the benefit of live listeners\n        if (opts.attachments && opts.include_docs) {\n          fetchAttachmentsIfNecessary(winningDoc, opts, txn, function () {\n            postProcessAttachments([change], opts.binary).then(function () {\n              opts.onChange(change);\n            });\n          });\n        } else {\n          opts.onChange(change);\n        }\n      }\n    }\n\n    function onBatchDone() {\n      for (var i = 0, len = winningDocs.length; i < len; i++) {\n        if (numResults === limit) {\n          break;\n        }\n        var winningDoc = winningDocs[i];\n        if (!winningDoc) {\n          continue;\n        }\n        var metadata = metadatas[i];\n        processMetadataAndWinningDoc(metadata, winningDoc);\n      }\n\n      if (numResults !== limit) {\n        cursor.continue();\n      }\n    }\n\n    // Fetch all metadatas/winningdocs from this batch in parallel, then process\n    // them all only once all data has been collected. This is done in parallel\n    // because it's faster than doing it one-at-a-time.\n    var numDone = 0;\n    batchValues.forEach(function (value, i) {\n      var doc = decodeDoc(value);\n      var seq = batchKeys[i];\n      fetchWinningDocAndMetadata(doc, seq, function (metadata, winningDoc) {\n        metadatas[i] = metadata;\n        winningDocs[i] = winningDoc;\n        if (++numDone === batchKeys.length) {\n          onBatchDone();\n        }\n      });\n    });\n  }\n\n  function onGetMetadata(doc, seq, metadata, cb) {\n    if (metadata.seq !== seq) {\n      // some other seq is later\n      return cb();\n    }\n\n    if (metadata.winningRev === doc._rev) {\n      // this is the winning doc\n      return cb(metadata, doc);\n    }\n\n    // fetch winning doc in separate request\n    var docIdRev = doc._id + '::' + metadata.winningRev;\n    var req = docIdRevIndex.get(docIdRev);\n    req.onsuccess = function (e) {\n      cb(metadata, decodeDoc(e.target.result));\n    };\n  }\n\n  function fetchWinningDocAndMetadata(doc, seq, cb) {\n    if (docIds && !docIds.has(doc._id)) {\n      return cb();\n    }\n\n    var metadata = docIdsToMetadata.get(doc._id);\n    if (metadata) { // cached\n      return onGetMetadata(doc, seq, metadata, cb);\n    }\n    // metadata not cached, have to go fetch it\n    docStore.get(doc._id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      docIdsToMetadata.set(doc._id, metadata);\n      onGetMetadata(doc, seq, metadata, cb);\n    };\n  }\n\n  function finish() {\n    opts.complete(null, {\n      results: results,\n      last_seq: lastSeq\n    });\n  }\n\n  function onTxnComplete() {\n    if (!opts.continuous && opts.attachments) {\n      // cannot guarantee that postProcessing was already done,\n      // so do it again\n      postProcessAttachments(results).then(finish);\n    } else {\n      finish();\n    }\n  }\n\n  var objectStores = [DOC_STORE, BY_SEQ_STORE];\n  if (opts.attachments) {\n    objectStores.push(ATTACH_STORE);\n  }\n  var txnResult = openTransactionSafely(idb, objectStores, 'readonly');\n  if (txnResult.error) {\n    return opts.complete(txnResult.error);\n  }\n  txn = txnResult.txn;\n  txn.onabort = idbError(opts.complete);\n  txn.oncomplete = onTxnComplete;\n\n  bySeqStore = txn.objectStore(BY_SEQ_STORE);\n  docStore = txn.objectStore(DOC_STORE);\n  docIdRevIndex = bySeqStore.index('_doc_id_rev');\n\n  var keyRange = (opts.since && !opts.descending) ?\n    IDBKeyRange.lowerBound(opts.since, true) : null;\n\n  runBatchedCursor(bySeqStore, keyRange, opts.descending, limit, onBatch);\n}\n\nvar cachedDBs = new ExportedMap();\nvar blobSupportPromise;\nvar openReqList = new ExportedMap();\n\nfunction IdbPouch(opts, callback) {\n  var api = this;\n\n  enqueueTask(function (thisCallback) {\n    init(api, opts, thisCallback);\n  }, callback, api.constructor);\n}\n\nfunction init(api, opts, callback) {\n\n  var dbName = opts.name;\n\n  var idb = null;\n  api._meta = null;\n\n  // called when creating a fresh new database\n  function createSchema(db) {\n    var docStore = db.createObjectStore(DOC_STORE, {keyPath : 'id'});\n    db.createObjectStore(BY_SEQ_STORE, {autoIncrement: true})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n    db.createObjectStore(ATTACH_STORE, {keyPath: 'digest'});\n    db.createObjectStore(META_STORE, {keyPath: 'id', autoIncrement: false});\n    db.createObjectStore(DETECT_BLOB_SUPPORT_STORE);\n\n    // added in v2\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    // added in v3\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'});\n\n    // added in v4\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 2\n  // unfortunately \"deletedOrLocal\" is a misnomer now that we no longer\n  // store local docs in the main doc-store, but whaddyagonnado\n  function addDeletedOrLocalIndex(txn, callback) {\n    var docStore = txn.objectStore(DOC_STORE);\n    docStore.createIndex('deletedOrLocal', 'deletedOrLocal', {unique : false});\n\n    docStore.openCursor().onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var deleted = isDeleted(metadata);\n        metadata.deletedOrLocal = deleted ? \"1\" : \"0\";\n        docStore.put(metadata);\n        cursor.continue();\n      } else {\n        callback();\n      }\n    };\n  }\n\n  // migration to version 3 (part 1)\n  function createLocalStoreSchema(db) {\n    db.createObjectStore(LOCAL_STORE, {keyPath: '_id'})\n      .createIndex('_doc_id_rev', '_doc_id_rev', {unique: true});\n  }\n\n  // migration to version 3 (part 2)\n  function migrateLocalStore(txn, cb) {\n    var localStore = txn.objectStore(LOCAL_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (event) {\n      var cursor = event.target.result;\n      if (cursor) {\n        var metadata = cursor.value;\n        var docId = metadata.id;\n        var local = isLocalId(docId);\n        var rev = winningRev(metadata);\n        if (local) {\n          var docIdRev = docId + \"::\" + rev;\n          // remove all seq entries\n          // associated with this docId\n          var start = docId + \"::\";\n          var end = docId + \"::~\";\n          var index = seqStore.index('_doc_id_rev');\n          var range = IDBKeyRange.bound(start, end, false, false);\n          var seqCursor = index.openCursor(range);\n          seqCursor.onsuccess = function (e) {\n            seqCursor = e.target.result;\n            if (!seqCursor) {\n              // done\n              docStore.delete(cursor.primaryKey);\n              cursor.continue();\n            } else {\n              var data = seqCursor.value;\n              if (data._doc_id_rev === docIdRev) {\n                localStore.put(data);\n              }\n              seqStore.delete(seqCursor.primaryKey);\n              seqCursor.continue();\n            }\n          };\n        } else {\n          cursor.continue();\n        }\n      } else if (cb) {\n        cb();\n      }\n    };\n  }\n\n  // migration to version 4 (part 1)\n  function addAttachAndSeqStore(db) {\n    var attAndSeqStore = db.createObjectStore(ATTACH_AND_SEQ_STORE,\n      {autoIncrement: true});\n    attAndSeqStore.createIndex('seq', 'seq');\n    attAndSeqStore.createIndex('digestSeq', 'digestSeq', {unique: true});\n  }\n\n  // migration to version 4 (part 2)\n  function migrateAttsAndSeqs(txn, callback) {\n    var seqStore = txn.objectStore(BY_SEQ_STORE);\n    var attStore = txn.objectStore(ATTACH_STORE);\n    var attAndSeqStore = txn.objectStore(ATTACH_AND_SEQ_STORE);\n\n    // need to actually populate the table. this is the expensive part,\n    // so as an optimization, check first that this database even\n    // contains attachments\n    var req = attStore.count();\n    req.onsuccess = function (e) {\n      var count = e.target.result;\n      if (!count) {\n        return callback(); // done\n      }\n\n      seqStore.openCursor().onsuccess = function (e) {\n        var cursor = e.target.result;\n        if (!cursor) {\n          return callback(); // done\n        }\n        var doc = cursor.value;\n        var seq = cursor.primaryKey;\n        var atts = Object.keys(doc._attachments || {});\n        var digestMap = {};\n        for (var j = 0; j < atts.length; j++) {\n          var att = doc._attachments[atts[j]];\n          digestMap[att.digest] = true; // uniq digests, just in case\n        }\n        var digests = Object.keys(digestMap);\n        for (j = 0; j < digests.length; j++) {\n          var digest = digests[j];\n          attAndSeqStore.put({\n            seq: seq,\n            digestSeq: digest + '::' + seq\n          });\n        }\n        cursor.continue();\n      };\n    };\n  }\n\n  // migration to version 5\n  // Instead of relying on on-the-fly migration of metadata,\n  // this brings the doc-store to its modern form:\n  // - metadata.winningrev\n  // - metadata.seq\n  // - stringify the metadata when storing it\n  function migrateMetadata(txn) {\n\n    function decodeMetadataCompat(storedObject) {\n      if (!storedObject.data) {\n        // old format, when we didn't store it stringified\n        storedObject.deleted = storedObject.deletedOrLocal === '1';\n        return storedObject;\n      }\n      return decodeMetadata(storedObject);\n    }\n\n    // ensure that every metadata has a winningRev and seq,\n    // which was previously created on-the-fly but better to migrate\n    var bySeqStore = txn.objectStore(BY_SEQ_STORE);\n    var docStore = txn.objectStore(DOC_STORE);\n    var cursor = docStore.openCursor();\n    cursor.onsuccess = function (e) {\n      var cursor = e.target.result;\n      if (!cursor) {\n        return; // done\n      }\n      var metadata = decodeMetadataCompat(cursor.value);\n\n      metadata.winningRev = metadata.winningRev ||\n        winningRev(metadata);\n\n      function fetchMetadataSeq() {\n        // metadata.seq was added post-3.2.0, so if it's missing,\n        // we need to fetch it manually\n        var start = metadata.id + '::';\n        var end = metadata.id + '::\\uffff';\n        var req = bySeqStore.index('_doc_id_rev').openCursor(\n          IDBKeyRange.bound(start, end));\n\n        var metadataSeq = 0;\n        req.onsuccess = function (e) {\n          var cursor = e.target.result;\n          if (!cursor) {\n            metadata.seq = metadataSeq;\n            return onGetMetadataSeq();\n          }\n          var seq = cursor.primaryKey;\n          if (seq > metadataSeq) {\n            metadataSeq = seq;\n          }\n          cursor.continue();\n        };\n      }\n\n      function onGetMetadataSeq() {\n        var metadataToStore = encodeMetadata(metadata,\n          metadata.winningRev, metadata.deleted);\n\n        var req = docStore.put(metadataToStore);\n        req.onsuccess = function () {\n          cursor.continue();\n        };\n      }\n\n      if (metadata.seq) {\n        return onGetMetadataSeq();\n      }\n\n      fetchMetadataSeq();\n    };\n\n  }\n\n  api.type = function () {\n    return 'idb';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, api._meta.instanceId);\n  });\n\n  api._bulkDocs = function idb_bulkDocs(req, reqOpts, callback) {\n    idbBulkDocs(opts, req, reqOpts, api, idb, callback);\n  };\n\n  // First we look up the metadata in the ids database, then we fetch the\n  // current revision(s) from the by sequence store\n  api._get = function idb_get(id, opts, callback) {\n    var doc;\n    var metadata;\n    var err;\n    var txn = opts.ctx;\n    if (!txn) {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n\n    function finish() {\n      callback(err, {doc: doc, metadata: metadata, ctx: txn});\n    }\n\n    txn.objectStore(DOC_STORE).get(id).onsuccess = function (e) {\n      metadata = decodeMetadata(e.target.result);\n      // we can determine the result here if:\n      // 1. there is no such document\n      // 2. the document is deleted and we don't ask about specific rev\n      // When we ask with opts.rev we expect the answer to be either\n      // doc (possibly with _deleted=true) or missing error\n      if (!metadata) {\n        err = createError(MISSING_DOC, 'missing');\n        return finish();\n      }\n\n      var rev;\n      if(!opts.rev) {\n        rev = metadata.winningRev;\n        var deleted = isDeleted(metadata);\n        if (deleted) {\n          err = createError(MISSING_DOC, \"deleted\");\n          return finish();\n        }\n      } else {\n        rev = opts.latest ? latest(opts.rev, metadata) : opts.rev;\n      }\n\n      var objectStore = txn.objectStore(BY_SEQ_STORE);\n      var key = metadata.id + '::' + rev;\n\n      objectStore.index('_doc_id_rev').get(key).onsuccess = function (e) {\n        doc = e.target.result;\n        if (doc) {\n          doc = decodeDoc(doc);\n        }\n        if (!doc) {\n          err = createError(MISSING_DOC, 'missing');\n          return finish();\n        }\n        finish();\n      };\n    };\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var txn;\n    if (opts.ctx) {\n      txn = opts.ctx;\n    } else {\n      var txnResult = openTransactionSafely(idb,\n        [DOC_STORE, BY_SEQ_STORE, ATTACH_STORE], 'readonly');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      txn = txnResult.txn;\n    }\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n\n    txn.objectStore(ATTACH_STORE).get(digest).onsuccess = function (e) {\n      var body = e.target.result.body;\n      readBlobData(body, type, opts.binary, function (blobData) {\n        callback(null, blobData);\n      });\n    };\n  };\n\n  api._info = function idb_info(callback) {\n    var updateSeq;\n    var docCount;\n\n    var txnResult = openTransactionSafely(idb, [META_STORE, BY_SEQ_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      docCount = e.target.result.docCount;\n    };\n    txn.objectStore(BY_SEQ_STORE).openCursor(null, 'prev').onsuccess = function (e) {\n      var cursor = e.target.result;\n      updateSeq = cursor ? cursor.key : 0;\n    };\n\n    txn.oncomplete = function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: updateSeq,\n        // for debugging\n        idb_attachment_format: (api._meta.blobSupport ? 'binary' : 'base64')\n      });\n    };\n  };\n\n  api._allDocs = function idb_allDocs(opts, callback) {\n    idbAllDocs(opts, idb, callback);\n  };\n\n  api._changes = function idbChanges(opts) {\n    changes(opts, api, dbName, idb);\n  };\n\n  api._close = function (callback) {\n    // https://developer.mozilla.org/en-US/docs/IndexedDB/IDBDatabase#close\n    // \"Returns immediately and closes the connection in a separate thread...\"\n    idb.close();\n    cachedDBs.delete(dbName);\n    callback();\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    var txnResult = openTransactionSafely(idb, [DOC_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n    var req = txn.objectStore(DOC_STORE).get(docId);\n    req.onsuccess = function (event) {\n      var doc = decodeMetadata(event.target.result);\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        callback(null, doc.rev_tree);\n      }\n    };\n  };\n\n  // This function removes revisions of document docId\n  // which are listed in revs and sets this document\n  // revision to to rev_tree\n  api._doCompaction = function (docId, revs, callback) {\n    var stores = [\n      DOC_STORE,\n      BY_SEQ_STORE,\n      ATTACH_STORE,\n      ATTACH_AND_SEQ_STORE\n    ];\n    var txnResult = openTransactionSafely(idb, stores, 'readwrite');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var txn = txnResult.txn;\n\n    var docStore = txn.objectStore(DOC_STORE);\n\n    docStore.get(docId).onsuccess = function (event) {\n      var metadata = decodeMetadata(event.target.result);\n      traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                         revHash, ctx, opts) {\n        var rev = pos + '-' + revHash;\n        if (revs.indexOf(rev) !== -1) {\n          opts.status = 'missing';\n        }\n      });\n      compactRevs(revs, docId, txn);\n      var winningRev$$1 = metadata.winningRev;\n      var deleted = metadata.deleted;\n      txn.objectStore(DOC_STORE).put(\n        encodeMetadata(metadata, winningRev$$1, deleted));\n    };\n    txn.onabort = idbError(callback);\n    txn.oncomplete = function () {\n      callback();\n    };\n  };\n\n\n  api._getLocal = function (id, callback) {\n    var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readonly');\n    if (txnResult.error) {\n      return callback(txnResult.error);\n    }\n    var tx = txnResult.txn;\n    var req = tx.objectStore(LOCAL_STORE).get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var doc = e.target.result;\n      if (!doc) {\n        callback(createError(MISSING_DOC));\n      } else {\n        delete doc['_doc_id_rev']; // for backwards compat\n        callback(null, doc);\n      }\n    };\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    if (!oldRev) {\n      doc._rev = '0-1';\n    } else {\n      doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n\n    var tx = opts.ctx;\n    var ret;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.onerror = idbError(callback);\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req;\n    if (oldRev) {\n      req = oStore.get(id);\n      req.onsuccess = function (e) {\n        var oldDoc = e.target.result;\n        if (!oldDoc || oldDoc._rev !== oldRev) {\n          callback(createError(REV_CONFLICT));\n        } else { // update\n          var req = oStore.put(doc);\n          req.onsuccess = function () {\n            ret = {ok: true, id: doc._id, rev: doc._rev};\n            if (opts.ctx) { // return immediately\n              callback(null, ret);\n            }\n          };\n        }\n      };\n    } else { // new doc\n      req = oStore.add(doc);\n      req.onerror = function (e) {\n        // constraint error, already exists\n        callback(createError(REV_CONFLICT));\n        e.preventDefault(); // avoid transaction abort\n        e.stopPropagation(); // avoid transaction onerror\n      };\n      req.onsuccess = function () {\n        ret = {ok: true, id: doc._id, rev: doc._rev};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      };\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var tx = opts.ctx;\n    if (!tx) {\n      var txnResult = openTransactionSafely(idb, [LOCAL_STORE], 'readwrite');\n      if (txnResult.error) {\n        return callback(txnResult.error);\n      }\n      tx = txnResult.txn;\n      tx.oncomplete = function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      };\n    }\n    var ret;\n    var id = doc._id;\n    var oStore = tx.objectStore(LOCAL_STORE);\n    var req = oStore.get(id);\n\n    req.onerror = idbError(callback);\n    req.onsuccess = function (e) {\n      var oldDoc = e.target.result;\n      if (!oldDoc || oldDoc._rev !== doc._rev) {\n        callback(createError(MISSING_DOC));\n      } else {\n        oStore.delete(id);\n        ret = {ok: true, id: id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      }\n    };\n  };\n\n  api._destroy = function (opts, callback) {\n    changesHandler$$1.removeAllListeners(dbName);\n\n    //Close open request for \"dbName\" database to fix ie delay.\n    var openReq = openReqList.get(dbName);\n    if (openReq && openReq.result) {\n      openReq.result.close();\n      cachedDBs.delete(dbName);\n    }\n    var req = indexedDB.deleteDatabase(dbName);\n\n    req.onsuccess = function () {\n      //Remove open request from the list.\n      openReqList.delete(dbName);\n      if (hasLocalStorage() && (dbName in localStorage)) {\n        delete localStorage[dbName];\n      }\n      callback(null, { 'ok': true });\n    };\n\n    req.onerror = idbError(callback);\n  };\n\n  var cached = cachedDBs.get(dbName);\n\n  if (cached) {\n    idb = cached.idb;\n    api._meta = cached.global;\n    return nextTick(function () {\n      callback(null, api);\n    });\n  }\n\n  var req;\n  if (opts.storage) {\n    req = tryStorageOption(dbName, opts.storage);\n  } else {\n    req = indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n\n  openReqList.set(dbName, req);\n\n  req.onupgradeneeded = function (e) {\n    var db = e.target.result;\n    if (e.oldVersion < 1) {\n      return createSchema(db); // new db, initial schema\n    }\n    // do migrations\n\n    var txn = e.currentTarget.transaction;\n    // these migrations have to be done in this function, before\n    // control is returned to the event loop, because IndexedDB\n\n    if (e.oldVersion < 3) {\n      createLocalStoreSchema(db); // v2 -> v3\n    }\n    if (e.oldVersion < 4) {\n      addAttachAndSeqStore(db); // v3 -> v4\n    }\n\n    var migrations = [\n      addDeletedOrLocalIndex, // v1 -> v2\n      migrateLocalStore,      // v2 -> v3\n      migrateAttsAndSeqs,     // v3 -> v4\n      migrateMetadata         // v4 -> v5\n    ];\n\n    var i = e.oldVersion;\n\n    function next() {\n      var migration = migrations[i - 1];\n      i++;\n      if (migration) {\n        migration(txn, next);\n      }\n    }\n\n    next();\n  };\n\n  req.onsuccess = function (e) {\n\n    idb = e.target.result;\n\n    idb.onversionchange = function () {\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    idb.onabort = function (e) {\n      guardedConsole('error', 'Database has a global failure', e.target.error);\n      idb.close();\n      cachedDBs.delete(dbName);\n    };\n\n    // Do a few setup operations (in parallel as much as possible):\n    // 1. Fetch meta doc\n    // 2. Check blob support\n    // 3. Calculate docCount\n    // 4. Generate an instanceId if necessary\n    // 5. Store docCount and instanceId on meta doc\n\n    var txn = idb.transaction([\n      META_STORE,\n      DETECT_BLOB_SUPPORT_STORE,\n      DOC_STORE\n    ], 'readwrite');\n\n    var storedMetaDoc = false;\n    var metaDoc;\n    var docCount;\n    var blobSupport;\n    var instanceId;\n\n    function completeSetup() {\n      if (typeof blobSupport === 'undefined' || !storedMetaDoc) {\n        return;\n      }\n      api._meta = {\n        name: dbName,\n        instanceId: instanceId,\n        blobSupport: blobSupport\n      };\n\n      cachedDBs.set(dbName, {\n        idb: idb,\n        global: api._meta\n      });\n      callback(null, api);\n    }\n\n    function storeMetaDocIfReady() {\n      if (typeof docCount === 'undefined' || typeof metaDoc === 'undefined') {\n        return;\n      }\n      var instanceKey = dbName + '_id';\n      if (instanceKey in metaDoc) {\n        instanceId = metaDoc[instanceKey];\n      } else {\n        metaDoc[instanceKey] = instanceId = uuid();\n      }\n      metaDoc.docCount = docCount;\n      txn.objectStore(META_STORE).put(metaDoc);\n    }\n\n    //\n    // fetch or generate the instanceId\n    //\n    txn.objectStore(META_STORE).get(META_STORE).onsuccess = function (e) {\n      metaDoc = e.target.result || { id: META_STORE };\n      storeMetaDocIfReady();\n    };\n\n    //\n    // countDocs\n    //\n    countDocs(txn, function (count) {\n      docCount = count;\n      storeMetaDocIfReady();\n    });\n\n    //\n    // check blob support\n    //\n    if (!blobSupportPromise) {\n      // make sure blob support is only checked once\n      blobSupportPromise = checkBlobSupport(txn);\n    }\n\n    blobSupportPromise.then(function (val) {\n      blobSupport = val;\n      completeSetup();\n    });\n\n    // only when the metadata put transaction has completed,\n    // consider the setup done\n    txn.oncomplete = function () {\n      storedMetaDoc = true;\n      completeSetup();\n    };\n  };\n\n  req.onerror = function () {\n    var msg = 'Failed to open indexedDB, are you in private browsing mode?';\n    guardedConsole('error', msg);\n    callback(createError(IDB_ERROR, msg));\n  };\n}\n\nIdbPouch.valid = function () {\n  // Issue #2533, we finally gave up on doing bug\n  // detection instead of browser sniffing. Safari brought us\n  // to our knees.\n  var isSafari = typeof openDatabase !== 'undefined' &&\n    /(Safari|iPhone|iPad|iPod)/.test(navigator.userAgent) &&\n    !/Chrome/.test(navigator.userAgent) &&\n    !/BlackBerry/.test(navigator.platform);\n\n  // some outdated implementations of IDB that appear on Samsung\n  // and HTC Android devices <4.4 are missing IDBKeyRange\n  return !isSafari && typeof indexedDB !== 'undefined' &&\n    typeof IDBKeyRange !== 'undefined';\n};\n\nfunction tryStorageOption(dbName, storage) {\n  try { // option only available in Firefox 26+\n    return indexedDB.open(dbName, {\n      version: ADAPTER_VERSION,\n      storage: storage\n    });\n  } catch(err) {\n      return indexedDB.open(dbName, ADAPTER_VERSION);\n  }\n}\n\nvar IDBPouch = function (PouchDB) {\n  PouchDB.adapter('idb', IdbPouch, true);\n};\n\n//\n// Parsing hex strings. Yeah.\n//\n// So basically we need this because of a bug in WebSQL:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n//\n// UTF-8 and UTF-16 are provided as separate functions\n// for meager performance improvements\n//\n\nfunction decodeUtf8(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction hexToInt(charCode) {\n  // '0'-'9' is 48-57\n  // 'A'-'F' is 65-70\n  // SQLite will only give us uppercase hex\n  return charCode < 65 ? (charCode - 48) : (charCode - 55);\n}\n\n\n// Example:\n// pragma encoding=utf8;\n// select hex('A');\n// returns '41'\nfunction parseHexUtf8(str, start, end) {\n  var result = '';\n  while (start < end) {\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start++)) << 4) |\n        hexToInt(str.charCodeAt(start++)));\n  }\n  return result;\n}\n\n// Example:\n// pragma encoding=utf16;\n// select hex('A');\n// returns '4100'\n// notice that the 00 comes after the 41 (i.e. it's swizzled)\nfunction parseHexUtf16(str, start, end) {\n  var result = '';\n  while (start < end) {\n    // UTF-16, so swizzle the bytes\n    result += String.fromCharCode(\n      (hexToInt(str.charCodeAt(start + 2)) << 12) |\n        (hexToInt(str.charCodeAt(start + 3)) << 8) |\n        (hexToInt(str.charCodeAt(start)) << 4) |\n        hexToInt(str.charCodeAt(start + 1)));\n    start += 4;\n  }\n  return result;\n}\n\nfunction parseHexString(str, encoding) {\n  if (encoding === 'UTF-8') {\n    return decodeUtf8(parseHexUtf8(str, 0, str.length));\n  } else {\n    return parseHexUtf16(str, 0, str.length);\n  }\n}\n\nfunction quote(str) {\n  return \"'\" + str + \"'\";\n}\n\nvar ADAPTER_VERSION$1 = 7; // used to manage migrations\n\n// The object stores created for each database\n// DOC_STORE stores the document meta data, its revision history and state\nvar DOC_STORE$1 = quote('document-store');\n// BY_SEQ_STORE stores a particular version of a document, keyed by its\n// sequence id\nvar BY_SEQ_STORE$1 = quote('by-sequence');\n// Where we store attachments\nvar ATTACH_STORE$1 = quote('attach-store');\nvar LOCAL_STORE$1 = quote('local-store');\nvar META_STORE$1 = quote('metadata-store');\n// where we store many-to-many relations between attachment\n// digests and seqs\nvar ATTACH_AND_SEQ_STORE$1 = quote('attach-seq-store');\n\n// escapeBlob and unescapeBlob are workarounds for a websql bug:\n// https://code.google.com/p/chromium/issues/detail?id=422690\n// https://bugs.webkit.org/show_bug.cgi?id=137637\n// The goal is to never actually insert the \\u0000 character\n// in the database.\nfunction escapeBlob(str) {\n  return str\n    .replace(/\\u0002/g, '\\u0002\\u0002')\n    .replace(/\\u0001/g, '\\u0001\\u0002')\n    .replace(/\\u0000/g, '\\u0001\\u0001');\n}\n\nfunction unescapeBlob(str) {\n  return str\n    .replace(/\\u0001\\u0001/g, '\\u0000')\n    .replace(/\\u0001\\u0002/g, '\\u0001')\n    .replace(/\\u0002\\u0002/g, '\\u0002');\n}\n\nfunction stringifyDoc(doc) {\n  // don't bother storing the id/rev. it uses lots of space,\n  // in persistent map/reduce especially\n  delete doc._id;\n  delete doc._rev;\n  return JSON.stringify(doc);\n}\n\nfunction unstringifyDoc(doc, id, rev) {\n  doc = JSON.parse(doc);\n  doc._id = id;\n  doc._rev = rev;\n  return doc;\n}\n\n// question mark groups IN queries, e.g. 3 -> '(?,?,?)'\nfunction qMarks(num) {\n  var s = '(';\n  while (num--) {\n    s += '?';\n    if (num) {\n      s += ',';\n    }\n  }\n  return s + ')';\n}\n\nfunction select(selector, table, joiner, where, orderBy) {\n  return 'SELECT ' + selector + ' FROM ' +\n    (typeof table === 'string' ? table : table.join(' JOIN ')) +\n    (joiner ? (' ON ' + joiner) : '') +\n    (where ? (' WHERE ' +\n    (typeof where === 'string' ? where : where.join(' AND '))) : '') +\n    (orderBy ? (' ORDER BY ' + orderBy) : '');\n}\n\nfunction compactRevs$1(revs, docId, tx) {\n\n  if (!revs.length) {\n    return;\n  }\n\n  var numDone = 0;\n  var seqs = [];\n\n  function checkDone() {\n    if (++numDone === revs.length) { // done\n      deleteOrphans();\n    }\n  }\n\n  function deleteOrphans() {\n    // find orphaned attachment digests\n\n    if (!seqs.length) {\n      return;\n    }\n\n    var sql = 'SELECT DISTINCT digest AS digest FROM ' +\n      ATTACH_AND_SEQ_STORE$1 + ' WHERE seq IN ' + qMarks(seqs.length);\n\n    tx.executeSql(sql, seqs, function (tx, res) {\n\n      var digestsToCheck = [];\n      for (var i = 0; i < res.rows.length; i++) {\n        digestsToCheck.push(res.rows.item(i).digest);\n      }\n      if (!digestsToCheck.length) {\n        return;\n      }\n\n      var sql = 'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 +\n        ' WHERE seq IN (' +\n        seqs.map(function () { return '?'; }).join(',') +\n        ')';\n      tx.executeSql(sql, seqs, function (tx) {\n\n        var sql = 'SELECT digest FROM ' + ATTACH_AND_SEQ_STORE$1 +\n          ' WHERE digest IN (' +\n          digestsToCheck.map(function () { return '?'; }).join(',') +\n          ')';\n        tx.executeSql(sql, digestsToCheck, function (tx, res) {\n          var nonOrphanedDigests = new ExportedSet();\n          for (var i = 0; i < res.rows.length; i++) {\n            nonOrphanedDigests.add(res.rows.item(i).digest);\n          }\n          digestsToCheck.forEach(function (digest) {\n            if (nonOrphanedDigests.has(digest)) {\n              return;\n            }\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_AND_SEQ_STORE$1 + ' WHERE digest=?',\n              [digest]);\n            tx.executeSql(\n              'DELETE FROM ' + ATTACH_STORE$1 + ' WHERE digest=?', [digest]);\n          });\n        });\n      });\n    });\n  }\n\n  // update by-seq and attach stores in parallel\n  revs.forEach(function (rev) {\n    var sql = 'SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=? AND rev=?';\n\n    tx.executeSql(sql, [docId, rev], function (tx, res) {\n      if (!res.rows.length) { // already deleted\n        return checkDone();\n      }\n      var seq = res.rows.item(0).seq;\n      seqs.push(seq);\n\n      tx.executeSql(\n        'DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?', [seq], checkDone);\n    });\n  });\n}\n\nfunction websqlError(callback) {\n  return function (event) {\n    guardedConsole('error', 'WebSQL threw an error', event);\n    // event may actually be a SQLError object, so report is as such\n    var errorNameMatch = event && event.constructor.toString()\n        .match(/function ([^\\(]+)/);\n    var errorName = (errorNameMatch && errorNameMatch[1]) || event.type;\n    var errorReason = event.target || event.message;\n    callback(createError(WSQ_ERROR, errorReason, errorName));\n  };\n}\n\nfunction getSize(opts) {\n  if ('size' in opts) {\n    // triggers immediate popup in iOS, fixes #2347\n    // e.g. 5000001 asks for 5 MB, 10000001 asks for 10 MB,\n    return opts.size * 1000000;\n  }\n  // In iOS, doesn't matter as long as it's <= 5000000.\n  // Except that if you request too much, our tests fail\n  // because of the native \"do you accept?\" popup.\n  // In Android <=4.3, this value is actually used as an\n  // honest-to-god ceiling for data, so we need to\n  // set it to a decently high number.\n  var isAndroid = typeof navigator !== 'undefined' &&\n    /Android/.test(navigator.userAgent);\n  return isAndroid ? 5000000 : 1; // in PhantomJS, if you use 0 it will crash\n}\n\nfunction websqlBulkDocs(dbOpts, req, opts, api, db, websqlChanges, callback) {\n  var newEdits = opts.new_edits;\n  var userDocs = req.docs;\n\n  // Parse the docs, give them a sequence number for the result\n  var docInfos = userDocs.map(function (doc) {\n    if (doc._id && isLocalId(doc._id)) {\n      return doc;\n    }\n    var newDoc = parseDoc(doc, newEdits);\n    return newDoc;\n  });\n\n  var docInfoErrors = docInfos.filter(function (docInfo) {\n    return docInfo.error;\n  });\n  if (docInfoErrors.length) {\n    return callback(docInfoErrors[0]);\n  }\n\n  var tx;\n  var results = new Array(docInfos.length);\n  var fetchedDocs = new ExportedMap();\n\n  var preconditionErrored;\n  function complete() {\n    if (preconditionErrored) {\n      return callback(preconditionErrored);\n    }\n    websqlChanges.notify(api._name);\n    callback(null, results);\n  }\n\n  function verifyAttachment(digest, callback) {\n    var sql = 'SELECT count(*) as cnt FROM ' + ATTACH_STORE$1 +\n      ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.item(0).cnt === 0) {\n        var err = createError(MISSING_STUB,\n          'unknown stub attachment with digest ' +\n          digest);\n        callback(err);\n      } else {\n        callback();\n      }\n    });\n  }\n\n  function verifyAttachments(finish) {\n    var digests = [];\n    docInfos.forEach(function (docInfo) {\n      if (docInfo.data && docInfo.data._attachments) {\n        Object.keys(docInfo.data._attachments).forEach(function (filename) {\n          var att = docInfo.data._attachments[filename];\n          if (att.stub) {\n            digests.push(att.digest);\n          }\n        });\n      }\n    });\n    if (!digests.length) {\n      return finish();\n    }\n    var numDone = 0;\n    var err;\n\n    function checkDone() {\n      if (++numDone === digests.length) {\n        finish(err);\n      }\n    }\n    digests.forEach(function (digest) {\n      verifyAttachment(digest, function (attErr) {\n        if (attErr && !err) {\n          err = attErr;\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function writeDoc(docInfo, winningRev$$1, winningRevIsDeleted, newRevIsDeleted,\n                    isUpdate, delta, resultsIdx, callback) {\n\n    function finish() {\n      var data = docInfo.data;\n      var deletedInt = newRevIsDeleted ? 1 : 0;\n\n      var id = data._id;\n      var rev = data._rev;\n      var json = stringifyDoc(data);\n      var sql = 'INSERT INTO ' + BY_SEQ_STORE$1 +\n        ' (doc_id, rev, json, deleted) VALUES (?, ?, ?, ?);';\n      var sqlArgs = [id, rev, json, deletedInt];\n\n      // map seqs to attachment digests, which\n      // we will need later during compaction\n      function insertAttachmentMappings(seq, callback) {\n        var attsAdded = 0;\n        var attsToAdd = Object.keys(data._attachments || {});\n\n        if (!attsToAdd.length) {\n          return callback();\n        }\n        function checkDone() {\n          if (++attsAdded === attsToAdd.length) {\n            callback();\n          }\n          return false; // ack handling a constraint error\n        }\n        function add(att) {\n          var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n            ' (digest, seq) VALUES (?,?)';\n          var sqlArgs = [data._attachments[att].digest, seq];\n          tx.executeSql(sql, sqlArgs, checkDone, checkDone);\n          // second callback is for a constaint error, which we ignore\n          // because this docid/rev has already been associated with\n          // the digest (e.g. when new_edits == false)\n        }\n        for (var i = 0; i < attsToAdd.length; i++) {\n          add(attsToAdd[i]); // do in parallel\n        }\n      }\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        var seq = result.insertId;\n        insertAttachmentMappings(seq, function () {\n          dataWritten(tx, seq);\n        });\n      }, function () {\n        // constraint error, recover by updating instead (see #1638)\n        var fetchSql = select('seq', BY_SEQ_STORE$1, null,\n          'doc_id=? AND rev=?');\n        tx.executeSql(fetchSql, [id, rev], function (tx, res) {\n          var seq = res.rows.item(0).seq;\n          var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n            ' SET json=?, deleted=? WHERE doc_id=? AND rev=?;';\n          var sqlArgs = [json, deletedInt, id, rev];\n          tx.executeSql(sql, sqlArgs, function (tx) {\n            insertAttachmentMappings(seq, function () {\n              dataWritten(tx, seq);\n            });\n          });\n        });\n        return false; // ack that we've handled the error\n      });\n    }\n\n    function collectResults(attachmentErr) {\n      if (!err) {\n        if (attachmentErr) {\n          err = attachmentErr;\n          callback(err);\n        } else if (recv === attachments.length) {\n          finish();\n        }\n      }\n    }\n\n    var err = null;\n    var recv = 0;\n\n    docInfo.data._id = docInfo.metadata.id;\n    docInfo.data._rev = docInfo.metadata.rev;\n    var attachments = Object.keys(docInfo.data._attachments || {});\n\n\n    if (newRevIsDeleted) {\n      docInfo.data._deleted = true;\n    }\n\n    function attachmentSaved(err) {\n      recv++;\n      collectResults(err);\n    }\n\n    attachments.forEach(function (key) {\n      var att = docInfo.data._attachments[key];\n      if (!att.stub) {\n        var data = att.data;\n        delete att.data;\n        att.revpos = parseInt(winningRev$$1, 10);\n        var digest = att.digest;\n        saveAttachment(digest, data, attachmentSaved);\n      } else {\n        recv++;\n        collectResults();\n      }\n    });\n\n    if (!attachments.length) {\n      finish();\n    }\n\n    function dataWritten(tx, seq) {\n      var id = docInfo.metadata.id;\n\n      var revsToCompact = docInfo.stemmedRevs || [];\n      if (isUpdate && api.auto_compaction) {\n        revsToCompact = compactTree(docInfo.metadata).concat(revsToCompact);\n      }\n      if (revsToCompact.length) {\n        compactRevs$1(revsToCompact, id, tx);\n      }\n\n      docInfo.metadata.seq = seq;\n      var rev = docInfo.metadata.rev;\n      delete docInfo.metadata.rev;\n\n      var sql = isUpdate ?\n      'UPDATE ' + DOC_STORE$1 +\n      ' SET json=?, max_seq=?, winningseq=' +\n      '(SELECT seq FROM ' + BY_SEQ_STORE$1 +\n      ' WHERE doc_id=' + DOC_STORE$1 + '.id AND rev=?) WHERE id=?'\n        : 'INSERT INTO ' + DOC_STORE$1 +\n      ' (id, winningseq, max_seq, json) VALUES (?,?,?,?);';\n      var metadataStr = safeJsonStringify(docInfo.metadata);\n      var params = isUpdate ?\n        [metadataStr, seq, winningRev$$1, id] :\n        [id, seq, seq, metadataStr];\n      tx.executeSql(sql, params, function () {\n        results[resultsIdx] = {\n          ok: true,\n          id: docInfo.metadata.id,\n          rev: rev\n        };\n        fetchedDocs.set(id, docInfo.metadata);\n        callback();\n      });\n    }\n  }\n\n  function websqlProcessDocs() {\n    processDocs(dbOpts.revs_limit, docInfos, api, fetchedDocs, tx,\n                results, writeDoc, opts);\n  }\n\n  function fetchExistingDocs(callback) {\n    if (!docInfos.length) {\n      return callback();\n    }\n\n    var numFetched = 0;\n\n    function checkDone() {\n      if (++numFetched === docInfos.length) {\n        callback();\n      }\n    }\n\n    docInfos.forEach(function (docInfo) {\n      if (docInfo._id && isLocalId(docInfo._id)) {\n        return checkDone(); // skip local docs\n      }\n      var id = docInfo.metadata.id;\n      tx.executeSql('SELECT json FROM ' + DOC_STORE$1 +\n      ' WHERE id = ?', [id], function (tx, result) {\n        if (result.rows.length) {\n          var metadata = safeJsonParse(result.rows.item(0).json);\n          fetchedDocs.set(id, metadata);\n        }\n        checkDone();\n      });\n    });\n  }\n\n  function saveAttachment(digest, data, callback) {\n    var sql = 'SELECT digest FROM ' + ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      if (result.rows.length) { // attachment already exists\n        return callback();\n      }\n      // we could just insert before selecting and catch the error,\n      // but my hunch is that it's cheaper not to serialize the blob\n      // from JS to C if we don't have to (TODO: confirm this)\n      sql = 'INSERT INTO ' + ATTACH_STORE$1 +\n      ' (digest, body, escaped) VALUES (?,?,1)';\n      tx.executeSql(sql, [digest, escapeBlob(data)], function () {\n        callback();\n      }, function () {\n        // ignore constaint errors, means it already exists\n        callback();\n        return false; // ack we handled the error\n      });\n    });\n  }\n\n  preprocessAttachments(docInfos, 'binary', function (err) {\n    if (err) {\n      return callback(err);\n    }\n    db.transaction(function (txn) {\n      tx = txn;\n      verifyAttachments(function (err) {\n        if (err) {\n          preconditionErrored = err;\n        } else {\n          fetchExistingDocs(websqlProcessDocs);\n        }\n      });\n    }, websqlError(callback), complete);\n  });\n}\n\nvar cachedDatabases = new ExportedMap();\n\n// openDatabase passed in through opts (e.g. for node-websql)\nfunction openDatabaseWithOpts(opts) {\n  return opts.websql(opts.name, opts.version, opts.description, opts.size);\n}\n\nfunction openDBSafely(opts) {\n  try {\n    return {\n      db: openDatabaseWithOpts(opts)\n    };\n  } catch (err) {\n    return {\n      error: err\n    };\n  }\n}\n\nfunction openDB$1(opts) {\n  var cachedResult = cachedDatabases.get(opts.name);\n  if (!cachedResult) {\n    cachedResult = openDBSafely(opts);\n    cachedDatabases.set(opts.name, cachedResult);\n  }\n  return cachedResult;\n}\n\nvar websqlChanges = new Changes();\n\nfunction fetchAttachmentsIfNecessary$1(doc, opts, api, txn, cb) {\n  var attachments = Object.keys(doc._attachments || {});\n  if (!attachments.length) {\n    return cb && cb();\n  }\n  var numDone = 0;\n\n  function checkDone() {\n    if (++numDone === attachments.length && cb) {\n      cb();\n    }\n  }\n\n  function fetchAttachment(doc, att) {\n    var attObj = doc._attachments[att];\n    var attOpts = {binary: opts.binary, ctx: txn};\n    api._getAttachment(doc._id, att, attObj, attOpts, function (_, data) {\n      doc._attachments[att] = assign$1(\n        pick(attObj, ['digest', 'content_type']),\n        { data: data }\n      );\n      checkDone();\n    });\n  }\n\n  attachments.forEach(function (att) {\n    if (opts.attachments && opts.include_docs) {\n      fetchAttachment(doc, att);\n    } else {\n      doc._attachments[att].stub = true;\n      checkDone();\n    }\n  });\n}\n\nvar POUCH_VERSION = 1;\n\n// these indexes cover the ground for most allDocs queries\nvar BY_SEQ_STORE_DELETED_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'by-seq-deleted-idx\\' ON ' +\n  BY_SEQ_STORE$1 + ' (seq, deleted)';\nvar BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'by-seq-doc-id-rev\\' ON ' +\n    BY_SEQ_STORE$1 + ' (doc_id, rev)';\nvar DOC_STORE_WINNINGSEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'doc-winningseq-idx\\' ON ' +\n  DOC_STORE$1 + ' (winningseq)';\nvar ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL =\n  'CREATE INDEX IF NOT EXISTS \\'attach-seq-seq-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (seq)';\nvar ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL =\n  'CREATE UNIQUE INDEX IF NOT EXISTS \\'attach-seq-digest-idx\\' ON ' +\n    ATTACH_AND_SEQ_STORE$1 + ' (digest, seq)';\n\nvar DOC_STORE_AND_BY_SEQ_JOINER = BY_SEQ_STORE$1 +\n  '.seq = ' + DOC_STORE$1 + '.winningseq';\n\nvar SELECT_DOCS = BY_SEQ_STORE$1 + '.seq AS seq, ' +\n  BY_SEQ_STORE$1 + '.deleted AS deleted, ' +\n  BY_SEQ_STORE$1 + '.json AS data, ' +\n  BY_SEQ_STORE$1 + '.rev AS rev, ' +\n  DOC_STORE$1 + '.json AS metadata';\n\nfunction WebSqlPouch$1(opts, callback) {\n  var api = this;\n  var instanceId = null;\n  var size = getSize(opts);\n  var idRequests = [];\n  var encoding;\n\n  api._name = opts.name;\n\n  // extend the options here, because sqlite plugin has a ton of options\n  // and they are constantly changing, so it's more prudent to allow anything\n  var websqlOpts = assign$1({}, opts, {\n    version: POUCH_VERSION,\n    description: opts.name,\n    size: size\n  });\n  var openDBResult = openDB$1(websqlOpts);\n  if (openDBResult.error) {\n    return websqlError(callback)(openDBResult.error);\n  }\n  var db = openDBResult.db;\n  if (typeof db.readTransaction !== 'function') {\n    // doesn't exist in sqlite plugin\n    db.readTransaction = db.transaction;\n  }\n\n  function dbCreated() {\n    // note the db name in case the browser upgrades to idb\n    if (hasLocalStorage()) {\n      window.localStorage['_pouch__websqldb_' + api._name] = true;\n    }\n    callback(null, api);\n  }\n\n  // In this migration, we added the 'deleted' and 'local' columns to the\n  // by-seq and doc store tables.\n  // To preserve existing user data, we re-process all the existing JSON\n  // and add these values.\n  // Called migration2 because it corresponds to adapter version (db_version) #2\n  function runMigration2(tx, callback) {\n    // index used for the join in the allDocs query\n    tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n\n    tx.executeSql('ALTER TABLE ' + BY_SEQ_STORE$1 +\n      ' ADD COLUMN deleted TINYINT(1) DEFAULT 0', [], function () {\n      tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n      tx.executeSql('ALTER TABLE ' + DOC_STORE$1 +\n        ' ADD COLUMN local TINYINT(1) DEFAULT 0', [], function () {\n        tx.executeSql('CREATE INDEX IF NOT EXISTS \\'doc-store-local-idx\\' ON ' +\n          DOC_STORE$1 + ' (local, id)');\n\n        var sql = 'SELECT ' + DOC_STORE$1 + '.winningseq AS seq, ' + DOC_STORE$1 +\n          '.json AS metadata FROM ' + BY_SEQ_STORE$1 + ' JOIN ' + DOC_STORE$1 +\n          ' ON ' + BY_SEQ_STORE$1 + '.seq = ' + DOC_STORE$1 + '.winningseq';\n\n        tx.executeSql(sql, [], function (tx, result) {\n\n          var deleted = [];\n          var local = [];\n\n          for (var i = 0; i < result.rows.length; i++) {\n            var item = result.rows.item(i);\n            var seq = item.seq;\n            var metadata = JSON.parse(item.metadata);\n            if (isDeleted(metadata)) {\n              deleted.push(seq);\n            }\n            if (isLocalId(metadata.id)) {\n              local.push(metadata.id);\n            }\n          }\n          tx.executeSql('UPDATE ' + DOC_STORE$1 + 'SET local = 1 WHERE id IN ' +\n            qMarks(local.length), local, function () {\n            tx.executeSql('UPDATE ' + BY_SEQ_STORE$1 +\n              ' SET deleted = 1 WHERE seq IN ' +\n              qMarks(deleted.length), deleted, callback);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we make all the local docs unversioned\n  function runMigration3(tx, callback) {\n    var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n      ' (id UNIQUE, rev, json)';\n    tx.executeSql(local, [], function () {\n      var sql = 'SELECT ' + DOC_STORE$1 + '.id AS id, ' +\n        BY_SEQ_STORE$1 + '.json AS data ' +\n        'FROM ' + BY_SEQ_STORE$1 + ' JOIN ' +\n        DOC_STORE$1 + ' ON ' + BY_SEQ_STORE$1 + '.seq = ' +\n        DOC_STORE$1 + '.winningseq WHERE local = 1';\n      tx.executeSql(sql, [], function (tx, res) {\n        var rows = [];\n        for (var i = 0; i < res.rows.length; i++) {\n          rows.push(res.rows.item(i));\n        }\n        function doNext() {\n          if (!rows.length) {\n            return callback(tx);\n          }\n          var row = rows.shift();\n          var rev = JSON.parse(row.data)._rev;\n          tx.executeSql('INSERT INTO ' + LOCAL_STORE$1 +\n              ' (id, rev, json) VALUES (?,?,?)',\n              [row.id, rev, row.data], function (tx) {\n            tx.executeSql('DELETE FROM ' + DOC_STORE$1 + ' WHERE id=?',\n                [row.id], function (tx) {\n              tx.executeSql('DELETE FROM ' + BY_SEQ_STORE$1 + ' WHERE seq=?',\n                  [row.seq], function () {\n                doNext();\n              });\n            });\n          });\n        }\n        doNext();\n      });\n    });\n  }\n\n  // in this migration, we remove doc_id_rev and just use rev\n  function runMigration4(tx, callback) {\n\n    function updateRows(rows) {\n      function doNext() {\n        if (!rows.length) {\n          return callback(tx);\n        }\n        var row = rows.shift();\n        var doc_id_rev = parseHexString(row.hex, encoding);\n        var idx = doc_id_rev.lastIndexOf('::');\n        var doc_id = doc_id_rev.substring(0, idx);\n        var rev = doc_id_rev.substring(idx + 2);\n        var sql = 'UPDATE ' + BY_SEQ_STORE$1 +\n          ' SET doc_id=?, rev=? WHERE doc_id_rev=?';\n        tx.executeSql(sql, [doc_id, rev, doc_id_rev], function () {\n          doNext();\n        });\n      }\n      doNext();\n    }\n\n    var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN doc_id';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'ALTER TABLE ' + BY_SEQ_STORE$1 + ' ADD COLUMN rev';\n      tx.executeSql(sql, [], function (tx) {\n        tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL, [], function (tx) {\n          var sql = 'SELECT hex(doc_id_rev) as hex FROM ' + BY_SEQ_STORE$1;\n          tx.executeSql(sql, [], function (tx, res) {\n            var rows = [];\n            for (var i = 0; i < res.rows.length; i++) {\n              rows.push(res.rows.item(i));\n            }\n            updateRows(rows);\n          });\n        });\n      });\n    });\n  }\n\n  // in this migration, we add the attach_and_seq table\n  // for issue #2818\n  function runMigration5(tx, callback) {\n\n    function migrateAttsAndSeqs(tx) {\n      // need to actually populate the table. this is the expensive part,\n      // so as an optimization, check first that this database even\n      // contains attachments\n      var sql = 'SELECT COUNT(*) AS cnt FROM ' + ATTACH_STORE$1;\n      tx.executeSql(sql, [], function (tx, res) {\n        var count = res.rows.item(0).cnt;\n        if (!count) {\n          return callback(tx);\n        }\n\n        var offset = 0;\n        var pageSize = 10;\n        function nextPage() {\n          var sql = select(\n            SELECT_DOCS + ', ' + DOC_STORE$1 + '.id AS id',\n            [DOC_STORE$1, BY_SEQ_STORE$1],\n            DOC_STORE_AND_BY_SEQ_JOINER,\n            null,\n            DOC_STORE$1 + '.id '\n          );\n          sql += ' LIMIT ' + pageSize + ' OFFSET ' + offset;\n          offset += pageSize;\n          tx.executeSql(sql, [], function (tx, res) {\n            if (!res.rows.length) {\n              return callback(tx);\n            }\n            var digestSeqs = {};\n            function addDigestSeq(digest, seq) {\n              // uniq digest/seq pairs, just in case there are dups\n              var seqs = digestSeqs[digest] = (digestSeqs[digest] || []);\n              if (seqs.indexOf(seq) === -1) {\n                seqs.push(seq);\n              }\n            }\n            for (var i = 0; i < res.rows.length; i++) {\n              var row = res.rows.item(i);\n              var doc = unstringifyDoc(row.data, row.id, row.rev);\n              var atts = Object.keys(doc._attachments || {});\n              for (var j = 0; j < atts.length; j++) {\n                var att = doc._attachments[atts[j]];\n                addDigestSeq(att.digest, row.seq);\n              }\n            }\n            var digestSeqPairs = [];\n            Object.keys(digestSeqs).forEach(function (digest) {\n              var seqs = digestSeqs[digest];\n              seqs.forEach(function (seq) {\n                digestSeqPairs.push([digest, seq]);\n              });\n            });\n            if (!digestSeqPairs.length) {\n              return nextPage();\n            }\n            var numDone = 0;\n            digestSeqPairs.forEach(function (pair) {\n              var sql = 'INSERT INTO ' + ATTACH_AND_SEQ_STORE$1 +\n                ' (digest, seq) VALUES (?,?)';\n              tx.executeSql(sql, pair, function () {\n                if (++numDone === digestSeqPairs.length) {\n                  nextPage();\n                }\n              });\n            });\n          });\n        }\n        nextPage();\n      });\n    }\n\n    var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n      ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n    tx.executeSql(attachAndRev, [], function (tx) {\n      tx.executeSql(\n        ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL, [], function (tx) {\n          tx.executeSql(\n            ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL, [],\n            migrateAttsAndSeqs);\n        });\n    });\n  }\n\n  // in this migration, we use escapeBlob() and unescapeBlob()\n  // instead of reading out the binary as HEX, which is slow\n  function runMigration6(tx, callback) {\n    var sql = 'ALTER TABLE ' + ATTACH_STORE$1 +\n      ' ADD COLUMN escaped TINYINT(1) DEFAULT 0';\n    tx.executeSql(sql, [], callback);\n  }\n\n  // issue #3136, in this migration we need a \"latest seq\" as well\n  // as the \"winning seq\" in the doc store\n  function runMigration7(tx, callback) {\n    var sql = 'ALTER TABLE ' + DOC_STORE$1 +\n      ' ADD COLUMN max_seq INTEGER';\n    tx.executeSql(sql, [], function (tx) {\n      var sql = 'UPDATE ' + DOC_STORE$1 + ' SET max_seq=(SELECT MAX(seq) FROM ' +\n        BY_SEQ_STORE$1 + ' WHERE doc_id=id)';\n      tx.executeSql(sql, [], function (tx) {\n        // add unique index after filling, else we'll get a constraint\n        // error when we do the ALTER TABLE\n        var sql =\n          'CREATE UNIQUE INDEX IF NOT EXISTS \\'doc-max-seq-idx\\' ON ' +\n          DOC_STORE$1 + ' (max_seq)';\n        tx.executeSql(sql, [], callback);\n      });\n    });\n  }\n\n  function checkEncoding(tx, cb) {\n    // UTF-8 on chrome/android, UTF-16 on safari < 7.1\n    tx.executeSql('SELECT HEX(\"a\") AS hex', [], function (tx, res) {\n        var hex = res.rows.item(0).hex;\n        encoding = hex.length === 2 ? 'UTF-8' : 'UTF-16';\n        cb();\n      }\n    );\n  }\n\n  function onGetInstanceId() {\n    while (idRequests.length > 0) {\n      var idCallback = idRequests.pop();\n      idCallback(null, instanceId);\n    }\n  }\n\n  function onGetVersion(tx, dbVersion) {\n    if (dbVersion === 0) {\n      // initial schema\n\n      var meta = 'CREATE TABLE IF NOT EXISTS ' + META_STORE$1 +\n        ' (dbid, db_version INTEGER)';\n      var attach = 'CREATE TABLE IF NOT EXISTS ' + ATTACH_STORE$1 +\n        ' (digest UNIQUE, escaped TINYINT(1), body BLOB)';\n      var attachAndRev = 'CREATE TABLE IF NOT EXISTS ' +\n        ATTACH_AND_SEQ_STORE$1 + ' (digest, seq INTEGER)';\n      // TODO: migrate winningseq to INTEGER\n      var doc = 'CREATE TABLE IF NOT EXISTS ' + DOC_STORE$1 +\n        ' (id unique, json, winningseq, max_seq INTEGER UNIQUE)';\n      var seq = 'CREATE TABLE IF NOT EXISTS ' + BY_SEQ_STORE$1 +\n        ' (seq INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, ' +\n        'json, deleted TINYINT(1), doc_id, rev)';\n      var local = 'CREATE TABLE IF NOT EXISTS ' + LOCAL_STORE$1 +\n        ' (id UNIQUE, rev, json)';\n\n      // creates\n      tx.executeSql(attach);\n      tx.executeSql(local);\n      tx.executeSql(attachAndRev, [], function () {\n        tx.executeSql(ATTACH_AND_SEQ_STORE_SEQ_INDEX_SQL);\n        tx.executeSql(ATTACH_AND_SEQ_STORE_ATTACH_INDEX_SQL);\n      });\n      tx.executeSql(doc, [], function () {\n        tx.executeSql(DOC_STORE_WINNINGSEQ_INDEX_SQL);\n        tx.executeSql(seq, [], function () {\n          tx.executeSql(BY_SEQ_STORE_DELETED_INDEX_SQL);\n          tx.executeSql(BY_SEQ_STORE_DOC_ID_REV_INDEX_SQL);\n          tx.executeSql(meta, [], function () {\n            // mark the db version, and new dbid\n            var initSeq = 'INSERT INTO ' + META_STORE$1 +\n              ' (db_version, dbid) VALUES (?,?)';\n            instanceId = uuid();\n            var initSeqArgs = [ADAPTER_VERSION$1, instanceId];\n            tx.executeSql(initSeq, initSeqArgs, function () {\n              onGetInstanceId();\n            });\n          });\n        });\n      });\n    } else { // version > 0\n\n      var setupDone = function () {\n        var migrated = dbVersion < ADAPTER_VERSION$1;\n        if (migrated) {\n          // update the db version within this transaction\n          tx.executeSql('UPDATE ' + META_STORE$1 + ' SET db_version = ' +\n            ADAPTER_VERSION$1);\n        }\n        // notify db.id() callers\n        var sql = 'SELECT dbid FROM ' + META_STORE$1;\n        tx.executeSql(sql, [], function (tx, result) {\n          instanceId = result.rows.item(0).dbid;\n          onGetInstanceId();\n        });\n      };\n\n      // would love to use promises here, but then websql\n      // ends the transaction early\n      var tasks = [\n        runMigration2,\n        runMigration3,\n        runMigration4,\n        runMigration5,\n        runMigration6,\n        runMigration7,\n        setupDone\n      ];\n\n      // run each migration sequentially\n      var i = dbVersion;\n      var nextMigration = function (tx) {\n        tasks[i - 1](tx, nextMigration);\n        i++;\n      };\n      nextMigration(tx);\n    }\n  }\n\n  function setup() {\n    db.transaction(function (tx) {\n      // first check the encoding\n      checkEncoding(tx, function () {\n        // then get the version\n        fetchVersion(tx);\n      });\n    }, websqlError(callback), dbCreated);\n  }\n\n  function fetchVersion(tx) {\n    var sql = 'SELECT sql FROM sqlite_master WHERE tbl_name = ' + META_STORE$1;\n    tx.executeSql(sql, [], function (tx, result) {\n      if (!result.rows.length) {\n        // database hasn't even been created yet (version 0)\n        onGetVersion(tx, 0);\n      } else if (!/db_version/.test(result.rows.item(0).sql)) {\n        // table was created, but without the new db_version column,\n        // so add it.\n        tx.executeSql('ALTER TABLE ' + META_STORE$1 +\n          ' ADD COLUMN db_version INTEGER', [], function () {\n          // before version 2, this column didn't even exist\n          onGetVersion(tx, 1);\n        });\n      } else { // column exists, we can safely get it\n        tx.executeSql('SELECT db_version FROM ' + META_STORE$1,\n          [], function (tx, result) {\n          var dbVersion = result.rows.item(0).db_version;\n          onGetVersion(tx, dbVersion);\n        });\n      }\n    });\n  }\n\n  setup();\n\n  function getMaxSeq(tx, callback) {\n    var sql = 'SELECT MAX(seq) AS seq FROM ' + BY_SEQ_STORE$1;\n    tx.executeSql(sql, [], function (tx, res) {\n      var updateSeq = res.rows.item(0).seq || 0;\n      callback(updateSeq);\n    });\n  }\n\n  function countDocs(tx, callback) {\n    // count the total rows\n    var sql = select(\n      'COUNT(' + DOC_STORE$1 + '.id) AS \\'num\\'',\n      [DOC_STORE$1, BY_SEQ_STORE$1],\n      DOC_STORE_AND_BY_SEQ_JOINER,\n      BY_SEQ_STORE$1 + '.deleted=0');\n\n    tx.executeSql(sql, [], function (tx, result) {\n      callback(result.rows.item(0).num);\n    });\n  }\n\n  api.type = function () {\n    return 'websql';\n  };\n\n  api._id = toPromise(function (callback) {\n    callback(null, instanceId);\n  });\n\n  api._info = function (callback) {\n    var seq;\n    var docCount;\n    db.readTransaction(function (tx) {\n      getMaxSeq(tx, function (theSeq) {\n        seq = theSeq;\n      });\n      countDocs(tx, function (theDocCount) {\n        docCount = theDocCount;\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        doc_count: docCount,\n        update_seq: seq,\n        websql_encoding: encoding\n      });\n    });\n  };\n\n  api._bulkDocs = function (req, reqOpts, callback) {\n    websqlBulkDocs(opts, req, reqOpts, api, db, websqlChanges, callback);\n  };\n\n  function latest$$1(tx, id, rev, callback, finish) {\n    var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n    var sqlArgs = [id];\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var err = createError(MISSING_DOC, 'missing');\n        return finish(err);\n      }\n      var item = results.rows.item(0);\n      var metadata = safeJsonParse(item.metadata);\n      callback(latest(rev, metadata));\n    });\n  }\n\n  api._get = function (id, opts, callback) {\n    var doc;\n    var metadata;\n    var tx = opts.ctx;\n    if (!tx) {\n      return db.readTransaction(function (txn) {\n        api._get(id, assign$1({ctx: txn}, opts), callback);\n      });\n    }\n\n    function finish(err) {\n      callback(err, {doc: doc, metadata: metadata, ctx: tx});\n    }\n\n    var sql;\n    var sqlArgs;\n\n    if(!opts.rev) {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        DOC_STORE$1 + '.id=?');\n      sqlArgs = [id];\n    } else if (opts.latest) {\n      latest$$1(tx, id, opts.rev, function (latestRev) {\n        opts.latest = false;\n        opts.rev = latestRev;\n        api._get(id, opts, callback);\n      }, finish);\n      return;\n    } else {\n      sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id',\n        [BY_SEQ_STORE$1 + '.doc_id=?', BY_SEQ_STORE$1 + '.rev=?']);\n      sqlArgs = [id, opts.rev];\n    }\n\n    tx.executeSql(sql, sqlArgs, function (a, results) {\n      if (!results.rows.length) {\n        var missingErr = createError(MISSING_DOC, 'missing');\n        return finish(missingErr);\n      }\n      var item = results.rows.item(0);\n      metadata = safeJsonParse(item.metadata);\n      if (item.deleted && !opts.rev) {\n        var deletedErr = createError(MISSING_DOC, 'deleted');\n        return finish(deletedErr);\n      }\n      doc = unstringifyDoc(item.data, metadata.id, item.rev);\n      finish();\n    });\n  };\n\n  api._allDocs = function (opts, callback) {\n    var results = [];\n    var totalRows;\n\n    var start = 'startkey' in opts ? opts.startkey : false;\n    var end = 'endkey' in opts ? opts.endkey : false;\n    var key = 'key' in opts ? opts.key : false;\n    var descending = 'descending' in opts ? opts.descending : false;\n    var limit = 'limit' in opts ? opts.limit : -1;\n    var offset = 'skip' in opts ? opts.skip : 0;\n    var inclusiveEnd = opts.inclusive_end !== false;\n\n    var sqlArgs = [];\n    var criteria = [];\n\n    if (key !== false) {\n      criteria.push(DOC_STORE$1 + '.id = ?');\n      sqlArgs.push(key);\n    } else if (start !== false || end !== false) {\n      if (start !== false) {\n        criteria.push(DOC_STORE$1 + '.id ' + (descending ? '<=' : '>=') + ' ?');\n        sqlArgs.push(start);\n      }\n      if (end !== false) {\n        var comparator = descending ? '>' : '<';\n        if (inclusiveEnd) {\n          comparator += '=';\n        }\n        criteria.push(DOC_STORE$1 + '.id ' + comparator + ' ?');\n        sqlArgs.push(end);\n      }\n      if (key !== false) {\n        criteria.push(DOC_STORE$1 + '.id = ?');\n        sqlArgs.push(key);\n      }\n    }\n\n    if (opts.deleted !== 'ok') {\n      // report deleted if keys are specified\n      criteria.push(BY_SEQ_STORE$1 + '.deleted = 0');\n    }\n\n    db.readTransaction(function (tx) {\n      // count the docs in parallel to other operations\n      countDocs(tx, function (docCount) {\n        totalRows = docCount;\n      });\n\n      if (limit === 0) {\n        return;\n      }\n\n      // do a single query to fetch the documents\n      var sql = select(\n        SELECT_DOCS,\n        [DOC_STORE$1, BY_SEQ_STORE$1],\n        DOC_STORE_AND_BY_SEQ_JOINER,\n        criteria,\n        DOC_STORE$1 + '.id ' + (descending ? 'DESC' : 'ASC')\n        );\n      sql += ' LIMIT ' + limit + ' OFFSET ' + offset;\n\n      tx.executeSql(sql, sqlArgs, function (tx, result) {\n        for (var i = 0, l = result.rows.length; i < l; i++) {\n          var item = result.rows.item(i);\n          var metadata = safeJsonParse(item.metadata);\n          var id = metadata.id;\n          var data = unstringifyDoc(item.data, id, item.rev);\n          var winningRev$$1 = data._rev;\n          var doc = {\n            id: id,\n            key: id,\n            value: {rev: winningRev$$1}\n          };\n          if (opts.include_docs) {\n            doc.doc = data;\n            doc.doc._rev = winningRev$$1;\n            if (opts.conflicts) {\n              var conflicts = collectConflicts(metadata);\n              if (conflicts.length) {\n                doc.doc._conflicts = conflicts;\n              }\n            }\n            fetchAttachmentsIfNecessary$1(doc.doc, opts, api, tx);\n          }\n          if (item.deleted) {\n            if (opts.deleted === 'ok') {\n              doc.value.deleted = true;\n              doc.doc = null;\n            } else {\n              continue;\n            }\n          }\n          results.push(doc);\n        }\n      });\n    }, websqlError(callback), function () {\n      callback(null, {\n        total_rows: totalRows,\n        offset: opts.skip,\n        rows: results\n      });\n    });\n  };\n\n  api._changes = function (opts) {\n    opts = clone(opts);\n\n    if (opts.continuous) {\n      var id = api._name + ':' + uuid();\n      websqlChanges.addListener(api._name, id, api, opts);\n      websqlChanges.notify(api._name);\n      return {\n        cancel: function () {\n          websqlChanges.removeListener(api._name, id);\n        }\n      };\n    }\n\n    var descending = opts.descending;\n\n    // Ignore the `since` parameter when `descending` is true\n    opts.since = opts.since && !descending ? opts.since : 0;\n\n    var limit = 'limit' in opts ? opts.limit : -1;\n    if (limit === 0) {\n      limit = 1; // per CouchDB _changes spec\n    }\n\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    var results = [];\n    var numResults = 0;\n\n    function fetchChanges() {\n\n      var selectStmt =\n        DOC_STORE$1 + '.json AS metadata, ' +\n        DOC_STORE$1 + '.max_seq AS maxSeq, ' +\n        BY_SEQ_STORE$1 + '.json AS winningDoc, ' +\n        BY_SEQ_STORE$1 + '.rev AS winningRev ';\n\n      var from = DOC_STORE$1 + ' JOIN ' + BY_SEQ_STORE$1;\n\n      var joiner = DOC_STORE$1 + '.id=' + BY_SEQ_STORE$1 + '.doc_id' +\n        ' AND ' + DOC_STORE$1 + '.winningseq=' + BY_SEQ_STORE$1 + '.seq';\n\n      var criteria = ['maxSeq > ?'];\n      var sqlArgs = [opts.since];\n\n      if (opts.doc_ids) {\n        criteria.push(DOC_STORE$1 + '.id IN ' + qMarks(opts.doc_ids.length));\n        sqlArgs = sqlArgs.concat(opts.doc_ids);\n      }\n\n      var orderBy = 'maxSeq ' + (descending ? 'DESC' : 'ASC');\n\n      var sql = select(selectStmt, from, joiner, criteria, orderBy);\n\n      var filter = filterChange(opts);\n      if (!opts.view && !opts.filter) {\n        // we can just limit in the query\n        sql += ' LIMIT ' + limit;\n      }\n\n      var lastSeq = opts.since || 0;\n      db.readTransaction(function (tx) {\n        tx.executeSql(sql, sqlArgs, function (tx, result) {\n          function reportChange(change) {\n            return function () {\n              opts.onChange(change);\n            };\n          }\n          for (var i = 0, l = result.rows.length; i < l; i++) {\n            var item = result.rows.item(i);\n            var metadata = safeJsonParse(item.metadata);\n            lastSeq = item.maxSeq;\n\n            var doc = unstringifyDoc(item.winningDoc, metadata.id,\n              item.winningRev);\n            var change = opts.processChange(doc, metadata, opts);\n            change.seq = item.maxSeq;\n\n            var filtered = filter(change);\n            if (typeof filtered === 'object') {\n              return opts.complete(filtered);\n            }\n\n            if (filtered) {\n              numResults++;\n              if (returnDocs) {\n                results.push(change);\n              }\n              // process the attachment immediately\n              // for the benefit of live listeners\n              if (opts.attachments && opts.include_docs) {\n                fetchAttachmentsIfNecessary$1(doc, opts, api, tx,\n                  reportChange(change));\n              } else {\n                reportChange(change)();\n              }\n            }\n            if (numResults === limit) {\n              break;\n            }\n          }\n        });\n      }, websqlError(opts.complete), function () {\n        if (!opts.continuous) {\n          opts.complete(null, {\n            results: results,\n            last_seq: lastSeq\n          });\n        }\n      });\n    }\n\n    fetchChanges();\n  };\n\n  api._close = function (callback) {\n    //WebSQL databases do not need to be closed\n    callback();\n  };\n\n  api._getAttachment = function (docId, attachId, attachment, opts, callback) {\n    var res;\n    var tx = opts.ctx;\n    var digest = attachment.digest;\n    var type = attachment.content_type;\n    var sql = 'SELECT escaped, ' +\n      'CASE WHEN escaped = 1 THEN body ELSE HEX(body) END AS body FROM ' +\n      ATTACH_STORE$1 + ' WHERE digest=?';\n    tx.executeSql(sql, [digest], function (tx, result) {\n      // websql has a bug where \\u0000 causes early truncation in strings\n      // and blobs. to work around this, we used to use the hex() function,\n      // but that's not performant. after migration 6, we remove \\u0000\n      // and add it back in afterwards\n      var item = result.rows.item(0);\n      var data = item.escaped ? unescapeBlob(item.body) :\n        parseHexString(item.body, encoding);\n      if (opts.binary) {\n        res = binStringToBluffer(data, type);\n      } else {\n        res = thisBtoa(data);\n      }\n      callback(null, res);\n    });\n  };\n\n  api._getRevisionTree = function (docId, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        if (!result.rows.length) {\n          callback(createError(MISSING_DOC));\n        } else {\n          var data = safeJsonParse(result.rows.item(0).metadata);\n          callback(null, data.rev_tree);\n        }\n      });\n    });\n  };\n\n  api._doCompaction = function (docId, revs, callback) {\n    if (!revs.length) {\n      return callback();\n    }\n    db.transaction(function (tx) {\n\n      // update doc store\n      var sql = 'SELECT json AS metadata FROM ' + DOC_STORE$1 + ' WHERE id = ?';\n      tx.executeSql(sql, [docId], function (tx, result) {\n        var metadata = safeJsonParse(result.rows.item(0).metadata);\n        traverseRevTree(metadata.rev_tree, function (isLeaf, pos,\n                                                           revHash, ctx, opts) {\n          var rev = pos + '-' + revHash;\n          if (revs.indexOf(rev) !== -1) {\n            opts.status = 'missing';\n          }\n        });\n\n        var sql = 'UPDATE ' + DOC_STORE$1 + ' SET json = ? WHERE id = ?';\n        tx.executeSql(sql, [safeJsonStringify(metadata), docId]);\n      });\n\n      compactRevs$1(revs, docId, tx);\n    }, websqlError(callback), function () {\n      callback();\n    });\n  };\n\n  api._getLocal = function (id, callback) {\n    db.readTransaction(function (tx) {\n      var sql = 'SELECT json, rev FROM ' + LOCAL_STORE$1 + ' WHERE id=?';\n      tx.executeSql(sql, [id], function (tx, res) {\n        if (res.rows.length) {\n          var item = res.rows.item(0);\n          var doc = unstringifyDoc(item.json, id, item.rev);\n          callback(null, doc);\n        } else {\n          callback(createError(MISSING_DOC));\n        }\n      });\n    });\n  };\n\n  api._putLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    delete doc._revisions; // ignore this, trust the rev\n    var oldRev = doc._rev;\n    var id = doc._id;\n    var newRev;\n    if (!oldRev) {\n      newRev = doc._rev = '0-1';\n    } else {\n      newRev = doc._rev = '0-' + (parseInt(oldRev.split('-')[1], 10) + 1);\n    }\n    var json = stringifyDoc(doc);\n\n    var ret;\n    function putLocal(tx) {\n      var sql;\n      var values;\n      if (oldRev) {\n        sql = 'UPDATE ' + LOCAL_STORE$1 + ' SET rev=?, json=? ' +\n          'WHERE id=? AND rev=?';\n        values = [newRev, json, id, oldRev];\n      } else {\n        sql = 'INSERT INTO ' + LOCAL_STORE$1 + ' (id, rev, json) VALUES (?,?,?)';\n        values = [id, newRev, json];\n      }\n      tx.executeSql(sql, values, function (tx, res) {\n        if (res.rowsAffected) {\n          ret = {ok: true, id: id, rev: newRev};\n          if (opts.ctx) { // return immediately\n            callback(null, ret);\n          }\n        } else {\n          callback(createError(REV_CONFLICT));\n        }\n      }, function () {\n        callback(createError(REV_CONFLICT));\n        return false; // ack that we handled the error\n      });\n    }\n\n    if (opts.ctx) {\n      putLocal(opts.ctx);\n    } else {\n      db.transaction(putLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._removeLocal = function (doc, opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var ret;\n\n    function removeLocal(tx) {\n      var sql = 'DELETE FROM ' + LOCAL_STORE$1 + ' WHERE id=? AND rev=?';\n      var params = [doc._id, doc._rev];\n      tx.executeSql(sql, params, function (tx, res) {\n        if (!res.rowsAffected) {\n          return callback(createError(MISSING_DOC));\n        }\n        ret = {ok: true, id: doc._id, rev: '0-0'};\n        if (opts.ctx) { // return immediately\n          callback(null, ret);\n        }\n      });\n    }\n\n    if (opts.ctx) {\n      removeLocal(opts.ctx);\n    } else {\n      db.transaction(removeLocal, websqlError(callback), function () {\n        if (ret) {\n          callback(null, ret);\n        }\n      });\n    }\n  };\n\n  api._destroy = function (opts, callback) {\n    websqlChanges.removeAllListeners(api._name);\n    db.transaction(function (tx) {\n      var stores = [DOC_STORE$1, BY_SEQ_STORE$1, ATTACH_STORE$1, META_STORE$1,\n        LOCAL_STORE$1, ATTACH_AND_SEQ_STORE$1];\n      stores.forEach(function (store) {\n        tx.executeSql('DROP TABLE IF EXISTS ' + store, []);\n      });\n    }, websqlError(callback), function () {\n      if (hasLocalStorage()) {\n        delete window.localStorage['_pouch__websqldb_' + api._name];\n        delete window.localStorage[api._name];\n      }\n      callback(null, {'ok': true});\n    });\n  };\n}\n\nfunction canOpenTestDB() {\n  try {\n    openDatabase('_pouch_validate_websql', 1, '', 1);\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\n// WKWebView had a bug where WebSQL would throw a DOM Exception 18\n// (see https://bugs.webkit.org/show_bug.cgi?id=137760 and\n// https://github.com/pouchdb/pouchdb/issues/5079)\n// This has been fixed in latest WebKit, so we try to detect it here.\nfunction isValidWebSQL() {\n  // WKWebView UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 9_2 like Mac OS X)\n  //   AppleWebKit/601.1.46 (KHTML, like Gecko) Mobile/13C75\n  // Chrome for iOS UA:\n  //   Mozilla/5.0 (iPhone; U; CPU iPhone OS 5_1_1 like Mac OS X; en)\n  //   AppleWebKit/534.46.0 (KHTML, like Gecko) CriOS/19.0.1084.60\n  //   Mobile/9B206 Safari/7534.48.3\n  // Firefox for iOS UA:\n  //   Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4\n  //   (KHTML, like Gecko) FxiOS/1.0 Mobile/12F69 Safari/600.1.4\n\n  // indexedDB is null on some UIWebViews and undefined in others\n  // see: https://bugs.webkit.org/show_bug.cgi?id=137034\n  if (typeof indexedDB === 'undefined' || indexedDB === null ||\n      !/iP(hone|od|ad)/.test(navigator.userAgent)) {\n    // definitely not WKWebView, avoid creating an unnecessary database\n    return true;\n  }\n  // Cache the result in LocalStorage. Reason we do this is because if we\n  // call openDatabase() too many times, Safari craps out in SauceLabs and\n  // starts throwing DOM Exception 14s.\n  var hasLS = hasLocalStorage();\n  // Include user agent in the hash, so that if Safari is upgraded, we don't\n  // continually think it's broken.\n  var localStorageKey = '_pouch__websqldb_valid_' + navigator.userAgent;\n  if (hasLS && localStorage[localStorageKey]) {\n    return localStorage[localStorageKey] === '1';\n  }\n  var openedTestDB = canOpenTestDB();\n  if (hasLS) {\n    localStorage[localStorageKey] = openedTestDB ? '1' : '0';\n  }\n  return openedTestDB;\n}\n\nfunction valid() {\n  if (typeof openDatabase !== 'function') {\n    return false;\n  }\n  return isValidWebSQL();\n}\n\nfunction openDB(name, version, description, size) {\n  // Traditional WebSQL API\n  return openDatabase(name, version, description, size);\n}\n\nfunction WebSQLPouch(opts, callback) {\n  var _opts = assign$1({\n    websql: openDB\n  }, opts);\n\n  WebSqlPouch$1.call(this, _opts, callback);\n}\n\nWebSQLPouch.valid = valid;\n\nWebSQLPouch.use_prefix = true;\n\nvar WebSqlPouch = function (PouchDB) {\n  PouchDB.adapter('websql', WebSQLPouch, true);\n};\n\n/* global fetch */\n/* global Headers */\nfunction wrappedFetch() {\n  var wrappedPromise = {};\n\n  var promise = new PouchPromise$1(function (resolve, reject) {\n    wrappedPromise.resolve = resolve;\n    wrappedPromise.reject = reject;\n  });\n\n  var args = new Array(arguments.length);\n\n  for (var i = 0; i < args.length; i++) {\n    args[i] = arguments[i];\n  }\n\n  wrappedPromise.promise = promise;\n\n  PouchPromise$1.resolve().then(function () {\n    return fetch.apply(null, args);\n  }).then(function (response) {\n    wrappedPromise.resolve(response);\n  }).catch(function (error) {\n    wrappedPromise.reject(error);\n  });\n\n  return wrappedPromise;\n}\n\nfunction fetchRequest(options, callback) {\n  var wrappedPromise, timer, response;\n\n  var headers = new Headers();\n\n  var fetchOptions = {\n    method: options.method,\n    credentials: 'include',\n    headers: headers\n  };\n\n  if (options.json) {\n    headers.set('Accept', 'application/json');\n    headers.set('Content-Type', options.headers['Content-Type'] ||\n      'application/json');\n  }\n\n  if (options.body &&\n      options.processData &&\n      typeof options.body !== 'string') {\n    fetchOptions.body = JSON.stringify(options.body);\n  } else if ('body' in options) {\n    fetchOptions.body = options.body;\n  } else {\n    fetchOptions.body = null;\n  }\n\n  Object.keys(options.headers).forEach(function (key) {\n    if (options.headers.hasOwnProperty(key)) {\n      headers.set(key, options.headers[key]);\n    }\n  });\n\n  wrappedPromise = wrappedFetch(options.url, fetchOptions);\n\n  if (options.timeout > 0) {\n    timer = setTimeout(function () {\n      wrappedPromise.reject(new Error('Load timeout for resource: ' +\n        options.url));\n    }, options.timeout);\n  }\n\n  wrappedPromise.promise.then(function (fetchResponse) {\n    response = {\n      statusCode: fetchResponse.status\n    };\n\n    if (options.timeout > 0) {\n      clearTimeout(timer);\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      return options.binary ? fetchResponse.blob() : fetchResponse.text();\n    }\n\n    return fetchResponse.json();\n  }).then(function (result) {\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      callback(null, response, result);\n    } else {\n      result.status = response.statusCode;\n      callback(result);\n    }\n  }).catch(function (error) {\n    if (!error) {\n      // this happens when the listener is canceled\n      error = new Error('canceled');\n    }\n    callback(error);\n  });\n\n  return {abort: wrappedPromise.reject};\n}\n\nfunction xhRequest(options, callback) {\n\n  var xhr, timer;\n  var timedout = false;\n\n  var abortReq = function () {\n    xhr.abort();\n    cleanUp();\n  };\n\n  var timeoutReq = function () {\n    timedout = true;\n    xhr.abort();\n    cleanUp();\n  };\n\n  var ret = {abort: abortReq};\n\n  var cleanUp = function () {\n    clearTimeout(timer);\n    ret.abort = function () {};\n    if (xhr) {\n      xhr.onprogress = undefined;\n      if (xhr.upload) {\n        xhr.upload.onprogress = undefined;\n      }\n      xhr.onreadystatechange = undefined;\n      xhr = undefined;\n    }\n  };\n\n  if (options.xhr) {\n    xhr = new options.xhr();\n  } else {\n    xhr = new XMLHttpRequest();\n  }\n\n  try {\n    xhr.open(options.method, options.url);\n  } catch (exception) {\n    return callback(new Error(exception.name || 'Url is invalid'));\n  }\n\n  xhr.withCredentials = ('withCredentials' in options) ?\n    options.withCredentials : true;\n\n  if (options.method === 'GET') {\n    delete options.headers['Content-Type'];\n  } else if (options.json) {\n    options.headers.Accept = 'application/json';\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n    if (options.body &&\n        options.processData &&\n        typeof options.body !== \"string\") {\n      options.body = JSON.stringify(options.body);\n    }\n  }\n\n  if (options.binary) {\n    xhr.responseType = 'arraybuffer';\n  }\n\n  if (!('body' in options)) {\n    options.body = null;\n  }\n\n  for (var key in options.headers) {\n    if (options.headers.hasOwnProperty(key)) {\n      xhr.setRequestHeader(key, options.headers[key]);\n    }\n  }\n\n  if (options.timeout > 0) {\n    timer = setTimeout(timeoutReq, options.timeout);\n    xhr.onprogress = function () {\n      clearTimeout(timer);\n      if(xhr.readyState !== 4) {\n        timer = setTimeout(timeoutReq, options.timeout);\n      }\n    };\n    if (typeof xhr.upload !== 'undefined') { // does not exist in ie9\n      xhr.upload.onprogress = xhr.onprogress;\n    }\n  }\n\n  xhr.onreadystatechange = function () {\n    if (xhr.readyState !== 4) {\n      return;\n    }\n\n    var response = {\n      statusCode: xhr.status\n    };\n\n    if (xhr.status >= 200 && xhr.status < 300) {\n      var data;\n      if (options.binary) {\n        data = createBlob([xhr.response || ''], {\n          type: xhr.getResponseHeader('Content-Type')\n        });\n      } else {\n        data = xhr.responseText;\n      }\n      callback(null, response, data);\n    } else {\n      var err = {};\n      if (timedout) {\n        err = new Error('ETIMEDOUT');\n        err.code = 'ETIMEDOUT';\n      } else if (typeof xhr.response === 'string') {\n        try {\n          err = JSON.parse(xhr.response);\n        } catch(e) {}\n      }\n      err.status = xhr.status;\n      callback(err);\n    }\n    cleanUp();\n  };\n\n  if (options.body && (options.body instanceof Blob)) {\n    readAsArrayBuffer(options.body, function (arrayBuffer) {\n      xhr.send(arrayBuffer);\n    });\n  } else {\n    xhr.send(options.body);\n  }\n\n  return ret;\n}\n\nfunction testXhr() {\n  try {\n    new XMLHttpRequest();\n    return true;\n  } catch (err) {\n    return false;\n  }\n}\n\nvar hasXhr = testXhr();\n\nfunction ajax$1(options, callback) {\n  if (!false && (hasXhr || options.xhr)) {\n    return xhRequest(options, callback);\n  } else {\n    return fetchRequest(options, callback);\n  }\n}\n\n// the blob already has a type; do nothing\nvar res$2 = function () {};\n\nfunction defaultBody() {\n  return '';\n}\n\nfunction ajaxCore$1(options, callback) {\n\n  options = clone(options);\n\n  var defaultOptions = {\n    method : \"GET\",\n    headers: {},\n    json: true,\n    processData: true,\n    timeout: 10000,\n    cache: false\n  };\n\n  options = assign$1(defaultOptions, options);\n\n  function onSuccess(obj, resp, cb) {\n    if (!options.binary && options.json && typeof obj === 'string') {\n      /* istanbul ignore next */\n      try {\n        obj = JSON.parse(obj);\n      } catch (e) {\n        // Probably a malformed JSON from server\n        return cb(e);\n      }\n    }\n    if (Array.isArray(obj)) {\n      obj = obj.map(function (v) {\n        if (v.error || v.missing) {\n          return generateErrorFromResponse(v);\n        } else {\n          return v;\n        }\n      });\n    }\n    if (options.binary) {\n      res$2(obj, resp);\n    }\n    cb(null, obj, resp);\n  }\n\n  if (options.json) {\n    if (!options.binary) {\n      options.headers.Accept = 'application/json';\n    }\n    options.headers['Content-Type'] = options.headers['Content-Type'] ||\n      'application/json';\n  }\n\n  if (options.binary) {\n    options.encoding = null;\n    options.json = false;\n  }\n\n  if (!options.processData) {\n    options.json = false;\n  }\n\n  return ajax$1(options, function (err, response, body) {\n\n    if (err) {\n      return callback(generateErrorFromResponse(err));\n    }\n\n    var error;\n    var content_type = response.headers && response.headers['content-type'];\n    var data = body || defaultBody();\n\n    // CouchDB doesn't always return the right content-type for JSON data, so\n    // we check for ^{ and }$ (ignoring leading/trailing whitespace)\n    if (!options.binary && (options.json || !options.processData) &&\n        typeof data !== 'object' &&\n        (/json/.test(content_type) ||\n         (/^[\\s]*\\{/.test(data) && /\\}[\\s]*$/.test(data)))) {\n      try {\n        data = JSON.parse(data.toString());\n      } catch (e) {}\n    }\n\n    if (response.statusCode >= 200 && response.statusCode < 300) {\n      onSuccess(data, response, callback);\n    } else {\n      error = generateErrorFromResponse(data);\n      error.status = response.statusCode;\n      callback(error);\n    }\n  });\n}\n\nfunction ajax(opts, callback) {\n\n  // cache-buster, specifically designed to work around IE's aggressive caching\n  // see http://www.dashbay.com/2011/05/internet-explorer-caches-ajax/\n  // Also Safari caches POSTs, so we need to cache-bust those too.\n  var ua = (navigator && navigator.userAgent) ?\n    navigator.userAgent.toLowerCase() : '';\n\n  var isSafari = ua.indexOf('safari') !== -1 && ua.indexOf('chrome') === -1;\n  var isIE = ua.indexOf('msie') !== -1;\n  var isEdge = ua.indexOf('edge') !== -1;\n\n  // it appears the new version of safari also caches GETs,\n  // see https://github.com/pouchdb/pouchdb/issues/5010\n  var shouldCacheBust = (isSafari ||\n    ((isIE || isEdge) && opts.method === 'GET'));\n\n  var cache = 'cache' in opts ? opts.cache : true;\n\n  var isBlobUrl = /^blob:/.test(opts.url); // don't append nonces for blob URLs\n\n  if (!isBlobUrl && (shouldCacheBust || !cache)) {\n    var hasArgs = opts.url.indexOf('?') !== -1;\n    opts.url += (hasArgs ? '&' : '?') + '_nonce=' + Date.now();\n  }\n\n  return ajaxCore$1(opts, callback);\n}\n\n// dead simple promise pool, inspired by https://github.com/timdp/es6-promise-pool\n// but much smaller in code size. limits the number of concurrent promises that are executed\n\nfunction pool(promiseFactories, limit) {\n  return new PouchPromise$1(function (resolve, reject) {\n    var running = 0;\n    var current = 0;\n    var done = 0;\n    var len = promiseFactories.length;\n    var err;\n\n    function runNext() {\n      running++;\n      promiseFactories[current++]().then(onSuccess, onError);\n    }\n\n    function doNext() {\n      if (++done === len) {\n        /* istanbul ignore if */\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      } else {\n        runNextBatch();\n      }\n    }\n\n    function onSuccess() {\n      running--;\n      doNext();\n    }\n\n    /* istanbul ignore next */\n    function onError(thisErr) {\n      running--;\n      err = err || thisErr;\n      doNext();\n    }\n\n    function runNextBatch() {\n      while (running < limit && current < len) {\n        runNext();\n      }\n    }\n\n    runNextBatch();\n  });\n}\n\nvar CHANGES_BATCH_SIZE = 25;\nvar MAX_SIMULTANEOUS_REVS = 50;\n\nvar supportsBulkGetMap = {};\n\nvar log$1 = debug('pouchdb:http');\n\nfunction readAttachmentsAsBlobOrBuffer(row) {\n  var atts = row.doc && row.doc._attachments;\n  if (!atts) {\n    return;\n  }\n  Object.keys(atts).forEach(function (filename) {\n    var att = atts[filename];\n    att.data = b64ToBluffer(att.data, att.content_type);\n  });\n}\n\nfunction encodeDocId(id) {\n  if (/^_design/.test(id)) {\n    return '_design/' + encodeURIComponent(id.slice(8));\n  }\n  if (/^_local/.test(id)) {\n    return '_local/' + encodeURIComponent(id.slice(7));\n  }\n  return encodeURIComponent(id);\n}\n\nfunction preprocessAttachments$2(doc) {\n  if (!doc._attachments || !Object.keys(doc._attachments)) {\n    return PouchPromise$1.resolve();\n  }\n\n  return PouchPromise$1.all(Object.keys(doc._attachments).map(function (key) {\n    var attachment = doc._attachments[key];\n    if (attachment.data && typeof attachment.data !== 'string') {\n      return new PouchPromise$1(function (resolve) {\n        blobToBase64(attachment.data, resolve);\n      }).then(function (b64) {\n        attachment.data = b64;\n      });\n    }\n  }));\n}\n\nfunction hasUrlPrefix(opts) {\n  if (!opts.prefix) {\n    return false;\n  }\n\n  var protocol = parseUri(opts.prefix).protocol;\n\n  return protocol === 'http' || protocol === 'https';\n}\n\n// Get all the information you possibly can about the URI given by name and\n// return it as a suitable object.\nfunction getHost(name, opts) {\n\n  // encode db name if opts.prefix is a url (#5574)\n  if (hasUrlPrefix(opts)) {\n    var dbName = opts.name.substr(opts.prefix.length);\n    name = opts.prefix + encodeURIComponent(dbName);\n  }\n\n  // Prase the URI into all its little bits\n  var uri = parseUri(name);\n\n  // Store the user and password as a separate auth object\n  if (uri.user || uri.password) {\n    uri.auth = {username: uri.user, password: uri.password};\n  }\n\n  // Split the path part of the URI into parts using '/' as the delimiter\n  // after removing any leading '/' and any trailing '/'\n  var parts = uri.path.replace(/(^\\/|\\/$)/g, '').split('/');\n\n  // Store the first part as the database name and remove it from the parts\n  // array\n  uri.db = parts.pop();\n  // Prevent double encoding of URI component\n  if (uri.db.indexOf('%') === -1) {\n    uri.db = encodeURIComponent(uri.db);\n  }\n\n  // Restore the path by joining all the remaining parts (all the parts\n  // except for the database name) with '/'s\n  uri.path = parts.join('/');\n\n  return uri;\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genDBUrl(opts, path) {\n  return genUrl(opts, opts.db + '/' + path);\n}\n\n// Generate a URL with the host data given by opts and the given path\nfunction genUrl(opts, path) {\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  var pathDel = !opts.path ? '' : '/';\n\n  // If the host already has a path, then we need to have a path delimiter\n  // Otherwise, the path delimiter is the empty string\n  return opts.protocol + '://' + opts.host +\n         (opts.port ? (':' + opts.port) : '') +\n         '/' + opts.path + pathDel + path;\n}\n\nfunction paramsToStr(params) {\n  return '?' + Object.keys(params).map(function (k) {\n    return k + '=' + encodeURIComponent(params[k]);\n  }).join('&');\n}\n\n// Implements the PouchDB API for dealing with CouchDB instances over HTTP\nfunction HttpPouch(opts, callback) {\n\n  // The functions that will be publicly available for HttpPouch\n  var api = this;\n\n  var host = getHost(opts.name, opts);\n  var dbUrl = genDBUrl(host, '');\n\n  opts = clone(opts);\n  var ajaxOpts = opts.ajax || {};\n\n  if (opts.auth || host.auth) {\n    var nAuth = opts.auth || host.auth;\n    var str = nAuth.username + ':' + nAuth.password;\n    var token = thisBtoa(unescape(encodeURIComponent(str)));\n    ajaxOpts.headers = ajaxOpts.headers || {};\n    ajaxOpts.headers.Authorization = 'Basic ' + token;\n  }\n\n  // Not strictly necessary, but we do this because numerous tests\n  // rely on swapping ajax in and out.\n  api._ajax = ajax;\n\n  function ajax$$1(userOpts, options, callback) {\n    var reqAjax = userOpts.ajax || {};\n    var reqOpts = assign$1(clone(ajaxOpts), reqAjax, options);\n    log$1(reqOpts.method + ' ' + reqOpts.url);\n    return api._ajax(reqOpts, callback);\n  }\n\n  function ajaxPromise(userOpts, opts) {\n    return new PouchPromise$1(function (resolve, reject) {\n      ajax$$1(userOpts, opts, function (err, res) {\n        /* istanbul ignore if */\n        if (err) {\n          return reject(err);\n        }\n        resolve(res);\n      });\n    });\n  }\n\n  function adapterFun$$1(name, fun) {\n    return adapterFun(name, getArguments(function (args) {\n      setup().then(function () {\n        return fun.apply(this, args);\n      }).catch(function (e) {\n        var callback = args.pop();\n        callback(e);\n      });\n    }));\n  }\n\n  var setupPromise;\n\n  function setup() {\n    // TODO: Remove `skipSetup` in favor of `skip_setup` in a future release\n    if (opts.skipSetup || opts.skip_setup) {\n      return PouchPromise$1.resolve();\n    }\n\n    // If there is a setup in process or previous successful setup\n    // done then we will use that\n    // If previous setups have been rejected we will try again\n    if (setupPromise) {\n      return setupPromise;\n    }\n\n    var checkExists = {method: 'GET', url: dbUrl};\n    setupPromise = ajaxPromise({}, checkExists).catch(function (err) {\n      if (err && err.status && err.status === 404) {\n        // Doesnt exist, create it\n        explainError(404, 'PouchDB is just detecting if the remote exists.');\n        return ajaxPromise({}, {method: 'PUT', url: dbUrl});\n      } else {\n        return PouchPromise$1.reject(err);\n      }\n    }).catch(function (err) {\n      // If we try to create a database that already exists, skipped in\n      // istanbul since its catching a race condition.\n      /* istanbul ignore if */\n      if (err && err.status && err.status === 412) {\n        return true;\n      }\n      return PouchPromise$1.reject(err);\n    });\n\n    setupPromise.catch(function () {\n      setupPromise = null;\n    });\n\n    return setupPromise;\n  }\n\n  nextTick(function () {\n    callback(null, api);\n  });\n\n  api.type = function () {\n    return 'http';\n  };\n\n  api.id = adapterFun$$1('id', function (callback) {\n    ajax$$1({}, {method: 'GET', url: genUrl(host, '')}, function (err, result) {\n      var uuid$$1 = (result && result.uuid) ?\n        (result.uuid + host.db) : genDBUrl(host, '');\n      callback(null, uuid$$1);\n    });\n  });\n\n  api.request = adapterFun$$1('request', function (options, callback) {\n    options.url = genDBUrl(host, options.url);\n    ajax$$1({}, options, callback);\n  });\n\n  // Sends a POST request to the host calling the couchdb _compact function\n  //    version: The version of CouchDB it is running\n  api.compact = adapterFun$$1('compact', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n    ajax$$1(opts, {\n      url: genDBUrl(host, '_compact'),\n      method: 'POST'\n    }, function () {\n      function ping() {\n        api.info(function (err, res) {\n          if (res && !res.compact_running) {\n            callback(null, {ok: true});\n          } else {\n            setTimeout(ping, opts.interval || 200);\n          }\n        });\n      }\n      // Ping the http if it's finished compaction\n      ping();\n    });\n  });\n\n  api.bulkGet = adapterFun('bulkGet', function (opts, callback) {\n    var self = this;\n\n    function doBulkGet(cb) {\n      var params = {};\n      if (opts.revs) {\n        params.revs = true;\n      }\n      if (opts.attachments) {\n        /* istanbul ignore next */\n        params.attachments = true;\n      }\n      if (opts.latest) {\n        params.latest = true;\n      }\n      ajax$$1(opts, {\n        url: genDBUrl(host, '_bulk_get' + paramsToStr(params)),\n        method: 'POST',\n        body: { docs: opts.docs}\n      }, cb);\n    }\n\n    function doBulkGetShim() {\n      // avoid \"url too long error\" by splitting up into multiple requests\n      var batchSize = MAX_SIMULTANEOUS_REVS;\n      var numBatches = Math.ceil(opts.docs.length / batchSize);\n      var numDone = 0;\n      var results = new Array(numBatches);\n\n      function onResult(batchNum) {\n        return function (err, res) {\n          // err is impossible because shim returns a list of errs in that case\n          results[batchNum] = res.results;\n          if (++numDone === numBatches) {\n            callback(null, {results: flatten(results)});\n          }\n        };\n      }\n\n      for (var i = 0; i < numBatches; i++) {\n        var subOpts = pick(opts, ['revs', 'attachments', 'latest']);\n        subOpts.ajax = ajaxOpts;\n        subOpts.docs = opts.docs.slice(i * batchSize,\n          Math.min(opts.docs.length, (i + 1) * batchSize));\n        bulkGet(self, subOpts, onResult(i));\n      }\n    }\n\n    // mark the whole database as either supporting or not supporting _bulk_get\n    var dbUrl = genUrl(host, '');\n    var supportsBulkGet = supportsBulkGetMap[dbUrl];\n\n    if (typeof supportsBulkGet !== 'boolean') {\n      // check if this database supports _bulk_get\n      doBulkGet(function (err, res) {\n        /* istanbul ignore else */\n        if (err) {\n          supportsBulkGetMap[dbUrl] = false;\n          explainError(\n            err.status,\n            'PouchDB is just detecting if the remote ' +\n            'supports the _bulk_get API.'\n          );\n          doBulkGetShim();\n        } else {\n          supportsBulkGetMap[dbUrl] = true;\n          callback(null, res);\n        }\n      });\n    } else if (supportsBulkGet) {\n      /* istanbul ignore next */\n      doBulkGet(callback);\n    } else {\n      doBulkGetShim();\n    }\n  });\n\n  // Calls GET on the host, which gets back a JSON string containing\n  //    couchdb: A welcome string\n  //    version: The version of CouchDB it is running\n  api._info = function (callback) {\n    setup().then(function () {\n      ajax$$1({}, {\n        method: 'GET',\n        url: genDBUrl(host, '')\n      }, function (err, res) {\n        /* istanbul ignore next */\n        if (err) {\n        return callback(err);\n        }\n        res.host = genDBUrl(host, '');\n        callback(null, res);\n      });\n    }).catch(callback);\n  };\n\n  // Get the document with the given id from the database given by host.\n  // The id could be solely the _id in the database, or it may be a\n  // _design/ID or _local/ID path\n  api.get = adapterFun$$1('get', function (id, opts, callback) {\n    // If no options were given, set the callback to the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n\n    if (opts.revs) {\n      params.revs = true;\n    }\n\n    if (opts.revs_info) {\n      params.revs_info = true;\n    }\n\n    if (opts.latest) {\n      params.latest = true;\n    }\n\n    if (opts.open_revs) {\n      if (opts.open_revs !== \"all\") {\n        opts.open_revs = JSON.stringify(opts.open_revs);\n      }\n      params.open_revs = opts.open_revs;\n    }\n\n    if (opts.rev) {\n      params.rev = opts.rev;\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = opts.conflicts;\n    }\n\n    id = encodeDocId(id);\n\n    // Set the options for the ajax call\n    var options = {\n      method: 'GET',\n      url: genDBUrl(host, id + paramsToStr(params))\n    };\n\n    function fetchAttachments(doc) {\n      var atts = doc._attachments;\n      var filenames = atts && Object.keys(atts);\n      if (!atts || !filenames.length) {\n        return;\n      }\n      // we fetch these manually in separate XHRs, because\n      // Sync Gateway would normally send it back as multipart/mixed,\n      // which we cannot parse. Also, this is more efficient than\n      // receiving attachments as base64-encoded strings.\n      function fetch(filename) {\n        var att = atts[filename];\n        var path = encodeDocId(doc._id) + '/' + encodeAttachmentId(filename) +\n          '?rev=' + doc._rev;\n        return ajaxPromise(opts, {\n          method: 'GET',\n          url: genDBUrl(host, path),\n          binary: true\n        }).then(function (blob$$1) {\n          if (opts.binary) {\n            return blob$$1;\n          }\n          return new PouchPromise$1(function (resolve) {\n            blobToBase64(blob$$1, resolve);\n          });\n        }).then(function (data) {\n          delete att.stub;\n          delete att.length;\n          att.data = data;\n        });\n      }\n\n      var promiseFactories = filenames.map(function (filename) {\n        return function () {\n          return fetch(filename);\n        };\n      });\n\n      // This limits the number of parallel xhr requests to 5 any time\n      // to avoid issues with maximum browser request limits\n      return pool(promiseFactories, 5);\n    }\n\n    function fetchAllAttachments(docOrDocs) {\n      if (Array.isArray(docOrDocs)) {\n        return PouchPromise$1.all(docOrDocs.map(function (doc) {\n          if (doc.ok) {\n            return fetchAttachments(doc.ok);\n          }\n        }));\n      }\n      return fetchAttachments(docOrDocs);\n    }\n\n    ajaxPromise(opts, options).then(function (res) {\n      return PouchPromise$1.resolve().then(function () {\n        if (opts.attachments) {\n          return fetchAllAttachments(res);\n        }\n      }).then(function () {\n        callback(null, res);\n      });\n    }).catch(callback);\n  });\n\n  // Delete the document given by doc from the database given by host.\n  api.remove = adapterFun$$1('remove',\n      function (docOrId, optsOrRev, opts, callback) {\n    var doc;\n    if (typeof optsOrRev === 'string') {\n      // id, rev, opts, callback style\n      doc = {\n        _id: docOrId,\n        _rev: optsOrRev\n      };\n      if (typeof opts === 'function') {\n        callback = opts;\n        opts = {};\n      }\n    } else {\n      // doc, opts, callback style\n      doc = docOrId;\n      if (typeof optsOrRev === 'function') {\n        callback = optsOrRev;\n        opts = {};\n      } else {\n        callback = opts;\n        opts = optsOrRev;\n      }\n    }\n\n    var rev = (doc._rev || opts.rev);\n\n    // Delete the document\n    ajax$$1(opts, {\n      method: 'DELETE',\n      url: genDBUrl(host, encodeDocId(doc._id)) + '?rev=' + rev\n    }, callback);\n  });\n\n  function encodeAttachmentId(attachmentId) {\n    return attachmentId.split(\"/\").map(encodeURIComponent).join(\"/\");\n  }\n\n  // Get the attachment\n  api.getAttachment =\n    adapterFun$$1('getAttachment', function (docId, attachmentId, opts,\n                                                callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    var params = opts.rev ? ('?rev=' + opts.rev) : '';\n    var url = genDBUrl(host, encodeDocId(docId)) + '/' +\n      encodeAttachmentId(attachmentId) + params;\n    ajax$$1(opts, {\n      method: 'GET',\n      url: url,\n      binary: true\n    }, callback);\n  });\n\n  // Remove the attachment given by the id and rev\n  api.removeAttachment =\n    adapterFun$$1('removeAttachment', function (docId, attachmentId, rev,\n                                                   callback) {\n\n    var url = genDBUrl(host, encodeDocId(docId) + '/' +\n      encodeAttachmentId(attachmentId)) + '?rev=' + rev;\n\n    ajax$$1({}, {\n      method: 'DELETE',\n      url: url\n    }, callback);\n  });\n\n  // Add the attachment given by blob and its contentType property\n  // to the document with the given id, the revision given by rev, and\n  // add it to the database given by host.\n  api.putAttachment =\n    adapterFun$$1('putAttachment', function (docId, attachmentId, rev, blob$$1,\n                                                type, callback) {\n    if (typeof type === 'function') {\n      callback = type;\n      type = blob$$1;\n      blob$$1 = rev;\n      rev = null;\n    }\n    var id = encodeDocId(docId) + '/' + encodeAttachmentId(attachmentId);\n    var url = genDBUrl(host, id);\n    if (rev) {\n      url += '?rev=' + rev;\n    }\n\n    if (typeof blob$$1 === 'string') {\n      // input is assumed to be a base64 string\n      var binary;\n      try {\n        binary = thisAtob(blob$$1);\n      } catch (err) {\n        return callback(createError(BAD_ARG,\n                        'Attachment is not a valid base64 string'));\n      }\n      blob$$1 = binary ? binStringToBluffer(binary, type) : '';\n    }\n\n    var opts = {\n      headers: {'Content-Type': type},\n      method: 'PUT',\n      url: url,\n      processData: false,\n      body: blob$$1,\n      timeout: ajaxOpts.timeout || 60000\n    };\n    // Add the attachment\n    ajax$$1({}, opts, callback);\n  });\n\n  // Update/create multiple documents given by req in the database\n  // given by host.\n  api._bulkDocs = function (req, opts, callback) {\n    // If new_edits=false then it prevents the database from creating\n    // new revision numbers for the documents. Instead it just uses\n    // the old ones. This is used in database replication.\n    req.new_edits = opts.new_edits;\n\n    setup().then(function () {\n      return PouchPromise$1.all(req.docs.map(preprocessAttachments$2));\n    }).then(function () {\n      // Update/create the documents\n      ajax$$1(opts, {\n        method: 'POST',\n        url: genDBUrl(host, '_bulk_docs'),\n        timeout: opts.timeout,\n        body: req\n      }, function (err, results) {\n        if (err) {\n          return callback(err);\n        }\n        results.forEach(function (result) {\n          result.ok = true; // smooths out cloudant not adding this\n        });\n        callback(null, results);\n      });\n    }).catch(callback);\n  };\n\n\n  // Update/create document\n  api._put = function (doc, opts, callback) {\n    setup().then(function () {\n      return preprocessAttachments$2(doc);\n    }).then(function () {\n      // Update/create the document\n      ajax$$1(opts, {\n        method: 'PUT',\n        url: genDBUrl(host, encodeDocId(doc._id)),\n        body: doc\n      }, function (err, result) {\n        if (err) {\n          return callback(err);\n        }\n        callback(null, result);\n      });\n    }).catch(callback);\n  };\n\n\n  // Get a listing of the documents in the database given\n  // by host and ordered by increasing id.\n  api.allDocs = adapterFun$$1('allDocs', function (opts, callback) {\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n    opts = clone(opts);\n\n    // List of parameters to add to the GET request\n    var params = {};\n    var body;\n    var method = 'GET';\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if (opts.include_docs) {\n      params.include_docs = true;\n    }\n\n    // added in CouchDB 1.6.0\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.key) {\n      params.key = JSON.stringify(opts.key);\n    }\n\n    if (opts.start_key) {\n      opts.startkey = opts.start_key;\n    }\n\n    if (opts.startkey) {\n      params.startkey = JSON.stringify(opts.startkey);\n    }\n\n    if (opts.end_key) {\n      opts.endkey = opts.end_key;\n    }\n\n    if (opts.endkey) {\n      params.endkey = JSON.stringify(opts.endkey);\n    }\n\n    if (typeof opts.inclusive_end !== 'undefined') {\n      params.inclusive_end = !!opts.inclusive_end;\n    }\n\n    if (typeof opts.limit !== 'undefined') {\n      params.limit = opts.limit;\n    }\n\n    if (typeof opts.skip !== 'undefined') {\n      params.skip = opts.skip;\n    }\n\n    var paramStr = paramsToStr(params);\n\n    if (typeof opts.keys !== 'undefined') {\n      method = 'POST';\n      body = {keys: opts.keys};\n    }\n\n    // Get the document listing\n    ajaxPromise(opts, {\n      method: method,\n      url: genDBUrl(host, '_all_docs' + paramStr),\n      body: body\n    }).then(function (res) {\n      if (opts.include_docs && opts.attachments && opts.binary) {\n        res.rows.forEach(readAttachmentsAsBlobOrBuffer);\n      }\n      callback(null, res);\n    }).catch(callback);\n  });\n\n  // Get a list of changes made to documents in the database given by host.\n  // TODO According to the README, there should be two other methods here,\n  // api.changes.addListener and api.changes.removeListener.\n  api._changes = function (opts) {\n\n    // We internally page the results of a changes request, this means\n    // if there is a large set of changes to be returned we can start\n    // processing them quicker instead of waiting on the entire\n    // set of changes to return and attempting to process them at once\n    var batchSize = 'batch_size' in opts ? opts.batch_size : CHANGES_BATCH_SIZE;\n\n    opts = clone(opts);\n    opts.timeout = ('timeout' in opts) ? opts.timeout :\n      ('timeout' in ajaxOpts) ? ajaxOpts.timeout :\n      30 * 1000;\n\n    // We give a 5 second buffer for CouchDB changes to respond with\n    // an ok timeout (if a timeout it set)\n    var params = opts.timeout ? {timeout: opts.timeout - (5 * 1000)} : {};\n    var limit = (typeof opts.limit !== 'undefined') ? opts.limit : false;\n    var returnDocs;\n    if ('return_docs' in opts) {\n      returnDocs = opts.return_docs;\n    } else if ('returnDocs' in opts) {\n      // TODO: Remove 'returnDocs' in favor of 'return_docs' in a future release\n      returnDocs = opts.returnDocs;\n    } else {\n      returnDocs = true;\n    }\n    //\n    var leftToFetch = limit;\n\n    if (opts.style) {\n      params.style = opts.style;\n    }\n\n    if (opts.include_docs || opts.filter && typeof opts.filter === 'function') {\n      params.include_docs = true;\n    }\n\n    if (opts.attachments) {\n      params.attachments = true;\n    }\n\n    if (opts.continuous) {\n      params.feed = 'longpoll';\n    }\n\n    if (opts.conflicts) {\n      params.conflicts = true;\n    }\n\n    if (opts.descending) {\n      params.descending = true;\n    }\n\n    if ('heartbeat' in opts) {\n      // If the heartbeat value is false, it disables the default heartbeat\n      if (opts.heartbeat) {\n        params.heartbeat = opts.heartbeat;\n      }\n    } else if (opts.continuous) {\n      // Default heartbeat to 10 seconds\n      params.heartbeat = 10000;\n    }\n\n    if (opts.filter && typeof opts.filter === 'string') {\n      params.filter = opts.filter;\n    }\n\n    if (opts.view && typeof opts.view === 'string') {\n      params.filter = '_view';\n      params.view = opts.view;\n    }\n\n    // If opts.query_params exists, pass it through to the changes request.\n    // These parameters may be used by the filter on the source database.\n    if (opts.query_params && typeof opts.query_params === 'object') {\n      for (var param_name in opts.query_params) {\n        /* istanbul ignore else */\n        if (opts.query_params.hasOwnProperty(param_name)) {\n          params[param_name] = opts.query_params[param_name];\n        }\n      }\n    }\n\n    var method = 'GET';\n    var body;\n\n    if (opts.doc_ids) {\n      // set this automagically for the user; it's annoying that couchdb\n      // requires both a \"filter\" and a \"doc_ids\" param.\n      params.filter = '_doc_ids';\n      method = 'POST';\n      body = {doc_ids: opts.doc_ids };\n    }\n\n    var xhr;\n    var lastFetchedSeq;\n\n    // Get all the changes starting wtih the one immediately after the\n    // sequence number given by since.\n    var fetch = function (since, callback) {\n      if (opts.aborted) {\n        return;\n      }\n      params.since = since;\n      // \"since\" can be any kind of json object in Coudant/CouchDB 2.x\n      /* istanbul ignore next */\n      if (typeof params.since === \"object\") {\n        params.since = JSON.stringify(params.since);\n      }\n\n      if (opts.descending) {\n        if (limit) {\n          params.limit = leftToFetch;\n        }\n      } else {\n        params.limit = (!limit || leftToFetch > batchSize) ?\n          batchSize : leftToFetch;\n      }\n\n      // Set the options for the ajax call\n      var xhrOpts = {\n        method: method,\n        url: genDBUrl(host, '_changes' + paramsToStr(params)),\n        timeout: opts.timeout,\n        body: body\n      };\n      lastFetchedSeq = since;\n\n      /* istanbul ignore if */\n      if (opts.aborted) {\n        return;\n      }\n\n      // Get the changes\n      setup().then(function () {\n        xhr = ajax$$1(opts, xhrOpts, callback);\n      }).catch(callback);\n    };\n\n    // If opts.since exists, get all the changes from the sequence\n    // number given by opts.since. Otherwise, get all the changes\n    // from the sequence number 0.\n    var results = {results: []};\n\n    var fetched = function (err, res) {\n      if (opts.aborted) {\n        return;\n      }\n      var raw_results_length = 0;\n      // If the result of the ajax call (res) contains changes (res.results)\n      if (res && res.results) {\n        raw_results_length = res.results.length;\n        results.last_seq = res.last_seq;\n        // For each change\n        var req = {};\n        req.query = opts.query_params;\n        res.results = res.results.filter(function (c) {\n          leftToFetch--;\n          var ret = filterChange(opts)(c);\n          if (ret) {\n            if (opts.include_docs && opts.attachments && opts.binary) {\n              readAttachmentsAsBlobOrBuffer(c);\n            }\n            if (returnDocs) {\n              results.results.push(c);\n            }\n            opts.onChange(c);\n          }\n          return ret;\n        });\n      } else if (err) {\n        // In case of an error, stop listening for changes and call\n        // opts.complete\n        opts.aborted = true;\n        opts.complete(err);\n        return;\n      }\n\n      // The changes feed may have timed out with no results\n      // if so reuse last update sequence\n      if (res && res.last_seq) {\n        lastFetchedSeq = res.last_seq;\n      }\n\n      var finished = (limit && leftToFetch <= 0) ||\n        (res && raw_results_length < batchSize) ||\n        (opts.descending);\n\n      if ((opts.continuous && !(limit && leftToFetch <= 0)) || !finished) {\n        // Queue a call to fetch again with the newest sequence number\n        nextTick(function () { fetch(lastFetchedSeq, fetched); });\n      } else {\n        // We're done, call the callback\n        opts.complete(null, results);\n      }\n    };\n\n    fetch(opts.since || 0, fetched);\n\n    // Return a method to cancel this method from processing any more\n    return {\n      cancel: function () {\n        opts.aborted = true;\n        if (xhr) {\n          xhr.abort();\n        }\n      }\n    };\n  };\n\n  // Given a set of document/revision IDs (given by req), tets the subset of\n  // those that do NOT correspond to revisions stored in the database.\n  // See http://wiki.apache.org/couchdb/HttpPostRevsDiff\n  api.revsDiff = adapterFun$$1('revsDiff', function (req, opts, callback) {\n    // If no options were given, set the callback to be the second parameter\n    if (typeof opts === 'function') {\n      callback = opts;\n      opts = {};\n    }\n\n    // Get the missing document/revision IDs\n    ajax$$1(opts, {\n      method: 'POST',\n      url: genDBUrl(host, '_revs_diff'),\n      body: req\n    }, callback);\n  });\n\n  api._close = function (callback) {\n    callback();\n  };\n\n  api._destroy = function (options, callback) {\n    ajax$$1(options, {\n      url: genDBUrl(host, ''),\n      method: 'DELETE'\n    }, function (err, resp) {\n      if (err && err.status && err.status !== 404) {\n        return callback(err);\n      }\n      callback(null, resp);\n    });\n  };\n}\n\n// HttpPouch is a valid adapter.\nHttpPouch.valid = function () {\n  return true;\n};\n\nvar HttpPouch$1 = function (PouchDB) {\n  PouchDB.adapter('http', HttpPouch, false);\n  PouchDB.adapter('https', HttpPouch, false);\n};\n\nfunction pad(str, padWith, upToLength) {\n  var padding = '';\n  var targetLength = upToLength - str.length;\n  /* istanbul ignore next */\n  while (padding.length < targetLength) {\n    padding += padWith;\n  }\n  return padding;\n}\n\nfunction padLeft(str, padWith, upToLength) {\n  var padding = pad(str, padWith, upToLength);\n  return padding + str;\n}\n\nvar MIN_MAGNITUDE = -324; // verified by -Number.MIN_VALUE\nvar MAGNITUDE_DIGITS = 3; // ditto\nvar SEP = ''; // set to '_' for easier debugging \n\nfunction collate(a, b) {\n\n  if (a === b) {\n    return 0;\n  }\n\n  a = normalizeKey(a);\n  b = normalizeKey(b);\n\n  var ai = collationIndex(a);\n  var bi = collationIndex(b);\n  if ((ai - bi) !== 0) {\n    return ai - bi;\n  }\n  switch (typeof a) {\n    case 'number':\n      return a - b;\n    case 'boolean':\n      return a < b ? -1 : 1;\n    case 'string':\n      return stringCollate(a, b);\n  }\n  return Array.isArray(a) ? arrayCollate(a, b) : objectCollate(a, b);\n}\n\n// couch considers null/NaN/Infinity/-Infinity === undefined,\n// for the purposes of mapreduce indexes. also, dates get stringified.\nfunction normalizeKey(key) {\n  switch (typeof key) {\n    case 'undefined':\n      return null;\n    case 'number':\n      if (key === Infinity || key === -Infinity || isNaN(key)) {\n        return null;\n      }\n      return key;\n    case 'object':\n      var origKey = key;\n      if (Array.isArray(key)) {\n        var len = key.length;\n        key = new Array(len);\n        for (var i = 0; i < len; i++) {\n          key[i] = normalizeKey(origKey[i]);\n        }\n      /* istanbul ignore next */\n      } else if (key instanceof Date) {\n        return key.toJSON();\n      } else if (key !== null) { // generic object\n        key = {};\n        for (var k in origKey) {\n          if (origKey.hasOwnProperty(k)) {\n            var val = origKey[k];\n            if (typeof val !== 'undefined') {\n              key[k] = normalizeKey(val);\n            }\n          }\n        }\n      }\n  }\n  return key;\n}\n\nfunction indexify(key) {\n  if (key !== null) {\n    switch (typeof key) {\n      case 'boolean':\n        return key ? 1 : 0;\n      case 'number':\n        return numToIndexableString(key);\n      case 'string':\n        // We've to be sure that key does not contain \\u0000\n        // Do order-preserving replacements:\n        // 0 -> 1, 1\n        // 1 -> 1, 2\n        // 2 -> 2, 2\n        return key\n          .replace(/\\u0002/g, '\\u0002\\u0002')\n          .replace(/\\u0001/g, '\\u0001\\u0002')\n          .replace(/\\u0000/g, '\\u0001\\u0001');\n      case 'object':\n        var isArray = Array.isArray(key);\n        var arr = isArray ? key : Object.keys(key);\n        var i = -1;\n        var len = arr.length;\n        var result = '';\n        if (isArray) {\n          while (++i < len) {\n            result += toIndexableString(arr[i]);\n          }\n        } else {\n          while (++i < len) {\n            var objKey = arr[i];\n            result += toIndexableString(objKey) +\n                toIndexableString(key[objKey]);\n          }\n        }\n        return result;\n    }\n  }\n  return '';\n}\n\n// convert the given key to a string that would be appropriate\n// for lexical sorting, e.g. within a database, where the\n// sorting is the same given by the collate() function.\nfunction toIndexableString(key) {\n  var zero = '\\u0000';\n  key = normalizeKey(key);\n  return collationIndex(key) + SEP + indexify(key) + zero;\n}\n\nfunction parseNumber(str, i) {\n  var originalIdx = i;\n  var num;\n  var zero = str[i] === '1';\n  if (zero) {\n    num = 0;\n    i++;\n  } else {\n    var neg = str[i] === '0';\n    i++;\n    var numAsString = '';\n    var magAsString = str.substring(i, i + MAGNITUDE_DIGITS);\n    var magnitude = parseInt(magAsString, 10) + MIN_MAGNITUDE;\n    /* istanbul ignore next */\n    if (neg) {\n      magnitude = -magnitude;\n    }\n    i += MAGNITUDE_DIGITS;\n    while (true) {\n      var ch = str[i];\n      if (ch === '\\u0000') {\n        break;\n      } else {\n        numAsString += ch;\n      }\n      i++;\n    }\n    numAsString = numAsString.split('.');\n    if (numAsString.length === 1) {\n      num = parseInt(numAsString, 10);\n    } else {\n      /* istanbul ignore next */\n      num = parseFloat(numAsString[0] + '.' + numAsString[1]);\n    }\n    /* istanbul ignore next */\n    if (neg) {\n      num = num - 10;\n    }\n    /* istanbul ignore next */\n    if (magnitude !== 0) {\n      // parseFloat is more reliable than pow due to rounding errors\n      // e.g. Number.MAX_VALUE would return Infinity if we did\n      // num * Math.pow(10, magnitude);\n      num = parseFloat(num + 'e' + magnitude);\n    }\n  }\n  return {num: num, length : i - originalIdx};\n}\n\n// move up the stack while parsing\n// this function moved outside of parseIndexableString for performance\nfunction pop(stack, metaStack) {\n  var obj = stack.pop();\n\n  if (metaStack.length) {\n    var lastMetaElement = metaStack[metaStack.length - 1];\n    if (obj === lastMetaElement.element) {\n      // popping a meta-element, e.g. an object whose value is another object\n      metaStack.pop();\n      lastMetaElement = metaStack[metaStack.length - 1];\n    }\n    var element = lastMetaElement.element;\n    var lastElementIndex = lastMetaElement.index;\n    if (Array.isArray(element)) {\n      element.push(obj);\n    } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n      var key = stack.pop();\n      element[key] = obj;\n    } else {\n      stack.push(obj); // obj with key only\n    }\n  }\n}\n\nfunction parseIndexableString(str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n\n  /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n  while (true) {\n    var collationIndex = str[i++];\n    if (collationIndex === '\\u0000') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case '1':\n        stack.push(null);\n        break;\n      case '2':\n        stack.push(str[i] === '1');\n        i++;\n        break;\n      case '3':\n        var parsedNum = parseNumber(str, i);\n        stack.push(parsedNum.num);\n        i += parsedNum.length;\n        break;\n      case '4':\n        var parsedStr = '';\n        /*eslint no-constant-condition: [\"error\", { \"checkLoops\": false }]*/\n        while (true) {\n          var ch = str[i];\n          if (ch === '\\u0000') {\n            break;\n          }\n          parsedStr += ch;\n          i++;\n        }\n        // perform the reverse of the order-preserving replacement\n        // algorithm (see above)\n        parsedStr = parsedStr.replace(/\\u0001\\u0001/g, '\\u0000')\n          .replace(/\\u0001\\u0002/g, '\\u0001')\n          .replace(/\\u0002\\u0002/g, '\\u0002');\n        stack.push(parsedStr);\n        break;\n      case '5':\n        var arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '6':\n        var objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      /* istanbul ignore next */\n      default:\n        throw new Error(\n          'bad collationIndex or unexpectedly reached end of input: ' +\n            collationIndex);\n    }\n  }\n}\n\nfunction arrayCollate(a, b) {\n  var len = Math.min(a.length, b.length);\n  for (var i = 0; i < len; i++) {\n    var sort = collate(a[i], b[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n  }\n  return (a.length === b.length) ? 0 :\n    (a.length > b.length) ? 1 : -1;\n}\nfunction stringCollate(a, b) {\n  // See: https://github.com/daleharvey/pouchdb/issues/40\n  // This is incompatible with the CouchDB implementation, but its the\n  // best we can do for now\n  return (a === b) ? 0 : ((a > b) ? 1 : -1);\n}\nfunction objectCollate(a, b) {\n  var ak = Object.keys(a), bk = Object.keys(b);\n  var len = Math.min(ak.length, bk.length);\n  for (var i = 0; i < len; i++) {\n    // First sort the keys\n    var sort = collate(ak[i], bk[i]);\n    if (sort !== 0) {\n      return sort;\n    }\n    // if the keys are equal sort the values\n    sort = collate(a[ak[i]], b[bk[i]]);\n    if (sort !== 0) {\n      return sort;\n    }\n\n  }\n  return (ak.length === bk.length) ? 0 :\n    (ak.length > bk.length) ? 1 : -1;\n}\n// The collation is defined by erlangs ordered terms\n// the atoms null, true, false come first, then numbers, strings,\n// arrays, then objects\n// null/undefined/NaN/Infinity/-Infinity are all considered null\nfunction collationIndex(x) {\n  var id = ['boolean', 'number', 'string', 'object'];\n  var idx = id.indexOf(typeof x);\n  //false if -1 otherwise true, but fast!!!!1\n  if (~idx) {\n    if (x === null) {\n      return 1;\n    }\n    if (Array.isArray(x)) {\n      return 5;\n    }\n    return idx < 3 ? (idx + 2) : (idx + 3);\n  }\n  /* istanbul ignore next */\n  if (Array.isArray(x)) {\n    return 5;\n  }\n}\n\n// conversion:\n// x yyy zz...zz\n// x = 0 for negative, 1 for 0, 2 for positive\n// y = exponent (for negative numbers negated) moved so that it's >= 0\n// z = mantisse\nfunction numToIndexableString(num) {\n\n  if (num === 0) {\n    return '1';\n  }\n\n  // convert number to exponential format for easier and\n  // more succinct string sorting\n  var expFormat = num.toExponential().split(/e\\+?/);\n  var magnitude = parseInt(expFormat[1], 10);\n\n  var neg = num < 0;\n\n  var result = neg ? '0' : '2';\n\n  // first sort by magnitude\n  // it's easier if all magnitudes are positive\n  var magForComparison = ((neg ? -magnitude : magnitude) - MIN_MAGNITUDE);\n  var magString = padLeft((magForComparison).toString(), '0', MAGNITUDE_DIGITS);\n\n  result += SEP + magString;\n\n  // then sort by the factor\n  var factor = Math.abs(parseFloat(expFormat[0])); // [1..10)\n  /* istanbul ignore next */\n  if (neg) { // for negative reverse ordering\n    factor = 10 - factor;\n  }\n\n  var factorStr = factor.toFixed(20);\n\n  // strip zeros from the end\n  factorStr = factorStr.replace(/\\.?0+$/, '');\n\n  result += SEP + factorStr;\n\n  return result;\n}\n\n/*\n * Simple task queue to sequentialize actions. Assumes\n * callbacks will eventually fire (once).\n */\n\nfunction TaskQueue$2() {\n  this.promise = new PouchPromise$1(function (fulfill) {fulfill(); });\n}\nTaskQueue$2.prototype.add = function (promiseFactory) {\n  this.promise = this.promise.catch(function () {\n    // just recover\n  }).then(function () {\n    return promiseFactory();\n  });\n  return this.promise;\n};\nTaskQueue$2.prototype.finish = function () {\n  return this.promise;\n};\n\nfunction createView(opts) {\n  var sourceDB = opts.db;\n  var viewName = opts.viewName;\n  var mapFun = opts.map;\n  var reduceFun = opts.reduce;\n  var temporary = opts.temporary;\n\n  // the \"undefined\" part is for backwards compatibility\n  var viewSignature = mapFun.toString() + (reduceFun && reduceFun.toString()) +\n    'undefined';\n\n  var cachedViews;\n  if (!temporary) {\n    // cache this to ensure we don't try to update the same view twice\n    cachedViews = sourceDB._cachedViews = sourceDB._cachedViews || {};\n    if (cachedViews[viewSignature]) {\n      return cachedViews[viewSignature];\n    }\n  }\n\n  var promiseForView = sourceDB.info().then(function (info) {\n\n    var depDbName = info.db_name + '-mrview-' +\n      (temporary ? 'temp' : stringMd5(viewSignature));\n\n    // save the view name in the source db so it can be cleaned up if necessary\n    // (e.g. when the _design doc is deleted, remove all associated view data)\n    function diffFunction(doc) {\n      doc.views = doc.views || {};\n      var fullViewName = viewName;\n      if (fullViewName.indexOf('/') === -1) {\n        fullViewName = viewName + '/' + viewName;\n      }\n      var depDbs = doc.views[fullViewName] = doc.views[fullViewName] || {};\n      /* istanbul ignore if */\n      if (depDbs[depDbName]) {\n        return; // no update necessary\n      }\n      depDbs[depDbName] = true;\n      return doc;\n    }\n    return upsert(sourceDB, '_local/mrviews', diffFunction).then(function () {\n      return sourceDB.registerDependentDatabase(depDbName).then(function (res) {\n        var db = res.db;\n        db.auto_compaction = true;\n        var view = {\n          name: depDbName,\n          db: db,\n          sourceDB: sourceDB,\n          adapter: sourceDB.adapter,\n          mapFun: mapFun,\n          reduceFun: reduceFun\n        };\n        return view.db.get('_local/lastSeq').catch(function (err) {\n          /* istanbul ignore if */\n          if (err.status !== 404) {\n            throw err;\n          }\n        }).then(function (lastSeqDoc) {\n          view.seq = lastSeqDoc ? lastSeqDoc.seq : 0;\n          if (cachedViews) {\n            view.db.once('destroyed', function () {\n              delete cachedViews[viewSignature];\n            });\n          }\n          return view;\n        });\n      });\n    });\n  });\n\n  if (cachedViews) {\n    cachedViews[viewSignature] = promiseForView;\n  }\n  return promiseForView;\n}\n\nfunction QueryParseError(message) {\n  this.status = 400;\n  this.name = 'query_parse_error';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, QueryParseError);\n  } catch (e) {}\n}\n\ninherits(QueryParseError, Error);\n\nfunction NotFoundError(message) {\n  this.status = 404;\n  this.name = 'not_found';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, NotFoundError);\n  } catch (e) {}\n}\n\ninherits(NotFoundError, Error);\n\nfunction BuiltInError(message) {\n  this.status = 500;\n  this.name = 'invalid_value';\n  this.message = message;\n  this.error = true;\n  try {\n    Error.captureStackTrace(this, BuiltInError);\n  } catch (e) {}\n}\n\ninherits(BuiltInError, Error);\n\nfunction createBuiltInError(name) {\n  var message = 'builtin ' + name +\n    ' function requires map values to be numbers' +\n    ' or number arrays';\n  return new BuiltInError(message);\n}\n\nfunction sum(values) {\n  var result = 0;\n  for (var i = 0, len = values.length; i < len; i++) {\n    var num = values[i];\n    if (typeof num !== 'number') {\n      if (Array.isArray(num)) {\n        // lists of numbers are also allowed, sum them separately\n        result = typeof result === 'number' ? [result] : result;\n        for (var j = 0, jLen = num.length; j < jLen; j++) {\n          var jNum = num[j];\n          if (typeof jNum !== 'number') {\n            throw createBuiltInError('_sum');\n          } else if (typeof result[j] === 'undefined') {\n            result.push(jNum);\n          } else {\n            result[j] += jNum;\n          }\n        }\n      } else { // not array/number\n        throw createBuiltInError('_sum');\n      }\n    } else if (typeof result === 'number') {\n      result += num;\n    } else { // add number to array\n      result[0] += num;\n    }\n  }\n  return result;\n}\n\nvar log$2 = guardedConsole.bind(null, 'log');\nvar isArray = Array.isArray;\nvar toJSON = JSON.parse;\n\nfunction evalFunctionWithEval(func, emit) {\n  return scopedEval(\n    \"return (\" + func.replace(/;\\s*$/, \"\") + \");\",\n    {\n      emit: emit,\n      sum: sum,\n      log: log$2,\n      isArray: isArray,\n      toJSON: toJSON\n    }\n  );\n}\n\nfunction promisedCallback(promise, callback) {\n  if (callback) {\n    promise.then(function (res) {\n      nextTick(function () {\n        callback(null, res);\n      });\n    }, function (reason) {\n      nextTick(function () {\n        callback(reason);\n      });\n    });\n  }\n  return promise;\n}\n\nfunction callbackify(fun) {\n  return getArguments(function (args) {\n    var cb = args.pop();\n    var promise = fun.apply(this, args);\n    if (typeof cb === 'function') {\n      promisedCallback(promise, cb);\n    }\n    return promise;\n  });\n}\n\n// Promise finally util similar to Q.finally\nfunction fin(promise, finalPromiseFactory) {\n  return promise.then(function (res) {\n    return finalPromiseFactory().then(function () {\n      return res;\n    });\n  }, function (reason) {\n    return finalPromiseFactory().then(function () {\n      throw reason;\n    });\n  });\n}\n\nfunction sequentialize(queue, promiseFactory) {\n  return function () {\n    var args = arguments;\n    var that = this;\n    return queue.add(function () {\n      return promiseFactory.apply(that, args);\n    });\n  };\n}\n\n// uniq an array of strings, order not guaranteed\n// similar to underscore/lodash _.uniq\nfunction uniq(arr) {\n  var theSet = new ExportedSet(arr);\n  var result = new Array(theSet.size);\n  var index = -1;\n  theSet.forEach(function (value) {\n    result[++index] = value;\n  });\n  return result;\n}\n\nfunction mapToKeysArray(map) {\n  var result = new Array(map.size);\n  var index = -1;\n  map.forEach(function (value, key) {\n    result[++index] = key;\n  });\n  return result;\n}\n\nvar persistentQueues = {};\nvar tempViewQueue = new TaskQueue$2();\nvar CHANGES_BATCH_SIZE$1 = 50;\n\nfunction parseViewName(name) {\n  // can be either 'ddocname/viewname' or just 'viewname'\n  // (where the ddoc name is the same)\n  return name.indexOf('/') === -1 ? [name, name] : name.split('/');\n}\n\nfunction isGenOne(changes) {\n  // only return true if the current change is 1-\n  // and there are no other leafs\n  return changes.length === 1 && /^1-/.test(changes[0].rev);\n}\n\nfunction emitError(db, e) {\n  try {\n    db.emit('error', e);\n  } catch (err) {\n    guardedConsole('error',\n      'The user\\'s map/reduce function threw an uncaught error.\\n' +\n      'You can debug this error by doing:\\n' +\n      'myDatabase.on(\\'error\\', function (err) { debugger; });\\n' +\n      'Please double-check your map/reduce function.');\n    guardedConsole('error', e);\n  }\n}\nfunction tryMap(db, fun, doc) {\n  // emit an event if there was an error thrown by a map function.\n  // putting try/catches in a single function also avoids deoptimizations.\n  try {\n    fun(doc);\n  } catch (e) {\n    emitError(db, e);\n  }\n}\n\nfunction tryReduce(db, fun, keys, values, rereduce) {\n  // same as above, but returning the result or an error. there are two separate\n  // functions to avoid extra memory allocations since the tryCode() case is used\n  // for custom map functions (common) vs this function, which is only used for\n  // custom reduce functions (rare)\n  try {\n    return {output : fun(keys, values, rereduce)};\n  } catch (e) {\n    emitError(db, e);\n    return {error: e};\n  }\n}\n\nfunction sortByKeyThenValue(x, y) {\n  var keyCompare = collate(x.key, y.key);\n  return keyCompare !== 0 ? keyCompare : collate(x.value, y.value);\n}\n\nfunction sliceResults(results, limit, skip) {\n  skip = skip || 0;\n  if (typeof limit === 'number') {\n    return results.slice(skip, limit + skip);\n  } else if (skip > 0) {\n    return results.slice(skip);\n  }\n  return results;\n}\n\nfunction rowToDocId(row) {\n  var val = row.value;\n  // Users can explicitly specify a joined doc _id, or it\n  // defaults to the doc _id that emitted the key/value.\n  var docId = (val && typeof val === 'object' && val._id) || row.id;\n  return docId;\n}\n\nfunction readAttachmentsAsBlobOrBuffer$1(res) {\n  res.rows.forEach(function (row) {\n    var atts = row.doc && row.doc._attachments;\n    if (!atts) {\n      return;\n    }\n    Object.keys(atts).forEach(function (filename) {\n      var att = atts[filename];\n      atts[filename].data = b64ToBluffer(att.data, att.content_type);\n    });\n  });\n}\n\nfunction postprocessAttachments(opts) {\n  return function (res) {\n    if (opts.include_docs && opts.attachments && opts.binary) {\n      readAttachmentsAsBlobOrBuffer$1(res);\n    }\n    return res;\n  };\n}\n\nvar builtInReduce = {\n  _sum: function (keys, values) {\n    return sum(values);\n  },\n\n  _count: function (keys, values) {\n    return values.length;\n  },\n\n  _stats: function (keys, values) {\n    // no need to implement rereduce=true, because Pouch\n    // will never call it\n    function sumsqr(values) {\n      var _sumsqr = 0;\n      for (var i = 0, len = values.length; i < len; i++) {\n        var num = values[i];\n        _sumsqr += (num * num);\n      }\n      return _sumsqr;\n    }\n    return {\n      sum     : sum(values),\n      min     : Math.min.apply(null, values),\n      max     : Math.max.apply(null, values),\n      count   : values.length,\n      sumsqr : sumsqr(values)\n    };\n  }\n};\n\nfunction addHttpParam(paramName, opts, params, asJson) {\n  // add an http param from opts to params, optionally json-encoded\n  var val = opts[paramName];\n  if (typeof val !== 'undefined') {\n    if (asJson) {\n      val = encodeURIComponent(JSON.stringify(val));\n    }\n    params.push(paramName + '=' + val);\n  }\n}\n\nfunction coerceInteger(integerCandidate) {\n  if (typeof integerCandidate !== 'undefined') {\n    var asNumber = Number(integerCandidate);\n    // prevents e.g. '1foo' or '1.1' being coerced to 1\n    if (!isNaN(asNumber) && asNumber === parseInt(integerCandidate, 10)) {\n      return asNumber;\n    } else {\n      return integerCandidate;\n    }\n  }\n}\n\nfunction coerceOptions(opts) {\n  opts.group_level = coerceInteger(opts.group_level);\n  opts.limit = coerceInteger(opts.limit);\n  opts.skip = coerceInteger(opts.skip);\n  return opts;\n}\n\nfunction checkPositiveInteger(number) {\n  if (number) {\n    if (typeof number !== 'number') {\n      return  new QueryParseError('Invalid value for integer: \"' +\n      number + '\"');\n    }\n    if (number < 0) {\n      return new QueryParseError('Invalid value for positive integer: ' +\n        '\"' + number + '\"');\n    }\n  }\n}\n\nfunction checkQueryParseError(options, fun) {\n  var startkeyName = options.descending ? 'endkey' : 'startkey';\n  var endkeyName = options.descending ? 'startkey' : 'endkey';\n\n  if (typeof options[startkeyName] !== 'undefined' &&\n    typeof options[endkeyName] !== 'undefined' &&\n    collate(options[startkeyName], options[endkeyName]) > 0) {\n    throw new QueryParseError('No rows can match your key range, ' +\n    'reverse your start_key and end_key or set {descending : true}');\n  } else if (fun.reduce && options.reduce !== false) {\n    if (options.include_docs) {\n      throw new QueryParseError('{include_docs:true} is invalid for reduce');\n    } else if (options.keys && options.keys.length > 1 &&\n        !options.group && !options.group_level) {\n      throw new QueryParseError('Multi-key fetches for reduce views must use ' +\n      '{group: true}');\n    }\n  }\n  ['group_level', 'limit', 'skip'].forEach(function (optionName) {\n    var error = checkPositiveInteger(options[optionName]);\n    if (error) {\n      throw error;\n    }\n  });\n}\n\nfunction httpQuery(db, fun, opts) {\n  // List of parameters to add to the PUT request\n  var params = [];\n  var body;\n  var method = 'GET';\n\n  // If opts.reduce exists and is defined, then add it to the list\n  // of parameters.\n  // If reduce=false then the results are that of only the map function\n  // not the final result of map and reduce.\n  addHttpParam('reduce', opts, params);\n  addHttpParam('include_docs', opts, params);\n  addHttpParam('attachments', opts, params);\n  addHttpParam('limit', opts, params);\n  addHttpParam('descending', opts, params);\n  addHttpParam('group', opts, params);\n  addHttpParam('group_level', opts, params);\n  addHttpParam('skip', opts, params);\n  addHttpParam('stale', opts, params);\n  addHttpParam('conflicts', opts, params);\n  addHttpParam('startkey', opts, params, true);\n  addHttpParam('start_key', opts, params, true);\n  addHttpParam('endkey', opts, params, true);\n  addHttpParam('end_key', opts, params, true);\n  addHttpParam('inclusive_end', opts, params);\n  addHttpParam('key', opts, params, true);\n\n  // Format the list of parameters into a valid URI query string\n  params = params.join('&');\n  params = params === '' ? '' : '?' + params;\n\n  // If keys are supplied, issue a POST to circumvent GET query string limits\n  // see http://wiki.apache.org/couchdb/HTTP_view_API#Querying_Options\n  if (typeof opts.keys !== 'undefined') {\n    var MAX_URL_LENGTH = 2000;\n    // according to http://stackoverflow.com/a/417184/680742,\n    // the de facto URL length limit is 2000 characters\n\n    var keysAsString =\n      'keys=' + encodeURIComponent(JSON.stringify(opts.keys));\n    if (keysAsString.length + params.length + 1 <= MAX_URL_LENGTH) {\n      // If the keys are short enough, do a GET. we do this to work around\n      // Safari not understanding 304s on POSTs (see pouchdb/pouchdb#1239)\n      params += (params[0] === '?' ? '&' : '?') + keysAsString;\n    } else {\n      method = 'POST';\n      if (typeof fun === 'string') {\n        body = {keys: opts.keys};\n      } else { // fun is {map : mapfun}, so append to this\n        fun.keys = opts.keys;\n      }\n    }\n  }\n\n  // We are referencing a query defined in the design doc\n  if (typeof fun === 'string') {\n    var parts = parseViewName(fun);\n    return db.request({\n      method: method,\n      url: '_design/' + parts[0] + '/_view/' + parts[1] + params,\n      body: body\n    }).then(postprocessAttachments(opts));\n  }\n\n  // We are using a temporary view, terrible for performance, good for testing\n  body = body || {};\n  Object.keys(fun).forEach(function (key) {\n    if (Array.isArray(fun[key])) {\n      body[key] = fun[key];\n    } else {\n      body[key] = fun[key].toString();\n    }\n  });\n  return db.request({\n    method: 'POST',\n    url: '_temp_view' + params,\n    body: body\n  }).then(postprocessAttachments(opts));\n}\n\n// custom adapters can define their own api._query\n// and override the default behavior\n/* istanbul ignore next */\nfunction customQuery(db, fun, opts) {\n  return new PouchPromise$1(function (resolve, reject) {\n    db._query(fun, opts, function (err, res) {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n}\n\n// custom adapters can define their own api._viewCleanup\n// and override the default behavior\n/* istanbul ignore next */\nfunction customViewCleanup(db) {\n  return new PouchPromise$1(function (resolve, reject) {\n    db._viewCleanup(function (err, res) {\n      if (err) {\n        return reject(err);\n      }\n      resolve(res);\n    });\n  });\n}\n\nfunction defaultsTo(value) {\n  return function (reason) {\n    /* istanbul ignore else */\n    if (reason.status === 404) {\n      return value;\n    } else {\n      throw reason;\n    }\n  };\n}\n\n// returns a promise for a list of docs to update, based on the input docId.\n// the order doesn't matter, because post-3.2.0, bulkDocs\n// is an atomic operation in all three adapters.\nfunction getDocsToPersist(docId, view, docIdsToChangesAndEmits) {\n  var metaDocId = '_local/doc_' + docId;\n  var defaultMetaDoc = {_id: metaDocId, keys: []};\n  var docData = docIdsToChangesAndEmits.get(docId);\n  var indexableKeysToKeyValues = docData[0];\n  var changes = docData[1];\n\n  function getMetaDoc() {\n    if (isGenOne(changes)) {\n      // generation 1, so we can safely assume initial state\n      // for performance reasons (avoids unnecessary GETs)\n      return PouchPromise$1.resolve(defaultMetaDoc);\n    }\n    return view.db.get(metaDocId).catch(defaultsTo(defaultMetaDoc));\n  }\n\n  function getKeyValueDocs(metaDoc) {\n    if (!metaDoc.keys.length) {\n      // no keys, no need for a lookup\n      return PouchPromise$1.resolve({rows: []});\n    }\n    return view.db.allDocs({\n      keys: metaDoc.keys,\n      include_docs: true\n    });\n  }\n\n  function processKeyValueDocs(metaDoc, kvDocsRes) {\n    var kvDocs = [];\n    var oldKeys = new ExportedSet();\n\n    for (var i = 0, len = kvDocsRes.rows.length; i < len; i++) {\n      var row = kvDocsRes.rows[i];\n      var doc = row.doc;\n      if (!doc) { // deleted\n        continue;\n      }\n      kvDocs.push(doc);\n      oldKeys.add(doc._id);\n      doc._deleted = !indexableKeysToKeyValues.has(doc._id);\n      if (!doc._deleted) {\n        var keyValue = indexableKeysToKeyValues.get(doc._id);\n        if ('value' in keyValue) {\n          doc.value = keyValue.value;\n        }\n      }\n    }\n    var newKeys = mapToKeysArray(indexableKeysToKeyValues);\n    newKeys.forEach(function (key) {\n      if (!oldKeys.has(key)) {\n        // new doc\n        var kvDoc = {\n          _id: key\n        };\n        var keyValue = indexableKeysToKeyValues.get(key);\n        if ('value' in keyValue) {\n          kvDoc.value = keyValue.value;\n        }\n        kvDocs.push(kvDoc);\n      }\n    });\n    metaDoc.keys = uniq(newKeys.concat(metaDoc.keys));\n    kvDocs.push(metaDoc);\n\n    return kvDocs;\n  }\n\n  return getMetaDoc().then(function (metaDoc) {\n    return getKeyValueDocs(metaDoc).then(function (kvDocsRes) {\n      return processKeyValueDocs(metaDoc, kvDocsRes);\n    });\n  });\n}\n\n// updates all emitted key/value docs and metaDocs in the mrview database\n// for the given batch of documents from the source database\nfunction saveKeyValues(view, docIdsToChangesAndEmits, seq) {\n  var seqDocId = '_local/lastSeq';\n  return view.db.get(seqDocId)\n  .catch(defaultsTo({_id: seqDocId, seq: 0}))\n  .then(function (lastSeqDoc) {\n    var docIds = mapToKeysArray(docIdsToChangesAndEmits);\n    return PouchPromise$1.all(docIds.map(function (docId) {\n      return getDocsToPersist(docId, view, docIdsToChangesAndEmits);\n    })).then(function (listOfDocsToPersist) {\n      var docsToPersist = flatten(listOfDocsToPersist);\n      lastSeqDoc.seq = seq;\n      docsToPersist.push(lastSeqDoc);\n      // write all docs in a single operation, update the seq once\n      return view.db.bulkDocs({docs : docsToPersist});\n    });\n  });\n}\n\nfunction getQueue(view) {\n  var viewName = typeof view === 'string' ? view : view.name;\n  var queue = persistentQueues[viewName];\n  if (!queue) {\n    queue = persistentQueues[viewName] = new TaskQueue$2();\n  }\n  return queue;\n}\n\nfunction updateView(view) {\n  return sequentialize(getQueue(view), function () {\n    return updateViewInQueue(view);\n  })();\n}\n\nfunction updateViewInQueue(view) {\n  // bind the emit function once\n  var mapResults;\n  var doc;\n\n  function emit(key, value) {\n    var output = {id: doc._id, key: normalizeKey(key)};\n    // Don't explicitly store the value unless it's defined and non-null.\n    // This saves on storage space, because often people don't use it.\n    if (typeof value !== 'undefined' && value !== null) {\n      output.value = normalizeKey(value);\n    }\n    mapResults.push(output);\n  }\n\n  var mapFun;\n  // for temp_views one can use emit(doc, emit), see #38\n  if (typeof view.mapFun === \"function\" && view.mapFun.length === 2) {\n    var origMap = view.mapFun;\n    mapFun = function (doc) {\n      return origMap(doc, emit);\n    };\n  } else {\n    mapFun = evalFunctionWithEval(view.mapFun.toString(), emit);\n  }\n\n  var currentSeq = view.seq || 0;\n\n  function processChange(docIdsToChangesAndEmits, seq) {\n    return function () {\n      return saveKeyValues(view, docIdsToChangesAndEmits, seq);\n    };\n  }\n\n  var queue = new TaskQueue$2();\n\n  function processNextBatch() {\n    return view.sourceDB.changes({\n      conflicts: true,\n      include_docs: true,\n      style: 'all_docs',\n      since: currentSeq,\n      limit: CHANGES_BATCH_SIZE$1\n    }).then(processBatch);\n  }\n\n  function processBatch(response) {\n    var results = response.results;\n    if (!results.length) {\n      return;\n    }\n    var docIdsToChangesAndEmits = createDocIdsToChangesAndEmits(results);\n    queue.add(processChange(docIdsToChangesAndEmits, currentSeq));\n    if (results.length < CHANGES_BATCH_SIZE$1) {\n      return;\n    }\n    return processNextBatch();\n  }\n\n  function createDocIdsToChangesAndEmits(results) {\n    var docIdsToChangesAndEmits = new ExportedMap();\n    for (var i = 0, len = results.length; i < len; i++) {\n      var change = results[i];\n      if (change.doc._id[0] !== '_') {\n        mapResults = [];\n        doc = change.doc;\n\n        if (!doc._deleted) {\n          tryMap(view.sourceDB, mapFun, doc);\n        }\n        mapResults.sort(sortByKeyThenValue);\n\n        var indexableKeysToKeyValues = createIndexableKeysToKeyValues(mapResults);\n        docIdsToChangesAndEmits.set(change.doc._id, [\n          indexableKeysToKeyValues,\n          change.changes\n        ]);\n      }\n      currentSeq = change.seq;\n    }\n    return docIdsToChangesAndEmits;\n  }\n\n  function createIndexableKeysToKeyValues(mapResults) {\n    var indexableKeysToKeyValues = new ExportedMap();\n    var lastKey;\n    for (var i = 0, len = mapResults.length; i < len; i++) {\n      var emittedKeyValue = mapResults[i];\n      var complexKey = [emittedKeyValue.key, emittedKeyValue.id];\n      if (i > 0 && collate(emittedKeyValue.key, lastKey) === 0) {\n        complexKey.push(i); // dup key+id, so make it unique\n      }\n      indexableKeysToKeyValues.set(toIndexableString(complexKey), emittedKeyValue);\n      lastKey = emittedKeyValue.key;\n    }\n    return indexableKeysToKeyValues;\n  }\n\n  return processNextBatch().then(function () {\n    return queue.finish();\n  }).then(function () {\n    view.seq = currentSeq;\n  });\n}\n\nfunction reduceView(view, results, options) {\n  if (options.group_level === 0) {\n    delete options.group_level;\n  }\n\n  var shouldGroup = options.group || options.group_level;\n\n  var reduceFun;\n  if (builtInReduce[view.reduceFun]) {\n    reduceFun = builtInReduce[view.reduceFun];\n  } else {\n    reduceFun = evalFunctionWithEval(view.reduceFun.toString());\n  }\n\n  var groups = [];\n  var lvl = isNaN(options.group_level) ? Number.POSITIVE_INFINITY :\n    options.group_level;\n  results.forEach(function (e) {\n    var last = groups[groups.length - 1];\n    var groupKey = shouldGroup ? e.key : null;\n\n    // only set group_level for array keys\n    if (shouldGroup && Array.isArray(groupKey)) {\n      groupKey = groupKey.slice(0, lvl);\n    }\n\n    if (last && collate(last.groupKey, groupKey) === 0) {\n      last.keys.push([e.key, e.id]);\n      last.values.push(e.value);\n      return;\n    }\n    groups.push({\n      keys: [[e.key, e.id]],\n      values: [e.value],\n      groupKey: groupKey\n    });\n  });\n  results = [];\n  for (var i = 0, len = groups.length; i < len; i++) {\n    var e = groups[i];\n    var reduceTry = tryReduce(view.sourceDB, reduceFun, e.keys, e.values, false);\n    if (reduceTry.error && reduceTry.error instanceof BuiltInError) {\n      // CouchDB returns an error if a built-in errors out\n      throw reduceTry.error;\n    }\n    results.push({\n      // CouchDB just sets the value to null if a non-built-in errors out\n      value: reduceTry.error ? null : reduceTry.output,\n      key: e.groupKey\n    });\n  }\n  // no total_rows/offset when reducing\n  return {rows: sliceResults(results, options.limit, options.skip)};\n}\n\nfunction queryView(view, opts) {\n  return sequentialize(getQueue(view), function () {\n    return queryViewInQueue(view, opts);\n  })();\n}\n\nfunction queryViewInQueue(view, opts) {\n  var totalRows;\n  var shouldReduce = view.reduceFun && opts.reduce !== false;\n  var skip = opts.skip || 0;\n  if (typeof opts.keys !== 'undefined' && !opts.keys.length) {\n    // equivalent query\n    opts.limit = 0;\n    delete opts.keys;\n  }\n\n  function fetchFromView(viewOpts) {\n    viewOpts.include_docs = true;\n    return view.db.allDocs(viewOpts).then(function (res) {\n      totalRows = res.total_rows;\n      return res.rows.map(function (result) {\n\n        // implicit migration - in older versions of PouchDB,\n        // we explicitly stored the doc as {id: ..., key: ..., value: ...}\n        // this is tested in a migration test\n        /* istanbul ignore next */\n        if ('value' in result.doc && typeof result.doc.value === 'object' &&\n            result.doc.value !== null) {\n          var keys = Object.keys(result.doc.value).sort();\n          // this detection method is not perfect, but it's unlikely the user\n          // emitted a value which was an object with these 3 exact keys\n          var expectedKeys = ['id', 'key', 'value'];\n          if (!(keys < expectedKeys || keys > expectedKeys)) {\n            return result.doc.value;\n          }\n        }\n\n        var parsedKeyAndDocId = parseIndexableString(result.doc._id);\n        return {\n          key: parsedKeyAndDocId[0],\n          id: parsedKeyAndDocId[1],\n          value: ('value' in result.doc ? result.doc.value : null)\n        };\n      });\n    });\n  }\n\n  function onMapResultsReady(rows) {\n    var finalResults;\n    if (shouldReduce) {\n      finalResults = reduceView(view, rows, opts);\n    } else {\n      finalResults = {\n        total_rows: totalRows,\n        offset: skip,\n        rows: rows\n      };\n    }\n    if (opts.include_docs) {\n      var docIds = uniq(rows.map(rowToDocId));\n\n      return view.sourceDB.allDocs({\n        keys: docIds,\n        include_docs: true,\n        conflicts: opts.conflicts,\n        attachments: opts.attachments,\n        binary: opts.binary\n      }).then(function (allDocsRes) {\n        var docIdsToDocs = new ExportedMap();\n        allDocsRes.rows.forEach(function (row) {\n          docIdsToDocs.set(row.id, row.doc);\n        });\n        rows.forEach(function (row) {\n          var docId = rowToDocId(row);\n          var doc = docIdsToDocs.get(docId);\n          if (doc) {\n            row.doc = doc;\n          }\n        });\n        return finalResults;\n      });\n    } else {\n      return finalResults;\n    }\n  }\n\n  if (typeof opts.keys !== 'undefined') {\n    var keys = opts.keys;\n    var fetchPromises = keys.map(function (key) {\n      var viewOpts = {\n        startkey : toIndexableString([key]),\n        endkey   : toIndexableString([key, {}])\n      };\n      return fetchFromView(viewOpts);\n    });\n    return PouchPromise$1.all(fetchPromises).then(flatten).then(onMapResultsReady);\n  } else { // normal query, no 'keys'\n    var viewOpts = {\n      descending : opts.descending\n    };\n    if (opts.start_key) {\n        opts.startkey = opts.start_key;\n    }\n    if (opts.end_key) {\n        opts.endkey = opts.end_key;\n    }\n    if (typeof opts.startkey !== 'undefined') {\n      viewOpts.startkey = opts.descending ?\n        toIndexableString([opts.startkey, {}]) :\n        toIndexableString([opts.startkey]);\n    }\n    if (typeof opts.endkey !== 'undefined') {\n      var inclusiveEnd = opts.inclusive_end !== false;\n      if (opts.descending) {\n        inclusiveEnd = !inclusiveEnd;\n      }\n\n      viewOpts.endkey = toIndexableString(\n        inclusiveEnd ? [opts.endkey, {}] : [opts.endkey]);\n    }\n    if (typeof opts.key !== 'undefined') {\n      var keyStart = toIndexableString([opts.key]);\n      var keyEnd = toIndexableString([opts.key, {}]);\n      if (viewOpts.descending) {\n        viewOpts.endkey = keyStart;\n        viewOpts.startkey = keyEnd;\n      } else {\n        viewOpts.startkey = keyStart;\n        viewOpts.endkey = keyEnd;\n      }\n    }\n    if (!shouldReduce) {\n      if (typeof opts.limit === 'number') {\n        viewOpts.limit = opts.limit;\n      }\n      viewOpts.skip = skip;\n    }\n    return fetchFromView(viewOpts).then(onMapResultsReady);\n  }\n}\n\nfunction httpViewCleanup(db) {\n  return db.request({\n    method: 'POST',\n    url: '_view_cleanup'\n  });\n}\n\nfunction localViewCleanup(db) {\n  return db.get('_local/mrviews').then(function (metaDoc) {\n    var docsToViews = new ExportedMap();\n    Object.keys(metaDoc.views).forEach(function (fullViewName) {\n      var parts = parseViewName(fullViewName);\n      var designDocName = '_design/' + parts[0];\n      var viewName = parts[1];\n      var views = docsToViews.get(designDocName);\n      if (!views) {\n        views = new ExportedSet();\n        docsToViews.set(designDocName, views);\n      }\n      views.add(viewName);\n    });\n    var opts = {\n      keys : mapToKeysArray(docsToViews),\n      include_docs : true\n    };\n    return db.allDocs(opts).then(function (res) {\n      var viewsToStatus = {};\n      res.rows.forEach(function (row) {\n        var ddocName = row.key.substring(8); // cuts off '_design/'\n        docsToViews.get(row.key).forEach(function (viewName) {\n          var fullViewName = ddocName + '/' + viewName;\n          /* istanbul ignore if */\n          if (!metaDoc.views[fullViewName]) {\n            // new format, without slashes, to support PouchDB 2.2.0\n            // migration test in pouchdb's browser.migration.js verifies this\n            fullViewName = viewName;\n          }\n          var viewDBNames = Object.keys(metaDoc.views[fullViewName]);\n          // design doc deleted, or view function nonexistent\n          var statusIsGood = row.doc && row.doc.views &&\n            row.doc.views[viewName];\n          viewDBNames.forEach(function (viewDBName) {\n            viewsToStatus[viewDBName] =\n              viewsToStatus[viewDBName] || statusIsGood;\n          });\n        });\n      });\n      var dbsToDelete = Object.keys(viewsToStatus).filter(\n        function (viewDBName) { return !viewsToStatus[viewDBName]; });\n      var destroyPromises = dbsToDelete.map(function (viewDBName) {\n        return sequentialize(getQueue(viewDBName), function () {\n          return new db.constructor(viewDBName, db.__opts).destroy();\n        })();\n      });\n      return PouchPromise$1.all(destroyPromises).then(function () {\n        return {ok: true};\n      });\n    });\n  }, defaultsTo({ok: true}));\n}\n\nvar viewCleanup = callbackify(function () {\n  var db = this;\n  if (db.type() === 'http') {\n    return httpViewCleanup(db);\n  }\n  /* istanbul ignore next */\n  if (typeof db._viewCleanup === 'function') {\n    return customViewCleanup(db);\n  }\n  return localViewCleanup(db);\n});\n\nfunction queryPromised(db, fun, opts) {\n  if (db.type() === 'http') {\n    return httpQuery(db, fun, opts);\n  }\n\n  /* istanbul ignore next */\n  if (typeof db._query === 'function') {\n    return customQuery(db, fun, opts);\n  }\n\n  if (typeof fun !== 'string') {\n    // temp_view\n    checkQueryParseError(opts, fun);\n\n    var createViewOpts = {\n      db : db,\n      viewName : 'temp_view/temp_view',\n      map : fun.map,\n      reduce : fun.reduce,\n      temporary : true\n    };\n    tempViewQueue.add(function () {\n      return createView(createViewOpts).then(function (view) {\n        function cleanup() {\n          return view.db.destroy();\n        }\n        return fin(updateView(view).then(function () {\n          return queryView(view, opts);\n        }), cleanup);\n      });\n    });\n    return tempViewQueue.finish();\n  } else {\n    // persistent view\n    var fullViewName = fun;\n    var parts = parseViewName(fullViewName);\n    var designDocName = parts[0];\n    var viewName = parts[1];\n    return db.get('_design/' + designDocName).then(function (doc) {\n      var fun = doc.views && doc.views[viewName];\n\n      if (!fun || typeof fun.map !== 'string') {\n        throw new NotFoundError('ddoc ' + designDocName +\n        ' has no view named ' + viewName);\n      }\n      checkQueryParseError(opts, fun);\n\n      var createViewOpts = {\n        db : db,\n        viewName : fullViewName,\n        map : fun.map,\n        reduce : fun.reduce\n      };\n      return createView(createViewOpts).then(function (view) {\n        if (opts.stale === 'ok' || opts.stale === 'update_after') {\n          if (opts.stale === 'update_after') {\n            nextTick(function () {\n              updateView(view);\n            });\n          }\n          return queryView(view, opts);\n        } else { // stale not ok\n          return updateView(view).then(function () {\n            return queryView(view, opts);\n          });\n        }\n      });\n    });\n  }\n}\n\nvar query = function (fun, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  opts = opts ? coerceOptions(opts) : {};\n\n  if (typeof fun === 'function') {\n    fun = {map : fun};\n  }\n\n  var db = this;\n  var promise = PouchPromise$1.resolve().then(function () {\n    return queryPromised(db, fun, opts);\n  });\n  promisedCallback(promise, callback);\n  return promise;\n};\n\n\nvar mapreduce = {\n  query: query,\n  viewCleanup: viewCleanup\n};\n\nfunction isGenOne$1(rev) {\n  return /^1-/.test(rev);\n}\n\nfunction fileHasChanged(localDoc, remoteDoc, filename) {\n  return !localDoc._attachments ||\n         !localDoc._attachments[filename] ||\n         localDoc._attachments[filename].digest !== remoteDoc._attachments[filename].digest;\n}\n\nfunction getDocAttachments(db, doc) {\n  var filenames = Object.keys(doc._attachments);\n  return PouchPromise$1.all(filenames.map(function (filename) {\n    return db.getAttachment(doc._id, filename, {rev: doc._rev});\n  }));\n}\n\nfunction getDocAttachmentsFromTargetOrSource(target, src, doc) {\n  var doCheckForLocalAttachments = src.type() === 'http' && target.type() !== 'http';\n  var filenames = Object.keys(doc._attachments);\n\n  if (!doCheckForLocalAttachments) {\n    return getDocAttachments(src, doc);\n  }\n\n  return target.get(doc._id).then(function (localDoc) {\n    return PouchPromise$1.all(filenames.map(function (filename) {\n      if (fileHasChanged(localDoc, doc, filename)) {\n        return src.getAttachment(doc._id, filename);\n      }\n\n      return target.getAttachment(localDoc._id, filename);\n    }));\n  }).catch(function (error) {\n    /* istanbul ignore if */\n    if (error.status !== 404) {\n      throw error;\n    }\n\n    return getDocAttachments(src, doc);\n  });\n}\n\nfunction createBulkGetOpts(diffs) {\n  var requests = [];\n  Object.keys(diffs).forEach(function (id) {\n    var missingRevs = diffs[id].missing;\n    missingRevs.forEach(function (missingRev) {\n      requests.push({\n        id: id,\n        rev: missingRev\n      });\n    });\n  });\n\n  return {\n    docs: requests,\n    revs: true,\n    latest: true\n  };\n}\n\n//\n// Fetch all the documents from the src as described in the \"diffs\",\n// which is a mapping of docs IDs to revisions. If the state ever\n// changes to \"cancelled\", then the returned promise will be rejected.\n// Else it will be resolved with a list of fetched documents.\n//\nfunction getDocs(src, target, diffs, state) {\n  diffs = clone(diffs); // we do not need to modify this\n\n  var resultDocs = [],\n      ok = true;\n\n  function getAllDocs() {\n\n    var bulkGetOpts = createBulkGetOpts(diffs);\n\n    if (!bulkGetOpts.docs.length) { // optimization: skip empty requests\n      return;\n    }\n\n    return src.bulkGet(bulkGetOpts).then(function (bulkGetResponse) {\n      /* istanbul ignore if */\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      return PouchPromise$1.all(bulkGetResponse.results.map(function (bulkGetInfo) {\n        return PouchPromise$1.all(bulkGetInfo.docs.map(function (doc) {\n          var remoteDoc = doc.ok;\n\n          if (doc.error) {\n            // when AUTO_COMPACTION is set, docs can be returned which look\n            // like this: {\"missing\":\"1-7c3ac256b693c462af8442f992b83696\"}\n            ok = false;\n          }\n\n          if (!remoteDoc || !remoteDoc._attachments) {\n            return remoteDoc;\n          }\n\n          return getDocAttachmentsFromTargetOrSource(target, src, remoteDoc).then(function (attachments) {\n            var filenames = Object.keys(remoteDoc._attachments);\n            attachments.forEach(function (attachment, i) {\n              var att = remoteDoc._attachments[filenames[i]];\n              delete att.stub;\n              delete att.length;\n              att.data = attachment;\n            });\n\n            return remoteDoc;\n          });\n        }));\n      }))\n\n      .then(function (results) {\n        resultDocs = resultDocs.concat(flatten(results).filter(Boolean));\n      });\n    });\n  }\n\n  function hasAttachments(doc) {\n    return doc._attachments && Object.keys(doc._attachments).length > 0;\n  }\n\n  function hasConflicts(doc) {\n    return doc._conflicts && doc._conflicts.length > 0;\n  }\n\n  function fetchRevisionOneDocs(ids) {\n    // Optimization: fetch gen-1 docs and attachments in\n    // a single request using _all_docs\n    return src.allDocs({\n      keys: ids,\n      include_docs: true,\n      conflicts: true\n    }).then(function (res) {\n      if (state.cancelled) {\n        throw new Error('cancelled');\n      }\n      res.rows.forEach(function (row) {\n        if (row.deleted || !row.doc || !isGenOne$1(row.value.rev) ||\n            hasAttachments(row.doc) || hasConflicts(row.doc)) {\n          // if any of these conditions apply, we need to fetch using get()\n          return;\n        }\n\n        // strip _conflicts array to appease CSG (#5793)\n        /* istanbul ignore if */\n        if (row.doc._conflicts) {\n          delete row.doc._conflicts;\n        }\n\n        // the doc we got back from allDocs() is sufficient\n        resultDocs.push(row.doc);\n        delete diffs[row.id];\n      });\n    });\n  }\n\n  function getRevisionOneDocs() {\n    // filter out the generation 1 docs and get them\n    // leaving the non-generation one docs to be got otherwise\n    var ids = Object.keys(diffs).filter(function (id) {\n      var missing = diffs[id].missing;\n      return missing.length === 1 && isGenOne$1(missing[0]);\n    });\n    if (ids.length > 0) {\n      return fetchRevisionOneDocs(ids);\n    }\n  }\n\n  function returnResult() {\n    return { ok:ok, docs:resultDocs };\n  }\n\n  return PouchPromise$1.resolve()\n    .then(getRevisionOneDocs)\n    .then(getAllDocs)\n    .then(returnResult);\n}\n\nvar CHECKPOINT_VERSION = 1;\nvar REPLICATOR = \"pouchdb\";\n// This is an arbitrary number to limit the\n// amount of replication history we save in the checkpoint.\n// If we save too much, the checkpoing docs will become very big,\n// if we save fewer, we'll run a greater risk of having to\n// read all the changes from 0 when checkpoint PUTs fail\n// CouchDB 2.0 has a more involved history pruning,\n// but let's go for the simple version for now.\nvar CHECKPOINT_HISTORY_SIZE = 5;\nvar LOWEST_SEQ = 0;\n\nfunction updateCheckpoint(db, id, checkpoint, session, returnValue) {\n  return db.get(id).catch(function (err) {\n    if (err.status === 404) {\n      if (db.type() === 'http') {\n        explainError(\n          404, 'PouchDB is just checking if a remote checkpoint exists.'\n        );\n      }\n      return {\n        session_id: session,\n        _id: id,\n        history: [],\n        replicator: REPLICATOR,\n        version: CHECKPOINT_VERSION\n      };\n    }\n    throw err;\n  }).then(function (doc) {\n    if (returnValue.cancelled) {\n      return;\n    }\n\n    // if the checkpoint has not changed, do not update\n    if (doc.last_seq === checkpoint) {\n      return;\n    }\n\n    // Filter out current entry for this replication\n    doc.history = (doc.history || []).filter(function (item) {\n      return item.session_id !== session;\n    });\n\n    // Add the latest checkpoint to history\n    doc.history.unshift({\n      last_seq: checkpoint,\n      session_id: session\n    });\n\n    // Just take the last pieces in history, to\n    // avoid really big checkpoint docs.\n    // see comment on history size above\n    doc.history = doc.history.slice(0, CHECKPOINT_HISTORY_SIZE);\n\n    doc.version = CHECKPOINT_VERSION;\n    doc.replicator = REPLICATOR;\n\n    doc.session_id = session;\n    doc.last_seq = checkpoint;\n\n    return db.put(doc).catch(function (err) {\n      if (err.status === 409) {\n        // retry; someone is trying to write a checkpoint simultaneously\n        return updateCheckpoint(db, id, checkpoint, session, returnValue);\n      }\n      throw err;\n    });\n  });\n}\n\nfunction Checkpointer(src, target, id, returnValue) {\n  this.src = src;\n  this.target = target;\n  this.id = id;\n  this.returnValue = returnValue;\n}\n\nCheckpointer.prototype.writeCheckpoint = function (checkpoint, session) {\n  var self = this;\n  return this.updateTarget(checkpoint, session).then(function () {\n    return self.updateSource(checkpoint, session);\n  });\n};\n\nCheckpointer.prototype.updateTarget = function (checkpoint, session) {\n  return updateCheckpoint(this.target, this.id, checkpoint,\n    session, this.returnValue);\n};\n\nCheckpointer.prototype.updateSource = function (checkpoint, session) {\n  var self = this;\n  if (this.readOnlySource) {\n    return PouchPromise$1.resolve(true);\n  }\n  return updateCheckpoint(this.src, this.id, checkpoint,\n    session, this.returnValue)\n    .catch(function (err) {\n      if (isForbiddenError(err)) {\n        self.readOnlySource = true;\n        return true;\n      }\n      throw err;\n    });\n};\n\nvar comparisons = {\n  \"undefined\": function (targetDoc, sourceDoc) {\n    // This is the previous comparison function\n    if (collate(targetDoc.last_seq, sourceDoc.last_seq) === 0) {\n      return sourceDoc.last_seq;\n    }\n    /* istanbul ignore next */\n    return 0;\n  },\n  \"1\": function (targetDoc, sourceDoc) {\n    // This is the comparison function ported from CouchDB\n    return compareReplicationLogs(sourceDoc, targetDoc).last_seq;\n  }\n};\n\nCheckpointer.prototype.getCheckpoint = function () {\n  var self = this;\n  return self.target.get(self.id).then(function (targetDoc) {\n    if (self.readOnlySource) {\n      return PouchPromise$1.resolve(targetDoc.last_seq);\n    }\n\n    return self.src.get(self.id).then(function (sourceDoc) {\n      // Since we can't migrate an old version doc to a new one\n      // (no session id), we just go with the lowest seq in this case\n      /* istanbul ignore if */\n      if (targetDoc.version !== sourceDoc.version) {\n        return LOWEST_SEQ;\n      }\n\n      var version;\n      if (targetDoc.version) {\n        version = targetDoc.version.toString();\n      } else {\n        version = \"undefined\";\n      }\n\n      if (version in comparisons) {\n        return comparisons[version](targetDoc, sourceDoc);\n      }\n      /* istanbul ignore next */\n      return LOWEST_SEQ;\n    }, function (err) {\n      if (err.status === 404 && targetDoc.last_seq) {\n        return self.src.put({\n          _id: self.id,\n          last_seq: LOWEST_SEQ\n        }).then(function () {\n          return LOWEST_SEQ;\n        }, function (err) {\n          if (isForbiddenError(err)) {\n            self.readOnlySource = true;\n            return targetDoc.last_seq;\n          }\n          /* istanbul ignore next */\n          return LOWEST_SEQ;\n        });\n      }\n      throw err;\n    });\n  }).catch(function (err) {\n    if (err.status !== 404) {\n      throw err;\n    }\n    return LOWEST_SEQ;\n  });\n};\n// This checkpoint comparison is ported from CouchDBs source\n// they come from here:\n// https://github.com/apache/couchdb-couch-replicator/blob/master/src/couch_replicator.erl#L863-L906\n\nfunction compareReplicationLogs(srcDoc, tgtDoc) {\n  if (srcDoc.session_id === tgtDoc.session_id) {\n    return {\n      last_seq: srcDoc.last_seq,\n      history: srcDoc.history\n    };\n  }\n\n  return compareReplicationHistory(srcDoc.history, tgtDoc.history);\n}\n\nfunction compareReplicationHistory(sourceHistory, targetHistory) {\n  // the erlang loop via function arguments is not so easy to repeat in JS\n  // therefore, doing this as recursion\n  var S = sourceHistory[0];\n  var sourceRest = sourceHistory.slice(1);\n  var T = targetHistory[0];\n  var targetRest = targetHistory.slice(1);\n\n  if (!S || targetHistory.length === 0) {\n    return {\n      last_seq: LOWEST_SEQ,\n      history: []\n    };\n  }\n\n  var sourceId = S.session_id;\n  /* istanbul ignore if */\n  if (hasSessionId(sourceId, targetHistory)) {\n    return {\n      last_seq: S.last_seq,\n      history: sourceHistory\n    };\n  }\n\n  var targetId = T.session_id;\n  if (hasSessionId(targetId, sourceRest)) {\n    return {\n      last_seq: T.last_seq,\n      history: targetRest\n    };\n  }\n\n  return compareReplicationHistory(sourceRest, targetRest);\n}\n\nfunction hasSessionId(sessionId, history) {\n  var props = history[0];\n  var rest = history.slice(1);\n\n  if (!sessionId || history.length === 0) {\n    return false;\n  }\n\n  if (sessionId === props.session_id) {\n    return true;\n  }\n\n  return hasSessionId(sessionId, rest);\n}\n\nfunction isForbiddenError(err) {\n  return typeof err.status === 'number' && Math.floor(err.status / 100) === 4;\n}\n\nvar STARTING_BACK_OFF = 0;\n\nfunction backOff(opts, returnValue, error, callback) {\n  if (opts.retry === false) {\n    returnValue.emit('error', error);\n    returnValue.removeAllListeners();\n    return;\n  }\n  if (typeof opts.back_off_function !== 'function') {\n    opts.back_off_function = defaultBackOff;\n  }\n  returnValue.emit('requestError', error);\n  if (returnValue.state === 'active' || returnValue.state === 'pending') {\n    returnValue.emit('paused', error);\n    returnValue.state = 'stopped';\n    var backOffSet = function backoffTimeSet() {\n      opts.current_back_off = STARTING_BACK_OFF;\n    };\n    var removeBackOffSetter = function removeBackOffTimeSet() {\n      returnValue.removeListener('active', backOffSet);\n    };\n    returnValue.once('paused', removeBackOffSetter);\n    returnValue.once('active', backOffSet);\n  }\n\n  opts.current_back_off = opts.current_back_off || STARTING_BACK_OFF;\n  opts.current_back_off = opts.back_off_function(opts.current_back_off);\n  setTimeout(callback, opts.current_back_off);\n}\n\nfunction sortObjectPropertiesByKey(queryParams) {\n  return Object.keys(queryParams).sort(collate).reduce(function (result, key) {\n    result[key] = queryParams[key];\n    return result;\n  }, {});\n}\n\n// Generate a unique id particular to this replication.\n// Not guaranteed to align perfectly with CouchDB's rep ids.\nfunction generateReplicationId(src, target, opts) {\n  var docIds = opts.doc_ids ? opts.doc_ids.sort(collate) : '';\n  var filterFun = opts.filter ? opts.filter.toString() : '';\n  var queryParams = '';\n  var filterViewName =  '';\n\n  if (opts.filter && opts.query_params) {\n    queryParams = JSON.stringify(sortObjectPropertiesByKey(opts.query_params));\n  }\n\n  if (opts.filter && opts.filter === '_view') {\n    filterViewName = opts.view.toString();\n  }\n\n  return PouchPromise$1.all([src.id(), target.id()]).then(function (res) {\n    var queryData = res[0] + res[1] + filterFun + filterViewName +\n      queryParams + docIds;\n    return new PouchPromise$1(function (resolve) {\n      binaryMd5(queryData, resolve);\n    });\n  }).then(function (md5sum) {\n    // can't use straight-up md5 alphabet, because\n    // the char '/' is interpreted as being for attachments,\n    // and + is also not url-safe\n    md5sum = md5sum.replace(/\\//g, '.').replace(/\\+/g, '_');\n    return '_local/' + md5sum;\n  });\n}\n\nfunction replicate(src, target, opts, returnValue, result) {\n  var batches = [];               // list of batches to be processed\n  var currentBatch;               // the batch currently being processed\n  var pendingBatch = {\n    seq: 0,\n    changes: [],\n    docs: []\n  }; // next batch, not yet ready to be processed\n  var writingCheckpoint = false;  // true while checkpoint is being written\n  var changesCompleted = false;   // true when all changes received\n  var replicationCompleted = false; // true when replication has completed\n  var last_seq = 0;\n  var continuous = opts.continuous || opts.live || false;\n  var batch_size = opts.batch_size || 100;\n  var batches_limit = opts.batches_limit || 10;\n  var changesPending = false;     // true while src.changes is running\n  var doc_ids = opts.doc_ids;\n  var repId;\n  var checkpointer;\n  var changedDocs = [];\n  // Like couchdb, every replication gets a unique session id\n  var session = uuid();\n\n  result = result || {\n    ok: true,\n    start_time: new Date(),\n    docs_read: 0,\n    docs_written: 0,\n    doc_write_failures: 0,\n    errors: []\n  };\n\n  var changesOpts = {};\n  returnValue.ready(src, target);\n\n  function initCheckpointer() {\n    if (checkpointer) {\n      return PouchPromise$1.resolve();\n    }\n    return generateReplicationId(src, target, opts).then(function (res) {\n      repId = res;\n      checkpointer = new Checkpointer(src, target, repId, returnValue);\n    });\n  }\n\n  function writeDocs() {\n    changedDocs = [];\n\n    if (currentBatch.docs.length === 0) {\n      return;\n    }\n    var docs = currentBatch.docs;\n    var bulkOpts = {timeout: opts.timeout};\n    return target.bulkDocs({docs: docs, new_edits: false}, bulkOpts).then(function (res) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n\n      // `res` doesn't include full documents (which live in `docs`), so we create a map of \n      // (id -> error), and check for errors while iterating over `docs`\n      var errorsById = Object.create(null);\n      res.forEach(function (res) {\n        if (res.error) {\n          errorsById[res.id] = res;\n        }\n      });\n\n      var errorsNo = Object.keys(errorsById).length;\n      result.doc_write_failures += errorsNo;\n      result.docs_written += docs.length - errorsNo;\n\n      docs.forEach(function (doc) {\n        var error = errorsById[doc._id];\n        if (error) {\n          result.errors.push(error);\n          if (error.name === 'unauthorized' || error.name === 'forbidden') {\n            returnValue.emit('denied', clone(error));\n          } else {\n            throw error;\n          }\n        } else {\n          changedDocs.push(doc);\n        }\n      });\n\n    }, function (err) {\n      result.doc_write_failures += docs.length;\n      throw err;\n    });\n  }\n\n  function finishBatch() {\n    if (currentBatch.error) {\n      throw new Error('There was a problem getting docs.');\n    }\n    result.last_seq = last_seq = currentBatch.seq;\n    var outResult = clone(result);\n    if (changedDocs.length) {\n      outResult.docs = changedDocs;\n      returnValue.emit('change', outResult);\n    }\n    writingCheckpoint = true;\n    return checkpointer.writeCheckpoint(currentBatch.seq,\n        session).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      currentBatch = undefined;\n      getChanges();\n    }).catch(function (err) {\n      onCheckpointError(err);\n      throw err;\n    });\n  }\n\n  function getDiffs() {\n    var diff = {};\n    currentBatch.changes.forEach(function (change) {\n      // Couchbase Sync Gateway emits these, but we can ignore them\n      /* istanbul ignore if */\n      if (change.id === \"_user/\") {\n        return;\n      }\n      diff[change.id] = change.changes.map(function (x) {\n        return x.rev;\n      });\n    });\n    return target.revsDiff(diff).then(function (diffs) {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        throw new Error('cancelled');\n      }\n      // currentBatch.diffs elements are deleted as the documents are written\n      currentBatch.diffs = diffs;\n    });\n  }\n\n  function getBatchDocs() {\n    return getDocs(src, target, currentBatch.diffs, returnValue).then(function (got) {\n      currentBatch.error = !got.ok;\n      got.docs.forEach(function (doc) {\n        delete currentBatch.diffs[doc._id];\n        result.docs_read++;\n        currentBatch.docs.push(doc);\n      });\n    });\n  }\n\n  function startNextBatch() {\n    if (returnValue.cancelled || currentBatch) {\n      return;\n    }\n    if (batches.length === 0) {\n      processPendingBatch(true);\n      return;\n    }\n    currentBatch = batches.shift();\n    getDiffs()\n      .then(getBatchDocs)\n      .then(writeDocs)\n      .then(finishBatch)\n      .then(startNextBatch)\n      .catch(function (err) {\n        abortReplication('batch processing terminated with error', err);\n      });\n  }\n\n\n  function processPendingBatch(immediate) {\n    if (pendingBatch.changes.length === 0) {\n      if (batches.length === 0 && !currentBatch) {\n        if ((continuous && changesOpts.live) || changesCompleted) {\n          returnValue.state = 'pending';\n          returnValue.emit('paused');\n        }\n        if (changesCompleted) {\n          completeReplication();\n        }\n      }\n      return;\n    }\n    if (\n      immediate ||\n      changesCompleted ||\n      pendingBatch.changes.length >= batch_size\n    ) {\n      batches.push(pendingBatch);\n      pendingBatch = {\n        seq: 0,\n        changes: [],\n        docs: []\n      };\n      if (returnValue.state === 'pending' || returnValue.state === 'stopped') {\n        returnValue.state = 'active';\n        returnValue.emit('active');\n      }\n      startNextBatch();\n    }\n  }\n\n\n  function abortReplication(reason, err) {\n    if (replicationCompleted) {\n      return;\n    }\n    if (!err.message) {\n      err.message = reason;\n    }\n    result.ok = false;\n    result.status = 'aborting';\n    batches = [];\n    pendingBatch = {\n      seq: 0,\n      changes: [],\n      docs: []\n    };\n    completeReplication(err);\n  }\n\n\n  function completeReplication(fatalError) {\n    if (replicationCompleted) {\n      return;\n    }\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      result.status = 'cancelled';\n      if (writingCheckpoint) {\n        return;\n      }\n    }\n    result.status = result.status || 'complete';\n    result.end_time = new Date();\n    result.last_seq = last_seq;\n    replicationCompleted = true;\n\n    if (fatalError) {\n      fatalError.result = result;\n\n      if (fatalError.name === 'unauthorized' || fatalError.name === 'forbidden') {\n        returnValue.emit('error', fatalError);\n        returnValue.removeAllListeners();\n      } else {\n        backOff(opts, returnValue, fatalError, function () {\n          replicate(src, target, opts, returnValue);\n        });\n      }\n    } else {\n      returnValue.emit('complete', result);\n      returnValue.removeAllListeners();\n    }\n  }\n\n\n  function onChange(change) {\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    var filter = filterChange(opts)(change);\n    if (!filter) {\n      return;\n    }\n    pendingBatch.seq = change.seq;\n    pendingBatch.changes.push(change);\n    processPendingBatch(batches.length === 0 && changesOpts.live);\n  }\n\n\n  function onChangesComplete(changes) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n\n    // if no results were returned then we're done,\n    // else fetch more\n    if (changes.results.length > 0) {\n      changesOpts.since = changes.last_seq;\n      getChanges();\n      processPendingBatch(true);\n    } else {\n\n      var complete = function () {\n        if (continuous) {\n          changesOpts.live = true;\n          getChanges();\n        } else {\n          changesCompleted = true;\n        }\n        processPendingBatch(true);\n      };\n\n      // update the checkpoint so we start from the right seq next time\n      if (!currentBatch && changes.results.length === 0) {\n        writingCheckpoint = true;\n        checkpointer.writeCheckpoint(changes.last_seq,\n            session).then(function () {\n          writingCheckpoint = false;\n          result.last_seq = last_seq = changes.last_seq;\n          complete();\n        })\n        .catch(onCheckpointError);\n      } else {\n        complete();\n      }\n    }\n  }\n\n\n  function onChangesError(err) {\n    changesPending = false;\n    /* istanbul ignore if */\n    if (returnValue.cancelled) {\n      return completeReplication();\n    }\n    abortReplication('changes rejected', err);\n  }\n\n\n  function getChanges() {\n    if (!(\n      !changesPending &&\n      !changesCompleted &&\n      batches.length < batches_limit\n      )) {\n      return;\n    }\n    changesPending = true;\n    function abortChanges() {\n      changes.cancel();\n    }\n    function removeListener() {\n      returnValue.removeListener('cancel', abortChanges);\n    }\n\n    if (returnValue._changes) { // remove old changes() and listeners\n      returnValue.removeListener('cancel', returnValue._abortChanges);\n      returnValue._changes.cancel();\n    }\n    returnValue.once('cancel', abortChanges);\n\n    var changes = src.changes(changesOpts)\n      .on('change', onChange);\n    changes.then(removeListener, removeListener);\n    changes.then(onChangesComplete)\n      .catch(onChangesError);\n\n    if (opts.retry) {\n      // save for later so we can cancel if necessary\n      returnValue._changes = changes;\n      returnValue._abortChanges = abortChanges;\n    }\n  }\n\n\n  function startChanges() {\n    initCheckpointer().then(function () {\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      return checkpointer.getCheckpoint().then(function (checkpoint) {\n        last_seq = checkpoint;\n        changesOpts = {\n          since: last_seq,\n          limit: batch_size,\n          batch_size: batch_size,\n          style: 'all_docs',\n          doc_ids: doc_ids,\n          return_docs: true // required so we know when we're done\n        };\n        if (opts.filter) {\n          if (typeof opts.filter !== 'string') {\n            // required for the client-side filter in onChange\n            changesOpts.include_docs = true;\n          } else { // ddoc filter\n            changesOpts.filter = opts.filter;\n          }\n        }\n        if ('heartbeat' in opts) {\n          changesOpts.heartbeat = opts.heartbeat;\n        }\n        if ('timeout' in opts) {\n          changesOpts.timeout = opts.timeout;\n        }\n        if (opts.query_params) {\n          changesOpts.query_params = opts.query_params;\n        }\n        if (opts.view) {\n          changesOpts.view = opts.view;\n        }\n        getChanges();\n      });\n    }).catch(function (err) {\n      abortReplication('getCheckpoint rejected with ', err);\n    });\n  }\n\n  /* istanbul ignore next */\n  function onCheckpointError(err) {\n    writingCheckpoint = false;\n    abortReplication('writeCheckpoint completed with error', err);\n  }\n\n  /* istanbul ignore if */\n  if (returnValue.cancelled) { // cancelled immediately\n    completeReplication();\n    return;\n  }\n\n  if (!returnValue._addedListeners) {\n    returnValue.once('cancel', completeReplication);\n\n    if (typeof opts.complete === 'function') {\n      returnValue.once('error', opts.complete);\n      returnValue.once('complete', function (result) {\n        opts.complete(null, result);\n      });\n    }\n    returnValue._addedListeners = true;\n  }\n\n  if (typeof opts.since === 'undefined') {\n    startChanges();\n  } else {\n    initCheckpointer().then(function () {\n      writingCheckpoint = true;\n      return checkpointer.writeCheckpoint(opts.since, session);\n    }).then(function () {\n      writingCheckpoint = false;\n      /* istanbul ignore if */\n      if (returnValue.cancelled) {\n        completeReplication();\n        return;\n      }\n      last_seq = opts.since;\n      startChanges();\n    }).catch(onCheckpointError);\n  }\n}\n\n// We create a basic promise so the caller can cancel the replication possibly\n// before we have actually started listening to changes etc\ninherits(Replication, events.EventEmitter);\nfunction Replication() {\n  events.EventEmitter.call(this);\n  this.cancelled = false;\n  this.state = 'pending';\n  var self = this;\n  var promise = new PouchPromise$1(function (fulfill, reject) {\n    self.once('complete', fulfill);\n    self.once('error', reject);\n  });\n  self.then = function (resolve, reject) {\n    return promise.then(resolve, reject);\n  };\n  self.catch = function (reject) {\n    return promise.catch(reject);\n  };\n  // As we allow error handling via \"error\" event as well,\n  // put a stub in here so that rejecting never throws UnhandledError.\n  self.catch(function () {});\n}\n\nReplication.prototype.cancel = function () {\n  this.cancelled = true;\n  this.state = 'cancelled';\n  this.emit('cancel');\n};\n\nReplication.prototype.ready = function (src, target) {\n  var self = this;\n  if (self._readyCalled) {\n    return;\n  }\n  self._readyCalled = true;\n\n  function onDestroy() {\n    self.cancel();\n  }\n  src.once('destroyed', onDestroy);\n  target.once('destroyed', onDestroy);\n  function cleanup() {\n    src.removeListener('destroyed', onDestroy);\n    target.removeListener('destroyed', onDestroy);\n  }\n  self.once('complete', cleanup);\n};\n\nfunction toPouch(db, opts) {\n  var PouchConstructor = opts.PouchConstructor;\n  if (typeof db === 'string') {\n    return new PouchConstructor(db, opts);\n  } else {\n    return db;\n  }\n}\n\nfunction replicateWrapper(src, target, opts, callback) {\n\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n\n  if (opts.doc_ids && !Array.isArray(opts.doc_ids)) {\n    throw createError(BAD_REQUEST,\n                       \"`doc_ids` filter parameter is not a list.\");\n  }\n\n  opts.complete = callback;\n  opts = clone(opts);\n  opts.continuous = opts.continuous || opts.live;\n  opts.retry = ('retry' in opts) ? opts.retry : false;\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  var replicateRet = new Replication(opts);\n  var srcPouch = toPouch(src, opts);\n  var targetPouch = toPouch(target, opts);\n  replicate(srcPouch, targetPouch, opts, replicateRet);\n  return replicateRet;\n}\n\ninherits(Sync, events.EventEmitter);\nfunction sync$1(src, target, opts, callback) {\n  if (typeof opts === 'function') {\n    callback = opts;\n    opts = {};\n  }\n  if (typeof opts === 'undefined') {\n    opts = {};\n  }\n  opts = clone(opts);\n  /*jshint validthis:true */\n  opts.PouchConstructor = opts.PouchConstructor || this;\n  src = toPouch(src, opts);\n  target = toPouch(target, opts);\n  return new Sync(src, target, opts, callback);\n}\n\nfunction Sync(src, target, opts, callback) {\n  var self = this;\n  this.canceled = false;\n\n  var optsPush = opts.push ? assign$1({}, opts, opts.push) : opts;\n  var optsPull = opts.pull ? assign$1({}, opts, opts.pull) : opts;\n\n  this.push = replicateWrapper(src, target, optsPush);\n  this.pull = replicateWrapper(target, src, optsPull);\n\n  this.pushPaused = true;\n  this.pullPaused = true;\n\n  function pullChange(change) {\n    self.emit('change', {\n      direction: 'pull',\n      change: change\n    });\n  }\n  function pushChange(change) {\n    self.emit('change', {\n      direction: 'push',\n      change: change\n    });\n  }\n  function pushDenied(doc) {\n    self.emit('denied', {\n      direction: 'push',\n      doc: doc\n    });\n  }\n  function pullDenied(doc) {\n    self.emit('denied', {\n      direction: 'pull',\n      doc: doc\n    });\n  }\n  function pushPaused() {\n    self.pushPaused = true;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('paused');\n    }\n  }\n  function pullPaused() {\n    self.pullPaused = true;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('paused');\n    }\n  }\n  function pushActive() {\n    self.pushPaused = false;\n    /* istanbul ignore if */\n    if (self.pullPaused) {\n      self.emit('active', {\n        direction: 'push'\n      });\n    }\n  }\n  function pullActive() {\n    self.pullPaused = false;\n    /* istanbul ignore if */\n    if (self.pushPaused) {\n      self.emit('active', {\n        direction: 'pull'\n      });\n    }\n  }\n\n  var removed = {};\n\n  function removeAll(type) { // type is 'push' or 'pull'\n    return function (event, func) {\n      var isChange = event === 'change' &&\n        (func === pullChange || func === pushChange);\n      var isDenied = event === 'denied' &&\n        (func === pullDenied || func === pushDenied);\n      var isPaused = event === 'paused' &&\n        (func === pullPaused || func === pushPaused);\n      var isActive = event === 'active' &&\n        (func === pullActive || func === pushActive);\n\n      if (isChange || isDenied || isPaused || isActive) {\n        if (!(event in removed)) {\n          removed[event] = {};\n        }\n        removed[event][type] = true;\n        if (Object.keys(removed[event]).length === 2) {\n          // both push and pull have asked to be removed\n          self.removeAllListeners(event);\n        }\n      }\n    };\n  }\n\n  if (opts.live) {\n    this.push.on('complete', self.pull.cancel.bind(self.pull));\n    this.pull.on('complete', self.push.cancel.bind(self.push));\n  }\n\n  function addOneListener(ee, event, listener) {\n    if (ee.listeners(event).indexOf(listener) == -1) {\n      ee.on(event, listener);\n    }\n  }\n\n  this.on('newListener', function (event) {\n    if (event === 'change') {\n      addOneListener(self.pull, 'change', pullChange);\n      addOneListener(self.push, 'change', pushChange);\n    } else if (event === 'denied') {\n      addOneListener(self.pull, 'denied', pullDenied);\n      addOneListener(self.push, 'denied', pushDenied);\n    } else if (event === 'active') {\n      addOneListener(self.pull, 'active', pullActive);\n      addOneListener(self.push, 'active', pushActive);\n    } else if (event === 'paused') {\n      addOneListener(self.pull, 'paused', pullPaused);\n      addOneListener(self.push, 'paused', pushPaused);\n    }\n  });\n\n  this.on('removeListener', function (event) {\n    if (event === 'change') {\n      self.pull.removeListener('change', pullChange);\n      self.push.removeListener('change', pushChange);\n    } else if (event === 'denied') {\n      self.pull.removeListener('denied', pullDenied);\n      self.push.removeListener('denied', pushDenied);\n    } else if (event === 'active') {\n      self.pull.removeListener('active', pullActive);\n      self.push.removeListener('active', pushActive);\n    } else if (event === 'paused') {\n      self.pull.removeListener('paused', pullPaused);\n      self.push.removeListener('paused', pushPaused);\n    }\n  });\n\n  this.pull.on('removeListener', removeAll('pull'));\n  this.push.on('removeListener', removeAll('push'));\n\n  var promise = PouchPromise$1.all([\n    this.push,\n    this.pull\n  ]).then(function (resp) {\n    var out = {\n      push: resp[0],\n      pull: resp[1]\n    };\n    self.emit('complete', out);\n    if (callback) {\n      callback(null, out);\n    }\n    self.removeAllListeners();\n    return out;\n  }, function (err) {\n    self.cancel();\n    if (callback) {\n      // if there's a callback, then the callback can receive\n      // the error event\n      callback(err);\n    } else {\n      // if there's no callback, then we're safe to emit an error\n      // event, which would otherwise throw an unhandled error\n      // due to 'error' being a special event in EventEmitters\n      self.emit('error', err);\n    }\n    self.removeAllListeners();\n    if (callback) {\n      // no sense throwing if we're already emitting an 'error' event\n      throw err;\n    }\n  });\n\n  this.then = function (success, err) {\n    return promise.then(success, err);\n  };\n\n  this.catch = function (err) {\n    return promise.catch(err);\n  };\n}\n\nSync.prototype.cancel = function () {\n  if (!this.canceled) {\n    this.canceled = true;\n    this.push.cancel();\n    this.pull.cancel();\n  }\n};\n\nfunction replication(PouchDB) {\n  PouchDB.replicate = replicateWrapper;\n  PouchDB.sync = sync$1;\n\n  Object.defineProperty(PouchDB.prototype, 'replicate', {\n    get: function () {\n      var self = this;\n      return {\n        from: function (other, opts, callback) {\n          return self.constructor.replicate(other, self, opts, callback);\n        },\n        to: function (other, opts, callback) {\n          return self.constructor.replicate(self, other, opts, callback);\n        }\n      };\n    }\n  });\n\n  PouchDB.prototype.sync = function (dbName, opts, callback) {\n    return this.constructor.sync(this, dbName, opts, callback);\n  };\n}\n\nPouchDB$5.plugin(IDBPouch)\n  .plugin(WebSqlPouch)\n  .plugin(HttpPouch$1)\n  .plugin(mapreduce)\n  .plugin(replication);\n\n// Pull from src because pouchdb-node/pouchdb-browser themselves\n// are aggressively optimized and jsnext:main would normally give us this\n// aggressive bundle.\n\nmodule.exports = PouchDB$5;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb/lib/index-browser.js\n// module id = 241\n// module chunks = 0","\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug.default = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  var split = (namespaces || '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb/~/debug/src/debug.js\n// module id = 243\n// module chunks = 0","(function (factory) {\n    if (typeof exports === 'object') {\n        // Node/CommonJS\n        module.exports = factory();\n    } else if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(factory);\n    } else {\n        // Browser globals (with support for web workers)\n        var glob;\n\n        try {\n            glob = window;\n        } catch (e) {\n            glob = self;\n        }\n\n        glob.SparkMD5 = factory();\n    }\n}(function (undefined) {\n\n    'use strict';\n\n    /*\n     * Fastest md5 implementation around (JKM md5).\n     * Credits: Joseph Myers\n     *\n     * @see http://www.myersdaily.org/joseph/javascript/md5-text.html\n     * @see http://jsperf.com/md5-shootout/7\n     */\n\n    /* this function is much faster,\n      so if possible we use it. Some IEs\n      are the only ones I know of that\n      need the idiotic second function,\n      generated by an if clause.  */\n    var add32 = function (a, b) {\n        return (a + b) & 0xFFFFFFFF;\n    },\n        hex_chr = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n\n\n    function cmn(q, a, b, x, s, t) {\n        a = add32(add32(a, q), add32(x, t));\n        return add32((a << s) | (a >>> (32 - s)), b);\n    }\n\n    function md5cycle(x, k) {\n        var a = x[0],\n            b = x[1],\n            c = x[2],\n            d = x[3];\n\n        a += (b & c | ~b & d) + k[0] - 680876936 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[1] - 389564586 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[2] + 606105819 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[4] - 176418897 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[7] - 45705983 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[10] - 42063 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;\n        a  = (a << 7 | a >>> 25) + b | 0;\n        d += (a & b | ~a & c) + k[13] - 40341101 | 0;\n        d  = (d << 12 | d >>> 20) + a | 0;\n        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;\n        c  = (c << 17 | c >>> 15) + d | 0;\n        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;\n        b  = (b << 22 | b >>> 10) + c | 0;\n\n        a += (b & d | c & ~d) + k[1] - 165796510 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[11] + 643717713 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[0] - 373897302 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[5] - 701558691 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[10] + 38016083 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[15] - 660478335 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[4] - 405537848 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[9] + 568446438 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[3] - 187363961 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;\n        a  = (a << 5 | a >>> 27) + b | 0;\n        d += (a & c | b & ~c) + k[2] - 51403784 | 0;\n        d  = (d << 9 | d >>> 23) + a | 0;\n        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;\n        c  = (c << 14 | c >>> 18) + d | 0;\n        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;\n        b  = (b << 20 | b >>> 12) + c | 0;\n\n        a += (b ^ c ^ d) + k[5] - 378558 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[14] - 35309556 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[7] - 155497632 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[13] + 681279174 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[0] - 358537222 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[3] - 722521979 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[6] + 76029189 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n        a += (b ^ c ^ d) + k[9] - 640364487 | 0;\n        a  = (a << 4 | a >>> 28) + b | 0;\n        d += (a ^ b ^ c) + k[12] - 421815835 | 0;\n        d  = (d << 11 | d >>> 21) + a | 0;\n        c += (d ^ a ^ b) + k[15] + 530742520 | 0;\n        c  = (c << 16 | c >>> 16) + d | 0;\n        b += (c ^ d ^ a) + k[2] - 995338651 | 0;\n        b  = (b << 23 | b >>> 9) + c | 0;\n\n        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;\n        b  = (b << 21 |b >>> 11) + c | 0;\n        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;\n        a  = (a << 6 | a >>> 26) + b | 0;\n        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;\n        d  = (d << 10 | d >>> 22) + a | 0;\n        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;\n        c  = (c << 15 | c >>> 17) + d | 0;\n        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;\n        b  = (b << 21 | b >>> 11) + c | 0;\n\n        x[0] = a + x[0] | 0;\n        x[1] = b + x[1] | 0;\n        x[2] = c + x[2] | 0;\n        x[3] = d + x[3] | 0;\n    }\n\n    function md5blk(s) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);\n        }\n        return md5blks;\n    }\n\n    function md5blk_array(a) {\n        var md5blks = [],\n            i; /* Andy King said do it this way. */\n\n        for (i = 0; i < 64; i += 4) {\n            md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);\n        }\n        return md5blks;\n    }\n\n    function md51(s) {\n        var n = s.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk(s.substring(i - 64, i)));\n        }\n        s = s.substring(i - 64);\n        length = s.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= s.charCodeAt(i) << ((i % 4) << 3);\n        }\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n        return state;\n    }\n\n    function md51_array(a) {\n        var n = a.length,\n            state = [1732584193, -271733879, -1732584194, 271733878],\n            i,\n            length,\n            tail,\n            tmp,\n            lo,\n            hi;\n\n        for (i = 64; i <= n; i += 64) {\n            md5cycle(state, md5blk_array(a.subarray(i - 64, i)));\n        }\n\n        // Not sure if it is a bug, however IE10 will always produce a sub array of length 1\n        // containing the last element of the parent array if the sub array specified starts\n        // beyond the length of the parent array - weird.\n        // https://connect.microsoft.com/IE/feedback/details/771452/typed-array-subarray-issue\n        a = (i - 64) < n ? a.subarray(i - 64) : new Uint8Array(0);\n\n        length = a.length;\n        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= a[i] << ((i % 4) << 3);\n        }\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(state, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Beware that the final length might not fit in 32 bits so we take care of that\n        tmp = n * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n\n        md5cycle(state, tail);\n\n        return state;\n    }\n\n    function rhex(n) {\n        var s = '',\n            j;\n        for (j = 0; j < 4; j += 1) {\n            s += hex_chr[(n >> (j * 8 + 4)) & 0x0F] + hex_chr[(n >> (j * 8)) & 0x0F];\n        }\n        return s;\n    }\n\n    function hex(x) {\n        var i;\n        for (i = 0; i < x.length; i += 1) {\n            x[i] = rhex(x[i]);\n        }\n        return x.join('');\n    }\n\n    // In some cases the fast add32 function cannot be used..\n    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592') {\n        add32 = function (x, y) {\n            var lsw = (x & 0xFFFF) + (y & 0xFFFF),\n                msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n            return (msw << 16) | (lsw & 0xFFFF);\n        };\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * ArrayBuffer slice polyfill.\n     *\n     * @see https://github.com/ttaubert/node-arraybuffer-slice\n     */\n\n    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {\n        (function () {\n            function clamp(val, length) {\n                val = (val | 0) || 0;\n\n                if (val < 0) {\n                    return Math.max(val + length, 0);\n                }\n\n                return Math.min(val, length);\n            }\n\n            ArrayBuffer.prototype.slice = function (from, to) {\n                var length = this.byteLength,\n                    begin = clamp(from, length),\n                    end = length,\n                    num,\n                    target,\n                    targetArray,\n                    sourceArray;\n\n                if (to !== undefined) {\n                    end = clamp(to, length);\n                }\n\n                if (begin > end) {\n                    return new ArrayBuffer(0);\n                }\n\n                num = end - begin;\n                target = new ArrayBuffer(num);\n                targetArray = new Uint8Array(target);\n\n                sourceArray = new Uint8Array(this, begin, num);\n                targetArray.set(sourceArray);\n\n                return target;\n            };\n        })();\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * Helpers.\n     */\n\n    function toUtf8(str) {\n        if (/[\\u0080-\\uFFFF]/.test(str)) {\n            str = unescape(encodeURIComponent(str));\n        }\n\n        return str;\n    }\n\n    function utf8Str2ArrayBuffer(str, returnUInt8Array) {\n        var length = str.length,\n           buff = new ArrayBuffer(length),\n           arr = new Uint8Array(buff),\n           i;\n\n        for (i = 0; i < length; i += 1) {\n            arr[i] = str.charCodeAt(i);\n        }\n\n        return returnUInt8Array ? arr : buff;\n    }\n\n    function arrayBuffer2Utf8Str(buff) {\n        return String.fromCharCode.apply(null, new Uint8Array(buff));\n    }\n\n    function concatenateArrayBuffers(first, second, returnUInt8Array) {\n        var result = new Uint8Array(first.byteLength + second.byteLength);\n\n        result.set(new Uint8Array(first));\n        result.set(new Uint8Array(second), first.byteLength);\n\n        return returnUInt8Array ? result : result.buffer;\n    }\n\n    function hexToBinaryString(hex) {\n        var bytes = [],\n            length = hex.length,\n            x;\n\n        for (x = 0; x < length - 1; x += 2) {\n            bytes.push(parseInt(hex.substr(x, 2), 16));\n        }\n\n        return String.fromCharCode.apply(String, bytes);\n    }\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation.\n     *\n     * Use this class to perform an incremental md5, otherwise use the\n     * static methods instead.\n     */\n\n    function SparkMD5() {\n        // call reset to init the instance\n        this.reset();\n    }\n\n    /**\n     * Appends a string.\n     * A conversion will be applied if an utf8 string is detected.\n     *\n     * @param {String} str The string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.append = function (str) {\n        // Converts the string to utf8 bytes if necessary\n        // Then append as binary\n        this.appendBinary(toUtf8(str));\n\n        return this;\n    };\n\n    /**\n     * Appends a binary string.\n     *\n     * @param {String} contents The binary string to be appended\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.appendBinary = function (contents) {\n        this._buff += contents;\n        this._length += contents.length;\n\n        var length = this._buff.length,\n            i;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));\n        }\n\n        this._buff = this._buff.substring(i - 64);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            i,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff.charCodeAt(i) << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.reset = function () {\n        this._buff = '';\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.prototype.getState = function () {\n        return {\n            buff: this._buff,\n            length: this._length,\n            hash: this._hash\n        };\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5} The instance itself\n     */\n    SparkMD5.prototype.setState = function (state) {\n        this._buff = state.buff;\n        this._length = state.length;\n        this._hash = state.hash;\n\n        return this;\n    };\n\n    /**\n     * Releases memory used by the incremental buffer and other additional\n     * resources. If you plan to use the instance again, use reset instead.\n     */\n    SparkMD5.prototype.destroy = function () {\n        delete this._hash;\n        delete this._buff;\n        delete this._length;\n    };\n\n    /**\n     * Finish the final calculation based on the tail.\n     *\n     * @param {Array}  tail   The tail (will be modified)\n     * @param {Number} length The length of the remaining buffer\n     */\n    SparkMD5.prototype._finish = function (tail, length) {\n        var i = length,\n            tmp,\n            lo,\n            hi;\n\n        tail[i >> 2] |= 0x80 << ((i % 4) << 3);\n        if (i > 55) {\n            md5cycle(this._hash, tail);\n            for (i = 0; i < 16; i += 1) {\n                tail[i] = 0;\n            }\n        }\n\n        // Do the final computation based on the tail and length\n        // Beware that the final length may not fit in 32 bits so we take care of that\n        tmp = this._length * 8;\n        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);\n        lo = parseInt(tmp[2], 16);\n        hi = parseInt(tmp[1], 16) || 0;\n\n        tail[14] = lo;\n        tail[15] = hi;\n        md5cycle(this._hash, tail);\n    };\n\n    /**\n     * Performs the md5 hash on a string.\n     * A conversion will be applied if utf8 string is detected.\n     *\n     * @param {String}  str The string\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hash = function (str, raw) {\n        // Converts the string to utf8 bytes if necessary\n        // Then compute it using the binary function\n        return SparkMD5.hashBinary(toUtf8(str), raw);\n    };\n\n    /**\n     * Performs the md5 hash on a binary string.\n     *\n     * @param {String}  content The binary string\n     * @param {Boolean} raw     True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.hashBinary = function (content, raw) {\n        var hash = md51(content),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    // ---------------------------------------------------\n\n    /**\n     * SparkMD5 OOP implementation for array buffers.\n     *\n     * Use this class to perform an incremental md5 ONLY for array buffers.\n     */\n    SparkMD5.ArrayBuffer = function () {\n        // call reset to init the instance\n        this.reset();\n    };\n\n    /**\n     * Appends an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array to be appended\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.append = function (arr) {\n        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),\n            length = buff.length,\n            i;\n\n        this._length += arr.byteLength;\n\n        for (i = 64; i <= length; i += 64) {\n            md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));\n        }\n\n        this._buff = (i - 64) < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);\n\n        return this;\n    };\n\n    /**\n     * Finishes the incremental computation, reseting the internal state and\n     * returning the result.\n     *\n     * @param {Boolean} raw True to get the raw string, false to get the hex string\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.prototype.end = function (raw) {\n        var buff = this._buff,\n            length = buff.length,\n            tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n            i,\n            ret;\n\n        for (i = 0; i < length; i += 1) {\n            tail[i >> 2] |= buff[i] << ((i % 4) << 3);\n        }\n\n        this._finish(tail, length);\n        ret = hex(this._hash);\n\n        if (raw) {\n            ret = hexToBinaryString(ret);\n        }\n\n        this.reset();\n\n        return ret;\n    };\n\n    /**\n     * Resets the internal state of the computation.\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.reset = function () {\n        this._buff = new Uint8Array(0);\n        this._length = 0;\n        this._hash = [1732584193, -271733879, -1732584194, 271733878];\n\n        return this;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @return {Object} The state\n     */\n    SparkMD5.ArrayBuffer.prototype.getState = function () {\n        var state = SparkMD5.prototype.getState.call(this);\n\n        // Convert buffer to a string\n        state.buff = arrayBuffer2Utf8Str(state.buff);\n\n        return state;\n    };\n\n    /**\n     * Gets the internal state of the computation.\n     *\n     * @param {Object} state The state\n     *\n     * @return {SparkMD5.ArrayBuffer} The instance itself\n     */\n    SparkMD5.ArrayBuffer.prototype.setState = function (state) {\n        // Convert string to buffer\n        state.buff = utf8Str2ArrayBuffer(state.buff, true);\n\n        return SparkMD5.prototype.setState.call(this, state);\n    };\n\n    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;\n\n    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;\n\n    /**\n     * Performs the md5 hash on an array buffer.\n     *\n     * @param {ArrayBuffer} arr The array buffer\n     * @param {Boolean}     raw True to get the raw string, false to get the hex one\n     *\n     * @return {String} The result\n     */\n    SparkMD5.ArrayBuffer.hash = function (arr, raw) {\n        var hash = md51_array(new Uint8Array(arr)),\n            ret = hex(hash);\n\n        return raw ? hexToBinaryString(ret) : ret;\n    };\n\n    return SparkMD5;\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb/~/spark-md5/spark-md5.js\n// module id = 245\n// module chunks = 0","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  IteratorPrototype[iteratorSymbol] = function () {\n    return this;\n  };\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunctionPrototype[toStringTagSymbol] =\n    GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      if (!(toStringTagSymbol in genFun)) {\n        genFun[toStringTagSymbol] = \"GeneratorFunction\";\n      }\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  runtime.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return Promise.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return Promise.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration. If the Promise is rejected, however, the\n          // result for this iteration will be rejected with the same\n          // reason. Note that rejections of yielded Promises are not\n          // thrown back into the generator function, as is the case\n          // when an awaited Promise is rejected. This difference in\n          // behavior between yield and await is important, because it\n          // allows the consumer to decide what to do with the yielded\n          // rejection (swallow it and continue, manually .throw it back\n          // into the generator, abandon iteration, whatever). With\n          // await, by contrast, there is no opportunity to examine the\n          // rejection reason outside the generator function, so the\n          // only option is to throw it from the await expression, and\n          // let the generator function handle the exception.\n          result.value = unwrapped;\n          resolve(result);\n        }, reject);\n      }\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new Promise(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  runtime.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        if (delegate.iterator.return) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[toStringTagSymbol] = \"Generator\";\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/regenerator-runtime/runtime.js\n// module id = 246\n// module chunks = 0","// Generated by CoffeeScript 1.9.2\n(function() {\n  var hasProp = {}.hasOwnProperty,\n    slice = [].slice;\n\n  module.exports = function(source, scope) {\n    var key, keys, value, values;\n    keys = [];\n    values = [];\n    for (key in scope) {\n      if (!hasProp.call(scope, key)) continue;\n      value = scope[key];\n      if (key === 'this') {\n        continue;\n      }\n      keys.push(key);\n      values.push(value);\n    }\n    return Function.apply(null, slice.call(keys).concat([source])).apply(scope[\"this\"], values);\n  };\n\n}).call(this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/scope-eval/scope_eval.js\n// module id = 247\n// module chunks = 0","'use strict';\n\n/**\n * Stringify/parse functions that don't operate\n * recursively, so they avoid call stack exceeded\n * errors.\n */\nexports.stringify = function stringify(input) {\n  var queue = [];\n  queue.push({obj: input});\n\n  var res = '';\n  var next, obj, prefix, val, i, arrayPrefix, keys, k, key, value, objPrefix;\n  while ((next = queue.pop())) {\n    obj = next.obj;\n    prefix = next.prefix || '';\n    val = next.val || '';\n    res += prefix;\n    if (val) {\n      res += val;\n    } else if (typeof obj !== 'object') {\n      res += typeof obj === 'undefined' ? null : JSON.stringify(obj);\n    } else if (obj === null) {\n      res += 'null';\n    } else if (Array.isArray(obj)) {\n      queue.push({val: ']'});\n      for (i = obj.length - 1; i >= 0; i--) {\n        arrayPrefix = i === 0 ? '' : ',';\n        queue.push({obj: obj[i], prefix: arrayPrefix});\n      }\n      queue.push({val: '['});\n    } else { // object\n      keys = [];\n      for (k in obj) {\n        if (obj.hasOwnProperty(k)) {\n          keys.push(k);\n        }\n      }\n      queue.push({val: '}'});\n      for (i = keys.length - 1; i >= 0; i--) {\n        key = keys[i];\n        value = obj[key];\n        objPrefix = (i > 0 ? ',' : '');\n        objPrefix += JSON.stringify(key) + ':';\n        queue.push({obj: value, prefix: objPrefix});\n      }\n      queue.push({val: '{'});\n    }\n  }\n  return res;\n};\n\n// Convenience function for the parse function.\n// This pop function is basically copied from\n// pouchCollate.parseIndexableString\nfunction pop(obj, stack, metaStack) {\n  var lastMetaElement = metaStack[metaStack.length - 1];\n  if (obj === lastMetaElement.element) {\n    // popping a meta-element, e.g. an object whose value is another object\n    metaStack.pop();\n    lastMetaElement = metaStack[metaStack.length - 1];\n  }\n  var element = lastMetaElement.element;\n  var lastElementIndex = lastMetaElement.index;\n  if (Array.isArray(element)) {\n    element.push(obj);\n  } else if (lastElementIndex === stack.length - 2) { // obj with key+value\n    var key = stack.pop();\n    element[key] = obj;\n  } else {\n    stack.push(obj); // obj with key only\n  }\n}\n\nexports.parse = function (str) {\n  var stack = [];\n  var metaStack = []; // stack for arrays and objects\n  var i = 0;\n  var collationIndex,parsedNum,numChar;\n  var parsedString,lastCh,numConsecutiveSlashes,ch;\n  var arrayElement, objElement;\n  while (true) {\n    collationIndex = str[i++];\n    if (collationIndex === '}' ||\n        collationIndex === ']' ||\n        typeof collationIndex === 'undefined') {\n      if (stack.length === 1) {\n        return stack.pop();\n      } else {\n        pop(stack.pop(), stack, metaStack);\n        continue;\n      }\n    }\n    switch (collationIndex) {\n      case ' ':\n      case '\\t':\n      case '\\n':\n      case ':':\n      case ',':\n        break;\n      case 'n':\n        i += 3; // 'ull'\n        pop(null, stack, metaStack);\n        break;\n      case 't':\n        i += 3; // 'rue'\n        pop(true, stack, metaStack);\n        break;\n      case 'f':\n        i += 4; // 'alse'\n        pop(false, stack, metaStack);\n        break;\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '-':\n        parsedNum = '';\n        i--;\n        while (true) {\n          numChar = str[i++];\n          if (/[\\d\\.\\-e\\+]/.test(numChar)) {\n            parsedNum += numChar;\n          } else {\n            i--;\n            break;\n          }\n        }\n        pop(parseFloat(parsedNum), stack, metaStack);\n        break;\n      case '\"':\n        parsedString = '';\n        lastCh = void 0;\n        numConsecutiveSlashes = 0;\n        while (true) {\n          ch = str[i++];\n          if (ch !== '\"' || (lastCh === '\\\\' &&\n              numConsecutiveSlashes % 2 === 1)) {\n            parsedString += ch;\n            lastCh = ch;\n            if (lastCh === '\\\\') {\n              numConsecutiveSlashes++;\n            } else {\n              numConsecutiveSlashes = 0;\n            }\n          } else {\n            break;\n          }\n        }\n        pop(JSON.parse('\"' + parsedString + '\"'), stack, metaStack);\n        break;\n      case '[':\n        arrayElement = { element: [], index: stack.length };\n        stack.push(arrayElement.element);\n        metaStack.push(arrayElement);\n        break;\n      case '{':\n        objElement = { element: {}, index: stack.length };\n        stack.push(objElement.element);\n        metaStack.push(objElement);\n        break;\n      default:\n        throw new Error(\n          'unexpectedly reached end of input: ' + collationIndex);\n    }\n  }\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/vuvuzela/index.js\n// module id = 248\n// module chunks = 0","(function(self) {\n  'use strict';\n\n  if (self.fetch) {\n    return\n  }\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob: 'FileReader' in self && 'Blob' in self && (function() {\n      try {\n        new Blob()\n        return true\n      } catch(e) {\n        return false\n      }\n    })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ]\n\n    var isDataView = function(obj) {\n      return obj && DataView.prototype.isPrototypeOf(obj)\n    }\n\n    var isArrayBufferView = ArrayBuffer.isView || function(obj) {\n      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n    }\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name)\n    }\n    if (/[^a-z0-9\\-#$%&'*+.\\^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value)\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift()\n        return {done: value === undefined, value: value}\n      }\n    }\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      }\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {}\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value)\n      }, this)\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1])\n      }, this)\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name])\n      }, this)\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name)\n    value = normalizeValue(value)\n    var oldValue = this.map[name]\n    this.map[name] = oldValue ? oldValue+','+value : value\n  }\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)]\n  }\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name)\n    return this.has(name) ? this.map[name] : null\n  }\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  }\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value)\n  }\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this)\n      }\n    }\n  }\n\n  Headers.prototype.keys = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push(name) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.values = function() {\n    var items = []\n    this.forEach(function(value) { items.push(value) })\n    return iteratorFor(items)\n  }\n\n  Headers.prototype.entries = function() {\n    var items = []\n    this.forEach(function(value, name) { items.push([name, value]) })\n    return iteratorFor(items)\n  }\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result)\n      }\n      reader.onerror = function() {\n        reject(reader.error)\n      }\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsArrayBuffer(blob)\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader()\n    var promise = fileReaderReady(reader)\n    reader.readAsText(blob)\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf)\n    var chars = new Array(view.length)\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i])\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength)\n      view.set(new Uint8Array(buf))\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false\n\n    this._initBody = function(body) {\n      this._bodyInit = body\n      if (!body) {\n        this._bodyText = ''\n      } else if (typeof body === 'string') {\n        this._bodyText = body\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString()\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer)\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer])\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body)\n      } else {\n        throw new Error('unsupported BodyInit type')\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8')\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type)\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')\n        }\n      }\n    }\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this)\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      }\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      }\n    }\n\n    this.text = function() {\n      var rejected = consumed(this)\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    }\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      }\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    }\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase()\n    return (methods.indexOf(upcased) > -1) ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {}\n    var body = options.body\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url\n      this.credentials = input.credentials\n      if (!options.headers) {\n        this.headers = new Headers(input.headers)\n      }\n      this.method = input.method\n      this.mode = input.mode\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit\n        input.bodyUsed = true\n      }\n    } else {\n      this.url = String(input)\n    }\n\n    this.credentials = options.credentials || this.credentials || 'omit'\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers)\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET')\n    this.mode = options.mode || this.mode || null\n    this.referrer = null\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body)\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, { body: this._bodyInit })\n  }\n\n  function decode(body) {\n    var form = new FormData()\n    body.trim().split('&').forEach(function(bytes) {\n      if (bytes) {\n        var split = bytes.split('=')\n        var name = split.shift().replace(/\\+/g, ' ')\n        var value = split.join('=').replace(/\\+/g, ' ')\n        form.append(decodeURIComponent(name), decodeURIComponent(value))\n      }\n    })\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers()\n    rawHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':')\n      var key = parts.shift().trim()\n      if (key) {\n        var value = parts.join(':').trim()\n        headers.append(key, value)\n      }\n    })\n    return headers\n  }\n\n  Body.call(Request.prototype)\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {}\n    }\n\n    this.type = 'default'\n    this.status = 'status' in options ? options.status : 200\n    this.ok = this.status >= 200 && this.status < 300\n    this.statusText = 'statusText' in options ? options.statusText : 'OK'\n    this.headers = new Headers(options.headers)\n    this.url = options.url || ''\n    this._initBody(bodyInit)\n  }\n\n  Body.call(Response.prototype)\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  }\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''})\n    response.type = 'error'\n    return response\n  }\n\n  var redirectStatuses = [301, 302, 303, 307, 308]\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  }\n\n  self.Headers = Headers\n  self.Request = Request\n  self.Response = Response\n\n  self.fetch = function(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init)\n      var xhr = new XMLHttpRequest()\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        }\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')\n        var body = 'response' in xhr ? xhr.response : xhr.responseText\n        resolve(new Response(body, options))\n      }\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'))\n      }\n\n      xhr.open(request.method, request.url, true)\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob'\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value)\n      })\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)\n    })\n  }\n  self.fetch.polyfill = true\n})(typeof self !== 'undefined' ? self : this);\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/whatwg-fetch/fetch.js\n// module id = 249\n// module chunks = 0","/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window && typeof window.process !== 'undefined' && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document && 'WebkitAppearance' in document.documentElement.style) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window && window.console && (console.firebug || (console.exception && console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  try {\n    return exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (typeof process !== 'undefined' && 'env' in process) {\n    return process.env.DEBUG;\n  }\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb/~/debug/src/browser.js\n// module id = 242\n// module chunks = 0","'use strict';\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar lie = _interopDefault(require('lie'));\n\n/* istanbul ignore next */\nvar PouchPromise = typeof Promise === 'function' ? Promise : lie;\n\nmodule.exports = PouchPromise;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/pouchdb-promise/lib/index.js\n// module id = 106\n// module chunks = 0"],"sourceRoot":""}